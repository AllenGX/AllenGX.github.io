<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="鑫酱" href="https://allengx.gitee.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="鑫酱" href="https://allengx.gitee.io/atom.xml"><link rel="alternate" type="application/json" title="鑫酱" href="https://allengx.gitee.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://allengx.gitee.io/computer-science/study/opengl/5-OpenGL-Heigh-Light/"><title>五、高级光照 - OpenGL - 学习笔记 - 计算机科学 | 个人博客 = 鑫酱 = 笔记本</title><meta name="generator" content="Hexo 5.1.1"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">五、高级光照</h1><div class="meta"><span class="item" title="创建时间：2020-04-12 20:46:25"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2020-04-12T20:46:25+08:00">2020-04-12</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>67k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>1:01</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">个人博客</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipeudstjqj20zk0m8k3r.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipex2cdtbj20zk0m8x6p.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclj61ylzj20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gicis081o9j20zk0m8dmr.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclflwv2aj20zk0m84qp.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclgi503lj20zk0m8hdt.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/" itemprop="item" rel="index" title="分类于 计算机科学"><span itemprop="name">计算机科学</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/study/" itemprop="item" rel="index" title="分类于 学习笔记"><span itemprop="name">学习笔记</span></a><meta itemprop="position" content="2"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/study/opengl/" itemprop="item" rel="index" title="分类于 OpenGL"><span itemprop="name">OpenGL</span></a><meta itemprop="position" content="3"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://allengx.gitee.io/computer-science/study/opengl/5-OpenGL-Heigh-Light/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="鑫酱(●'◡'●)"><meta itemprop="description" content="笔记本, 整天摸鱼，却妄想拯救世界的技术宅"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="鑫酱"></span><div class="body md" itemprop="articleBody"><div class="note info"><p>以下为个人学习笔记整理</p></div><h2 id="高级光照"><a class="anchor" href="#高级光照">#</a> 高级光照</h2><p>在光照小节中，我们简单地介绍了冯氏光照模型，它让我们的场景有了一定的真实感。虽然冯氏模型看起来已经很不错了，但是使用它的时候仍然存在一些细节问题，我们将在这一节里讨论它们。</p><h3 id="blinn-phong"><a class="anchor" href="#blinn-phong">#</a> Blinn-Phong</h3><p>冯氏光照不仅对真实光照有很好的近似，而且性能也很高。但是它的镜面反射会在一些情况下出现问题，特别是物体反光度很低时，会导致大片（粗糙的）高光区域。下面这张图展示了当反光度为 1.0 时地板会出现的效果：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/01/advanced_lighting_phong_limit.png" alt="image"></p><p>可以看到，在镜面高光区域的边缘出现了一道很明显的断层。出现这个问题的原因是观察向量和反射向量间的夹角不能大于 90 度。如果点积的结果为负数，镜面光分量会变为 0.0。你可能会觉得，当光线与视线夹角大于 90 度时你应该不会接收到任何光才对，所以这不是什么问题。</p><p>然而，这种想法仅仅只适用于漫反射分量。当考虑漫反射光的时候，如果法线和光源夹角大于 90 度，光源会处于被照表面的下方，这个时候光照的漫反射分量的确是为 0.0。但是，在考虑镜面高光时，我们测量的角度并不是光源与法线的夹角，而是视线与反射光线向量的夹角。看一下下面这两张图：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/01/advanced_lighting_over_90.png" alt="image"></p><p>现在问题就应该很明显了。左图中是我们熟悉的冯氏光照中的反射向量，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.02778em">θ</span></span></span></span> 角小于 90 度。而右图中，视线与反射方向之间的夹角明显大于 90 度，这种情况下镜面光分量会变为 0.0。这在大多数情况下都不是什么问题，因为观察方向离反射方向都非常远。然而，当物体的镜面光分量非常小时，它产生的镜面高光半径足以让这些相反方向的光线对亮度产生足够大的影响。在这种情况下就不能忽略它们对镜面光分量的贡献了。</p><p>1977 年，James F. Blinn 在冯氏着色模型上加以拓展，引入了<mark> Blinn-Phong</mark> 着色模型。Blinn-Phong 模型与冯氏模型非常相似，但是它对镜面光模型的处理上有一些不同，让我们能够解决之前提到的问题。Blinn-Phong 模型不再依赖于反射向量，而是采用了所谓的半程向量 (Halfway Vector)，即光线与视线夹角一半方向上的一个单位向量。当半程向量与法线向量越接近时，镜面光分量就越大。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/01/advanced_lighting_halfway_vector.png" alt="image"></p><p>当视线正好与（现在不需要的）反射向量对齐时，半程向量就会与法线完美契合。所以当观察者视线越接近于原本反射光线的方向时，镜面高光就会越强。</p><p>现在，不论观察者向哪个方向看，半程向量与表面法线之间的夹角都不会超过 90 度（除非光源在表面以下）。它产生的效果会与冯氏光照有些许不同，但是大部分情况下看起来会更自然一点，特别是低高光的区域。Blinn-Phong 着色模型正是早期固定渲染管线时代时 OpenGL 所采用的光照模型。</p><p>获取半程向量的方法很简单，只需要将光线的方向向量和观察向量加到一起，并将结果正规化 (Normalize) 就可以了：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi>H</mi><mo>ˉ</mo></mover><mo>=</mo><mfrac><mrow><mover accent="true"><mi>L</mi><mo>ˉ</mo></mover><mo>+</mo><mover accent="true"><mi>V</mi><mo>ˉ</mo></mover></mrow><mrow><mo fence="true">∥</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mover accent="true"><mi>L</mi><mo>ˉ</mo></mover><mo>+</mo><mover accent="true"><mi>V</mi><mo>ˉ</mo></mover></mrow></mstyle></mtd></mtr></mtable><mo fence="true">∥</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\bar{H}=\frac{\bar{L}+\bar{V}}{\begin{Vmatrix} \bar{L}+\bar{V}\\ \end{Vmatrix}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8201099999999999em;vertical-align:0"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8201099999999999em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.08125em">H</span></span></span><span style="top:-3.25233em"><span class="pstrut" style="height:3em"></span><span class="accent-body" style="left:-.19444em"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:2.6051em;vertical-align:-1.10799em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.49711em"><span style="top:-2.24202em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.8679800000000001em"><span style="top:-2.2559899999999997em"><span class="pstrut" style="height:2.606em"></span><span class="delimsizinginner delim-size1"><span>∥</span></span></span><span style="top:-2.26698em"><span class="pstrut" style="height:2.606em"></span><span class="delimsizinginner delim-size1"><span>∥</span></span></span><span style="top:-2.86798em"><span class="pstrut" style="height:2.606em"></span><span class="delimsizinginner delim-size1"><span>∥</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.35000999999999993em"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.8500000000000001em"><span style="top:-3.01em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8201099999999999em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">L</span></span></span><span style="top:-3.25233em"><span class="pstrut" style="height:3em"></span><span class="accent-body" style="left:-.22222em"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8201099999999999em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.22222em">V</span></span></span><span style="top:-3.25233em"><span class="pstrut" style="height:3em"></span><span class="accent-body" style="left:-.25em"><span class="mord">ˉ</span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.35000000000000003em"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.8679800000000001em"><span style="top:-2.2559899999999997em"><span class="pstrut" style="height:2.606em"></span><span class="delimsizinginner delim-size1"><span>∥</span></span></span><span style="top:-2.26698em"><span class="pstrut" style="height:2.606em"></span><span class="delimsizinginner delim-size1"><span>∥</span></span></span><span style="top:-2.86798em"><span class="pstrut" style="height:2.606em"></span><span class="delimsizinginner delim-size1"><span>∥</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.35000999999999993em"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8201099999999999em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">L</span></span></span><span style="top:-3.25233em"><span class="pstrut" style="height:3em"></span><span class="accent-body" style="left:-.22222em"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8201099999999999em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.22222em">V</span></span></span><span style="top:-3.25233em"><span class="pstrut" style="height:3em"></span><span class="accent-body" style="left:-.25em"><span class="mord">ˉ</span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.10799em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>翻译成 GLSL 代码如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vec3 lightDir   <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>lightPos <span class="token operator">-</span> FragPos<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>vec3 viewDir    <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>viewPos <span class="token operator">-</span> FragPos<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>vec3 halfwayDir <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>lightDir <span class="token operator">+</span> viewDir<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>接下来，镜面光分量的实际计算只不过是对表面法线和半程向量进行一次约束点乘 (Clamped Dot Product)，让点乘结果不为负，从而获取它们之间夹角的余弦值，之后我们对这个值取反光度次方：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> spec <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>normal<span class="token punctuation">,</span> halfwayDir<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> shininess<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>vec3 specular <span class="token operator">=</span> lightColor <span class="token operator">*</span> spec<span class="token punctuation">;</span></pre></td></tr></table></figure><p>除此之外 Blinn-Phong 模型就没什么好说的了，Blinn-Phong 与冯氏模型唯一的区别就是，Blinn-Phong 测量的是法线与半程向量之间的夹角，而冯氏模型测量的是观察方向与反射向量间的夹角。</p><p>在引入半程向量之后，我们现在应该就不会再看到冯氏光照中高光断层的情况了。下面两个图片展示的是两种方法在镜面光分量为 0.5 时的对比：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/01/advanced_lighting_comparrison.png" alt="image"></p><p>除此之外，冯氏模型与 Blinn-Phong 模型也有一些细微的差别：半程向量与表面法线的夹角通常会小于观察与反射向量的夹角。所以，如果你想获得和冯氏着色类似的效果，就必须在使用 Blinn-Phong 模型时将镜面反光度设置更高一点。通常我们会选择冯氏着色时反光度分量的 2 到 4 倍。</p><p>下面是冯氏着色反光度为 8.0，Blinn-Phong 着色反光度为 32.0 时的一个对比：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/01/advanced_lighting_comparrison2.png" alt="image"></p><p>你可以看到，Blinn-Phong 的镜面光分量会比冯氏模型更锐利一些。为了得到与冯氏模型类似的结果，你可能会需要不断进行一些微调，但 Blinn-Phong 模型通常会产出更真实的结果。</p><p>这里，我们使用了一个简单的片段着色器，让我们能够在冯氏反射与 Blinn-Phong 反射间进行切换：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">float</span> spec <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>blinn<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        vec3 halfwayDir <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>lightDir <span class="token operator">+</span> viewDir<span class="token punctuation">)</span><span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="8"></td><td><pre>        spec <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>normal<span class="token punctuation">,</span> halfwayDir<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">16.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">else</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        vec3 reflectDir <span class="token operator">=</span> <span class="token function">reflect</span><span class="token punctuation">(</span><span class="token operator">-</span>lightDir<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        spec <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>viewDir<span class="token punctuation">,</span> reflectDir<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">8.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="gamma校正"><a class="anchor" href="#gamma校正">#</a> Gamma 校正</h2><p>当我们计算出场景中所有像素的最终颜色以后，我们就必须把它们显示在监视器上。过去，大多数监视器是阴极射线管显示器（CRT）。这些监视器有一个物理特性就是两倍的输入电压产生的不是两倍的亮度。输入电压产生约为输入电压的 2.2 次幂的亮度，这叫做监视器 Gamma。</p><blockquote><p>Gamma 也叫灰度系数，每种显示设备都有自己的 Gamma 值，都不相同，有一个公式：设备输出亮度 = 电压的 Gamma 次幂，任何设备 Gamma 基本上都不会等于 1，等于 1 是一种理想的线性状态，这种理想状态是：如果电压和亮度都是在 0 到 1 的区间，那么多少电压就等于多少亮度。对于 CRT，Gamma 通常为 2.2，因而，输出亮度 = 输入电压的 2.2 次幂，你可以从本节第二张图中看到 Gamma2.2 实际显示出来的总会比预期暗，相反 Gamma0.45 就会比理想预期亮，如果你讲 Gamma0.45 叠加到 Gamma2.2 的显示设备上，便会对偏暗的显示效果做到校正，这个简单的思路就是本节的核心</p></blockquote><p>人类所感知的亮度恰好和 CRT 所显示出来相似的指数关系非常匹配。为了更好的理解所有含义，请看下面的图片：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/02/gamma_correction_brightness.png" alt="image"></p><p>第一行是人眼所感知到的正常的灰阶，亮度要增加一倍（比如从 0.1 到 0.2）你才会感觉比原来变亮了一倍（译注：这里的意思是说比如一个东西的亮度 0.3，让人感觉它比原来变亮一倍，那么现在这个亮度应该成为 0.6，而不是 0.4，也就是说人眼感知到的亮度的变化并非线性均匀分布的。问题的关键在于这样的一倍相当于一个亮度级，例如假设 0.1、0.2、0.4、0.8 是我们定义的四个亮度级别，在 0.1 和 0.2 之间人眼只能识别出 0.15 这个中间级，而虽然 0.4 到 0.8 之间的差距更大，这个区间人眼也只能识别出一个颜色）。然而，当我们谈论光的物理亮度，比如光源发射光子的数量的时候，底部（第二行）的灰阶显示出的才是物理世界真实的亮度。如底部的灰阶显示，亮度加倍时返回的也是真实的物理亮度（译注：这里亮度是指光子数量和正相关的亮度，即物理亮度，前面讨论的是人的感知亮度；物理亮度和感知亮度的区别在于，物理亮度基于光子数量，感知亮度基于人的感觉，比如第二个灰阶里亮度 0.1 的光子数量是 0.2 的二分之一），但是由于这与我们的眼睛感知亮度不完全一致（<mark>对比较暗的颜色变化更敏感</mark>），所以它看起来有差异。</p><p>因为人眼看到颜色的亮度更倾向于顶部的灰阶，监视器使用的也是一种指数关系（电压的 2.2 次幂），所以物理亮度通过监视器能够被映射到顶部的非线性亮度；因此看起来效果不错（译注：CRT 亮度是是电压的 2.2 次幂而人眼相当于 2 次幂，因此 CRT 这个缺陷正好能满足人的需要）。</p><p>监视器的这个非线性映射的确可以让亮度在我们眼中看起来更好，但当渲染图像时，会产生一个问题：我们在应用中配置的亮度和颜色是基于监视器所看到的，这样所有的配置实际上是非线性的亮度 / 颜色配置。请看下图：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/02/gamma_correction_gamma_curves.png" alt="image"></p><p>点线代表线性颜色 / 亮度值（译注：这表示的是理想状态，Gamma 为 1），<mark>实线</mark>代表监视器显示的颜色。如果我们把一个点线线性的颜色翻一倍，结果就是这个值的两倍。比如，光的颜色向量 L¯=(0.5,0.0,0.0) 代表的是暗红色。如果我们在线性空间中把它翻倍，就会变成 (1.0,0.0,0.0)，就像你在图中看到的那样。然而，由于我们定义的颜色仍然需要输出的监视器上，监视器上显示的实际颜色就会是 (0.218,0.0,0.0)。在这儿问题就出现了：当我们将理想中直线上的那个暗红色翻一倍时，在监视器上实际上亮度翻了 4.5 倍以上！</p><p>直到现在，我们还一直假设我们所有的工作都是在线性空间中进行的（译注：Gamma 为 1），但最终还是要把所有的颜色输出到监视器上，所以我们配置的所有颜色和光照变量从物理角度来看都是不正确的，在我们的监视器上很少能够正确地显示。出于这个原因，我们（以及艺术家）通常将光照值设置得比本来更亮一些（由于监视器会将其亮度显示的更暗一些），如果不是这样，在线性空间里计算出来的光照就会不正确。同时，还要记住，监视器所显示出来的图像和线性图像的最小亮度是相同的，它们最大的亮度也是相同的；只是中间亮度部分会被压暗。</p><p>因为所有中间亮度都是线性空间计算出来的（译注：计算的时候假设 Gamma 为 1）监视器显以后，实际上都会不正确。当使用更高级的光照算法时，这个问题会变得越来越明显，你可以看看下图：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/02/gamma_correction_example.png" alt="image"></p><h3 id="gamma校正-2"><a class="anchor" href="#gamma校正-2">#</a> Gamma 校正</h3><p>Gamma 校正 (Gamma Correction) 的思路是在最终的颜色输出上应用监视器 Gamma 的倒数。回头看前面的 Gamma 曲线图，你会有一个短划线，它是监视器 Gamma 曲线的翻转曲线。我们在颜色显示到监视器的时候把每个颜色输出都加上这个翻转的 Gamma 曲线，这样应用了监视器 Gamma 以后最终的颜色将会变为线性的。我们所得到的中间色调就会更亮，所以虽然监视器使它们变暗，但是我们又将其平衡回来了。</p><p>我们来看另一个例子。还是那个暗红色 (0.5,0.0,0.0)。在将颜色显示到监视器之前，我们先对颜色应用 Gamma 校正曲线。线性的颜色显示在监视器上相当于降低了 2.2 次幂的亮度，所以倒数就是 1/2.2 次幂。Gamma 校正后的暗红色就会成为 (0.5,0.0,0.0)<sup>(1/2.2)=(0.5,0.0,0.0)</sup>(0.45)=(0.73,0.0,0.0)。校正后的颜色接着被发送给监视器，最终显示出来的颜色是 (0.73,0.0,0.0)^(2.2)=(0.5,0.0,0.0)。你会发现使用了 Gamma 校正，监视器最终会显示出我们在应用中设置的那种线性的颜色。</p><blockquote><p>2.2 通常是是大多数显示设备的大概平均 gamma 值。基于 gamma2.2 的颜色空间叫做 sRGB 颜色空间。每个监视器的 gamma 曲线都有所不同，但是 gamma2.2 在大多数监视器上表现都不错。出于这个原因，游戏经常都会为玩家提供改变游戏 gamma 设置的选项，以适应每个监视器（译注：现在 Gamma2.2 相当于一个标准，后文中你会看到。但现在你可能会问，前面不是说 Gamma2.2 看起来不是正好适合人眼么，为何还需要校正。这是因为你在程序中设置的颜色，比如光照都是基于线性 Gamma，即 Gamma1，所以你理想中的亮度和实际表达出的不一样，如果要表达出你理想中的亮度就要对这个光照进行校正）。</p></blockquote><p>有两种在你的场景中应用 gamma 校正的方式：</p><p>使用 OpenGL 内建的 sRGB 帧缓冲。 自己在像素着色器中进行 gamma 校正。 第一个选项也许是最简单的方式，但是我们也会丧失一些控制权。开启 GL_FRAMEBUFFER_SRGB，可以告诉 OpenGL 每个后续的绘制命令里，在颜色储存到颜色缓冲之前先校正 sRGB 颜色。sRGB 这个颜色空间大致对应于 gamma2.2，它也是家用设备的一个标准。开启 GL_FRAMEBUFFER_SRGB 以后，每次像素着色器运行后续帧缓冲，OpenGL 将自动执行 gamma 校正，包括默认帧缓冲。</p><p>开启 GL_FRAMEBUFFER_SRGB 简单的调用 glEnable 就行：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glEnable</span><span class="token punctuation">(</span>GL_FRAMEBUFFER_SRGB<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>自此，你渲染的图像就被进行 gamma 校正处理，你不需要做任何事情硬件就帮你处理了。有时候，你应该记得这个建议：gamma 校正将把线性颜色空间转变为非线性空间，所以在最后一步进行 gamma 校正是极其重要的。如果你在最后输出之前就进行 gamma 校正，所有的后续操作都是在操作不正确的颜色值。例如，如果你使用多个帧缓冲，你可能打算让两个帧缓冲之间传递的中间结果仍然保持线性空间颜色，只是给发送给监视器的最后的那个帧缓冲应用 gamma 校正。</p><p>第二个方法稍微复杂点，但同时也是我们对 gamma 操作有完全的控制权。我们在每个相关像素着色器运行的最后应用 gamma 校正，所以在发送到帧缓冲前，颜色就被校正了。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// do super fancy lighting </span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// apply gamma correction</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">float</span> gamma <span class="token operator">=</span> <span class="token number">2.2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    fragColor<span class="token punctuation">.</span>rgb <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span>fragColor<span class="token punctuation">.</span>rgb<span class="token punctuation">,</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token operator">/</span>gamma<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>最后一行代码，将 fragColor 的每个颜色元素应用有一个 1.0/gamma 的幂运算，校正像素着色器的颜色输出。</p><p>这个方法有个问题就是为了保持一致，你必须在像素着色器里加上这个 gamma 校正，所以如果你有很多像素着色器，它们可能分别用于不同物体，那么你就必须在每个着色器里都加上 gamma 校正了。一个更简单的方案是在你的渲染循环中引入后处理阶段，在后处理四边形上应用 gamma 校正，这样你只要做一次就好了。</p><p>这些单行代码代表了 gamma 校正的实现。不太令人印象深刻，但当你进行 gamma 校正的时候有一些额外的事情别忘了考虑。</p><h3 id="srgb纹理"><a class="anchor" href="#srgb纹理">#</a> sRGB 纹理</h3><p>因为监视器总是在 sRGB 空间中显示应用了 gamma 的颜色，无论什么时候当你在计算机上绘制、编辑或者画出一个图片的时候，你所选的颜色都是根据你在监视器上看到的那种。这实际意味着所有你创建或编辑的图片并不是在线性空间，而是在 sRGB 空间中（译注：sRGB 空间定义的 gamma 接近于 2.2），假如在你的屏幕上对暗红色翻一倍，便是根据你所感知到的亮度进行的，并不等于将红色元素加倍。</p><p>结果就是纹理编辑者，所创建的所有纹理都是在 sRGB 空间中的纹理，所以如果我们在渲染应用中使用这些纹理，我们必须考虑到这点。在我们应用 gamma 校正之前，这不是个问题，因为纹理在 sRGB 空间创建和展示，同样我们还是在 sRGB 空间中使用，从而不必 gamma 校正纹理显示也没问题。然而，现在我们是把所有东西都放在线性空间中展示的，纹理颜色就会变坏，如下图展示的那样：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/02/gamma_correction_srgbtextures.png" alt="image"></p><p>纹理图像实在太亮了，发生这种情况是因为，它们实际上进行了两次 gamma 校正！想一想，当我们基于监视器上看到的情况创建一个图像，我们就已经对颜色值进行了 gamma 校正，所以再次显示在监视器上就没错。由于我们在渲染中又进行了一次 gamma 校正，图片就实在太亮了。</p><p>为了修复这个问题，我们得确保纹理制作者是在线性空间中进行创作的。但是，由于大多数纹理制作者并不知道什么是 gamma 校正，并且在 sRGB 空间中进行创作更简单，这也许不是一个好办法。</p><p>另一个解决方案是重校，或把这些 sRGB 纹理在进行任何颜色值的计算前变回线性空间。我们可以这样做：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> gamma <span class="token operator">=</span> <span class="token number">2.2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>vec3 diffuseColor <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token function">texture</span><span class="token punctuation">(</span>diffuse<span class="token punctuation">,</span> texCoords<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb<span class="token punctuation">,</span> <span class="token function">vec3</span><span class="token punctuation">(</span>gamma<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>为每个 sRGB 空间的纹理做这件事非常烦人。幸好，OpenGL 给我们提供了另一个方案来解决我们的麻烦，这就是 GL_SRGB 和 GL_SRGB_ALPHA 内部纹理格式。</p><p>如果我们在 OpenGL 中创建了一个纹理，把它指定为以上两种 sRGB 纹理格式其中之一，OpenGL 将自动把颜色校正到线性空间中，这样我们所使用的所有颜色值都是在线性空间中的了。我们可以这样把一个纹理指定为一个 sRGB 纹理：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glTexImage2D</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_SRGB<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RGB<span class="token punctuation">,</span> GL_UNSIGNED_BYTE<span class="token punctuation">,</span> image<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>如果你还打算在你的纹理中引入 alpha 元素，必究必须将纹理的内部格式指定为 GL_SRGB_ALPHA。</p><p>因为不是所有纹理都是在 sRGB 空间中的所以当你把纹理指定为 sRGB 纹理时要格外小心。比如 diffuse 纹理，这种为物体上色的纹理几乎都是在 sRGB 空间中的。而为了获取光照参数的纹理，像 specular 贴图和法线贴图几乎都在线性空间中，所以如果你把它们也配置为 sRGB 纹理的话，光照就坏掉了。指定 sRGB 纹理时要当心。</p><p>将 diffuse 纹理定义为 sRGB 纹理之后，你将获得你所期望的视觉输出，但这次每个物体都会只进行一次 gamma 校正。</p><h3 id="衰减"><a class="anchor" href="#衰减">#</a> 衰减</h3><p>在使用了 gamma 校正之后，另一个不同之处是光照衰减 (Attenuation)。真实的物理世界中，光照的衰减和光源的距离的平方成反比。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> attenuation <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token punctuation">(</span>distance <span class="token operator">*</span> distance<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>然而，当我们使用这个衰减公式的时候，衰减效果总是过于强烈，光只能照亮一小圈，看起来并不真实。出于这个原因，我们使用在基本光照教程中所讨论的那种衰减方程，它给了我们更大的控制权，此外我们还可以使用双曲线函数：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> attenuation <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> distance<span class="token punctuation">;</span></pre></td></tr></table></figure><p>双曲线比使用二次函数变体在不用 gamma 校正的时候看起来更真实，不过但我们开启 gamma 校正以后线性衰减看起来太弱了，符合物理的二次函数突然出现了更好的效果。下图显示了其中的不同：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/02/gamma_correction_attenuation.png" alt="image"></p><p>这种差异产生的原因是，光的衰减方程改变了亮度值，而且屏幕上显示出来的也不是线性空间，在监视器上效果最好的衰减方程，并不是符合物理的。想想平方衰减方程，如果我们使用这个方程，而且不进行 gamma 校正，显示在监视器上的衰减方程实际上将变成 (1.0/distance<sup>(2))</sup>(2.2)。若不进行 gamma 校正，将产生更强烈的衰减。这也解释了为什么双曲线不用 gamma 校正时看起来更真实，因为它实际变成了 (1.0/distance)^(2.2) =1.0/distance^(2.2)。这和物理公式是很相似的。</p><blockquote><p>我们在基础光照教程中讨论的更高级的那个衰减方程在有 gamma 校正的场景中也仍然有用，因为它可以让我们对衰减拥有更多准确的控制权（不过，在进行 gamma 校正的场景中当然需要不同的参数）。</p></blockquote><p>我创建的这个简单的 demo 场景，你可以在这里找到源码以及顶点和像素着色器。按下空格就能在有 gamma 校正和无 gamma 校正的场景进行切换，两个场景使用的是相同的纹理和衰减。这不是效果最好的 demo，不过它能展示出如何应用所有这些技术。</p><p>总而言之，gamma 校正使你可以在线性空间中进行操作。因为线性空间更符合物理世界，大多数物理公式现在都可以获得较好效果，比如真实的光的衰减。你的光照越真实，使用 gamma 校正获得漂亮的效果就越容易。这也正是为什么当引进 gamma 校正时，建议只去调整光照参数的原因。</p><h3 id="附加资源"><a class="anchor" href="#附加资源">#</a> 附加资源</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY2FtYnJpZGdlaW5jb2xvdXIuY29tL3R1dG9yaWFscy9nYW1tYS1jb3JyZWN0aW9uLmh0bQ==">cambridgeincolour.com</span>: 更多关于 gamma 和 gamma 校正的内容。</li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cud29sZmlyZS5jb20vMjAxMC8wMi9HYW1tYS1jb3JyZWN0LWxpZ2h0aW5n">wolfire.com</span>: David Rosen 关于在渲染领域使用 gamma 校正的好处。</li><li><span class="exturl" data-url="aHR0cDovL3JlbmRlcndvbmsuY29tL2Jsb2cvaW5kZXgucGhwL2FyY2hpdmUvYWR2ZW50dXJlcy13aXRoLWdhbW1hLWNvcnJlY3QtcmVuZGVyaW5nLw==">renderwonk.com</span>: 一些额外的实践上的思考。</li></ul><h2 id="shadow-mapping"><a class="anchor" href="#shadow-mapping">#</a> Shadow Mapping</h2><p>阴影是由于遮挡导致的光线缺失的结果；当光源的光线没有撞到物体时，因为它被一些其他物体遮挡，物体处于阴影中。阴影为光照场景添加了大量的真实感，使观察者更容易观察物体之间的空间关系。它们为我们的场景和物体提供了更大的深度感。例如，查看带阴影和没有阴影的场景的以下图像：</p><p><img data-src="https://learnopengl.com/img/advanced-lighting/shadow_mapping_with_without.png" alt="image"></p><p>你可以看到，对于阴影，对象如何相互关联变得更加明显。例如，当我们有阴影时，其中一个立方体浮动在其他立方体之上的事实会更加明显。</p><p>然而，阴影实现起来有点棘手，特别是因为在当前的实时（光栅化图形）研究中，还没有开发出完美的阴影算法。有几种很好的阴影近似技术，但它们都有它们的小怪癖和烦恼，我们必须考虑到这些。</p><p>大多数视频游戏使用的一种技术可以提供不错的结果并且相对容易实现 <strong>阴影贴图</strong>。阴影贴图不易理解，性能成本不高，并且很容易扩展到更高级的算法（如<span class="exturl" data-url="aHR0cHM6Ly9sZWFybm9wZW5nbC5jb20vQWR2YW5jZWQtTGlnaHRpbmcvU2hhZG93cy9Qb2ludC1TaGFkb3dz">全向阴影贴图</span>和<span class="exturl" data-url="aHR0cHM6Ly9sZWFybm9wZW5nbC5jb20vQWR2YW5jZWQtTGlnaHRpbmcvU2hhZG93cy9DU00=">级联阴影贴图</span>）。</p><h3 id="阴影贴图"><a class="anchor" href="#阴影贴图">#</a> 阴影贴图</h3><p>阴影贴图背后的想法很简单：我们从灯光的角度渲染场景，我们从灯光的角度看到的一切都被照亮，我们看不到的一切都必须在阴影中。想象一下一个地板部分，它自身和一个光源之间有一个大盒子。由于光源在看方向时会看到这个方框而不是地板部分，特定的地板部分应该是阴影。</p><p><img data-src="https://learnopengl.com/img/advanced-lighting/shadow_mapping_theory.png" alt="image"></p><p>这里所有的蓝线代表光源可以看到的碎片。被遮挡的碎片显示为黑色线条：这些被渲染为阴影。如果我们画一条线或射线从光源到最右边的盒子上的碎片我们可以看到射线在撞到最右边的容器之前首先撞到浮动容器。结果，浮动容器的片段被点亮，最右边的容器的片段不亮，因此处于阴影中。</p><p>我们希望在射线首先击中一个物体并将该最近点与该射线上的其他点进行比较时获得一个点。然后，我们进行基本测试，以查看测试点的光线位置是否比光线位置更靠近光线，如果是这样，测试点必须处于阴影中。迭代来自这种光源的数千个光线是一种非常低效的方法，并且不适合实时渲染。我们可以做类似的事情，但不能投射光线。相反，我们使用我们非常熟悉的东西：<mark>深度缓冲</mark>区。</p><p>您可能还记得深度测试教程中深度缓冲区中的值对应于从摄像机视角夹紧到 [0,1] 的片段的深度。如果我们从灯光的角度渲染场景并将结果深度值存储在纹理中，该怎么办？通过这种方式，我们可以从灯光的角度对最近的深度值进行采样。毕竟，深度值显示从灯光的角度可见的第一个片段。我们将所有这些深度值存储在我们称之为的纹理中<mark>深度图</mark>或者 <mark>阴影贴图</mark>。</p><p><img data-src="https://learnopengl.com/img/advanced-lighting/shadow_mapping_theory_spaces.png" alt="image"></p><p>左图显示了定向光源（所有光线平行），在立方体下方的表面上投射阴影。使用存储在深度图中的深度值，我们找到最近的点并使用它来确定片段是否在阴影中。我们通过使用特定于该光源的视图和投影矩阵渲染场景（<mark>从光的角度</mark>）来创建深度图。该投影和视图矩阵一起形成 T 变换，它可以将任何三维位置转变到光源的可见坐标空间。</p><blockquote><p>定向光没有位置，因为它被建模为无限远。但是，为了阴影贴图，我们需要从灯光的角度渲染场景，从而从沿光线方向的某个位置渲染场景。</p></blockquote><p>在右边的图中我们显示出同样的平行光和观察者。我们渲染一个点 P 处的片元，需要决定它是否在阴影中。我们先得使用 T 把 P 变换到光源的坐标空间里。既然点 P 是从光的透视图中看到的，它的 z 坐标就对应于它的深度，例子中这个值是 0.9。使用点 P 在光源的坐标空间的坐标，我们可以索引深度贴图，来获得从光的视角中最近的可见深度，结果是点 C，最近的深度是 0.4。因为索引深度贴图的结果是一个小于点 P 的深度，我们可以断定 P 被挡住了，它在阴影中了。</p><p>深度映射由两个步骤组成：首先，我们渲染深度贴图（<mark>用于判断阴影的深度值</mark>），然后我们像往常一样渲染场景，使用生成的深度贴图来计算片元是否在阴影之中。听起来有点复杂，但随着我们一步一步地讲解这个技术，就能理解了。</p><h3 id="深度贴图"><a class="anchor" href="#深度贴图">#</a> 深度贴图</h3><p>第一步我们需要生成一张深度贴图 (Depth Map)。深度贴图是从光的透视图里渲染的深度纹理，用它计算阴影。因为我们需要将场景的渲染结果储存到一个纹理中，我们将再次需要帧缓冲。</p><p>首先，我们要为渲染的深度贴图创建一个帧缓冲对象：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> depthMapFBO<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glGenFramebuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>depthMapFBO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>接下来，我们创建一个 2D 纹理，我们将其用作帧缓冲区的深度缓冲区：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> SHADOW_WIDTH <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">,</span> SHADOW_HEIGHT <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> depthMap<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glGenTextures</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>depthMap<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> depthMap<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">glTexImage2D</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_DEPTH_COMPONENT<span class="token punctuation">,</span> SHADOW_WIDTH<span class="token punctuation">,</span> SHADOW_HEIGHT<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_DEPTH_COMPONENT<span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_MIN_FILTER<span class="token punctuation">,</span> GL_NEAREST<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_MAG_FILTER<span class="token punctuation">,</span> GL_NEAREST<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_WRAP_S<span class="token punctuation">,</span> GL_REPEAT<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_WRAP_T<span class="token punctuation">,</span> GL_REPEAT<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>生成深度贴图不太复杂。因为我们只关心深度值，我们要把纹理格式指定为 GL_DEPTH_COMPONENT。我们还要把纹理的高宽设置为 1024：这是深度贴图的解析度。</p><p>把我们把生成的深度纹理作为帧缓冲的深度缓冲：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> depthMapFBO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glFramebufferTexture2D</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> GL_DEPTH_ATTACHMENT<span class="token punctuation">,</span> GL_TEXTURE_2D<span class="token punctuation">,</span> depthMap<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glDrawBuffer</span><span class="token punctuation">(</span>GL_NONE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glReadBuffer</span><span class="token punctuation">(</span>GL_NONE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>我们需要的只是在从光的透视图下渲染场景的时候深度信息，所以颜色缓冲没有用。然而帧缓冲对象不是完全不包含颜色缓冲的，所以我们需要显式告诉 OpenGL 我们不适用任何颜色数据进行渲染。我们通过将调用 glDrawBuffer 和 glReadBuffer 把读和绘制缓冲设置为 GL_NONE 来做这件事。</p><p>合理配置将深度值渲染到纹理的帧缓冲后，我们就可以开始第一步了：生成深度贴图。两个步骤的完整的渲染阶段，看起来有点像这样：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 1. 首选渲染深度贴图</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glViewport</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> SHADOW_WIDTH<span class="token punctuation">,</span> SHADOW_HEIGHT<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> depthMapFBO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">glClear</span><span class="token punctuation">(</span>GL_DEPTH_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">ConfigureShaderAndMatrices</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">RenderScene</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// 2. 像往常一样渲染场景，但这次使用深度贴图</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token function">glViewport</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> SCR_WIDTH<span class="token punctuation">,</span> SCR_HEIGHT<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT <span class="token operator">|</span> GL_DEPTH_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token function">ConfigureShaderAndMatrices</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> depthMap<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token function">RenderScene</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这段代码隐去了一些细节，但它表达了阴影映射的基本思路。这里一定要记得调用 glViewport。因为阴影贴图经常和我们原来渲染的场景（通常是窗口解析度）有着不同的解析度，我们需要改变视口（viewport）的参数以适应阴影贴图的尺寸。如果我们忘了更新视口参数，最后的深度贴图要么太小要么就不完整。</p><h3 id="光源空间的变换"><a class="anchor" href="#光源空间的变换">#</a> 光源空间的变换</h3><p>前面那段代码中一个不清楚的函数是<mark> ConfigureShaderAndMatrices</mark>。它是用来在第二个步骤确保为每个物体设置了合适的投影和视图矩阵，以及相关的模型矩阵。然而，第一个步骤中，我们从光的位置的视野下使用了不同的投影和视图矩阵来渲染的场景。</p><p>因为我们使用的是一个所有光线都平行的定向光。出于这个原因，我们将为光源使用正交投影矩阵，透视图将没有任何变形：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> near_plane <span class="token operator">=</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> far_plane <span class="token operator">=</span> <span class="token number">7.5f</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>glm<span class="token operator">::</span>mat4 lightProjection <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">ortho</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">10.0f</span><span class="token punctuation">,</span> <span class="token number">10.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">10.0f</span><span class="token punctuation">,</span> <span class="token number">10.0f</span><span class="token punctuation">,</span> near_plane<span class="token punctuation">,</span> far_plane<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这里有个本节教程的 demo 场景中使用的正交投影矩阵的例子。因为投影矩阵间接决定可视区域的范围，以及哪些东西不会被裁切，你需要保证投影视锥（frustum）的大小，以包含打算在深度贴图中包含的物体。当物体和片元不在深度贴图中时，它们就不会产生阴影。</p><p>为了创建一个视图矩阵来变换每个物体，把它们变换到从光源视角可见的空间中，我们将使用 glm::lookAt 函数；这次从光源的位置看向场景中央。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span>mat4 lightView <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">lookAt</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">vec</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2.0f</span><span class="token punctuation">,</span> <span class="token number">4.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>二者相结合为我们提供了一个光空间的变换矩阵，它将每个世界空间坐标变换到光源处所见到的那个空间；这正是我们渲染深度贴图所需要的。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span>mat4 lightSpaceMatrix <span class="token operator">=</span> lightProjection <span class="token operator">*</span> lightView<span class="token punctuation">;</span></pre></td></tr></table></figure><p>这个 lightSpaceMatrix 正是前面我们称为<mark> T</mark> 的那个<mark>变换矩阵</mark>。有了 lightSpaceMatrix 只要给 shader 提供光空间的投影和视图矩阵，我们就能像往常那样渲染场景了。然而，我们只关心深度值，并非所有片元计算都在我们的着色器中进行。为了提升性能，我们将使用一个与之不同但更为简单的着色器来渲染出深度贴图。</p><h3 id="渲染至深度贴图"><a class="anchor" href="#渲染至深度贴图">#</a> 渲染至深度贴图</h3><p>当我们以光的透视图进行场景渲染的时候，我们会用一个比较简单的着色器，这个着色器除了把顶点变换到光空间以外，不会做得更多了。这个简单的着色器叫做 simpleDepthShader，就是使用下面的这个着色器：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> in vec3 position<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>uniform mat4 lightSpaceMatrix<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>uniform mat4 model<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    gl_Position <span class="token operator">=</span> lightSpaceMatrix <span class="token operator">*</span> model <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这个顶点着色器将一个单独模型的一个顶点，使用 lightSpaceMatrix 变换到光空间中。</p><p>由于我们没有颜色缓冲，最后的片元不需要任何处理，所以我们可以简单地使用一个空像素着色器：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span>             </pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// gl_FragDepth = gl_FragCoord.z;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这个空像素着色器什么也不干，运行完后，深度缓冲会被更新。我们可以取消那行的注释，来显式设置深度，但是这个（指注释掉那行之后）是更有效率的，因为底层无论如何都会默认去设置深度缓冲。</p><p>渲染深度缓冲现在成了：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>simpleDepthShader<span class="token punctuation">.</span><span class="token function">Use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glUniformMatrix4fv</span><span class="token punctuation">(</span>lightSpaceMatrixLocation<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">value_ptr</span><span class="token punctuation">(</span>lightSpaceMatrix<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glViewport</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> SHADOW_WIDTH<span class="token punctuation">,</span> SHADOW_HEIGHT<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> depthMapFBO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">glClear</span><span class="token punctuation">(</span>GL_DEPTH_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">RenderScene</span><span class="token punctuation">(</span>simpleDepthShader<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这里的 RenderScene 函数的参数是一个着色器程序（shader program），它调用所有相关的绘制函数，并在需要的地方设置相应的模型矩阵。</p><p>最后，在光的透视图视角下，很完美地用每个可见片元的最近深度填充了深度缓冲。通过将这个纹理投射到一个 2D 四边形上（和我们在帧缓冲一节做的后处理过程类似），就能在屏幕上显示出来，我们会获得这样的东西：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/03/01/shadow_mapping_depth_map.png" alt="image"></p><p>将深度贴图渲染到四边形上的像素着色器：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>out vec4 color<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>in vec2 TexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>uniform sampler2D depthMap<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#123;</span>             </pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">float</span> depthValue <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>depthMap<span class="token punctuation">,</span> TexCoords<span class="token punctuation">)</span><span class="token punctuation">.</span>r<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    color <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span><span class="token function">vec3</span><span class="token punctuation">(</span>depthValue<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>要注意的是当用透视投影矩阵取代正交投影矩阵来显示深度时，有一些轻微的改动，因为使用透视投影时，深度是非线性的。本节教程的最后，我们会讨论这些不同之处。</p><h3 id="渲染阴影"><a class="anchor" href="#渲染阴影">#</a> 渲染阴影</h3><p>正确地生成深度贴图以后我们就可以开始生成阴影了。这段代码在像素着色器中执行，用来检验一个片元是否在阴影之中，不过我们在顶点着色器中进行光空间的变换：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> in vec3 position<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> in vec3 normal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> in vec2 texCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>out vec2 TexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>out VS_OUT <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    vec3 FragPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    vec3 Normal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    vec2 TexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    vec4 FragPosLightSpace<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span> vs_out<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>uniform mat4 projection<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>uniform mat4 view<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>uniform mat4 model<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>uniform mat4 lightSpaceMatrix<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    gl_Position <span class="token operator">=</span> projection <span class="token operator">*</span> view <span class="token operator">*</span> model <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    vs_out<span class="token punctuation">.</span>FragPos <span class="token operator">=</span> <span class="token function">vec3</span><span class="token punctuation">(</span>model <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    vs_out<span class="token punctuation">.</span>Normal <span class="token operator">=</span> <span class="token function">transpose</span><span class="token punctuation">(</span><span class="token function">inverse</span><span class="token punctuation">(</span><span class="token function">mat3</span><span class="token punctuation">(</span>model<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> normal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    vs_out<span class="token punctuation">.</span>TexCoords <span class="token operator">=</span> texCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    vs_out<span class="token punctuation">.</span>FragPosLightSpace <span class="token operator">=</span> lightSpaceMatrix <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>vs_out<span class="token punctuation">.</span>FragPos<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这儿的新的地方是 FragPosLightSpace 这个输出向量。我们用同一个 lightSpaceMatrix，把世界空间顶点位置转换为光空间。顶点着色器传递一个普通的经变换的世界空间顶点位置 vs_out.FragPos 和一个光空间的 vs_out.FragPosLightSpace 给像素着色器。</p><p>像素着色器使用 Blinn-Phong 光照模型渲染场景。我们接着计算出一个 shadow 值，当 fragment 在阴影中时是 1.0，在阴影外是 0.0。然后，diffuse 和 specular 颜色会乘以这个阴影元素。由于阴影不会是全黑的（由于散射），我们把 ambient 分量从乘法中剔除。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>out vec4 FragColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>in VS_OUT <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    vec3 FragPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    vec3 Normal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    vec2 TexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    vec4 FragPosLightSpace<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span> fs_in<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>uniform sampler2D diffuseTexture<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>uniform sampler2D shadowMap<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>uniform vec3 lightPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>uniform vec3 viewPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token keyword">float</span> <span class="token function">ShadowCalculation</span><span class="token punctuation">(</span>vec4 fragPosLightSpace<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#123;</span>           </pre></td></tr><tr><td data-num="24"></td><td><pre>    vec3 color <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>diffuseTexture<span class="token punctuation">,</span> fs_in<span class="token punctuation">.</span>TexCoords<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    vec3 normal <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>fs_in<span class="token punctuation">.</span>Normal<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    vec3 lightColor <span class="token operator">=</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token comment">// Ambient</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    vec3 ambient <span class="token operator">=</span> <span class="token number">0.15</span> <span class="token operator">*</span> color<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token comment">// Diffuse</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    vec3 lightDir <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>lightPos <span class="token operator">-</span> fs_in<span class="token punctuation">.</span>FragPos<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token keyword">float</span> diff <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>lightDir<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    vec3 diffuse <span class="token operator">=</span> diff <span class="token operator">*</span> lightColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token comment">// Specular</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    vec3 viewDir <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>viewPos <span class="token operator">-</span> fs_in<span class="token punctuation">.</span>FragPos<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    vec3 reflectDir <span class="token operator">=</span> <span class="token function">reflect</span><span class="token punctuation">(</span><span class="token operator">-</span>lightDir<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token keyword">float</span> spec <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>    vec3 halfwayDir <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>lightDir <span class="token operator">+</span> viewDir<span class="token punctuation">)</span><span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="38"></td><td><pre>    spec <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>normal<span class="token punctuation">,</span> halfwayDir<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">64.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>    vec3 specular <span class="token operator">=</span> spec <span class="token operator">*</span> lightColor<span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num="40"></td><td><pre>    <span class="token comment">// 计算阴影</span></pre></td></tr><tr><td data-num="41"></td><td><pre>    <span class="token keyword">float</span> shadow <span class="token operator">=</span> <span class="token function">ShadowCalculation</span><span class="token punctuation">(</span>fs_in<span class="token punctuation">.</span>FragPosLightSpace<span class="token punctuation">)</span><span class="token punctuation">;</span>       </pre></td></tr><tr><td data-num="42"></td><td><pre>    vec3 lighting <span class="token operator">=</span> <span class="token punctuation">(</span>ambient <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> shadow<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>diffuse <span class="token operator">+</span> specular<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> color<span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num="43"></td><td><pre></pre></td></tr><tr><td data-num="44"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>lighting<span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>像素着色器大部分是从高级光照教程中复制过来，只不过加上了个阴影计算。我们声明一个 shadowCalculation 函数，用它计算阴影。像素着色器的最后，我们我们把 diffuse 和 specular 乘以 (1 - 阴影元素)，这表示这个片元有多大成分不在阴影中。这个像素着色器还需要两个额外输入，一个是光空间的片元位置和第一个渲染阶段得到的深度贴图。</p><p>首先要检查一个片元是否在阴影中，把光空间片元位置转换为裁切空间的标准化设备坐标。当我们在顶点着色器输出一个裁切空间顶点位置到 gl_Position 时，OpenGL 自动进行一个透视除法，将裁切空间坐标的范围 - w 到 w 转为 - 1 到 1，这要将 x、y、z 元素除以向量的 w 元素来实现。由于裁切空间的 FragPosLightSpace 并不会通过 gl_Position 传到像素着色器里，我们必须自己做透视除法：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> <span class="token function">ShadowCalculation</span><span class="token punctuation">(</span>vec4 fragPosLightSpace<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 执行透视除法</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    vec3 projCoords <span class="token operator">=</span> fragPosLightSpace<span class="token punctuation">.</span>xyz <span class="token operator">/</span> fragPosLightSpace<span class="token punctuation">.</span>w<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这将返回片段在 [-1，1] 范围内的光空间位置。</p><blockquote><p>当使用正交投影矩阵，顶点 w 元素仍保持不变，所以这一步实际上毫无意义。可是，当使用透视投影的时候就是必须的了，所以为了保证在两种投影矩阵下都有效就得留着这行。</p></blockquote><p>因为深度图的深度在 [0，1] 范围内，我们还想使用 projCoords 从深度图中进行采样，因此我们将 NDC 坐标转换为范围 [ 0，1]：（译者注：这里的意思是，上面的 projCoords 的 xyz 分量都是 [-1,1]（下面会指出这对于远平面之类的点才成立），而为了和深度贴图的深度相比较，z 分量需要变换到 [0,1]；为了作为从深度贴图中采样的坐标，xy 分量也需要变换到 [0,1]。所以整个 projCoords 向量都需要变换到 [0,1] 范围。）</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>projCoords <span class="token operator">=</span> projCoords <span class="token operator">*</span> <span class="token number">0.5</span> <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>有了这些投影坐标，我们就能从深度贴图中采样得到 0 到 1 的结果，从第一个渲染阶段的 projCoords 坐标直接对应于变换过的 NDC 坐标。我们将得到光的位置视野下最近的深度:</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> closestDepth <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>shadowMap<span class="token punctuation">,</span> projCoords<span class="token punctuation">.</span>xy<span class="token punctuation">)</span><span class="token punctuation">.</span>r<span class="token punctuation">;</span></pre></td></tr></table></figure><p>为了得到片元的当前深度，我们简单获取投影向量的 z 坐标，它等于来自光的透视视角的片元的深度。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> currentDepth <span class="token operator">=</span> projCoords<span class="token punctuation">.</span>z<span class="token punctuation">;</span></pre></td></tr></table></figure><p>实际的对比就是简单检查 currentDepth 是否高于 closetDepth，如果是，那么片元就在阴影中。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> shadow <span class="token operator">=</span> currentDepth <span class="token operator">></span> closestDepth  <span class="token operator">?</span> <span class="token number">1.0</span> <span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>完整的 shadowCalculation 函数是这样的：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> <span class="token function">ShadowCalculation</span><span class="token punctuation">(</span>vec4 fragPosLightSpace<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 执行透视除法</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    vec3 projCoords <span class="token operator">=</span> fragPosLightSpace<span class="token punctuation">.</span>xyz <span class="token operator">/</span> fragPosLightSpace<span class="token punctuation">.</span>w<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// 变换到 [0,1] 的范围</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    projCoords <span class="token operator">=</span> projCoords <span class="token operator">*</span> <span class="token number">0.5</span> <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// 取得最近点的深度 (使用 [0,1] 范围下的 fragPosLight 当坐标)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">float</span> closestDepth <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>shadowMap<span class="token punctuation">,</span> projCoords<span class="token punctuation">.</span>xy<span class="token punctuation">)</span><span class="token punctuation">.</span>r<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// 取得当前片元在光源视角下的深度</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">float</span> currentDepth <span class="token operator">=</span> projCoords<span class="token punctuation">.</span>z<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">// 检查当前片元是否在阴影中</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">float</span> shadow <span class="token operator">=</span> currentDepth <span class="token operator">></span> closestDepth  <span class="token operator">?</span> <span class="token number">1.0</span> <span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">return</span> shadow<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>激活这个着色器，绑定合适的纹理，激活第二个渲染阶段默认的投影以及视图矩阵，结果如下图所示：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/03/01/shadow_mapping_shadows.png" alt="image"></p><h3 id="改进阴影贴图"><a class="anchor" href="#改进阴影贴图">#</a> 改进阴影贴图</h3><p>我们试图让阴影映射工作，但是你也看到了，阴影映射还是有点不真实，我们修复它才能获得更好的效果，这是下面的部分所关注的焦点。</p><h3 id="阴影失真"><a class="anchor" href="#阴影失真">#</a> 阴影失真</h3><p>前面的图片中明显有不对的地方。放大看会发现明显的线条样式：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/03/01/shadow_mapping_acne.png" alt="image"></p><p>我们可以看到地板四边形渲染出很大一块交替黑线。这种阴影贴图的不真实感叫做<mark>阴影失真</mark> (Shadow Acne)，下图解释了成因：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/03/01/shadow_mapping_acne_diagram.png" alt="image"></p><p>因为阴影贴图受限于解析度，在距离光源比较远的情况下，多个片元可能从深度贴图的同一个值中去采样。图片每个斜坡代表深度贴图一个单独的纹理像素。你可以看到，多个片元从同一个深度值进行采样。</p><p>虽然很多时候没问题，但是当光源以一个角度朝向表面的时候就会出问题，这种情况下深度贴图也是从一个角度下进行渲染的。多个片元就会从同一个斜坡的深度纹理像素中采样，有些在地板上面，有些在地板下面；这样我们所得到的阴影就有了差异。因为这个，有些片元被认为是在阴影之中，有些不在，由此产生了图片中的条纹样式。</p><p>我们可以用一个叫做<mark>阴影偏移</mark>（shadow bias）的技巧来解决这个问题，我们简单的对表面的深度（或深度贴图）应用一个偏移量，这样片元就不会被错误地认为在表面之下了。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/03/01/shadow_mapping_acne_bias.png" alt="image"></p><p>使用了偏移量后，所有采样点都获得了比表面深度更小的深度值，这样整个表面就正确地被照亮，没有任何阴影。我们可以这样实现这个偏移：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> bias <span class="token operator">=</span> <span class="token number">0.005</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">float</span> shadow <span class="token operator">=</span> currentDepth <span class="token operator">-</span> bias <span class="token operator">></span> closestDepth  <span class="token operator">?</span> <span class="token number">1.0</span> <span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>一个 0.005 的偏移就能帮到很大的忙，但是有些表面坡度很大，仍然会产生阴影失真。有一个更加可靠的办法能够根据表面朝向光线的角度更改偏移量：使用点乘：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> bias <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0.05</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> <span class="token function">dot</span><span class="token punctuation">(</span>normal<span class="token punctuation">,</span> lightDir<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.005</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这里我们有一个偏移量的最大值 0.05，和一个最小值 0.005，它们是基于表面法线和光照方向的。这样像地板这样的表面几乎与光源垂直，得到的偏移就很小，而比如立方体的侧面这种表面得到的偏移就更大。下图展示了同一个场景，但使用了阴影偏移，效果的确更好：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/03/01/shadow_mapping_with_bias.png" alt="image"></p><p>选用正确的偏移数值，在不同的场景中需要一些像这样的轻微调校，但大多情况下，实际上就是增加偏移量直到所有失真都被移除的问题。</p><h3 id="悬浮"><a class="anchor" href="#悬浮">#</a> 悬浮</h3><p>使用阴影偏移的一个缺点是你对物体的实际深度应用了平移。偏移有可能足够大，以至于可以看出阴影相对实际物体位置的偏移，你可以从下图看到这个现象（这是一个夸张的偏移值）：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/03/01/shadow_mapping_peter_panning.png" alt="image"></p><p>这个阴影失真叫做<mark>悬浮</mark> (Peter Panning)，因为物体看起来轻轻悬浮在表面之上（译注 Peter Pan 就是童话彼得潘，而 panning 有平移、悬浮之意，而且彼得潘是个会飞的男孩…）。我们可以使用一个叫技巧解决大部分的 Peter panning 问题：当渲染深度贴图时候使用<mark>正面剔除</mark>（front face culling）你也许记得在面剔除教程中 OpenGL 默认是背面剔除。我们要告诉 OpenGL 我们要剔除正面。</p><p>因为我们只需要深度贴图的深度值，对于实体物体无论我们用它们的正面还是背面都没问题。使用背面深度不会有错误，因为阴影在物体内部有错误我们也看不见。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/03/01/shadow_mapping_culling.png" alt="image"></p><p>为了修复 peter 游移，我们要进行正面剔除，先必须开启 GL_CULL_FACE：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glCullFace</span><span class="token punctuation">(</span>GL_FRONT<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">RenderSceneToDepthMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glCullFace</span><span class="token punctuation">(</span>GL_BACK<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不要忘记设回原先的 culling face</span></pre></td></tr></table></figure><p>这十分有效地解决了 peter panning 的问题，但只针对实体物体，内部不会对外开口。我们的场景中，在立方体上工作的很好，但在地板上无效，因为正面剔除完全移除了地板。地面是一个单独的平面，不会被完全剔除。如果有人打算使用这个技巧解决 peter panning 必须考虑到只有剔除物体的正面才有意义。</p><p>另一个要考虑到的地方是接近阴影的物体仍然会出现不正确的效果。必须考虑到何时使用正面剔除对物体才有意义。不过使用普通的偏移值通常就能避免 peter panning。</p><h3 id="采样过多"><a class="anchor" href="#采样过多">#</a> 采样过多</h3><p>无论你喜不喜欢还有一个视觉差异，就是光的视锥不可见的区域一律被认为是处于阴影中，不管它真的处于阴影之中。出现这个状况是因为超出光的视锥的投影坐标比 1.0 大，这样采样的深度纹理就会超出他默认的 0 到 1 的范围。根据纹理环绕方式，我们将会得到不正确的深度结果，它不是基于真实的来自光源的深度值。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/03/01/shadow_mapping_outside_frustum.png" alt="image"></p><p>你可以在图中看到，光照有一个区域，超出该区域就成为了阴影；这个区域实际上代表着深度贴图的大小，这个贴图投影到了地板上。发生这种情况的原因是我们之前将深度贴图的环绕方式设置成了 GL_REPEAT。</p><p>我们宁可让所有超出深度贴图的坐标的深度范围是 1.0，这样超出的坐标将永远不在阴影之中。我们可以储存一个边框颜色，然后把深度贴图的纹理环绕选项设置为 GL_CLAMP_TO_BORDER：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_WRAP_S<span class="token punctuation">,</span> GL_CLAMP_TO_BORDER<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_WRAP_T<span class="token punctuation">,</span> GL_CLAMP_TO_BORDER<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>GLfloat borderColor<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glTexParameterfv</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_BORDER_COLOR<span class="token punctuation">,</span> borderColor<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>现在如果我们采样深度贴图 0 到 1 坐标范围以外的区域，纹理函数总会返回一个 1.0 的深度值，阴影值为 0.0。结果看起来会更真实：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/03/01/shadow_mapping_clamp_edge.png" alt="image"></p><p>仍有一部分是黑暗区域。那里的坐标超出了光的<mark>正交视锥的远平面</mark>。你可以看到这片黑色区域总是出现在光源视锥的极远处。</p><p>当一个点比光的远平面还要远时，它的投影坐标的 z 坐标大于 1.0。这种情况下，GL_CLAMP_TO_BORDER 环绕方式不起作用，因为我们把坐标的 z 元素和深度贴图的值进行了对比；它总是为大于 1.0 的 z 返回 true。</p><p>解决这个问题也很简单，只要投影向量的 z 坐标大于 1.0，我们就把 shadow 的值强制设为 0.0：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> <span class="token function">ShadowCalculation</span><span class="token punctuation">(</span>vec4 fragPosLightSpace<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>projCoords<span class="token punctuation">.</span>z <span class="token operator">></span> <span class="token number">1.0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        shadow <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">return</span> shadow<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>检查远平面，并将深度贴图限制为一个手工指定的边界颜色，就能解决深度贴图采样超出的问题，我们最终会得到下面我们所追求的效果：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/03/01/shadow_mapping_over_sampling_fixed.png" alt="image"></p><p>这些结果意味着，只有在深度贴图范围以内的被投影的 fragment 坐标才有阴影，所以任何超出范围的都将会没有阴影。由于在游戏中通常这只发生在远处，就会比我们之前的那个明显的黑色区域效果更真实。</p><h3 id="pcf"><a class="anchor" href="#pcf">#</a> PCF</h3><p>阴影现在已经附着到场景中了，不过这仍不是我们想要的。如果你放大看阴影，阴影映射对解析度的依赖很快变得很明显。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/03/01/shadow_mapping_zoom.png" alt="image"></p><p>因为深度贴图有一个固定的解析度，多个片元对应于一个纹理像素。结果就是多个片元会从深度贴图的同一个深度值进行采样，这几个片元便得到的是同一个阴影，这就会产生锯齿边。</p><p>你可以通过增加深度贴图解析度的方式来降低锯齿块，也可以尝试尽可能的让光的视锥接近场景。</p><p>另一个（并不完整的）解决方案叫做 PCF（percentage-closer filtering），这是一种多个不同过滤方式的组合，它产生柔和阴影，使它们出现更少的锯齿块和硬边。核心思想是从<mark>深度贴图中多次采样</mark>，每一次采样的纹理坐标都稍有不同。每个独立的样本可能在也可能不再阴影中。所有的次生结果接着结合在一起，进行平均化，我们就得到了柔和阴影。</p><p>一个简单的 PCF 的实现是简单的从纹理像素四周对深度贴图采样，然后把结果平均起来：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> shadow <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>vec2 texelSize <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token function">textureSize</span><span class="token punctuation">(</span>shadowMap<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> x <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>x<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> y <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>y<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">float</span> pcfDepth <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>shadowMap<span class="token punctuation">,</span> projCoords<span class="token punctuation">.</span>xy <span class="token operator">+</span> <span class="token function">vec2</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">*</span> texelSize<span class="token punctuation">)</span><span class="token punctuation">.</span>r<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre>        shadow <span class="token operator">+=</span> currentDepth <span class="token operator">-</span> bias <span class="token operator">></span> pcfDepth <span class="token operator">?</span> <span class="token number">1.0</span> <span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">;</span>        </pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span>    </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>shadow <span class="token operator">/=</span> <span class="token number">9.0</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这个 textureSize 返回一个给定采样器纹理的 0 级 mipmap 的 vec2 类型的宽和高。用 1 除以它返回一个单独纹理像素的大小，我们用以对纹理坐标进行偏移，确保每个新样本，来自不同的深度值。这里我们采样得到 9 个值，它们在投影坐标的 x 和 y 值的周围，为阴影阻挡进行测试，并最终通过样本的总数目将结果平均化。</p><p>使用更多的样本，更改 texelSize 变量，你就可以增加阴影的柔和程度。下面你可以看到应用了 PCF 的阴影：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/03/01/shadow_mapping_soft_shadows.png" alt="image"></p><p>从稍微远一点的距离看去，阴影效果好多了，也不那么生硬了。如果你放大，仍会看到阴影贴图解析度的不真实感，但通常对于大多数应用来说效果已经很好了。</p><p>实际上 PCF 还有更多的内容，以及很多技术要点需要考虑以提升柔和阴影的效果，但处于本章内容长度考虑，我们将留在以后讨论。</p><h3 id="正交-vs-投影"><a class="anchor" href="#正交-vs-投影">#</a> 正交 vs 投影</h3><p>在渲染深度贴图的时候，正交 (Orthographic) 和投影 (Projection) 矩阵之间有所不同。正交投影矩阵并不会将场景用透视图进行变形，所有视线 / 光线都是平行的，这使它对于定向光来说是个很好的投影矩阵。然而透视投影矩阵，会将所有顶点根据透视关系进行变形，结果因此而不同。下图展示了两种投影方式所产生的不同阴影区域：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/03/01/shadow_mapping_projection.png" alt="image"></p><p>透视投影对于光源来说更合理，不像定向光，它是有自己的位置的。透视投影因此更经常用在点光源和聚光灯上，而正交投影经常用在定向光上。</p><p>另一个细微差别是，透视投影矩阵，将深度缓冲视觉化经常会得到一个几乎全白的结果。发生这个是因为透视投影下，深度变成了非线性的深度值，它的大多数可辨范围接近于近平面。为了可以像使用正交投影一样合适的观察到深度值，你必须先讲过非线性深度值转变为线性的，我们在深度测试教程中已经讨论过。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>out vec4 color<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>in vec2 TexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>uniform sampler2D depthMap<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>uniform <span class="token keyword">float</span> near_plane<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>uniform <span class="token keyword">float</span> far_plane<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">float</span> <span class="token function">LinearizeDepth</span><span class="token punctuation">(</span><span class="token keyword">float</span> depth<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">float</span> z <span class="token operator">=</span> depth <span class="token operator">*</span> <span class="token number">2.0</span> <span class="token operator">-</span> <span class="token number">1.0</span><span class="token punctuation">;</span> <span class="token comment">// Back to NDC </span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">2.0</span> <span class="token operator">*</span> near_plane <span class="token operator">*</span> far_plane<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>far_plane <span class="token operator">+</span> near_plane <span class="token operator">-</span> z <span class="token operator">*</span> <span class="token punctuation">(</span>far_plane <span class="token operator">-</span> near_plane<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#123;</span>             </pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">float</span> depthValue <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>depthMap<span class="token punctuation">,</span> TexCoords<span class="token punctuation">)</span><span class="token punctuation">.</span>r<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    color <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token function">LinearizeDepth</span><span class="token punctuation">(</span>depthValue<span class="token punctuation">)</span> <span class="token operator">/</span> far_plane<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// perspective</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token comment">// color = vec4(vec3(depthValue), 1.0); // orthographic</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这个深度值与我们见到的用正交投影的很相似。需要注意的是，这个只适用于调试；正交或投影矩阵的深度检查仍然保持原样，因为相关的深度并没有改变。</p><h3 id="附加资源-2"><a class="anchor" href="#附加资源-2">#</a> 附加资源</h3><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wtdHV0b3JpYWwub3JnL2ludGVybWVkaWF0ZS10dXRvcmlhbHMvdHV0b3JpYWwtMTYtc2hhZG93LW1hcHBpbmcv">Tutorial 16 : Shadow mapping</span>：提供的类似的阴影映射教程，里面有一些额外的解释。</li><li><span class="exturl" data-url="aHR0cDovL29nbGRldi5hdHNwYWNlLmNvLnVrL3d3dy90dXRvcmlhbDIzL3R1dG9yaWFsMjMuaHRtbA==">Shadow Mapping – Part 1：ogldev</span>：提供的另一个阴影映射教程。</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1Fc2NjZ2VVcGRzTQ==">How Shadow Mapping Works</span>：的一个第三方 YouTube 视频教程，里面解释了阴影映射及其实现。</li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vemgtY24vd2luZG93cy9kZXNrdG9wL0R4VGVjaEFydHMvY29tbW9uLXRlY2huaXF1ZXMtdG8taW1wcm92ZS1zaGFkb3ctZGVwdGgtbWFwcw==">Common Techniques to Improve Shadow Depth Maps</span>：微软的一篇好文章，其中理出了很多提升阴影贴图质量的技术。</li></ul><h2 id="点光源阴影"><a class="anchor" href="#点光源阴影">#</a> 点光源阴影</h2><p>上个教程我们学到了如何使用阴影映射技术创建动态阴影。效果不错，但它只适合定向光，因为阴影只是在单一定向光源下生成的。所以它也叫定向阴影映射，深度（阴影）贴图生成自定向光的视角。</p><blockquote><p>本节我们的焦点是在各种方向生成<strong>动态阴影</strong>。这个技术可以适用于点光源，生成所有方向上的阴影。</p></blockquote><p>这个技术叫做点<mark>光阴影</mark>，过去的名字是<mark>万向阴影贴图</mark>（omnidirectional shadow maps）技术。</p><p>本节代码基于前面的阴影映射教程，所以如果你对传统阴影映射不熟悉，还是建议先读一读阴影映射教程。 算法和定向阴影映射差不多：我们从光的透视图生成一个深度贴图，基于当前 fragment 位置来对深度贴图采样，然后用储存的深度值和每个 fragment 进行对比，看看它是否在阴影中。定向阴影映射和万向阴影映射的主要不同在于深度贴图的使用上。</p><p>对于深度贴图，我们需要从一个点光源的所有渲染场景，普通 2D 深度贴图不能工作；如果我们使用立方体贴图会怎样？因为立方体贴图可以储存 6 个面的环境数据，它可以将整个场景渲染到立方体贴图的每个面上，把它们当作点光源四周的深度值来采样。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/03/02/point_shadows_diagram.png" alt="image"></p><p>生成后的深度立方体贴图被传递到光照像素着色器，它会用一个方向向量来采样立方体贴图，从而得到当前的 fragment 的深度（从光的透视图）。大部分复杂的事情已经在阴影映射教程中讨论过了。算法只是在深度立方体贴图生成上稍微复杂一点。</p><h3 id="生成深度立方体贴图"><a class="anchor" href="#生成深度立方体贴图">#</a> 生成深度立方体贴图</h3><p>为创建一个光周围的深度值的立方体贴图，我们必须渲染场景 6 次：每次一个面。显然渲染场景 6 次需要 6 个不同的视图矩阵，每次把一个不同的立方体贴图面附加到帧缓冲对象上。这看起来是这样的：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    GLuint face <span class="token operator">=</span> GL_TEXTURE_CUBE_MAP_POSITIVE_X <span class="token operator">+</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">glFramebufferTexture2D</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> GL_DEPTH_ATTACHMENT<span class="token punctuation">,</span> face<span class="token punctuation">,</span> depthCubemap<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">BindViewMatrix</span><span class="token punctuation">(</span>lightViewMatrices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">RenderScene</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这会很耗费性能因为一个深度贴图下需要进行很多渲染调用。这个教程中我们将转而使用另外的一个小技巧来做这件事，几何着色器允许我们使用一次渲染过程来建立深度立方体贴图。</p><p>首先，我们需要创建一个立方体贴图：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> depthCubemap<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glGenTextures</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>depthCubemap<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>然后生成立方体贴图的每个面，将它们作为 2D 深度值纹理图像：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> SHADOW_WIDTH <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">,</span> SHADOW_HEIGHT <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> depthCubemap<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token function">glTexImage2D</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP_POSITIVE_X <span class="token operator">+</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_DEPTH_COMPONENT<span class="token punctuation">,</span>SHADOW_WIDTH<span class="token punctuation">,</span> SHADOW_HEIGHT<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_DEPTH_COMPONENT<span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>不要忘记设置合适的纹理参数：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> GL_TEXTURE_MAG_FILTER<span class="token punctuation">,</span> GL_NEAREST<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> GL_TEXTURE_MIN_FILTER<span class="token punctuation">,</span> GL_NEAREST<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> GL_TEXTURE_WRAP_S<span class="token punctuation">,</span> GL_CLAMP_TO_EDGE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> GL_TEXTURE_WRAP_T<span class="token punctuation">,</span> GL_CLAMP_TO_EDGE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> GL_TEXTURE_WRAP_R<span class="token punctuation">,</span> GL_CLAMP_TO_EDGE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>还要记得调用 glDrawBuffer 和 glReadBuffer：当生成一个深度立方体贴图时我们只关心深度值，所以我们必须显式告诉 OpenGL 这个帧缓冲对象不会渲染到一个颜色缓冲里。</p><p>万向阴影贴图有两个渲染阶段：首先我们生成深度贴图，然后我们正常使用深度贴图渲染，在场景中创建阴影。帧缓冲对象和立方体贴图的处理看起是这样的：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 1. first render to depth cubemap</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glViewport</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> SHADOW_WIDTH<span class="token punctuation">,</span> SHADOW_HEIGHT<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> depthMapFBO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glClear</span><span class="token punctuation">(</span>GL_DEPTH_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">ConfigureShaderAndMatrices</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">RenderScene</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// 2. then render scene as normal with shadow mapping (using depth cubemap)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token function">glViewport</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> SCR_WIDTH<span class="token punctuation">,</span> SCR_HEIGHT<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT <span class="token operator">|</span> GL_DEPTH_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token function">ConfigureShaderAndMatrices</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> depthCubemap<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token function">RenderScene</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这个过程和默认的阴影映射一样，尽管这次我们渲染和使用的是一个立方体贴图深度纹理，而不是 2D 深度纹理。在我们实际开始从光的视角的所有方向渲染场景之前，我们先得计算出合适的变换矩阵。</p><h3 id="光空间的变换"><a class="anchor" href="#光空间的变换">#</a> 光空间的变换</h3><p>设置了帧缓冲和立方体贴图，我们需要一些方法来讲场景的所有几何体变换到 6 个光的方向中相应的光空间。与阴影映射教程类似，我们将需要一个光空间的变换矩阵 T，但是这次是每个面都有一个。</p><p>每个光空间的变换矩阵包含了投影和视图矩阵。对于投影矩阵来说，我们将使用一个透视投影矩阵；光源代表一个空间中的点，所以透视投影矩阵更有意义。每个光空间变换矩阵使用同样的投影矩阵：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> aspect <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>SHADOW_WIDTH<span class="token operator">/</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>SHADOW_HEIGHT<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">float</span> near <span class="token operator">=</span> <span class="token number">1.0f</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">float</span> far <span class="token operator">=</span> <span class="token number">25.0f</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>glm<span class="token operator">::</span>mat4 shadowProj <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">perspective</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">radians</span><span class="token punctuation">(</span><span class="token number">90.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> aspect<span class="token punctuation">,</span> near<span class="token punctuation">,</span> far<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>非常重要的一点是，这里 glm::perspective 的视野参数，设置为 90 度。90 度我们才能保证视野足够大到可以合适地填满立方体贴图的一个面，立方体贴图的所有面都能与其他面在边缘对齐。</p><p>因为投影矩阵在每个方向上并不会改变，我们可以在 6 个变换矩阵中重复使用。我们要为每个方向提供一个不同的视图矩阵。用 glm::lookAt 创建 6 个观察方向，每个都按顺序注视着立方体贴图的的一个方向：右、左、上、下、近、远：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>glm<span class="token operator">::</span>mat4<span class="token operator">></span> shadowTransforms<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>shadowTransforms<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>shadowProj <span class="token operator">*</span> glm<span class="token operator">::</span><span class="token function">lookAt</span><span class="token punctuation">(</span>lightPos<span class="token punctuation">,</span> lightPos <span class="token operator">+</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span><span class="token number">0.0</span><span class="token punctuation">,</span><span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">,</span><span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>shadowTransforms<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>shadowProj <span class="token operator">*</span> glm<span class="token operator">::</span><span class="token function">lookAt</span><span class="token punctuation">(</span>lightPos<span class="token punctuation">,</span> lightPos <span class="token operator">+</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">,</span><span class="token number">0.0</span><span class="token punctuation">,</span><span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">,</span><span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>shadowTransforms<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>shadowProj <span class="token operator">*</span> glm<span class="token operator">::</span><span class="token function">lookAt</span><span class="token punctuation">(</span>lightPos<span class="token punctuation">,</span> lightPos <span class="token operator">+</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span><span class="token number">1.0</span><span class="token punctuation">,</span><span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span><span class="token number">0.0</span><span class="token punctuation">,</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>shadowTransforms<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>shadowProj <span class="token operator">*</span> glm<span class="token operator">::</span><span class="token function">lookAt</span><span class="token punctuation">(</span>lightPos<span class="token punctuation">,</span> lightPos <span class="token operator">+</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">,</span><span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span><span class="token number">0.0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>shadowTransforms<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>shadowProj <span class="token operator">*</span> glm<span class="token operator">::</span><span class="token function">lookAt</span><span class="token punctuation">(</span>lightPos<span class="token punctuation">,</span> lightPos <span class="token operator">+</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span><span class="token number">0.0</span><span class="token punctuation">,</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">,</span><span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>shadowTransforms<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>shadowProj <span class="token operator">*</span> glm<span class="token operator">::</span><span class="token function">lookAt</span><span class="token punctuation">(</span>lightPos<span class="token punctuation">,</span> lightPos <span class="token operator">+</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span><span class="token number">0.0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">,</span><span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这里我们创建了 6 个视图矩阵，把它们乘以投影矩阵，来得到 6 个不同的光空间变换矩阵。glm::lookAt 的 target 参数是它注视的立方体贴图的面的一个方向。</p><p>这些变换矩阵发送到着色器渲染到立方体贴图里。</p><h3 id="深度着色器"><a class="anchor" href="#深度着色器">#</a> 深度着色器</h3><p>为了把值渲染到深度立方体贴图，我们将需要 3 个着色器：顶点和像素着色器，以及一个它们之间的几何着色器。</p><p>几何着色器是负责将所有世界空间的顶点变换到 6 个不同的光空间的着色器。因此顶点着色器简单地将顶点变换到世界空间，然后直接发送到几何着色器：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> in vec3 position<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>uniform mat4 model<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    gl_Position <span class="token operator">=</span> model <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>紧接着几何着色器以 3 个三角形的顶点作为输入，它还有一个光空间变换矩阵的 uniform 数组。几何着色器接下来会负责将顶点变换到光空间；这里它开始变得有趣了。</p><p>几何着色器有一个内建变量叫做 gl_Layer，它指定发散出基本图形送到立方体贴图的哪个面。当不管它时，几何着色器就会像往常一样把它的基本图形发送到输送管道的下一阶段，但当我们更新这个变量就能控制每个基本图形将渲染到立方体贴图的哪一个面。当然这只有当我们有了一个附加到激活的帧缓冲的立方体贴图纹理才有效：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>triangles<span class="token punctuation">)</span> in<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>triangle_strip<span class="token punctuation">,</span> max_vertices<span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">)</span> out<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>uniform mat4 shadowMatrices<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>out vec4 FragPos<span class="token punctuation">;</span> <span class="token comment">// FragPos from GS (output per emitvertex)</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> face <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> face <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token operator">++</span>face<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        gl_Layer <span class="token operator">=</span> face<span class="token punctuation">;</span> <span class="token comment">// built-in variable that specifies to which face we render.</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token comment">// for each triangle's vertices</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            FragPos <span class="token operator">=</span> gl_in<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>gl_Position<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            gl_Position <span class="token operator">=</span> shadowMatrices<span class="token punctuation">[</span>face<span class="token punctuation">]</span> <span class="token operator">*</span> FragPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token function">EmitVertex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">&#125;</span>    </pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token function">EndPrimitive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>几何着色器相对简单。我们输入一个三角形，输出总共 6 个三角形（6*3 顶点，所以总共 18 个顶点）。在 main 函数中，我们遍历立方体贴图的 6 个面，我们每个面指定为一个输出面，把这个面的 interger（整数）存到 gl_Layer。然后，我们通过把面的光空间变换矩阵乘以 FragPos，将每个世界空间顶点变换到相关的光空间，生成每个三角形。注意，我们还要将最后的 FragPos 变量发送给像素着色器，我们需要计算一个深度值。</p><p>上个教程，我们使用的是一个空的像素着色器，让 OpenGL 配置深度贴图的深度值。这次我们将计算自己的深度，这个深度就是每个 fragment 位置和光源位置之间的线性距离。计算自己的深度值使得之后的阴影计算更加直观。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>in vec4 FragPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>uniform vec3 lightPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>uniform <span class="token keyword">float</span> far_plane<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// get distance between fragment and light source</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">float</span> lightDistance <span class="token operator">=</span> <span class="token function">length</span><span class="token punctuation">(</span>FragPos<span class="token punctuation">.</span>xyz <span class="token operator">-</span> lightPos<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">// map to [0;1] range by dividing by far_plane</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    lightDistance <span class="token operator">=</span> lightDistance <span class="token operator">/</span> far_plane<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">// write this as modified depth</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    gl_FragDepth <span class="token operator">=</span> lightDistance<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>像素着色器将来自几何着色器的 FragPos、光的位置向量和视锥的远平面值作为输入。这里我们把 fragment 和光源之间的距离，映射到 0 到 1 的范围，把它写入为 fragment 的深度值。</p><p>使用这些着色器渲染场景，立方体贴图附加的帧缓冲对象激活以后，你会得到一个完全填充的深度立方体贴图，以便于进行第二阶段的阴影计算。</p><h3 id="万向阴影贴图"><a class="anchor" href="#万向阴影贴图">#</a> 万向阴影贴图</h3><p>所有事情都做好了，是时候来渲染万向阴影 (Omnidirectional Shadow) 了。这个过程和定向阴影映射教程相似，尽管这次我们绑定的深度贴图是一个立方体贴图，而不是 2D 纹理，并且将光的投影的远平面发送给了着色器。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glViewport</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> SCR_WIDTH<span class="token punctuation">,</span> SCR_HEIGHT<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT <span class="token operator">|</span> GL_DEPTH_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>shader<span class="token punctuation">.</span><span class="token function">Use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// ... send uniforms to shader (including light's far_plane value)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">glActiveTexture</span><span class="token punctuation">(</span>GL_TEXTURE0<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> depthCubemap<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// ... bind other textures</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">RenderScene</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这里的 renderScene 函数在一个大立方体房间中渲染一些立方体，它们散落在大立方体各处，光源在场景中央。</p><p>顶点着色器和像素着色器和原来的阴影映射着色器大部分都一样：不同之处是在光空间中像素着色器不再需要一个 fragment 位置，现在我们可以使用一个方向向量采样深度值。</p><p>因为这个顶点着色器不再需要将他的位置向量变换到光空间，所以我们可以去掉 FragPosLightSpace 变量：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> in vec3 position<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> in vec3 normal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> in vec2 texCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>out vec2 TexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>out VS_OUT <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    vec3 FragPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    vec3 Normal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    vec2 TexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span> vs_out<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>uniform mat4 projection<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>uniform mat4 view<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>uniform mat4 model<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    gl_Position <span class="token operator">=</span> projection <span class="token operator">*</span> view <span class="token operator">*</span> model <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    vs_out<span class="token punctuation">.</span>FragPos <span class="token operator">=</span> <span class="token function">vec3</span><span class="token punctuation">(</span>model <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    vs_out<span class="token punctuation">.</span>Normal <span class="token operator">=</span> <span class="token function">transpose</span><span class="token punctuation">(</span><span class="token function">inverse</span><span class="token punctuation">(</span><span class="token function">mat3</span><span class="token punctuation">(</span>model<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> normal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    vs_out<span class="token punctuation">.</span>TexCoords <span class="token operator">=</span> texCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>片段着色器的 Blinn-Phong 光照代码和我们之前阴影相乘的结尾部分一样：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>out vec4 FragColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>in VS_OUT <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    vec3 FragPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    vec3 Normal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    vec2 TexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span> fs_in<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>uniform sampler2D diffuseTexture<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>uniform samplerCube depthMap<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>uniform vec3 lightPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>uniform vec3 viewPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>uniform <span class="token keyword">float</span> far_plane<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token keyword">float</span> <span class="token function">ShadowCalculation</span><span class="token punctuation">(</span>vec3 fragPos<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#123;</span>           </pre></td></tr><tr><td data-num="25"></td><td><pre>    vec3 color <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>diffuseTexture<span class="token punctuation">,</span> fs_in<span class="token punctuation">.</span>TexCoords<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    vec3 normal <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>fs_in<span class="token punctuation">.</span>Normal<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    vec3 lightColor <span class="token operator">=</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token comment">// Ambient</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    vec3 ambient <span class="token operator">=</span> <span class="token number">0.3</span> <span class="token operator">*</span> color<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token comment">// Diffuse</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    vec3 lightDir <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>lightPos <span class="token operator">-</span> fs_in<span class="token punctuation">.</span>FragPos<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token keyword">float</span> diff <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>lightDir<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    vec3 diffuse <span class="token operator">=</span> diff <span class="token operator">*</span> lightColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token comment">// Specular</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    vec3 viewDir <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>viewPos <span class="token operator">-</span> fs_in<span class="token punctuation">.</span>FragPos<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    vec3 reflectDir <span class="token operator">=</span> <span class="token function">reflect</span><span class="token punctuation">(</span><span class="token operator">-</span>lightDir<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>    <span class="token keyword">float</span> spec <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    vec3 halfwayDir <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>lightDir <span class="token operator">+</span> viewDir<span class="token punctuation">)</span><span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="39"></td><td><pre>    spec <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>normal<span class="token punctuation">,</span> halfwayDir<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">64.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>    vec3 specular <span class="token operator">=</span> spec <span class="token operator">*</span> lightColor<span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num="41"></td><td><pre>    <span class="token comment">// Calculate shadow</span></pre></td></tr><tr><td data-num="42"></td><td><pre>    <span class="token keyword">float</span> shadow <span class="token operator">=</span> <span class="token function">ShadowCalculation</span><span class="token punctuation">(</span>fs_in<span class="token punctuation">.</span>FragPos<span class="token punctuation">)</span><span class="token punctuation">;</span>                      </pre></td></tr><tr><td data-num="43"></td><td><pre>    vec3 lighting <span class="token operator">=</span> <span class="token punctuation">(</span>ambient <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> shadow<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>diffuse <span class="token operator">+</span> specular<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> color<span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num="44"></td><td><pre></pre></td></tr><tr><td data-num="45"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>lighting<span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>有一些细微的不同：光照代码一样，但我们现在有了一个 uniform 变量 samplerCube，shadowCalculation 函数用 fragment 的位置作为它的参数，取代了光空间的 fragment 位置。我们现在还要引入光的视锥的远平面值，后面我们会需要它。像素着色器的最后，我们计算出阴影元素，当 fragment 在阴影中时它是 1.0，不在阴影中时是 0.0。我们使用计算出来的阴影元素去影响光照的 diffuse 和 specular 元素。</p><p>在 ShadowCalculation 函数中有很多不同之处，现在是从立方体贴图中进行采样，不再使用 2D 纹理了。我们来一步一步的讨论一下的它的内容。</p><p>我们需要做的第一件事是获取立方体贴图的深度。你可能已经从教程的立方体贴图部分想到，我们已经将深度储存为 fragment 和光位置之间的距离了；我们这里采用相似的处理方式：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> <span class="token function">ShadowCalculation</span><span class="token punctuation">(</span>vec3 fragPos<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    vec3 fragToLight <span class="token operator">=</span> fragPos <span class="token operator">-</span> lightPos<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">float</span> closestDepth <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>depthMap<span class="token punctuation">,</span> fragToLight<span class="token punctuation">)</span><span class="token punctuation">.</span>r<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在这里，我们得到了 fragment 的位置与光的位置之间的不同的向量，使用这个向量作为一个方向向量去对立方体贴图进行采样。方向向量不需要是单位向量，所以无需对它进行标准化。最后的 closestDepth 是光源和它最接近的可见 fragment 之间的标准化的深度值。</p><p>closestDepth 值现在在 0 到 1 的范围内了，所以我们先将其转换会 0 到 far_plane 的范围，这需要把他乘以 far_plane：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>closestDepth <span class="token operator">*=</span> far_plane<span class="token punctuation">;</span></pre></td></tr></table></figure><p>下一步我们获取当前 fragment 和光源之间的深度值，我们可以简单的使用 fragToLight 的长度来获取它，这取决于我们如何计算立方体贴图中的深度值：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> currentDepth <span class="token operator">=</span> <span class="token function">length</span><span class="token punctuation">(</span>fragToLight<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>返回的是和 closestDepth 范围相同的深度值。</p><p>现在我们可以将两个深度值对比一下，看看哪一个更接近，以此决定当前的 fragment 是否在阴影当中。我们还要包含一个阴影偏移，所以才能避免阴影失真，这在前面教程中已经讨论过了。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> bias <span class="token operator">=</span> <span class="token number">0.05</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">float</span> shadow <span class="token operator">=</span> currentDepth <span class="token operator">-</span>  bias <span class="token operator">></span> closestDepth <span class="token operator">?</span> <span class="token number">1.0</span> <span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>完整的 ShadowCalculation 现在变成了这样：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> <span class="token function">ShadowCalculation</span><span class="token punctuation">(</span>vec3 fragPos<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// Get vector between fragment position and light position</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    vec3 fragToLight <span class="token operator">=</span> fragPos <span class="token operator">-</span> lightPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// Use the light to fragment vector to sample from the depth map    </span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">float</span> closestDepth <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>depthMap<span class="token punctuation">,</span> fragToLight<span class="token punctuation">)</span><span class="token punctuation">.</span>r<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// It is currently in linear range between [0,1]. Re-transform back to original value</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    closestDepth <span class="token operator">*=</span> far_plane<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// Now get current linear depth as the length between the fragment and light position</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">float</span> currentDepth <span class="token operator">=</span> <span class="token function">length</span><span class="token punctuation">(</span>fragToLight<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">// Now test for shadows</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">float</span> bias <span class="token operator">=</span> <span class="token number">0.05</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">float</span> shadow <span class="token operator">=</span> currentDepth <span class="token operator">-</span>  bias <span class="token operator">></span> closestDepth <span class="token operator">?</span> <span class="token number">1.0</span> <span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">return</span> shadow<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>有了这些着色器，我们已经能得到非常好的阴影效果了，这次从一个点光源所有周围方向上都有阴影。有一个位于场景中心的点光源，看起来会像这样：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/03/02/point_shadows.png" alt="image"></p><h3 id="显示立方体贴图深度缓冲"><a class="anchor" href="#显示立方体贴图深度缓冲">#</a> 显示立方体贴图深度缓冲</h3><p>如果你想我一样第一次并没有做对，那么就要进行调试排错，将深度贴图显示出来以检查其是否正确。因为我们不再用 2D 深度贴图纹理，深度贴图的显示不会那么显而易见。</p><p>一个简单的把深度缓冲显示出来的技巧是，在 ShadowCalculation 函数中计算标准化的 closestDepth 变量，把变量显示为：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span><span class="token function">vec3</span><span class="token punctuation">(</span>closestDepth <span class="token operator">/</span> far_plane<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>结果是一个灰度场景，每个颜色代表着场景的线性深度值：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/03/02/point_shadows_depth_cubemap.png" alt="image"></p><p>你可能也注意到了带阴影部分在墙外。如果看起来和这个差不多，你就知道深度立方体贴图生成的没错。否则你可能做错了什么，也许是 closestDepth 仍然还在 0 到 far_plane 的范围。</p><h3 id="pcf-2"><a class="anchor" href="#pcf-2">#</a> PCF</h3><p>由于万向阴影贴图基于传统阴影映射的原则，它便也继承了由解析度产生的非真实感。如果你放大就会看到锯齿边了。PCF 或称 Percentage-closer filtering 允许我们通过对 fragment 位置周围过滤多个样本，并对结果平均化。</p><p>如果我们用和前面教程同样的那个简单的 PCF 过滤器，并加入第三个维度，就是这样的：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> shadow <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">float</span> bias <span class="token operator">=</span> <span class="token number">0.05</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">float</span> samples <span class="token operator">=</span> <span class="token number">4.0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">float</span> offset <span class="token operator">=</span> <span class="token number">0.1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">float</span> x <span class="token operator">=</span> <span class="token operator">-</span>offset<span class="token punctuation">;</span> x <span class="token operator">&lt;</span> offset<span class="token punctuation">;</span> x <span class="token operator">+=</span> offset <span class="token operator">/</span> <span class="token punctuation">(</span>samples <span class="token operator">*</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">float</span> y <span class="token operator">=</span> <span class="token operator">-</span>offset<span class="token punctuation">;</span> y <span class="token operator">&lt;</span> offset<span class="token punctuation">;</span> y <span class="token operator">+=</span> offset <span class="token operator">/</span> <span class="token punctuation">(</span>samples <span class="token operator">*</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">float</span> z <span class="token operator">=</span> <span class="token operator">-</span>offset<span class="token punctuation">;</span> z <span class="token operator">&lt;</span> offset<span class="token punctuation">;</span> z <span class="token operator">+=</span> offset <span class="token operator">/</span> <span class="token punctuation">(</span>samples <span class="token operator">*</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">float</span> closestDepth <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>depthMap<span class="token punctuation">,</span> fragToLight <span class="token operator">+</span> <span class="token function">vec3</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>r<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre>            closestDepth <span class="token operator">*=</span> far_plane<span class="token punctuation">;</span>   <span class="token comment">// Undo mapping [0;1]</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">if</span><span class="token punctuation">(</span>currentDepth <span class="token operator">-</span> bias <span class="token operator">></span> closestDepth<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                shadow <span class="token operator">+=</span> <span class="token number">1.0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>shadow <span class="token operator">/=</span> <span class="token punctuation">(</span>samples <span class="token operator">*</span> samples <span class="token operator">*</span> samples<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这段代码和我们传统的阴影映射没有多少不同。这里我们根据样本的数量动态计算了纹理偏移量，我们在三个轴向采样三次，最后对子样本进行平均化。</p><p>现在阴影看起来更加柔和平滑了，由此得到更加真实的效果：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/03/02/point_shadows_soft.png" alt="image"></p><p>然而，samples 设置为 4.0，每个 fragment 我们会得到总共 64 个样本，这太多了！</p><p>大多数这些样本都是多余的，它们在原始方向向量近处采样，不如在采样方向向量的垂直方向进行采样更有意义。可是，没有（简单的）方式能够指出哪一个子方向是多余的，这就难了。有个技巧可以使用，用一个偏移量方向数组，它们差不多都是分开的，每一个指向完全不同的方向，剔除彼此接近的那些子方向。下面就是一个有着 20 个偏移方向的数组：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vec3 sampleOffsetDirections<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span> <span class="token operator">=</span> vec3<span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token function">vec3</span><span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">vec3</span><span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token function">vec3</span><span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">vec3</span><span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token function">vec3</span><span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">vec3</span><span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>   <span class="token function">vec3</span><span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">vec3</span><span class="token punctuation">(</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>   <span class="token function">vec3</span><span class="token punctuation">(</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">vec3</span><span class="token punctuation">(</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">vec3</span><span class="token punctuation">(</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">vec3</span><span class="token punctuation">(</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>然后我们把 PCF 算法与从 sampleOffsetDirections 得到的样本数量进行适配，使用它们从立方体贴图里采样。这么做的好处是与之前的 PCF 算法相比，我们需要的样本数量变少了。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> shadow <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">float</span> bias <span class="token operator">=</span> <span class="token number">0.15</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> samples <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">float</span> viewDistance <span class="token operator">=</span> <span class="token function">length</span><span class="token punctuation">(</span>viewPos <span class="token operator">-</span> fragPos<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">float</span> diskRadius <span class="token operator">=</span> <span class="token number">0.05</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> samples<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">float</span> closestDepth <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>depthMap<span class="token punctuation">,</span> fragToLight <span class="token operator">+</span> sampleOffsetDirections<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> diskRadius<span class="token punctuation">)</span><span class="token punctuation">.</span>r<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    closestDepth <span class="token operator">*=</span> far_plane<span class="token punctuation">;</span>   <span class="token comment">// Undo mapping [0;1]</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>currentDepth <span class="token operator">-</span> bias <span class="token operator">></span> closestDepth<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        shadow <span class="token operator">+=</span> <span class="token number">1.0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>shadow <span class="token operator">/=</span> <span class="token keyword">float</span><span class="token punctuation">(</span>samples<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这里我们把一个偏移量添加到指定的 diskRadius 中，它在 fragToLight 方向向量周围从立方体贴图里采样。</p><p>另一个在这里可以应用的有意思的技巧是，我们可以基于观察者里一个 fragment 的距离来改变 diskRadius；这样我们就能根据观察者的距离来增加偏移半径了，当距离更远的时候阴影更柔和，更近了就更锐利。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> diskRadius <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">+</span> <span class="token punctuation">(</span>viewDistance <span class="token operator">/</span> far_plane<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">25.0</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>PCF 算法的结果如果没有变得更好，也是非常不错的，这是柔和的阴影效果：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/03/02/point_shadows_soft_better.png" alt="image"></p><p>当然了，我们添加到每个样本的 bias（偏移）高度依赖于上下文，总是要根据场景进行微调的。试试这些值，看看怎样影响了场景。 这里是最终版本的顶点和像素着色器。</p><p>我还要提醒一下使用几何着色器来生成深度贴图不会一定比每个面渲染场景 6 次更快。使用几何着色器有它自己的性能局限，在第一个阶段使用它可能获得更好的性能表现。这取决于环境的类型，以及特定的显卡驱动等等，所以如果你很关心性能，就要确保对两种方法有大致了解，然后选择对你场景来说更高效的那个。我个人还是喜欢使用几何着色器来进行阴影映射，原因很简单，因为它们使用起来更简单。</p><h3 id="附加资源-3"><a class="anchor" href="#附加资源-3">#</a> 附加资源</h3><ul><li><span class="exturl" data-url="aHR0cDovL3d3dy5zdW5hbmRibGFja2NhdC5jb20vdGlwRnVsbFZpZXcucGhwP2w9ZW5nJmFtcDt0b3BpY2lkPTM2">Shadow Mapping for point light sources in OpenGL</span>：sunandblackcat 的万向阴影映射教程。</li><li><span class="exturl" data-url="aHR0cDovL29nbGRldi5hdHNwYWNlLmNvLnVrL3d3dy90dXRvcmlhbDQzL3R1dG9yaWFsNDMuaHRtbA==">Multipass Shadow Mapping With Point Lights</span>：ogldev 的万向阴影映射教程。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jZy50dXdpZW4uYWMuYXQvfmh1c2t5L1JUUi9PbW5pZGlyU2hhZG93cy13aHlDYXBzLnBkZg==">Omni-directional Shadows</span>：Peter Houska 的关于万向阴影映射的一组很好的 ppt。</li></ul><h2 id="法线贴图"><a class="anchor" href="#法线贴图">#</a> 法线贴图</h2><p>我们的场景中已经充满了多边形物体，其中每个都可能由成百上千平坦的三角形组成。我们以向三角形上附加纹理的方式来增加额外细节，提升真实感，隐藏多边形几何体是由无数三角形组成的事实。纹理确有助益，然而当你近看它们时，这个事实便隐藏不住了。现实中的物体表面并非是平坦的，而是表现出无数（凹凸不平的）细节。</p><p>例如，砖块的表面。砖块的表面非常粗糙，显然不是完全平坦的：它包含着接缝处水泥凹痕，以及非常多的细小的空洞。如果我们在一个有光的场景中看这样一个砖块的表面，问题就出来了。下图中我们可以看到砖块纹理应用到了平坦的表面，并被一个点光源照亮。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/04/normal_mapping_flat.png" alt="image"></p><p>光照并没有呈现出任何裂痕和孔洞，完全忽略了砖块之间凹进去的线条；表面看起来完全就是平的。我们可以使用 specular 贴图根据深度或其他细节阻止部分表面被照的更亮，以此部分地解决问题，但这并不是一个好方案。我们需要的是某种可以告知光照系统给所有有关物体表面类似深度这样的细节的方式。</p><p>如果我们以光的视角来看这个问题：是什么使表面被视为完全平坦的表面来照亮？答案会是表面的法线向量。以光照算法的视角考虑的话，只有一件事决定物体的形状，这就是垂直于它的法线向量。砖块表面只有一个法线向量，表面完全根据这个法线向量被以一致的方式照亮。如果每个 fragment 都是用自己的不同的法线会怎样？这样我们就可以根据表面细微的细节对法线向量进行改变；这样就会获得一种表面看起来要复杂得多的幻觉：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/04/normal_mapping_surfaces.png" alt="image"></p><p>每个 fragment 使用了自己的法线，我们就可以让光照相信一个表面由很多微小的（垂直于法线向量的）平面所组成，物体表面的细节将会得到极大提升。这种每个 fragment 使用各自的法线，替代一个面上所有 fragment 使用同一个法线的技术叫做法线贴图（normal mapping）或凹凸贴图（bump mapping）。应用到砖墙上，效果像这样：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/04/normal_mapping_compare.png" alt="image"></p><p>你可以看到细节获得了极大提升，开销却不大。因为我们只需要改变每个 fragment 的法线向量，并不需要改变所有光照公式。现在我们是为每个 fragment 传递一个法线，不再使用插值表面法线。这样光照使表面拥有了自己的细节。</p><h3 id="法线贴图-2"><a class="anchor" href="#法线贴图-2">#</a> 法线贴图</h3><p>为使法线贴图工作，我们需要为每个 fragment 提供一个法线。像 diffuse 贴图和 specular 贴图一样，我们可以使用一个 2D 纹理来储存法线数据。2D 纹理不仅可以储存颜色和光照数据，还可以储存法线向量。这样我们可以从 2D 纹理中采样得到特定纹理的法线向量。</p><p>由于法线向量是个几何工具，而纹理通常只用于储存颜色信息，用纹理储存法线向量不是非常直接。如果你想一想，就会知道纹理中的颜色向量用 r、g、b 元素代表一个 3D 向量。类似的我们也可以将法线向量的 x、y、z 元素储存到纹理中，代替颜色的 r、g、b 元素。<mark>法线向量的范围在 - 1 到 1 之间</mark>，所以我们先要将其映射到 0 到 1 的范围：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vec3 rgb_normal <span class="token operator">=</span> normal <span class="token operator">*</span> <span class="token number">0.5</span> <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">;</span> <span class="token comment">// 从 [-1,1] 转换至 [0,1]</span></pre></td></tr></table></figure><p>将法线向量变换为像这样的 RGB 颜色元素，我们就能把根据表面的形状的 fragment 的法线保存在 2D 纹理中。教程开头展示的那个砖块的例子的法线贴图如下所示：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/04/normal_mapping_normal_map.png" alt="image"></p><p>这会是一种偏蓝色调的纹理（你在网上找到的几乎所有法线贴图都是这样的）。这是因为所有法线的指向都偏向 z 轴（0, 0, 1）这是一种偏蓝的颜色。法线向量从 z 轴方向也向其他方向轻微偏移，颜色也就发生了轻微变化，这样看起来便有了一种深度。例如，你可以看到在每个砖块的顶部，颜色倾向于偏绿，这是因为砖块的顶部的法线偏向于指向正 y 轴方向（0, 1, 0），这样它就是绿色的了。</p><p>在一个简单的朝向正 z 轴的平面上，我们可以用这个<span class="exturl" data-url="aHR0cHM6Ly9sZWFybm9wZW5nbC5jb20vaW1nL3RleHR1cmVzL2JyaWNrd2FsbC5qcGc="> diffuse 纹理</span>和这个<span class="exturl" data-url="aHR0cHM6Ly9sZWFybm9wZW5nbC5jb20vaW1nL3RleHR1cmVzL2JyaWNrd2FsbF9ub3JtYWwuanBn">法线贴图</span>来渲染前面部分的图片。要注意的是这个链接里的法线贴图和上面展示的那个不一样。原因是 OpenGL 读取的纹理的 y（或 V）坐标和纹理通常被创建的方式相反。链接里的法线贴图的 y（或绿色）元素是相反的（你可以看到绿色现在在下边）；如果你没考虑这个，光照就不正确了（译注：如果你现在不再使用 SOIL 了，那就不要用链接里的那个法线贴图，这个问题是 SOIL 载入纹理上下颠倒所致，它也会把法线在 y 方向上颠倒）。加载纹理，把它们绑定到合适的纹理单元，然后使用下面的改变了的像素着色器来渲染一个平面：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>uniform sampler2D normalMap<span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span>           </pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// 从法线贴图范围 [0,1] 获取法线</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    normal <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>normalMap<span class="token punctuation">,</span> fs_in<span class="token punctuation">.</span>TexCoords<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// 将法线向量转换为范围 [-1,1]</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    normal <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>normal <span class="token operator">*</span> <span class="token number">2.0</span> <span class="token operator">-</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   </pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">// 像往常那样处理光照</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里我们将被采样的法线颜色从 0 到 1 重新映射回 - 1 到 1，便能将 RGB 颜色重新处理成法线，然后使用采样出的法线向量应用于光照的计算。在例子中我们使用的是 Blinn-Phong 着色器。</p><p>通过慢慢随着时间慢慢移动光源，你就能明白法线贴图是什么意思了。运行这个例子你就能得到本教程开始的那个效果：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/04/normal_mapping_correct.png" alt="image"></p><p>然而有个问题限制了刚才讲的那种法线贴图的使用。我们使用的那个法线贴图里面的所有法线向量都是指向正 z 方向的。上面的例子能用，是因为那个平面的表面法线也是指向正 z 方向的。可是，如果我们在表面法线指向正 y 方向的平面上使用同一个法线贴图会发生什么？</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/04/normal_mapping_ground.png" alt="image"></p><p>光照看起来完全不对！发生这种情况是平面的表面法线现在指向了 y，而采样得到的法线仍然指向的是 z。结果就是光照仍然认为表面法线和之前朝向正 z 方向时一样；这样光照就不对了。下面的图片展示了这个表面上采样的法线的近似情况：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/04/normal_mapping_ground_normals.png" alt="image"></p><p>你可以看到所有法线都指向 z 方向，它们本该朝着表面法线指向 y 方向的。一个可行方案是为每个表面制作一个单独的法线贴图。如果是一个立方体的话我们就需要 6 个法线贴图，但是如果模型上有无数的朝向不同方向的表面，这就不可行了（译注：实际上对于复杂模型可以把朝向各个方向的法线储存在同一张贴图上，你可能看到过不只是蓝色的法线贴图，不过用那样的法线贴图有个问题是你必须记住模型的起始朝向，如果模型运动了还要记录模型的变换，这是非常不方便的；此外就像作者所说的，如果把一个 diffuse 纹理应用在同一个物体的不同表面上，就像立方体那样的，就需要做 6 个法线贴图，这也不可取）。</p><p>另一个稍微有点难的解决方案是，在一个不同的坐标空间中进行光照，这个坐标空间里，法线贴图向量总是指向这个坐标空间的正 z 方向；所有的光照向量都相对与这个正 z 方向进行变换。这样我们就能始终使用同样的法线贴图，不管朝向问题。这个坐标空间叫做<mark>切线空间</mark>（tangent space）。</p><h3 id="切线空间"><a class="anchor" href="#切线空间">#</a> 切线空间</h3><p>法线贴图中的法线向量在切线空间中，法线永远指着正 z 方向。切线空间是位于三角形表面之上的空间：法线相对于单个三角形的本地参考框架。它就像法线贴图向量的本地空间；它们都被定义为指向正 z 方向，无论最终变换到什么方向。使用一个特定的矩阵我们就能将本地 / 切线空寂中的法线向量转成世界或视图坐标，使它们转向到最终的贴图表面的方向。</p><p>我们可以说，上个部分那个朝向正 y 的法线贴图错误的贴到了表面上。法线贴图被定义在切线空间中，所以一种解决问题的方式是计算出一种矩阵，把法线从切线空间变换到一个不同的空间，这样它们就能和表面法线方向对齐了：法线向量都会指向正 y 方向。切线空间的一大好处是我们可以为任何类型的表面计算出一个这样的矩阵，由此我们可以把切线空间的 z 方向和表面的法线方向对齐。</p><p>这种矩阵叫做 TBN 矩阵这三个字母分别代表<mark> tangent</mark>、<mark>bitangent</mark> 和<mark> normal</mark> 向量。这是建构这个矩阵所需的向量。要建构这样一个把切线空间转变为不同空间的变异矩阵，我们需要三个相互垂直的向量，它们沿一个表面的法线贴图对齐于：上、右、前；这和我们在摄像机教程中做的类似。</p><p>已知上向量是表面的法线向量。右和前向量是切线 (Tagent) 和副切线 (Bitangent) 向量。下面的图片展示了一个表面的三个向量：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/04/normal_mapping_tbn_vectors.png" alt="image"></p><p>计算出切线和副切线并不像法线向量那么容易。从图中可以看到法线贴图的切线和副切线与纹理坐标的两个方向对齐。我们就是用到这个特性计算每个表面的切线和副切线的。需要用到一些数学才能得到它们；请看下图：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/04/normal_mapping_surface_edges.png" alt="image"></p><p>注意上图中边 E2 与纹理坐标的差 ΔU2、ΔV2 构成一个三角形。ΔU2 与切线向量 T 方向相同，而 ΔV2 与副切线向量 B 方向相同。这也就是说，所以我们可以将三角形的边 E1 与 E2 写成切线向量 \T 和副切线向量 B 的线性组合：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>E</mi><mn>1</mn></msub><mo>=</mo><mi mathvariant="normal">Δ</mi><msub><mi>U</mi><mn>1</mn></msub><mi>T</mi><mo>+</mo><mi mathvariant="normal">Δ</mi><msub><mi>V</mi><mn>1</mn></msub><mi>B</mi><msub><mi>E</mi><mn>2</mn></msub><mo>=</mo><mi mathvariant="normal">Δ</mi><msub><mi>U</mi><mn>2</mn></msub><mi>T</mi><mo>+</mo><mi mathvariant="normal">Δ</mi><msub><mi>V</mi><mn>2</mn></msub><mi>B</mi></mrow><annotation encoding="application/x-tex">E_1=ΔU_1T+ΔV_1B E_2=ΔU_2T+ΔV_2B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.05764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal" style="margin-right:.22222em">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.22222em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:.05017em">B</span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.05764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal" style="margin-right:.22222em">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.22222em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:.05017em">B</span></span></span></span></span></p><p>我们也可以写成这样：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>E</mi><mrow><mn>1</mn><mi>x</mi></mrow></msub><mo separator="true">,</mo><msub><mi>E</mi><mrow><mn>1</mn><mi>y</mi></mrow></msub><mo separator="true">,</mo><msub><mi>E</mi><mrow><mn>1</mn><mi>z</mi></mrow></msub><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Δ</mi><msub><mi>U</mi><mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>T</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>T</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>T</mi><mi>z</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mi mathvariant="normal">Δ</mi><msub><mi>V</mi><mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>B</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>B</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>B</mi><mi>z</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>E</mi><mrow><mn>2</mn><mi>x</mi></mrow></msub><mo separator="true">,</mo><msub><mi>E</mi><mrow><mn>2</mn><mi>y</mi></mrow></msub><mo separator="true">,</mo><msub><mi>E</mi><mrow><mn>2</mn><mi>z</mi></mrow></msub><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Δ</mi><msub><mi>U</mi><mn>2</mn></msub><mo stretchy="false">(</mo><msub><mi>T</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>T</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>T</mi><mi>z</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mi mathvariant="normal">Δ</mi><msub><mi>V</mi><mn>2</mn></msub><mo stretchy="false">(</mo><msub><mi>B</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>B</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>B</mi><mi>z</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(E_{1x},E_{1y},E_{1z})=ΔU_1(T_x,T_y,T_z)+ΔV_1(B_x,B_y,B_z) (E_{2x},E_{2y},E_{2z})=ΔU_2(T_x,T_y,T_z)+ΔV_2(B_x,B_y,B_z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-.286108em"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.05764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.301108em"><span style="top:-2.5500000000000003em;margin-left:-.05764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mathnormal mtight" style="margin-right:.03588em">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.05764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mathnormal mtight" style="margin-right:.04398em">z</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-.286108em"></span><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03588em">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.04398em">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-.286108em"></span><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal" style="margin-right:.22222em">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.22222em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:.05017em">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.05017em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05017em">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:-.05017em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03588em">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05017em">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.05017em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.04398em">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.05764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.301108em"><span style="top:-2.5500000000000003em;margin-left:-.05764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:.03588em">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.05764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:.04398em">z</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-.286108em"></span><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03588em">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.04398em">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-.286108em"></span><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal" style="margin-right:.22222em">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.22222em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:.05017em">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.05017em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05017em">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:-.05017em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03588em">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05017em">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.05017em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.04398em">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>E 是两个向量位置的差，ΔU 和 ΔV 是纹理坐标的差。然后我们得到两个未知数（切线 T 和副切线 B）和两个等式。你可能想起你的代数课了，这是让我们去解 T 和 B。</p><p>上面的方程允许我们把它们写成另一种格式：矩阵乘法</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>E</mi><mrow><mn>1</mn><mi>x</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>E</mi><mrow><mn>1</mn><mi>y</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>E</mi><mrow><mn>1</mn><mi>z</mi></mrow></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>E</mi><mrow><mn>2</mn><mi>x</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>E</mi><mrow><mn>2</mn><mi>y</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>E</mi><mrow><mn>2</mn><mi>z</mi></mrow></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">Δ</mi><msub><mi>U</mi><mn>1</mn></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">Δ</mi><msub><mi>V</mi><mn>1</mn></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">Δ</mi><msub><mi>U</mi><mn>2</mn></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">Δ</mi><msub><mi>V</mi><mn>2</mn></msub></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>T</mi><mi>x</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>T</mi><mi>y</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>T</mi><mi>z</mi></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>B</mi><mi>x</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>B</mi><mi>y</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>B</mi><mi>z</mi></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{bmatrix} E_{1x} &amp; E_{1y} &amp;E_{1z} \\ E_{2x} &amp; E_{2y} &amp;E_{2z} \end{bmatrix} = \begin{bmatrix} ΔU_1 &amp; ΔV_1 \\ ΔU_2 &amp; ΔV_2 \end{bmatrix} \begin{bmatrix} T_x &amp; T_y &amp; T_z \\ B_x &amp; B_y &amp; B_z \end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-.95003em"></span><span class="minner"><span class="mopen delimcenter" style="top:0"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em"><span style="top:-3.61em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.05764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.05764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9500000000000004em"><span></span></span></span></span></span><span class="arraycolsep" style="width:.5em"></span><span class="arraycolsep" style="width:.5em"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em"><span style="top:-3.61em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.301108em"><span style="top:-2.5500000000000003em;margin-left:-.05764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mathnormal mtight" style="margin-right:.03588em">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.301108em"><span style="top:-2.5500000000000003em;margin-left:-.05764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:.03588em">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9500000000000004em"><span></span></span></span></span></span><span class="arraycolsep" style="width:.5em"></span><span class="arraycolsep" style="width:.5em"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em"><span style="top:-3.61em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.05764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mathnormal mtight" style="margin-right:.04398em">z</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.05764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:.04398em">z</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9500000000000004em"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-.95003em"></span><span class="minner"><span class="mopen delimcenter" style="top:0"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em"><span style="top:-3.61em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9500000000000004em"><span></span></span></span></span></span><span class="arraycolsep" style="width:.5em"></span><span class="arraycolsep" style="width:.5em"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em"><span style="top:-3.61em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal" style="margin-right:.22222em">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.22222em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal" style="margin-right:.22222em">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.22222em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9500000000000004em"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="minner"><span class="mopen delimcenter" style="top:0"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em"><span style="top:-3.61em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.05017em">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.05017em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9500000000000004em"><span></span></span></span></span></span><span class="arraycolsep" style="width:.5em"></span><span class="arraycolsep" style="width:.5em"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em"><span style="top:-3.61em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03588em">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.05017em">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:-.05017em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03588em">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9500000000000004em"><span></span></span></span></span></span><span class="arraycolsep" style="width:.5em"></span><span class="arraycolsep" style="width:.5em"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em"><span style="top:-3.61em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.04398em">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.05017em">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.05017em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.04398em">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9500000000000004em"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0"><span class="delimsizing size3">]</span></span></span></span></span></span></span></p><p>尝试会意一下矩阵乘法，它们确实是同一种等式。把等式写成矩阵形式的好处是，解 T 和 B 会因此变得很容易。两边都乘以 ΔUΔV 的逆矩阵等于：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">Δ</mi><msub><mi>U</mi><mn>1</mn></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">Δ</mi><msub><mi>V</mi><mn>1</mn></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">Δ</mi><msub><mi>U</mi><mn>2</mn></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">Δ</mi><msub><mi>V</mi><mn>2</mn></msub></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>E</mi><mrow><mn>1</mn><mi>x</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>E</mi><mrow><mn>1</mn><mi>y</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>E</mi><mrow><mn>1</mn><mi>z</mi></mrow></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>E</mi><mrow><mn>2</mn><mi>x</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>E</mi><mrow><mn>2</mn><mi>y</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>E</mi><mrow><mn>2</mn><mi>z</mi></mrow></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>T</mi><mi>x</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>T</mi><mi>y</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>T</mi><mi>z</mi></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>B</mi><mi>x</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>B</mi><mi>y</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>B</mi><mi>z</mi></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{bmatrix} ΔU_1 &amp; ΔV_1 \\ ΔU_2 &amp; ΔV_2 \end{bmatrix}^{-1} \begin{bmatrix} E_{1x} &amp; E_{1y} &amp;E_{1z} \\ E_{2x} &amp; E_{2y} &amp;E_{2z} \end{bmatrix} = \begin{bmatrix} T_x &amp; T_y &amp; T_z \\ B_x &amp; B_y &amp; B_z \end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.604038em;vertical-align:-.95003em"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em"><span style="top:-3.61em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9500000000000004em"><span></span></span></span></span></span><span class="arraycolsep" style="width:.5em"></span><span class="arraycolsep" style="width:.5em"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em"><span style="top:-3.61em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal" style="margin-right:.22222em">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.22222em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal" style="margin-right:.22222em">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.22222em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9500000000000004em"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0"><span class="delimsizing size3">]</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.6540080000000001em"><span style="top:-3.9029000000000003em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="minner"><span class="mopen delimcenter" style="top:0"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em"><span style="top:-3.61em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.05764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.05764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9500000000000004em"><span></span></span></span></span></span><span class="arraycolsep" style="width:.5em"></span><span class="arraycolsep" style="width:.5em"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em"><span style="top:-3.61em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.301108em"><span style="top:-2.5500000000000003em;margin-left:-.05764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mathnormal mtight" style="margin-right:.03588em">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.301108em"><span style="top:-2.5500000000000003em;margin-left:-.05764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:.03588em">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9500000000000004em"><span></span></span></span></span></span><span class="arraycolsep" style="width:.5em"></span><span class="arraycolsep" style="width:.5em"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em"><span style="top:-3.61em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.05764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mathnormal mtight" style="margin-right:.04398em">z</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.05764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:.04398em">z</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9500000000000004em"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-.95003em"></span><span class="minner"><span class="mopen delimcenter" style="top:0"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em"><span style="top:-3.61em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.05017em">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.05017em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9500000000000004em"><span></span></span></span></span></span><span class="arraycolsep" style="width:.5em"></span><span class="arraycolsep" style="width:.5em"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em"><span style="top:-3.61em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03588em">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.05017em">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:-.05017em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03588em">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9500000000000004em"><span></span></span></span></span></span><span class="arraycolsep" style="width:.5em"></span><span class="arraycolsep" style="width:.5em"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em"><span style="top:-3.61em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.04398em">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.05017em">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.05017em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.04398em">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9500000000000004em"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0"><span class="delimsizing size3">]</span></span></span></span></span></span></span></p><p>这样我们就可以解出 T 和 B 了。这需要我们计算出 delta 纹理坐标矩阵的逆矩阵。我不打算讲解计算逆矩阵的细节，但大致是把它变化为，1 除以矩阵的行列式，再乘以它的<mark>伴随矩阵</mark> (Adjugate Matrix)。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>T</mi><mi>x</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>T</mi><mi>y</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>T</mi><mi>z</mi></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>B</mi><mi>x</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>B</mi><mi>y</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>B</mi><mi>z</mi></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mfrac><mn>1</mn><mrow><mi mathvariant="normal">Δ</mi><msub><mi>U</mi><mn>1</mn></msub><mi mathvariant="normal">Δ</mi><msub><mi>V</mi><mn>2</mn></msub><mo>−</mo><mi mathvariant="normal">Δ</mi><msub><mi>U</mi><mn>2</mn></msub><mi mathvariant="normal">Δ</mi><msub><mi>V</mi><mn>1</mn></msub></mrow></mfrac><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">Δ</mi><msub><mi>V</mi><mn>2</mn></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi mathvariant="normal">Δ</mi><msub><mi>V</mi><mn>1</mn></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi mathvariant="normal">Δ</mi><msub><mi>U</mi><mn>2</mn></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">Δ</mi><msub><mi>U</mi><mn>1</mn></msub></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>E</mi><mrow><mn>1</mn><mi>x</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>E</mi><mrow><mn>1</mn><mi>y</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>E</mi><mrow><mn>1</mn><mi>z</mi></mrow></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>E</mi><mrow><mn>2</mn><mi>x</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>E</mi><mrow><mn>2</mn><mi>y</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>E</mi><mrow><mn>2</mn><mi>z</mi></mrow></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{bmatrix} T_x &amp; T_y &amp; T_z \\ B_x &amp; B_y &amp; B_z \end{bmatrix} = \cfrac{1}{ΔU_1ΔV_2-ΔU_2ΔV_1} \begin{bmatrix} ΔV_2 &amp; -ΔV_1 \\ -ΔU_2 &amp; ΔU_1 \end{bmatrix} \begin{bmatrix} E_{1x} &amp; E_{1y} &amp;E_{1z} \\ E_{2x} &amp; E_{2y} &amp;E_{2z} \end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-.95003em"></span><span class="minner"><span class="mopen delimcenter" style="top:0"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em"><span style="top:-3.61em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.05017em">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.05017em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9500000000000004em"><span></span></span></span></span></span><span class="arraycolsep" style="width:.5em"></span><span class="arraycolsep" style="width:.5em"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em"><span style="top:-3.61em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03588em">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.05017em">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:-.05017em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03588em">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9500000000000004em"><span></span></span></span></span></span><span class="arraycolsep" style="width:.5em"></span><span class="arraycolsep" style="width:.5em"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em"><span style="top:-3.61em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.04398em">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.05017em">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.05017em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.04398em">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9500000000000004em"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:2.54003em;vertical-align:-.95003em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5899999999999999em"><span style="top:-2.3139999999999996em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal" style="margin-right:.22222em">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.22222em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal" style="margin-right:.22222em">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.22222em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.74em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.8360000000000001em"><span></span></span></span></span></span><span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="minner"><span class="mopen delimcenter" style="top:0"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em"><span style="top:-3.61em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal" style="margin-right:.22222em">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.22222em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">−</span><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9500000000000004em"><span></span></span></span></span></span><span class="arraycolsep" style="width:.5em"></span><span class="arraycolsep" style="width:.5em"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em"><span style="top:-3.61em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">−</span><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal" style="margin-right:.22222em">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.22222em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9500000000000004em"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="minner"><span class="mopen delimcenter" style="top:0"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em"><span style="top:-3.61em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.05764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.05764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9500000000000004em"><span></span></span></span></span></span><span class="arraycolsep" style="width:.5em"></span><span class="arraycolsep" style="width:.5em"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em"><span style="top:-3.61em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.301108em"><span style="top:-2.5500000000000003em;margin-left:-.05764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mathnormal mtight" style="margin-right:.03588em">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.301108em"><span style="top:-2.5500000000000003em;margin-left:-.05764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:.03588em">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9500000000000004em"><span></span></span></span></span></span><span class="arraycolsep" style="width:.5em"></span><span class="arraycolsep" style="width:.5em"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em"><span style="top:-3.61em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.05764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mathnormal mtight" style="margin-right:.04398em">z</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.05764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight" style="margin-right:.04398em">z</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9500000000000004em"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0"><span class="delimsizing size3">]</span></span></span></span></span></span></span></p><p>有了最后这个等式，我们就可以用公式、三角形的两条边以及纹理坐标计算出<mark>切线向量 T</mark> 和<mark>副切线 B</mark>。</p><p>如果你对这些数学内容不理解也不用担心。当你知道我们可以用一个三角形的顶点和纹理坐标（因为纹理坐标和切线向量在同一空间中）计算出切线和副切线你就已经部分地达到目的了（译注：上面的推导已经很清楚了，如果你不明白可以参考任意线性代数教材，就像作者所说的记住求得切线空间的公式也行，不过不管怎样都得理解切线空间的含义）。</p><h3 id="手工计算切线和副切线"><a class="anchor" href="#手工计算切线和副切线">#</a> 手工计算切线和副切线</h3><p>这个教程的 demo 场景中有一个简单的 2D 平面，它朝向正 z 方向。这次我们会使用切线空间来实现法线贴图，所以我们可以使平面朝向任意方向，法线贴图仍然能够工作。使用前面讨论的数学方法，我们来手工计算出表面的切线和副切线向量。</p><p>假设平面使用下面的向量建立起来（1、2、3 和 1、3、4，它们是两个三角形）：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// positions</span></pre></td></tr><tr><td data-num="2"></td><td><pre>glm<span class="token operator">::</span>vec3 <span class="token function">pos1</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">,</span>  <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>glm<span class="token operator">::</span>vec3 <span class="token function">pos2</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>glm<span class="token operator">::</span>vec3 <span class="token function">pos3</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>glm<span class="token operator">::</span>vec3 <span class="token function">pos4</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// texture coordinates</span></pre></td></tr><tr><td data-num="7"></td><td><pre>glm<span class="token operator">::</span>vec2 <span class="token function">uv1</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>glm<span class="token operator">::</span>vec2 <span class="token function">uv2</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>glm<span class="token operator">::</span>vec2 <span class="token function">uv3</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>glm<span class="token operator">::</span>vec2 <span class="token function">uv4</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">// normal vector</span></pre></td></tr><tr><td data-num="12"></td><td><pre>glm<span class="token operator">::</span>vec3 <span class="token function">nm</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>我们先计算第一个三角形的边和 deltaUV 坐标：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span>vec3 edge1 <span class="token operator">=</span> pos2 <span class="token operator">-</span> pos1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>glm<span class="token operator">::</span>vec3 edge2 <span class="token operator">=</span> pos3 <span class="token operator">-</span> pos1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>glm<span class="token operator">::</span>vec2 deltaUV1 <span class="token operator">=</span> uv2 <span class="token operator">-</span> uv1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>glm<span class="token operator">::</span>vec2 deltaUV2 <span class="token operator">=</span> uv3 <span class="token operator">-</span> uv1<span class="token punctuation">;</span></pre></td></tr></table></figure><p>有了计算切线和副切线的必备数据，我们就可以开始写出来自于前面部分中的下列等式：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>GLfloat f <span class="token operator">=</span> <span class="token number">1.0f</span> <span class="token operator">/</span> <span class="token punctuation">(</span>deltaUV1<span class="token punctuation">.</span>x <span class="token operator">*</span> deltaUV2<span class="token punctuation">.</span>y <span class="token operator">-</span> deltaUV2<span class="token punctuation">.</span>x <span class="token operator">*</span> deltaUV1<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>tangent1<span class="token punctuation">.</span>x <span class="token operator">=</span> f <span class="token operator">*</span> <span class="token punctuation">(</span>deltaUV2<span class="token punctuation">.</span>y <span class="token operator">*</span> edge1<span class="token punctuation">.</span>x <span class="token operator">-</span> deltaUV1<span class="token punctuation">.</span>y <span class="token operator">*</span> edge2<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>tangent1<span class="token punctuation">.</span>y <span class="token operator">=</span> f <span class="token operator">*</span> <span class="token punctuation">(</span>deltaUV2<span class="token punctuation">.</span>y <span class="token operator">*</span> edge1<span class="token punctuation">.</span>y <span class="token operator">-</span> deltaUV1<span class="token punctuation">.</span>y <span class="token operator">*</span> edge2<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>tangent1<span class="token punctuation">.</span>z <span class="token operator">=</span> f <span class="token operator">*</span> <span class="token punctuation">(</span>deltaUV2<span class="token punctuation">.</span>y <span class="token operator">*</span> edge1<span class="token punctuation">.</span>z <span class="token operator">-</span> deltaUV1<span class="token punctuation">.</span>y <span class="token operator">*</span> edge2<span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>tangent1 <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">normalize</span><span class="token punctuation">(</span>tangent1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>bitangent1<span class="token punctuation">.</span>x <span class="token operator">=</span> f <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">-</span>deltaUV2<span class="token punctuation">.</span>x <span class="token operator">*</span> edge1<span class="token punctuation">.</span>x <span class="token operator">+</span> deltaUV1<span class="token punctuation">.</span>x <span class="token operator">*</span> edge2<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>bitangent1<span class="token punctuation">.</span>y <span class="token operator">=</span> f <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">-</span>deltaUV2<span class="token punctuation">.</span>x <span class="token operator">*</span> edge1<span class="token punctuation">.</span>y <span class="token operator">+</span> deltaUV1<span class="token punctuation">.</span>x <span class="token operator">*</span> edge2<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>bitangent1<span class="token punctuation">.</span>z <span class="token operator">=</span> f <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">-</span>deltaUV2<span class="token punctuation">.</span>x <span class="token operator">*</span> edge1<span class="token punctuation">.</span>z <span class="token operator">+</span> deltaUV1<span class="token punctuation">.</span>x <span class="token operator">*</span> edge2<span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>bitangent1 <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">normalize</span><span class="token punctuation">(</span>bitangent1<span class="token punctuation">)</span><span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token comment">// 对平面的第二个三角形采用类似步骤计算切线和副切线</span></pre></td></tr></table></figure><p>我们预先计算出等式的分数部分 f，然后把它和每个向量的元素进行相应矩阵乘法。如果你把代码和最终的等式对比你会发现，这就是直接套用。最后我们还要进行标准化，来确保切线 / 副切线向量最后是单位向量。</p><p>因为一个三角形永远是平坦的形状，我们只需为每个三角形计算一个切线 / 副切线，它们对于每个三角形上的顶点都是一样的。要注意的是大多数实现通常三角形和三角形之间都会共享顶点。这种情况下开发者通常将每个顶点的法线和切线 / 副切线等顶点属性平均化，以获得更加柔和的效果。我们的平面的三角形之间分享了一些顶点，但是因为两个三角形相互并行，因此并不需要将结果平均化，但无论何时只要你遇到这种情况记住它就是件好事。</p><p>最后的切线和副切线向量的值应该是 (1, 0, 0) 和 (0, 1, 0)，它们和法线 (0, 0, 1) 组成相互垂直的 TBN 矩阵。在平面上显示出来 TBN 应该是这样的：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/04/normal_mapping_tbn_shown.png" alt="image"></p><p>每个顶点定义了切线和副切线向量，我们就可以开始实现正确的法线贴图了。</p><h3 id="切线空间法线贴图"><a class="anchor" href="#切线空间法线贴图">#</a> 切线空间法线贴图</h3><p>为让法线贴图工作，我们先得在着色器中创建一个 TBN 矩阵。我们先将前面计算出来的切线和副切线向量传给顶点着色器，作为它的属性：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> in vec3 position<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> in vec3 normal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> in vec2 texCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span> in vec3 tangent<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">)</span> in vec3 bitangent<span class="token punctuation">;</span></pre></td></tr></table></figure><p>在顶点着色器的 main 函数中我们创建 TBN 矩阵：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   vec3 T <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token function">vec3</span><span class="token punctuation">(</span>model <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>tangent<span class="token punctuation">,</span>   <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   vec3 B <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token function">vec3</span><span class="token punctuation">(</span>model <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>bitangent<span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>   vec3 N <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token function">vec3</span><span class="token punctuation">(</span>model <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>normal<span class="token punctuation">,</span>    <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>   mat3 TBN <span class="token operator">=</span> <span class="token function">mat3</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> B<span class="token punctuation">,</span> N<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>我们先将所有 TBN 向量变换到我们所操作的坐标系中，现在是世界空间，我们可以乘以 model 矩阵。然后我们创建实际的 TBN 矩阵，直接把相应的向量应用到 mat3 构造器就行。注意，如果我们希望更精确的话就不要将 TBN 向量乘以 model 矩阵，而是使用法线矩阵，但我们只关心向量的方向，不会平移也和缩放这个变换。</p><blockquote><p>从技术上讲，顶点着色器中无需副切线。所有的这三个 TBN 向量都是相互垂直的所以我们可以在顶点着色器中用 T 和 N 向量的叉乘，自己计算出副切线：<strong>vec3 B = cross(T, N)</strong>;</p></blockquote><p>现在我们有了 TBN 矩阵，如果来使用它呢？通常来说有两种方式使用它，我们会把这两种方式都说明一下：</p><ul><li>我们直接使用 TBN 矩阵，这个矩阵可以把切线坐标空间的向量转换到世界坐标空间。因此我们把它传给片段着色器中，把通过采样得到的法线坐标左乘上 TBN 矩阵，转换到世界坐标空间中，这样所有法线和其他光照变量就在同一个坐标系中了。</li><li>我们也可以使用 TBN 矩阵的逆矩阵，这个矩阵可以把世界坐标空间的向量转换到切线坐标空间。因此我们使用这个矩阵左乘其他光照变量，把他们转换到切线空间，这样法线和其他光照变量再一次在一个坐标系中了。</li></ul><p><strong>我们来看看第一种情况</strong>。我们从法线贴图重采样得来的法线向量，是以切线空间表达的，尽管其他光照向量是以世界空间表达的。把 TBN 传给像素着色器，我们就能将采样得来的切线空间的法线乘以这个 TBN 矩阵，将法线向量变换到和其他光照向量一样的参考空间中。这种方式随后所有光照计算都可以简单的理解。</p><p>把 TBN 矩阵发给像素着色器很简单：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>out VS_OUT <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    vec3 FragPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    vec2 TexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    mat3 TBN<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span> vs_out<span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    vs_out<span class="token punctuation">.</span>TBN <span class="token operator">=</span> <span class="token function">mat3</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> B<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在像素着色器中我们用 mat3 作为输入变量：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>in VS_OUT <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    vec3 FragPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    vec2 TexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    mat3 TBN<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span> fs_in<span class="token punctuation">;</span></pre></td></tr></table></figure><p>有了 TBN 矩阵我们现在就可以更新法线贴图代码，引入切线到世界空间变换：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>normal <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>normalMap<span class="token punctuation">,</span> fs_in<span class="token punctuation">.</span>TexCoords<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>normal <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>normal <span class="token operator">*</span> <span class="token number">2.0</span> <span class="token operator">-</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   </pre></td></tr><tr><td data-num="3"></td><td><pre>normal <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>fs_in<span class="token punctuation">.</span>TBN <span class="token operator">*</span> normal<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>因为最后的 normal 现在在世界空间中了，就不用改变其他像素着色器的代码了，因为光照代码就是假设法线向量在世界空间中。</p><p>我们同样看看第二种情况。我们用 TBN 矩阵的逆矩阵将所有相关的世界空间向量转变到采样所得法线向量的空间：切线空间。TBN 的建构还是一样，但我们在将其发送给像素着色器之前先要求逆矩阵：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vs_out<span class="token punctuation">.</span>TBN <span class="token operator">=</span> <span class="token function">transpose</span><span class="token punctuation">(</span><span class="token function">mat3</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> B<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>注意，这里我们使用 transpose 函数，而不是 inverse 函数。正交矩阵（每个轴既是单位向量同时相互垂直）的一大属性是一个<mark>正交矩阵的置换矩阵</mark>与<mark>它的逆矩阵</mark><strong>相等</strong>。这个属性很重要因为逆矩阵的求得比求置换开销大；结果却是一样的。</p><p>在像素着色器中我们不用对法线向量变换，但我们要把其他相关向量转换到切线空间，它们是 lightDir 和 viewDir。这样每个向量还是在同一个空间（切线空间）中了。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span>           </pre></td></tr><tr><td data-num="3"></td><td><pre>    vec3 normal <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>normalMap<span class="token punctuation">,</span> fs_in<span class="token punctuation">.</span>TexCoords<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    normal <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>normal <span class="token operator">*</span> <span class="token number">2.0</span> <span class="token operator">-</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   </pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    vec3 lightDir <span class="token operator">=</span> fs_in<span class="token punctuation">.</span>TBN <span class="token operator">*</span> <span class="token function">normalize</span><span class="token punctuation">(</span>lightPos <span class="token operator">-</span> fs_in<span class="token punctuation">.</span>FragPos<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    vec3 viewDir  <span class="token operator">=</span> fs_in<span class="token punctuation">.</span>TBN <span class="token operator">*</span> <span class="token function">normalize</span><span class="token punctuation">(</span>viewPos <span class="token operator">-</span> fs_in<span class="token punctuation">.</span>FragPos<span class="token punctuation">)</span><span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>第二种方法看似要做的更多，它还需要在像素着色器中进行更多的乘法操作，所以为何还用第二种方法呢？</p><p>将向量从世界空间转换到切线空间有个额外好处，我们可以把所有相关向量在顶点着色器中转换到切线空间，不用在像素着色器中做这件事。这是可行的，因为 lightPos 和 viewPos 不是每个 fragment 运行都要改变，对于 fs_in.FragPos，我们也可以在顶点着色器计算它的切线空间位置。基本上，不需要把任何向量在像素着色器中进行变换，而第一种方法中就是必须的，因为采样出来的法线向量对于每个像素着色器都不一样。</p><p>所以现在不是把 TBN 矩阵的逆矩阵发送给像素着色器，而是将切线空间的光源位置，观察位置以及顶点位置发送给像素着色器。这样我们就不用在像素着色器里进行矩阵乘法了。这是一个极佳的优化，因为顶点着色器通常比像素着色器运行的少。这也是为什么这种方法是一种更好的实现方式的原因。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>out VS_OUT <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    vec3 FragPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    vec2 TexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    vec3 TangentLightPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    vec3 TangentViewPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    vec3 TangentFragPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span> vs_out<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>uniform vec3 lightPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>uniform vec3 viewPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#123;</span>    </pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    mat3 TBN <span class="token operator">=</span> <span class="token function">transpose</span><span class="token punctuation">(</span><span class="token function">mat3</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> B<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    vs_out<span class="token punctuation">.</span>TangentLightPos <span class="token operator">=</span> TBN <span class="token operator">*</span> lightPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    vs_out<span class="token punctuation">.</span>TangentViewPos  <span class="token operator">=</span> TBN <span class="token operator">*</span> viewPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    vs_out<span class="token punctuation">.</span>TangentFragPos  <span class="token operator">=</span> TBN <span class="token operator">*</span> <span class="token function">vec3</span><span class="token punctuation">(</span>model <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在像素着色器中我们使用这些新的输入变量来计算切线空间的光照。因为法线向量已经在切线空间中了，光照就有意义了。</p><p>将法线贴图应用到切线空间上，我们会得到混合教程一开始那个例子相似的结果，但这次我们可以将平面朝向各个方向，光照一直都会是正确的：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span>mat4 model<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>model <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">rotate</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span> <span class="token punctuation">(</span>GLfloat<span class="token punctuation">)</span><span class="token function">glfwGetTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">normalize</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glUniformMatrix4fv</span><span class="token punctuation">(</span>modelLoc <span class="token number">1</span><span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">value_ptr</span><span class="token punctuation">(</span>model<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">RenderQuad</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>看起来是正确的法线贴图：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/04/normal_mapping_correct_tangent.png" alt="image"></p><h3 id="复杂物体"><a class="anchor" href="#复杂物体">#</a> 复杂物体</h3><p>我们已经说明了如何通过手工计算切线和副切线向量，来使用切线空间和法线贴图。幸运的是，计算这些切线和副切线向量对于你来说不是经常能遇到的事；大多数时候，在模型加载器中实现了一次就行了，我们是在使用了 Assimp 的那个加载器中实现的。</p><p>Assimp 有个很有用的配置，在我们加载模型的时候调用 aiProcess_CalcTangentSpace。当 aiProcess_CalcTangentSpace 应用到 Assimp 的 ReadFile 函数时，Assimp 会为每个加载的顶点计算出柔和的切线和副切线向量，它所使用的方法和我们本教程使用的类似。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> aiScene<span class="token operator">*</span> scene <span class="token operator">=</span> importer<span class="token punctuation">.</span><span class="token function">ReadFile</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    path<span class="token punctuation">,</span> aiProcess_Triangulate <span class="token operator">|</span> aiProcess_FlipUVs <span class="token operator">|</span> aiProcess_CalcTangentSpace</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>我们可以通过下面的代码用 Assimp 获取计算出来的切线空间：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vector<span class="token punctuation">.</span>x <span class="token operator">=</span> mesh<span class="token operator">-></span>mTangents<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>vector<span class="token punctuation">.</span>y <span class="token operator">=</span> mesh<span class="token operator">-></span>mTangents<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>vector<span class="token punctuation">.</span>z <span class="token operator">=</span> mesh<span class="token operator">-></span>mTangents<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>z<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>vertex<span class="token punctuation">.</span>Tangent <span class="token operator">=</span> vector<span class="token punctuation">;</span></pre></td></tr></table></figure><p>然后，你还必须更新模型加载器，用以从带纹理模型中加载法线贴图。wavefront 的模型格式（.obj）导出的法线贴图有点不一样，Assimp 的 aiTextureType_NORMAL 并不会加载它的法线贴图，而 aiTextureType_HEIGHT 却能，所以我们经常这样加载它们：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vector<span class="token operator">&lt;</span>Texture<span class="token operator">></span> specularMaps <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">loadMaterialTextures</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    material<span class="token punctuation">,</span> aiTextureType_HEIGHT<span class="token punctuation">,</span> <span class="token string">"texture_normal"</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>当然，对于每个模型的类型和文件格式来说都是不同的。同样了解 aiProcess_CalcTangentSpace 并不能总是很好的工作也很重要。计算切线是需要根据纹理坐标的，有些模型制作者使用一些纹理小技巧比如镜像一个模型上的纹理表面时也镜像了另一半的纹理坐标；这样当不考虑这个镜像的特别操作的时候（Assimp 就不考虑）结果就不对了。</p><p>运行程序，用新的模型加载器，加载一个有 specular 和法线贴图的模型，看起来会像这样：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/04/normal_mapping_complex_compare.png" alt="image"></p><p>你可以看到在没有太多点的额外开销的情况下法线贴图难以置信地提升了物体的细节。</p><p>使用法线贴图也是一种提升你的场景的表现的重要方式。在使用法线贴图之前你不得不使用相当多的顶点才能表现出一个更精细的网格，但使用了法线贴图我们可以使用更少的顶点表现出同样丰富的细节。下图来自 Paolo Cignoni，图中对比了两种方式：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/04/normal_mapping_comparison.png" alt="image"></p><p>高精度网格和使用法线贴图的低精度网格几乎区分不出来。所以法线贴图不仅看起来漂亮，它也是一个将高精度多边形转换为低精度多边形而不失细节的重要工具。</p><h3 id="最后一件事"><a class="anchor" href="#最后一件事">#</a> 最后一件事</h3><p>关于法线贴图还有最后一个技巧要讨论，它可以在不必花费太多性能开销的情况下稍稍提升画质表现。</p><p>当在更大的网格上计算切线向量的时候，它们往往有很大数量的共享顶点，当法向贴图应用到这些表面时将切线向量平均化通常能获得更好更平滑的结果。这样做有个问题，就是 TBN 向量可能会不能互相垂直，这意味着 TBN 矩阵不再是正交矩阵了。法线贴图可能会稍稍偏移，但这仍然可以改进。</p><p>使用叫做<mark>格拉姆 - 施密特正交化过程</mark>（Gram-Schmidt process）的数学技巧，我们可以对 TBN 向量进行<mark>重正交化</mark>，这样每个向量就又会重新垂直了。在顶点着色器中我们这样做：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vec3 T <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token function">vec3</span><span class="token punctuation">(</span>model <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>tangent<span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>vec3 N <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token function">vec3</span><span class="token punctuation">(</span>model <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>normal<span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// re-orthogonalize T with respect to N</span></pre></td></tr><tr><td data-num="4"></td><td><pre>T <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>T <span class="token operator">-</span> <span class="token function">dot</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> N<span class="token punctuation">)</span> <span class="token operator">*</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// then retrieve perpendicular vector B with the cross product of T and N</span></pre></td></tr><tr><td data-num="6"></td><td><pre>vec3 B <span class="token operator">=</span> <span class="token function">cross</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>mat3 TBN <span class="token operator">=</span> <span class="token function">mat3</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> B<span class="token punctuation">,</span> N<span class="token punctuation">)</span></pre></td></tr></table></figure><p>这样稍微花费一些性能开销就能对法线贴图进行一点提升。看看最后的那个附加资源： Normal Mapping Mathematics 视频，里面有对这个过程的解释。</p><h3 id="附加资源-4"><a class="anchor" href="#附加资源-4">#</a> 附加资源</h3><ul><li><span class="exturl" data-url="aHR0cDovL29nbGRldi5hdHNwYWNlLmNvLnVrL3d3dy90dXRvcmlhbDI2L3R1dG9yaWFsMjYuaHRtbA==">Tutorial 26: Normal Mapping</span>：ogldev 的法线贴图教程。</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1MSU9QWW1rbmo1UQ==">How Normal Mapping Works</span>：TheBennyBox 的讲述法线贴图如何工作的视频。</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj00RmFXTGdzY3RxWQ==">Normal Mapping Mathematics</span>：TheBennyBox 关于法线贴图的数学原理的教程。</li><li><span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wtdHV0b3JpYWwub3JnL2ludGVybWVkaWF0ZS10dXRvcmlhbHMvdHV0b3JpYWwtMTMtbm9ybWFsLW1hcHBpbmcv">Tutorial 13: Normal Mapping</span>：opengl-tutorial.org 提供的法线贴图教程。</li></ul><h2 id="视差贴图"><a class="anchor" href="#视差贴图">#</a> 视差贴图</h2><p><mark>视差贴图</mark> (Parallax Mapping) 技术和法线贴图差不多，但它有着不同的原则。和法线贴图一样视差贴图能够极大<mark>提升表面细节</mark>，使之具有深度感。它也是利用了视错觉，然而对深度有着更好的表达，与法线贴图一起用能够产生难以置信的效果。视差贴图<mark>和光照无关</mark>，我在这里是作为法线贴图的技术延续来讨论它的。需要注意的是在开始学习视差贴图之前强烈建议先对法线贴图，特别是切线空间有较好的理解。</p><p>视差贴图属于 == 位移贴图 (==Displacement Mapping) 技术的一种，它对根据储存在纹理中的几何信息对顶点进行位移或偏移。一种实现的方式是比如有 1000 个顶点，根据纹理中的数据对平面特定区域的顶点的高度进行位移。这样的每个纹理像素包含了高度值纹理叫做高度贴图。一张简单的砖块表面的高度贴图如下所示：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/05/parallax_mapping_height_map.png" alt="image"></p><p>整个平面上的每个顶点都根据从高度贴图采样出来的高度值进行位移，根据材质的几何属性平坦的平面变换成凹凸不平的表面。例如一个平坦的平面利用上面的高度贴图进行置换能得到以下结果：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/05/parallax_mapping_plane_heightmap.png" alt="image"></p><p>置换顶点有一个问题就是平面必须由很多顶点组成才能获得具有真实感的效果，否则看起来效果并不会很好。一个平坦的表面上有 1000 个顶点计算量太大了。我们能否不用这么多的顶点就能取得相似的效果呢？事实上，上面的表面就是用 6 个顶点渲染出来的（两个三角形）。上面的那个表面使用视差贴图技术渲染，位移贴图技术不需要额外的顶点数据来表达深度，它像法线贴图一样采用一种聪明的手段欺骗用户的眼睛。</p><p>视差贴图背后的思想是修改纹理坐标使一个 fragment 的表面看起来比实际的更高或者更低，所有这些都根据观察方向和高度贴图。为了理解它如何工作，看看下面砖块表面的图片：</p><p>这里粗糙的红线代表高度贴图中的数值的立体表达，向量 V¯ 代表观察方向。如果平面进行实际位移，观察者会在点 B 看到表面。然而我们的平面没有实际上进行位移，观察方向将在点 A 与平面接触。视差贴图的目的是，在 A 位置上的 fragment 不再使用点 A 的纹理坐标而是使用点 B 的。随后我们用点 B 的纹理坐标采样，观察者就像看到了点 B 一样。</p><p>这个技巧就是描述如何从点 A 得到点 B 的纹理坐标。视差贴图尝试通过对从 fragment 到观察者的方向向量 V¯ 进行缩放的方式解决这个问题，缩放的大小是 A 处 fragment 的高度。所以我们将 V¯ 的长度缩放为高度贴图在点 A 处 H (A) 采样得来的值。下图展示了经缩放得到的向量 P¯：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/05/parallax_mapping_scaled_height.png" alt="image"></p><p>我们随后选出 P¯ 以及这个向量与平面对齐的坐标作为纹理坐标的偏移量。这能工作是因为向量 P¯ 是使用从高度贴图得到的高度值计算出来的，所以一个 fragment 的高度越高位移的量越大。</p><p>这个技巧在大多数时候都没问题，但点 B 是粗略估算得到的。当表面的高度变化很快的时候，看起来就不会真实，因为向量 P¯ 最终不会和 B 接近，就像下图这样：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/05/parallax_mapping_incorrect_p.png" alt="image"></p><p>视差贴图的另一个问题是，当表面被任意旋转以后很难指出从 P¯ 获取哪一个坐标。我们在视差贴图中使用了另一个坐标空间，这个空间 P¯ 向量的 x 和 y 元素总是与纹理表面对齐。如果你看了法线贴图教程，你也许猜到了，我们实现它的方法，是的，我们还是在切线空间中实现视差贴图。</p><p>将 fragment 到观察者的向量 V¯ 转换到切线空间中，经变换的 P¯ 向量的 x 和 y 元素将于表面的切线和副切线向量对齐。由于切线和副切线向量与表面纹理坐标的方向相同，我们可以用 P¯ 的 x 和 y 元素作为纹理坐标的偏移量，这样就不用考虑表面的方向了。</p><p>理论都有了，下面我们来动手实现视差贴图。</p><h3 id="视差贴图-2"><a class="anchor" href="#视差贴图-2">#</a> 视差贴图</h3><p>我们将使用一个简单的 2D 平面，在把它发送给 GPU 之前我们先计算它的切线和副切线向量；和法线贴图教程做的差不多。我们将向平面贴 diffuse 纹理、法线贴图以及一个位移贴图，你可以点击链接下载。这个例子中我们将视差贴图和法线贴图连用。因为视差贴图生成表面位移了的幻觉，当光照不匹配时这种幻觉就被破坏了。法线贴图通常根据高度贴图生成，法线贴图和高度贴图一起用能保证光照能和位移想匹配。</p><p>你可能已经注意到，上面链接上的那个位移贴图和教程一开始的那个高度贴图相比是颜色是相反的。这是因为使用反色高度贴图（也叫深度贴图）去模拟深度比模拟高度更容易。下图反映了这个轻微的改变：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/05/parallax_mapping_depth.png" alt="image"></p><p>我们再次获得 A 和 B，但是这次我们用向量 V¯ 减去点 A 的纹理坐标得到 P¯。我们通过在着色器中用 1.0 减去采样得到的高度贴图中的值来取得深度值，而不再是高度值，或者简单地在图片编辑软件中把这个纹理进行反色操作，就像我们对连接中的那个深度贴图所做的一样。</p><p>位移贴图是在像素着色器中实现的，因为三角形表面的所有位移效果都不同。在像素着色器中我们将需要计算 fragment 到观察者到方向向量 V¯ 所以我们需要观察者位置和在切线空间中的 fragment 位置。法线贴图教程中我们已经有了一个顶点着色器，它把这些向量发送到切线空间，所以我们可以复制那个顶点着色器：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> in vec3 position<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> in vec3 normal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> in vec2 texCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span> in vec3 tangent<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">)</span> in vec3 bitangent<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>out VS_OUT <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    vec3 FragPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    vec2 TexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    vec3 TangentLightPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    vec3 TangentViewPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    vec3 TangentFragPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span> vs_out<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>uniform mat4 projection<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>uniform mat4 view<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>uniform mat4 model<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>uniform vec3 lightPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>uniform vec3 viewPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    gl_Position      <span class="token operator">=</span> projection <span class="token operator">*</span> view <span class="token operator">*</span> model <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    vs_out<span class="token punctuation">.</span>FragPos   <span class="token operator">=</span> <span class="token function">vec3</span><span class="token punctuation">(</span>model <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   </pre></td></tr><tr><td data-num="27"></td><td><pre>    vs_out<span class="token punctuation">.</span>TexCoords <span class="token operator">=</span> texCoords<span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre>    vec3 T   <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token function">mat3</span><span class="token punctuation">(</span>model<span class="token punctuation">)</span> <span class="token operator">*</span> tangent<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    vec3 B   <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token function">mat3</span><span class="token punctuation">(</span>model<span class="token punctuation">)</span> <span class="token operator">*</span> bitangent<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    vec3 N   <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token function">mat3</span><span class="token punctuation">(</span>model<span class="token punctuation">)</span> <span class="token operator">*</span> normal<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    mat3 TBN <span class="token operator">=</span> <span class="token function">transpose</span><span class="token punctuation">(</span><span class="token function">mat3</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> B<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre></pre></td></tr><tr><td data-num="34"></td><td><pre>    vs_out<span class="token punctuation">.</span>TangentLightPos <span class="token operator">=</span> TBN <span class="token operator">*</span> lightPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    vs_out<span class="token punctuation">.</span>TangentViewPos  <span class="token operator">=</span> TBN <span class="token operator">*</span> viewPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    vs_out<span class="token punctuation">.</span>TangentFragPos  <span class="token operator">=</span> TBN <span class="token operator">*</span> vs_out<span class="token punctuation">.</span>FragPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在这里有件事很重要，我们需要把 position 和在切线空间中的观察者的位置 viewPos 发送给像素着色器。</p><p>在像素着色器中，我们实现视差贴图的逻辑。像素着色器看起来会是这样的：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>out vec4 FragColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>in VS_OUT <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    vec3 FragPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    vec2 TexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    vec3 TangentLightPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    vec3 TangentViewPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    vec3 TangentFragPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span> fs_in<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>uniform sampler2D diffuseMap<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>uniform sampler2D normalMap<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>uniform sampler2D depthMap<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>uniform <span class="token keyword">float</span> height_scale<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>vec2 <span class="token function">ParallaxMapping</span><span class="token punctuation">(</span>vec2 texCoords<span class="token punctuation">,</span> vec3 viewDir<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#123;</span>           </pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token comment">// Offset texture coordinates with Parallax Mapping</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    vec3 viewDir   <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>fs_in<span class="token punctuation">.</span>TangentViewPos <span class="token operator">-</span> fs_in<span class="token punctuation">.</span>TangentFragPos<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    vec2 texCoords <span class="token operator">=</span> <span class="token function">ParallaxMapping</span><span class="token punctuation">(</span>fs_in<span class="token punctuation">.</span>TexCoords<span class="token punctuation">,</span>  viewDir<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token comment">// then sample textures with new texture coords</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    vec3 diffuse <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>diffuseMap<span class="token punctuation">,</span> texCoords<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    vec3 normal  <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>normalMap<span class="token punctuation">,</span> texCoords<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    normal <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>normal <span class="token operator">*</span> <span class="token number">2.0</span> <span class="token operator">-</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token comment">// proceed with lighting code</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>    </pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>我们定义了一个叫做 ParallaxMapping 的函数，它把 fragment 的纹理坐标作和切线空间中的 fragment 到观察者的方向向量为输入。这个函数返回经位移的纹理坐标。然后我们使用这些经位移的纹理坐标进行 diffuse 和法线贴图的采样。最后 fragment 的 diffuse 颜色和法线向量就正确的对应于表面的经位移的位置上了。</p><p>我们来看看 ParallaxMapping 函数的内部：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vec2 <span class="token function">ParallaxMapping</span><span class="token punctuation">(</span>vec2 texCoords<span class="token punctuation">,</span> vec3 viewDir<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">float</span> height <span class="token operator">=</span>  <span class="token function">texture</span><span class="token punctuation">(</span>depthMap<span class="token punctuation">,</span> texCoords<span class="token punctuation">)</span><span class="token punctuation">.</span>r<span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num="4"></td><td><pre>    vec2 p <span class="token operator">=</span> viewDir<span class="token punctuation">.</span>xy <span class="token operator">/</span> viewDir<span class="token punctuation">.</span>z <span class="token operator">*</span> <span class="token punctuation">(</span>height <span class="token operator">*</span> height_scale<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">return</span> texCoords <span class="token operator">-</span> p<span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这个相对简单的函数是我们所讨论过的内容的直接表述。我们用本来的纹理坐标 texCoords 从高度贴图中来采样出当前 fragment 高度 H (A)。然后计算出 P¯，x 和 y 元素在切线空间中，viewDir 向量除以它的 z 元素，用 fragment 的高度对它进行缩放。我们同时引入额一个 height_scale 的 uniform，来进行一些额外的控制，因为视差效果如果没有一个缩放参数通常会过于强烈。然后我们用 P¯ 减去纹理坐标来获得最终的经过位移纹理坐标。</p><p>有一个地方需要注意，就是 viewDir.xy 除以 viewDir.z 那里。因为 viewDir 向量是经过了标准化的，viewDir.z 会在 0.0 到 1.0 之间的某处。当 viewDir 大致平行于表面时，它的 z 元素接近于 0.0，除法会返回比 viewDir 垂直于表面的时候更大的 P¯ 向量。所以基本上我们增加了 P¯ 的大小，当以一个角度朝向一个表面相比朝向顶部时它对纹理坐标会进行更大程度的缩放；这回在角上获得更大的真实度。</p><p>有些人更喜欢在等式中不使用 viewDir.z，因为普通的视差贴图会在角上产生不想要的结果；这个技术叫做有偏移量限制的视差贴图（Parallax Mapping with Offset Limiting）。选择哪一个技术是个人偏好问题，但我倾向于普通的视差贴图。</p><p>最后的纹理坐标随后被用来进行采样（diffuse 和法线）贴图，下图所展示的位移效果中 height_scale 等于 1：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/05/parallax_mapping.png" alt="image"></p><p>这里你会看到只用法线贴图和与视差贴图相结合的法线贴图的不同之处。因为视差贴图尝试模拟深度，它实际上能够根据你观察它们的方向使砖块叠加到其他砖块上。</p><p>在视差贴图的那个平面里你仍然能看到在边上有古怪的失真。原因是在平面的边缘上，纹理坐标超出了 0 到 1 的范围进行采样，根据纹理的环绕方式导致了不真实的结果。解决的方法是当它超出默认纹理坐标范围进行采样的时候就丢弃这个 fragment：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>texCoords <span class="token operator">=</span> <span class="token function">ParallaxMapping</span><span class="token punctuation">(</span>fs_in<span class="token punctuation">.</span>TexCoords<span class="token punctuation">,</span>  viewDir<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span>texCoords<span class="token punctuation">.</span>x <span class="token operator">></span> <span class="token number">1.0</span> <span class="token operator">||</span> texCoords<span class="token punctuation">.</span>y <span class="token operator">></span> <span class="token number">1.0</span> <span class="token operator">||</span> texCoords<span class="token punctuation">.</span>x <span class="token operator">&lt;</span> <span class="token number">0.0</span> <span class="token operator">||</span> texCoords<span class="token punctuation">.</span>y <span class="token operator">&lt;</span> <span class="token number">0.0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    discard<span class="token punctuation">;</span></pre></td></tr></table></figure><p>丢弃了超出默认范围的纹理坐标的所有 fragment，视差贴图的表面边缘给出了正确的结果。注意，这个技巧不能在所有类型的表面上都能工作，但是应用于平面上它还是能够是平面看起来真的进行位移了：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/05/parallax_mapping_edge_fix.png" alt="image"></p><p>看起来不错，运行起来也很快，因为我们只要给视差贴图提供一个额外的纹理样本就能工作。当从一个角度看过去的时候，会有一些问题产生（和法线贴图相似），陡峭的地方会产生不正确的结果，从下图你可以看到：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/05/parallax_mapping_issues.png" alt="image"></p><p>问题的原因是这只是一个大致近似的视差映射。还有一些技巧让我们在陡峭的高度上能够获得几乎完美的结果，即使当以一定角度观看的时候。例如，我们不再使用单一样本，取而代之使用多样本来找到最近点 B 会得到怎样的结果？</p><h3 id="陡峭视差映射"><a class="anchor" href="#陡峭视差映射">#</a> 陡峭视差映射</h3><p>陡峭视差映射 (Steep Parallax Mapping) 是视差映射的扩展，原则是一样的，但不是使用一个样本而是多个样本来确定向量 P¯ 到 B。它能得到更好的结果，它将总深度范围分布到同一个深度 / 高度的多个层中。从每个层中我们沿着 P¯ 方向移动采样纹理坐标，直到我们找到了一个采样得到的低于当前层的深度值的深度值。看看下面的图片：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/05/parallax_mapping_steep_parallax_mapping_diagram.png" alt="image"></p><p>我们从上到下遍历深度层，我们把每个深度层和储存在深度贴图中的它的深度值进行对比。如果这个层的深度值小于深度贴图的值，就意味着这一层的 P¯ 向量部分在表面之下。我们继续这个处理过程直到有一层的深度高于储存在深度贴图中的值：这个点就在（经过位移的）表面下方。</p><p>这个例子中我们可以看到第二层 (D (2) = 0.73) 的深度贴图的值仍低于第二层的深度值 0.4，所以我们继续。下一次迭代，这一层的深度值 0.6 大于深度贴图中采样的深度值 (D (3) = 0.37)。我们便可以假设第三层向量 P¯ 是可用的位移几何位置。我们可以用从向量 P3¯ 的纹理坐标偏移 T3 来对 fragment 的纹理坐标进行位移。你可以看到随着深度曾的增加精确度也在提高。</p><p>为实现这个技术，我们只需要改变 ParallaxMapping 函数，因为所有需要的变量都有了：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vec2 <span class="token function">ParallaxMapping</span><span class="token punctuation">(</span>vec2 texCoords<span class="token punctuation">,</span> vec3 viewDir<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// number of depth layers</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">const</span> <span class="token keyword">float</span> numLayers <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// calculate the size of each layer</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">float</span> layerDepth <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> numLayers<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// depth of current layer</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">float</span> currentLayerDepth <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// the amount to shift the texture coordinates per layer (from vector P)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    vec2 P <span class="token operator">=</span> viewDir<span class="token punctuation">.</span>xy <span class="token operator">*</span> height_scale<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">float</span> deltaTexCoords <span class="token operator">=</span> P <span class="token operator">/</span> numLayers<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>     </pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>我们先定义层的数量，计算每一层的深度，最后计算纹理坐标偏移，每一层我们必须沿着 P¯ 的方向进行移动。</p><p>然后我们遍历所有层，从上开始，知道找到小于这一层的深度值的深度贴图值：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// get initial values</span></pre></td></tr><tr><td data-num="2"></td><td><pre>vec2  currentTexCoords     <span class="token operator">=</span> texCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">float</span> currentDepthMapValue <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>depthMap<span class="token punctuation">,</span> currentTexCoords<span class="token punctuation">)</span><span class="token punctuation">.</span>r<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">while</span><span class="token punctuation">(</span>currentLayerDepth <span class="token operator">&lt;</span> currentDepthMapValue<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// shift texture coordinates along direction of P</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    currentTexCoords <span class="token operator">-=</span> deltaTexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// get depthmap value at current texture coordinates</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    currentDepthMapValue <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>depthMap<span class="token punctuation">,</span> currentTexCoords<span class="token punctuation">)</span><span class="token punctuation">.</span>r<span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">// get depth of next layer</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    currentLayerDepth <span class="token operator">+=</span> layerDepth<span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">return</span> texCoords <span class="token operator">-</span> currentTexCoords<span class="token punctuation">;</span></pre></td></tr></table></figure><p>这里我们循环每一层深度，直到沿着 P¯ 向量找到第一个返回低于（位移）表面的深度的纹理坐标偏移量。从 fragment 的纹理坐标减去最后的偏移量，来得到最终的经过位移的纹理坐标向量，这次就比传统的视差映射更精确了。</p><p>有 10 个样本砖墙从一个角度看上去就已经很好了，但是当有一个强前面展示的木制表面一样陡峭的表面时，陡峭的视差映射的威力就显示出来了：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/05/parallax_mapping_steep_parallax_mapping.png" alt="image"></p><p>我们可以通过对视差贴图的一个属性的利用，对算法进行一点提升。当垂直看一个表面的时候纹理时位移比以一定角度看时的小。我们可以在垂直看时使用更少的样本，以一定角度看时增加样本数量：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">float</span> minLayers <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">float</span> maxLayers <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">float</span> numLayers <span class="token operator">=</span> <span class="token function">mix</span><span class="token punctuation">(</span>maxLayers<span class="token punctuation">,</span> minLayers<span class="token punctuation">,</span> <span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> viewDir<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这里我们得到 viewDir 和正 z 方向的点乘，使用它的结果根据我们看向表面的角度调整样本数量（注意正 z 方向等于切线空间中的表面的法线）。如果我们所看的方向平行于表面，我们就是用 32 层。</p><p>你可以在这里找到最新的像素着色器代码。这里也提供木制玩具箱的表面贴图：diffuse、法线、深度。</p><p>陡峭视差贴图同样有自己的问题。因为这个技术是基于有限的样本数量的，我们会遇到锯齿效果以及图层之间有明显的断层：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/05/parallax_mapping_steep_artifact.png" alt="image"></p><p>我们可以通过增加样本的方式减少这个问题，但是很快就会花费很多性能。有些旨在修复这个问题的方法：不适用低于表面的第一个位置，而是在两个接近的深度层进行插值找出更匹配 B 的。</p><p>两种最流行的解决方法叫做 Relief Parallax Mapping 和 Parallax Occlusion Mapping，Relief Parallax Mapping 更精确一些，但是比 Parallax Occlusion Mapping 性能开销更多。因为 Parallax Occlusion Mapping 的效果和前者差不多但是效率更高，因此这种方式更经常使用，所以我们将在下面讨论一下。</p><h3 id="视差遮蔽映射"><a class="anchor" href="#视差遮蔽映射">#</a> 视差遮蔽映射</h3><p>视差遮蔽映射 (Parallax Occlusion Mapping) 和陡峭视差映射的原则相同，但不是用触碰的第一个深度层的纹理坐标，而是在触碰之前和之后，在深度层之间进行线性插值。我们根据表面的高度距离啷个深度层的深度层值的距离来确定线性插值的大小。看看下面的图片就能了解它是如何工作的：</p><p>你可以看到大部分和陡峭视差映射一样，不一样的地方是有个额外的步骤，两个深度层的纹理坐标围绕着交叉点的线性插值。这也是近似的，但是比陡峭视差映射更精确。</p><p>视差遮蔽映射的代码基于陡峭视差映射，所以并不难：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token comment">// steep parallax mapping code here</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// get texture coordinates before collision (reverse operations)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>vec2 prevTexCoords <span class="token operator">=</span> currentTexCoords <span class="token operator">+</span> deltaTexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// get depth after and before collision for linear interpolation</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">float</span> afterDepth  <span class="token operator">=</span> currentDepthMapValue <span class="token operator">-</span> currentLayerDepth<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">float</span> beforeDepth <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>depthMap<span class="token punctuation">,</span> prevTexCoords<span class="token punctuation">)</span><span class="token punctuation">.</span>r <span class="token operator">-</span> currentLayerDepth <span class="token operator">+</span> layerDepth<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// interpolation of texture coordinates</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">float</span> weight <span class="token operator">=</span> afterDepth <span class="token operator">/</span> <span class="token punctuation">(</span>afterDepth <span class="token operator">-</span> beforeDepth<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>vec2 finalTexCoords <span class="token operator">=</span> prevTexCoords <span class="token operator">*</span> weight <span class="token operator">+</span> currentTexCoords <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> weight<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">return</span> finalTexCoords<span class="token punctuation">;</span></pre></td></tr></table></figure><p>在对（位移的）表面几何进行交叉，找到深度层之后，我们获取交叉前的纹理坐标。然后我们计算来自相应深度层的几何之间的深度之间的距离，并在两个值之间进行插值。线性插值的方式是在两个层的纹理坐标之间进行的基础插值。函数最后返回最终的经过插值的纹理坐标。</p><p>视差遮蔽映射的效果非常好，尽管有一些可以看到的轻微的不真实和锯齿的问题，这仍是一个好交易，因为除非是放得非常大或者观察角度特别陡，否则也看不到。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/05/parallax_mapping_parallax_occlusion_mapping.png" alt="image"></p><p>视差贴图是提升场景细节非常好的技术，但是使用的时候还是要考虑到它会带来一点不自然。大多数时候视差贴图用在地面和墙壁表面，这种情况下查明表面的轮廓并不容易，同时观察角度往往趋向于垂直于表面。这样视差贴图的不自然也就很难能被注意到了，对于提升物体的细节可以祈祷难以置信的效果。</p><h3 id="附加资源-5"><a class="anchor" href="#附加资源-5">#</a> 附加资源</h3><ul><li><span class="exturl" data-url="aHR0cDovL3N1bmFuZGJsYWNrY2F0LmNvbS90aXBGdWxsVmlldy5waHA/dG9waWNpZD0yOA==">Parallax Occlusion Mapping in GLSL</span>：sunandblackcat.com 上的视差贴图教程。</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj14dk9UNjJMLWZRSQ==">How Parallax Displacement Mapping Works</span>：TheBennyBox 的关于视差贴图原理的视频教程。</li></ul><h2 id="hdr"><a class="anchor" href="#hdr">#</a> HDR</h2><p>一般来说，当存储在帧缓冲 (Framebuffer) 中时，亮度和颜色的值是默认被限制在 0.0 到 1.0 之间的。这个看起来无辜的语句使我们一直将亮度与颜色的值设置在这个范围内，尝试着与场景契合。这样是能够运行的，也能给出还不错的效果。但是如果我们遇上了一个特定的区域，其中有多个亮光源使这些数值总和超过了 1.0，又会发生什么呢？答案是这些片段中超过 1.0 的亮度或者颜色值会被约束在 1.0，从而导致场景混成一片，难以分辨：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/06/hdr_clamped.png" alt="image"></p><p>这是由于大量片段的颜色值都非常接近 1.0，在很大一个区域内每一个亮的片段都有相同的白色。这损失了很多的细节，使场景看起来非常假。</p><p>解决这个问题的一个方案是减小光源的强度从而保证场景内没有一个片段亮于 1.0。然而这并不是一个好的方案，因为你需要使用不切实际的光照参数。一个更好的方案是让颜色暂时超过 1.0，然后将其转换至 0.0 到 1.0 的区间内，从而防止损失细节。</p><p>显示器被限制为只能显示值为 0.0 到 1.0 间的颜色，但是在光照方程中却没有这个限制。通过使片段的颜色超过 1.0，我们有了一个更大的颜色范围，这也被称作 HDR (High Dynamic Range, 高动态范围)。有了 HDR，亮的东西可以变得非常亮，暗的东西可以变得非常暗，而且充满细节。</p><p>HDR 原本只是被运用在摄影上，摄影师对同一个场景采取不同曝光拍多张照片，捕捉大范围的色彩值。这些图片被合成为 HDR 图片，从而综合不同的曝光等级使得大范围的细节可见。看下面这个例子，左边这张图片在被光照亮的区域充满细节，但是在黑暗的区域就什么都看不见了；但是右边这张图的高曝光却可以让之前看不出来的黑暗区域显现出来。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/06/hdr_image.png" alt="image"></p><p>这与我们眼睛工作的原理非常相似，也是 HDR 渲染的基础。当光线很弱的啥时候，人眼会自动调整从而使过暗和过亮的部分变得更清晰，就像人眼有一个能自动根据场景亮度调整的自动曝光滑块。</p><p>HDR 渲染和其很相似，我们允许用更大范围的颜色值渲染从而获取大范围的黑暗与明亮的场景细节，最后将所有 HDR 值转换成在 [0.0, 1.0] 范围的 LDR (Low Dynamic Range, 低动态范围)。转换 HDR 值到 LDR 值得过程叫做色调映射 (Tone Mapping)，现在现存有很多的色调映射算法，这些算法致力于在转换过程中保留尽可能多的 HDR 细节。这些色调映射算法经常会包含一个选择性倾向黑暗或者明亮区域的参数。</p><p>在实时渲染中，HDR 不仅允许我们超过 LDR 的范围 [0.0, 1.0] 与保留更多的细节，同时还让我们能够根据光源的真实强度指定它的强度。比如太阳有比闪光灯之类的东西更高的强度，那么我们为什么不这样子设置呢？(比如说设置一个 10.0 的漫亮度) 这允许我们用更现实的光照参数恰当地配置一个场景的光照，而这在 LDR 渲染中是不能实现的，因为他们会被上限约束在 1.0。</p><p>因为显示器只能显示在 0.0 到 1.0 范围之内的颜色，我们肯定要做一些转换从而使得当前的 HDR 颜色值符合显示器的范围。简单地取平均值重新转换这些颜色值并不能很好的解决这个问题，因为明亮的地方会显得更加显著。我们能做的是用一个不同的方程与 / 或曲线来转换这些 HDR 值到 LDR 值，从而给我们对于场景的亮度完全掌控，这就是之前说的色调变换，也是 HDR 渲染的最终步骤。</p><h3 id="浮点帧缓冲"><a class="anchor" href="#浮点帧缓冲">#</a> 浮点帧缓冲</h3><p>在实现 HDR 渲染之前，我们首先需要一些防止颜色值在每一个片段着色器运行后被限制约束的方法。当帧缓冲使用了一个标准化的定点格式 (像 GL_RGB) 为其颜色缓冲的内部格式，OpenGL 会在将这些值存入帧缓冲前自动将其约束到 0.0 到 1.0 之间。这一操作对大部分帧缓冲格式都是成立的，除了专门用来存放被拓展范围值的浮点格式。</p><p>当一个帧缓冲的颜色缓冲的内部格式被设定成了 GL_RGB16F, GL_RGBA16F, GL_RGB32F 或者 GL_RGBA32F 时，这些帧缓冲被叫做浮点帧缓冲 (Floating Point Framebuffer)，浮点帧缓冲可以存储超过 0.0 到 1.0 范围的浮点值，所以非常适合 HDR 渲染。</p><p>想要创建一个浮点帧缓冲，我们只需要改变颜色缓冲的内部格式参数就行了（注意 GL_FLOAT 参数)：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> colorBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glTexImage2D</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RGB16F<span class="token punctuation">,</span> SCR_WIDTH<span class="token punctuation">,</span> SCR_HEIGHT<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RGB<span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>默认的帧缓冲默认一个颜色分量只占用 8 位 (bits)。当使用一个使用 32 位每颜色分量的浮点帧缓冲时 (使用 GL_RGB32F 或者 GL_RGBA32F)，我们需要四倍的内存来存储这些颜色。所以除非你需要一个非常高的精确度，32 位不是必须的，使用 GLRGB16F 就足够了。</p><p>有了一个带有浮点颜色缓冲的帧缓冲，我们可以放心渲染场景到这个帧缓冲中。在这个教程的例子当中，我们先渲染一个光照的场景到浮点帧缓冲中，之后再在一个铺屏四边形 (Screen-filling Quad) 上应用这个帧缓冲的颜色缓冲，代码会是这样子：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> hdrFBO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT <span class="token operator">|</span> GL_DEPTH_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// [...] 渲染 (光照的) 场景</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 现在使用一个不同的着色器将 HDR 颜色缓冲渲染至 2D 铺屏四边形上</span></pre></td></tr><tr><td data-num="7"></td><td><pre>hdrShader<span class="token punctuation">.</span><span class="token function">Use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">glActiveTexture</span><span class="token punctuation">(</span>GL_TEXTURE0<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> hdrColorBufferTexture<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token function">RenderQuad</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这里场景的颜色值存在一个可以包含任意颜色值的浮点颜色缓冲中，值可能是超过 1.0 的。这个简单的演示中，场景被创建为一个被拉伸的立方体通道和四个点光源，其中一个非常亮的在隧道的尽头：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>glm<span class="token operator">::</span>vec3<span class="token operator">></span> lightColors<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>lightColors<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">200.0f</span><span class="token punctuation">,</span> <span class="token number">200.0f</span><span class="token punctuation">,</span> <span class="token number">200.0f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>lightColors<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.1f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>lightColors<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.2f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>lightColors<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.1f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>渲染至浮点帧缓冲和渲染至一个普通的帧缓冲是一样的。新的东西就是这个的 hdrShader 的片段着色器，用来渲染最终拥有浮点颜色缓冲纹理的 2D 四边形。我们来定义一个简单的直通片段着色器 (Pass-through Fragment Shader)：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>out vec4 color<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>in vec2 TexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>uniform sampler2D hdrBuffer<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#123;</span>             </pre></td></tr><tr><td data-num="9"></td><td><pre>    vec3 hdrColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>hdrBuffer<span class="token punctuation">,</span> TexCoords<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    color <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>hdrColor<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里我们直接采样了浮点颜色缓冲并将其作为片段着色器的输出。然而，这个 2D 四边形的输出是被直接渲染到默认的帧缓冲中，导致所有片段着色器的输出值被约束在 0.0 到 1.0 间，尽管我们已经有了一些存在浮点颜色纹理的值超过了 1.0。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/06/hdr_direct.png" alt="image"></p><p>很明显，在隧道尽头的强光的值被约束在 1.0，因为一大块区域都是白色的，过程中超过 1.0 的地方损失了所有细节。因为我们直接转换 HDR 值到 LDR 值，这就像我们根本就没有应用 HDR 一样。为了修复这个问题我们需要做的是无损转化所有浮点颜色值回 0.0-1.0 范围中。我们需要应用到色调映射。</p><h3 id="色调映射"><a class="anchor" href="#色调映射">#</a> 色调映射</h3><p>色调映射 (Tone Mapping) 是一个损失很小的转换浮点颜色值至我们所需的 LDR [0.0, 1.0] 范围内的过程，通常会伴有特定的风格的色平衡 (Stylistic Color Balance)。</p><p>最简单的色调映射算法是 Reinhard 色调映射，它涉及到分散整个 HDR 颜色值到 LDR 颜色值上，所有的值都有对应。Reinhard 色调映射算法平均得将所有亮度值分散到 LDR 上。我们将 Reinhard 色调映射应用到之前的片段着色器上，并且为了更好的测量加上一个 Gamma 校正过滤 (包括 SRGB 纹理的使用)：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span>             </pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">const</span> <span class="token keyword">float</span> gamma <span class="token operator">=</span> <span class="token number">2.2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    vec3 hdrColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>hdrBuffer<span class="token punctuation">,</span> TexCoords<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// Reinhard 色调映射</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    vec3 mapped <span class="token operator">=</span> hdrColor <span class="token operator">/</span> <span class="token punctuation">(</span>hdrColor <span class="token operator">+</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// Gamma 校正</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    mapped <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span>mapped<span class="token punctuation">,</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">/</span> gamma<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    color <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>mapped<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>有了 Reinhard 色调映射的应用，我们不再会在场景明亮的地方损失细节。当然，这个算法是倾向明亮的区域的，暗的区域会不那么精细也不那么有区分度。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/06/hdr_reinhard.png" alt="image"></p><p>现在你可以看到在隧道的尽头木头纹理变得可见了。用了这个非常简单地色调映射算法，我们可以合适的看到存在浮点帧缓冲中整个范围的 HDR 值，给我们对于无损场景光照精确的控制。</p><p>另一个有趣的色调映射应用是曝光 (Exposure) 参数的使用。你可能还记得之前我们在介绍里讲到的，HDR 图片包含在不同曝光等级的细节。如果我们有一个场景要展现日夜交替，我们当然会在白天使用低曝光，在夜间使用高曝光，就像人眼调节方式一样。有了这个曝光参数，我们可以去设置可以同时在白天和夜晚不同光照条件工作的光照参数，我们只需要调整曝光参数就行了。</p><p>一个简单的曝光色调映射算法会像这样：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>uniform <span class="token keyword">float</span> exposure<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span>             </pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">const</span> <span class="token keyword">float</span> gamma <span class="token operator">=</span> <span class="token number">2.2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    vec3 hdrColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>hdrBuffer<span class="token punctuation">,</span> TexCoords<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// 曝光色调映射</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    vec3 mapped <span class="token operator">=</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">exp</span><span class="token punctuation">(</span><span class="token operator">-</span>hdrColor <span class="token operator">*</span> exposure<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// Gamma 校正 </span></pre></td></tr><tr><td data-num="11"></td><td><pre>    mapped <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span>mapped<span class="token punctuation">,</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">/</span> gamma<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>    color <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>mapped<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在这里我们将 exposure 定义为默认为 1.0 的 uniform，从而允许我们更加精确设定我们是要注重黑暗还是明亮的区域的 HDR 颜色值。举例来说，高曝光值会使隧道的黑暗部分显示更多的细节，然而低曝光值会显著减少黑暗区域的细节，但允许我们看到更多明亮区域的细节。下面这组图片展示了在不同曝光值下的通道：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/06/hdr_exposure.png" alt="image"></p><p>这个图片清晰地展示了 HDR 渲染的优点。通过改变曝光等级，我们可以看见场景的很多细节，而这些细节可能在 LDR 渲染中都被丢失了。比如说隧道尽头，在正常曝光下木头结构隐约可见，但用低曝光木头的花纹就可以清晰看见了。对于近处的木头花纹来说，在高曝光下会能更好的看见。</p><h3 id="hdr拓展"><a class="anchor" href="#hdr拓展">#</a> HDR 拓展</h3><p>在这里展示的两个色调映射算法仅仅是大量 (更先进) 的色调映射算法中的一小部分，这些算法各有长短。一些色调映射算法倾向于特定的某种颜色 / 强度，也有一些算法同时显示低于高曝光颜色从而能够显示更加多彩和精细的图像。也有一些技巧被称作自动曝光调整 (Automatic Exposure Adjustment) 或者叫人眼适应 (Eye Adaptation) 技术，它能够检测前一帧场景的亮度并且缓慢调整曝光参数模仿人眼使得场景在黑暗区域逐渐变亮或者在明亮区域逐渐变暗，</p><p>HDR 渲染的真正优点在庞大和复杂的场景中应用复杂光照算法会被显示出来，但是出于教学目的创建这样复杂的演示场景是很困难的，这个教程用的场景是很小的，而且缺乏细节。但是如此简单的演示也是能够显示出 HDR 渲染的一些优点：在明亮和黑暗区域无细节损失，因为它们可以由色调映射重新获取；多个光照的叠加不会导致亮度被约束的区域；光照可以被设定为他们原来的亮度而不是被 LDR 值限定。而且，HDR 渲染也使一些有趣的效果更加可行和真实；其中一个效果叫做泛光 (Bloom)，我们将在下一节讨论他。</p><h3 id="附加资源-6"><a class="anchor" href="#附加资源-6">#</a> 附加资源</h3><ul><li><span class="exturl" data-url="aHR0cDovL2dhbWVkZXYuc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzYyODM2L2RvZXMtaGRyLXJlbmRlcmluZy1oYXZlLWFueS1iZW5lZml0cy1pZi1ibG9vbS13b250LWJlLWFwcGxpZWQ=">如果泛光效果不被应用 HDR 渲染还有好处吗？</span>: 一个 StackExchange 问题，其中有一个答案非常详细地解释 HDR 渲染的好处。</li><li><span class="exturl" data-url="aHR0cDovL3Bob3RvLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy83NjMwL3doYXQtaXMtdG9uZS1tYXBwaW5nLWhvdy1kb2VzLWl0LXJlbGF0ZS10by1oZHI=">什么是色调映射？它与 HDR 有什么联系？</span>: 另一个非常有趣的答案，用了大量图片解释色调映射。</li></ul><h2 id="泛光"><a class="anchor" href="#泛光">#</a> 泛光</h2><p>明亮的光源和区域经常很难向观察者表达出来，因为监视器的亮度范围是有限的。一种区分明亮光源的方式是使它们在监视器上发出光芒，光源的的光芒向四周发散。这样观察者就会产生光源或亮区的确是强光区。（译注：这个问题的提出简单来说是为了解决这样的问题：例如有一张在阳光下的白纸，白纸在监视器上显示出是出白色，而前方的太阳也是纯白色的，所以基本上白纸和太阳就是一样的了，给太阳加一个光晕，这样太阳看起来似乎就比白纸更亮了）</p><p><mark>光晕效果</mark>可以使用一个后处理特效泛光来实现。泛光使所有明亮区域产生光晕效果。下面是一个使用了和没有使用光晕的对比（图片生成自虚幻引擎）：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/07/bloom_example.png" alt="image"></p><p>Bloom 是我们能够注意到一个明亮的物体真的有种明亮的感觉。泛光可以极大提升场景中的光照效果，并提供了极大的效果提升，尽管做到这一切只需一点改变。</p><p>Bloom 和 HDR 结合使用效果很好。常见的一个误解是 HDR 和泛光是一样的，很多人认为两种技术是可以互换的。但是它们是两种不同的技术，用于各自不同的目的上。可以使用默认的 8 位精确度的帧缓冲，也可以在不使用泛光效果的时候，使用 HDR。只不过在有了 HDR 之后再实现泛光就更简单了。</p><p>为实现泛光，我们像平时那样渲染一个有光场景，提取出场景的 HDR 颜色缓冲以及只有这个场景明亮区域可见的图片。被提取的带有亮度的图片接着被模糊，结果被添加到 HDR 场景上面。</p><p>我们来一步一步解释这个处理过程。我们在场景中渲染一个带有 4 个立方体形式不同颜色的明亮的光源。带有颜色的发光立方体的亮度在 1.5 到 15.0 之间。如果我们将其渲染至 HDR 颜色缓冲，场景看起来会是这样的：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/07/bloom_scene.png" alt="image"></p><p>我们得到这个 HDR 颜色缓冲纹理，提取所有超出一定亮度的 fragment。这样我们就会获得一个只有 fragment 超过了一定阈限的颜色区域：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/07/bloom_extracted.png" alt="image"></p><p>我们将这个超过一定亮度阈限的纹理进行模糊。泛光效果的强度很大程度上被模糊过滤器的范围和强度所决定。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/07/bloom_blurred.png" alt="image"></p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/07/bloom_blurred.png" alt="image"></p><p>最终的被模糊化的纹理就是我们用来获得发出光晕效果的东西。这个已模糊的纹理要添加到原来的 HDR 场景纹理的上部。因为模糊过滤器的应用明亮区域发出光晕，所以明亮区域在长和宽上都有所扩展。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/07/bloom_small.png" alt="image"></p><p>泛光本身并不是个复杂的技术，但很难获得正确的效果。它的品质很大程度上取决于所用的模糊过滤器的质量和类型。简单的改改模糊过滤器就会极大的改变泛光效果的品质。</p><p>下面这几步就是泛光后处理特效的过程，它总结了实现泛光所需的步骤。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/07/bloom_steps.png" alt="image"></p><p>首先我们需要根据一定的阈限提取所有明亮的颜色。我们先来做这件事。</p><h3 id="提取亮色"><a class="anchor" href="#提取亮色">#</a> 提取亮色</h3><p>第一步我们要从渲染出来的场景中提取两张图片。我们可以渲染场景两次，每次使用一个不同的不同的着色器渲染到不同的帧缓冲中，但我们可以使用一个叫做<mark> MRT</mark>（Multiple Render Targets 多渲染目标）的小技巧，这样我们就能定义多个像素着色器了；有了它我们还能够在一个单独渲染处理中提取头两个图片。在像素着色器的输出前，我们指定一个布局 location 标识符，这样我们便可控制一个像素着色器写入到哪个颜色缓冲：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> out vec4 FragColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> out vec4 BrightColor<span class="token punctuation">;</span></pre></td></tr></table></figure><p>只有我们真的具有多个地方可写的时候这才能工作。使用多个像素着色器输出的必要条件是，有多个颜色缓冲附加到了当前绑定的帧缓冲对象上。你可能从帧缓冲教程那里回忆起，当把一个纹理链接到帧缓冲的颜色缓冲上时，我们可以指定一个颜色附件。直到现在，我们一直使用着 GL_COLOR_ATTACHMENT0，但通过使用 GL_COLOR_ATTACHMENT1，我们可以得到一个附加了两个颜色缓冲的帧缓冲对象：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// Set up floating point framebuffer to render scene to</span></pre></td></tr><tr><td data-num="2"></td><td><pre>GLuint hdrFBO<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glGenFramebuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>hdrFBO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> hdrFBO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>GLuint colorBuffers<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">glGenTextures</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> colorBuffers<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span>GLuint i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> colorBuffers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token function">glTexImage2D</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RGB16F<span class="token punctuation">,</span> SCR_WIDTH<span class="token punctuation">,</span> SCR_HEIGHT<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RGB<span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> <span class="token constant">NULL</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_MIN_FILTER<span class="token punctuation">,</span> GL_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_MAG_FILTER<span class="token punctuation">,</span> GL_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_WRAP_S<span class="token punctuation">,</span> GL_CLAMP_TO_EDGE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_WRAP_T<span class="token punctuation">,</span> GL_CLAMP_TO_EDGE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token comment">// attach texture to framebuffer</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token function">glFramebufferTexture2D</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        GL_FRAMEBUFFER<span class="token punctuation">,</span> GL_COLOR_ATTACHMENT0 <span class="token operator">+</span> i<span class="token punctuation">,</span> GL_TEXTURE_2D<span class="token punctuation">,</span> colorBuffers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>我们需要显式告知 OpenGL 我们正在通过 glDrawBuffers 渲染到多个颜色缓冲，否则 OpenGL 只会渲染到帧缓冲的第一个颜色附件，而忽略所有其他的。我们可以通过传递多个颜色附件的枚举来做这件事，我们以下面的操作进行渲染：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>GLuint attachments<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> GL_COLOR_ATTACHMENT0<span class="token punctuation">,</span> GL_COLOR_ATTACHMENT1 <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glDrawBuffers</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> attachments<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>当渲染到这个帧缓冲中的时候，一个着色器使用一个布局 location 修饰符，那么 fragment 就会用相应的颜色缓冲就会被用来渲染。这很棒，因为这样省去了我们为提取明亮区域的额外渲染步骤，因为我们现在可以直接从将被渲染的 fragment 提取出它们：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> out vec4 FragColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> out vec4 BrightColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#123;</span>            </pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token comment">// first do normal lighting calculations and output results</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>lighting<span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">// Check whether fragment output is higher than threshold, if so output as brightness color</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">float</span> brightness <span class="token operator">=</span> <span class="token function">dot</span><span class="token punctuation">(</span>FragColor<span class="token punctuation">.</span>rgb<span class="token punctuation">,</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.2126</span><span class="token punctuation">,</span> <span class="token number">0.7152</span><span class="token punctuation">,</span> <span class="token number">0.0722</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>brightness <span class="token operator">></span> <span class="token number">1.0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        BrightColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>FragColor<span class="token punctuation">.</span>rgb<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里我们先正常计算光照，将其传递给第一个像素着色器的输出变量 FragColor。然后我们使用当前储存在 FragColor 的东西来决定它的亮度是否超过了一定阈限。我们通过恰当地将其转为灰度的方式计算一个 fragment 的亮度，如果它超过了一定阈限，我们就把颜色输出到第二个颜色缓冲，那里保存着所有亮部；渲染发光的立方体也是一样的。</p><p>这也说明了为什么泛光在 HDR 基础上能够运行得很好。因为 HDR 中，我们可以将颜色值指定超过 1.0 这个默认的范围，我们能够得到对一个图像中的亮度的更好的控制权。没有 HDR 我们必须将阈限设置为小于 1.0 的数，虽然可行，但是亮部很容易变得很多，这就导致光晕效果过重。</p><p>有了两个颜色缓冲，我们就有了一个正常场景的图像和一个提取出的亮区的图像；这些都在一个渲染步骤中完成。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/07/bloom_attachments.png" alt="image"></p><p>有了一个提取出的亮区图像，我们现在就要把这个图像进行模糊处理。我们可以使用帧缓冲教程后处理部分的那个简单的盒子过滤器，但不过我们最好还是使用一个更高级的更漂亮的模糊过滤器：<mark>高斯模糊</mark> (Gaussian blur)。</p><h3 id="高斯模糊"><a class="anchor" href="#高斯模糊">#</a> 高斯模糊</h3><p>在后处理教程那里，我们采用的模糊是一个图像中所有周围像素的均值，它的确为我们提供了一个简易实现的模糊，但是效果并不好。高斯模糊基于高斯曲线，高斯曲线通常被描述为一个钟形曲线，中间的值达到最大化，随着距离的增加，两边的值不断减少。高斯曲线在数学上有不同的形式，但是通常是这样的形状：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/07/bloom_gaussian.png" alt="image"></p><p>高斯曲线在它的中间处的面积最大，使用它的值作为权重使得近处的样本拥有最大的优先权。比如，如果我们从 fragment 的 32×32 的四方形区域采样，这个权重随着和 fragment 的距离变大逐渐减小；通常这会得到更好更真实的模糊效果，这种模糊叫做高斯模糊。</p><p>要实现高斯模糊过滤我们需要一个二维四方形作为权重，从这个二维高斯曲线方程中去获取它。然而这个过程有个问题，就是很快会消耗极大的性能。以一个 32×32 的模糊 kernel 为例，我们必须对每个 fragment 从一个纹理中采样 1024 次！</p><p>幸运的是，高斯方程有个非常巧妙的特性，它允许我们把二维方程分解为两个更小的方程：一个描述水平权重，另一个描述垂直权重。我们首先用水平权重在整个纹理上进行水平模糊，然后在经改变的纹理上进行垂直模糊。利用这个特性，结果是一样的，但是可以节省难以置信的性能，因为我们现在只需做 32+32 次采样，不再是 1024 了！这叫做两步高斯模糊。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/07/bloom_gaussian_two_pass.png" alt="image"></p><p>这意味着我们如果对一个图像进行模糊处理，至少需要两步，最好使用帧缓冲对象做这件事。具体来说，我们将实现像乒乓球一样的帧缓冲来实现高斯模糊。它的意思是，有一对儿帧缓冲，我们把另一个帧缓冲的颜色缓冲放进当前的帧缓冲的颜色缓冲中，使用不同的着色效果渲染指定的次数。基本上就是不断地切换帧缓冲和纹理去绘制。这样我们先在场景纹理的第一个缓冲中进行模糊，然后在把第一个帧缓冲的颜色缓冲放进第二个帧缓冲进行模糊，接着，将第二个帧缓冲的颜色缓冲放进第一个，循环往复。</p><p>在我们研究帧缓冲之前，先讨论高斯模糊的像素着色器：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>out vec4 FragColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>in vec2 TexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>uniform sampler2D image<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>uniform <span class="token keyword">bool</span> horizontal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>uniform <span class="token keyword">float</span> weight<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">float</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token number">0.227027</span><span class="token punctuation">,</span> <span class="token number">0.1945946</span><span class="token punctuation">,</span> <span class="token number">0.1216216</span><span class="token punctuation">,</span> <span class="token number">0.054054</span><span class="token punctuation">,</span> <span class="token number">0.016216</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#123;</span>             </pre></td></tr><tr><td data-num="13"></td><td><pre>    vec2 tex_offset <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token function">textureSize</span><span class="token punctuation">(</span>image<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// gets size of single texel</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    vec3 result <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>image<span class="token punctuation">,</span> TexCoords<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb <span class="token operator">*</span> weight<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// current fragment's contribution</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>horizontal<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            result <span class="token operator">+=</span> <span class="token function">texture</span><span class="token punctuation">(</span>image<span class="token punctuation">,</span> TexCoords <span class="token operator">+</span> <span class="token function">vec2</span><span class="token punctuation">(</span>tex_offset<span class="token punctuation">.</span>x <span class="token operator">*</span> i<span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rgb <span class="token operator">*</span> weight<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            result <span class="token operator">+=</span> <span class="token function">texture</span><span class="token punctuation">(</span>image<span class="token punctuation">,</span> TexCoords <span class="token operator">-</span> <span class="token function">vec2</span><span class="token punctuation">(</span>tex_offset<span class="token punctuation">.</span>x <span class="token operator">*</span> i<span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rgb <span class="token operator">*</span> weight<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token keyword">else</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            result <span class="token operator">+=</span> <span class="token function">texture</span><span class="token punctuation">(</span>image<span class="token punctuation">,</span> TexCoords <span class="token operator">+</span> <span class="token function">vec2</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> tex_offset<span class="token punctuation">.</span>y <span class="token operator">*</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rgb <span class="token operator">*</span> weight<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            result <span class="token operator">+=</span> <span class="token function">texture</span><span class="token punctuation">(</span>image<span class="token punctuation">,</span> TexCoords <span class="token operator">-</span> <span class="token function">vec2</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> tex_offset<span class="token punctuation">.</span>y <span class="token operator">*</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rgb <span class="token operator">*</span> weight<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里我们使用一个比较小的高斯权重做例子，每次我们用它来指定当前 fragment 的水平或垂直样本的特定权重。你会发现我们基本上是将模糊过滤器根据我们在 uniform 变量 horizontal 设置的值分割为一个水平和一个垂直部分。通过用 1.0 除以纹理的大小（从 textureSize 得到一个 vec2）得到一个纹理像素的实际大小，以此作为偏移距离的根据。</p><p>我们为图像的模糊处理创建两个基本的帧缓冲，每个只有一个颜色缓冲纹理：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>GLuint pingpongFBO<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>GLuint pingpongBuffer<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glGenFramebuffers</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> pingpongFBO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glGenTextures</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> pingpongBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span>GLuint i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> pingpongFBO<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> pingpongBuffer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">glTexImage2D</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RGB16F<span class="token punctuation">,</span> SCR_WIDTH<span class="token punctuation">,</span> SCR_HEIGHT<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RGB<span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> <span class="token constant">NULL</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_MIN_FILTER<span class="token punctuation">,</span> GL_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_MAG_FILTER<span class="token punctuation">,</span> GL_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_WRAP_S<span class="token punctuation">,</span> GL_CLAMP_TO_EDGE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_WRAP_T<span class="token punctuation">,</span> GL_CLAMP_TO_EDGE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token function">glFramebufferTexture2D</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        GL_FRAMEBUFFER<span class="token punctuation">,</span> GL_COLOR_ATTACHMENT0<span class="token punctuation">,</span> GL_TEXTURE_2D<span class="token punctuation">,</span> pingpongBuffer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>得到一个 HDR 纹理后，我们用提取出来的亮区纹理填充一个帧缓冲，然后对其模糊处理 10 次（5 次垂直 5 次水平）：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>GLboolean horizontal <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span> first_iteration <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>GLuint amount <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>shaderBlur<span class="token punctuation">.</span><span class="token function">Use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span>GLuint i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> amount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> pingpongFBO<span class="token punctuation">[</span>horizontal<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">glUniform1i</span><span class="token punctuation">(</span><span class="token function">glGetUniformLocation</span><span class="token punctuation">(</span>shaderBlur<span class="token punctuation">.</span>Program<span class="token punctuation">,</span> <span class="token string">"horizontal"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> horizontal<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">glBindTexture</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        GL_TEXTURE_2D<span class="token punctuation">,</span> first_iteration <span class="token operator">?</span> colorBuffers<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">:</span> pingpongBuffers<span class="token punctuation">[</span><span class="token operator">!</span>horizontal<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token function">RenderQuad</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    horizontal <span class="token operator">=</span> <span class="token operator">!</span>horizontal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>first_iteration<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        first_iteration <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>每次循环我们根据我们打算渲染的是水平还是垂直来绑定两个缓冲其中之一，而将另一个绑定为纹理进行模糊。第一次迭代，因为两个颜色缓冲都是空的所以我们随意绑定一个去进行模糊处理。重复这个步骤 10 次，亮区图像就进行一个重复 5 次的高斯模糊了。这样我们可以对任意图像进行任意次模糊处理；高斯模糊循环次数越多，模糊的强度越大。</p><p>通过对提取亮区纹理进行 5 次模糊，我们就得到了一个正确的模糊的场景亮区图像。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/07/bloom_blurred_large.png" alt="image"></p><p>泛光的最后一步是把模糊处理的图像和场景原来的 HDR 纹理进行结合。</p><h3 id="把两个纹理混合"><a class="anchor" href="#把两个纹理混合">#</a> 把两个纹理混合</h3><p>有了场景的 HDR 纹理和模糊处理的亮区纹理，我们只需把它们结合起来就能实现泛光或称光晕效果了。最终的像素着色器（大部分和 HDR 教程用的差不多）要把两个纹理混合：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>out vec4 FragColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>in vec2 TexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>uniform sampler2D scene<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>uniform sampler2D bloomBlur<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>uniform <span class="token keyword">float</span> exposure<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span>             </pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">const</span> <span class="token keyword">float</span> gamma <span class="token operator">=</span> <span class="token number">2.2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    vec3 hdrColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>scene<span class="token punctuation">,</span> TexCoords<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb<span class="token punctuation">;</span>      </pre></td></tr><tr><td data-num="13"></td><td><pre>    vec3 bloomColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>bloomBlur<span class="token punctuation">,</span> TexCoords<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    hdrColor <span class="token operator">+=</span> bloomColor<span class="token punctuation">;</span> <span class="token comment">// additive blending</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">// tone mapping</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    vec3 result <span class="token operator">=</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">exp</span><span class="token punctuation">(</span><span class="token operator">-</span>hdrColor <span class="token operator">*</span> exposure<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token comment">// also gamma correct while we're at it       </span></pre></td></tr><tr><td data-num="18"></td><td><pre>    result <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">/</span> gamma<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>要注意的是我们要在<mark>应用色调映射</mark><strong>之前</strong><mark>添加泛光</mark>效果。这样添加的亮区的泛光，也会柔和转换为 LDR，光照效果相对会更好。</p><p>把两个纹理结合以后，场景亮区便有了合适的光晕特效：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/05/07/bloom.png" alt="image"></p><p>有颜色的立方体看起来仿佛更亮，它向外发射光芒，的确是一个更好的视觉效果。这个场景比较简单，所以泛光效果不算十分令人瞩目，但在更好的场景中合理配置之后效果会有巨大的不同。</p><p>这个教程我们只是用了一个相对简单的高斯模糊过滤器，它在每个方向上只有 5 个样本。通过沿着更大的半径或重复更多次数的模糊，进行采样我们就可以提升模糊的效果。因为模糊的质量与泛光效果的质量正相关，提升模糊效果就能够提升泛光效果。有些提升将模糊过滤器与不同大小的模糊 kernel 或采用多个高斯曲线来选择性地结合权重结合起来使用。来自 Kalogirou 和 EpicGames 的附加资源讨论了如何通过提升高斯模糊来显著提升泛光效果。</p><h3 id="附加资源-7"><a class="anchor" href="#附加资源-7">#</a> 附加资源</h3><ul><li><span class="exturl" data-url="aHR0cDovL3Jhc3RlcmdyaWQuY29tL2Jsb2cvMjAxMC8wOS9lZmZpY2llbnQtZ2F1c3NpYW4tYmx1ci13aXRoLWxpbmVhci1zYW1wbGluZy8=">Efficient Gaussian Blur with linear sampling</span>：非常详细地描述了高斯模糊，以及如何使用 OpenGL 的双线性纹理采样提升性能。</li><li><span class="exturl" data-url="aHR0cHM6Ly91ZG4uZXBpY2dhbWVzLmNvbS9UaHJlZS9CbG9vbS5odG1s">Bloom Post Process Effect</span>：来自 Epic Games 关于通过对权重的多个高斯曲线结合来提升泛光效果的文章。</li><li><span class="exturl" data-url="aHR0cDovL2thbG9naXJvdS5uZXQvMjAwNi8wNS8yMC9ob3ctdG8tZG8tZ29vZC1ibG9vbS1mb3ItaGRyLXJlbmRlcmluZy8=">How to do good bloom for HDR rendering</span>：Kalogirou 的文章描述了如何使用更好的高斯模糊算法来提升泛光效果。</li></ul></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2020-10-26 10:33:45" itemprop="dateModified" datetime="2020-10-26T10:33:45+08:00">2020-10-26</time> </span><span id="computer-science/study/opengl/5-OpenGL-Heigh-Light/" class="item leancloud_visitors" data-flag-title="五、高级光照" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 充电</button><p>请我[恰饭]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="鑫酱(●'◡'●) 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="鑫酱(●'◡'●) 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>鑫酱(●'◡'●) <i class="ic i-at"><em>@</em></i>鑫酱</li><li class="link"><strong>本文链接：</strong> <a href="https://allengx.gitee.io/computer-science/study/opengl/5-OpenGL-Heigh-Light/" title="五、高级光照">https://allengx.gitee.io/computer-science/study/opengl/5-OpenGL-Heigh-Light/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/computer-science/study/opengl/4-OpenGL-High-Level/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicitcxhpij20zk0m8hdt.jpg" title="四、高级OpenGL"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> OpenGL</span><h3>四、高级OpenGL</h3></a></div><div class="item right"><a href="/computer-science/study/opengl/1-OpenGL-Introduction/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclhfehz7j20zk0m8u0x.jpg" title="一、OpenGL入门"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> OpenGL</span><h3>一、OpenGL入门</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E5%85%89%E7%85%A7"><span class="toc-number">1.</span> <span class="toc-text">高级光照</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#blinn-phong"><span class="toc-number">1.1.</span> <span class="toc-text">Blinn-Phong</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gamma%E6%A0%A1%E6%AD%A3"><span class="toc-number">2.</span> <span class="toc-text">Gamma 校正</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gamma%E6%A0%A1%E6%AD%A3-2"><span class="toc-number">2.1.</span> <span class="toc-text">Gamma 校正</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#srgb%E7%BA%B9%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">sRGB 纹理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%B0%E5%87%8F"><span class="toc-number">2.3.</span> <span class="toc-text">衰减</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84%E5%8A%A0%E8%B5%84%E6%BA%90"><span class="toc-number">2.4.</span> <span class="toc-text">附加资源</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shadow-mapping"><span class="toc-number">3.</span> <span class="toc-text">Shadow Mapping</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE"><span class="toc-number">3.1.</span> <span class="toc-text">阴影贴图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E8%B4%B4%E5%9B%BE"><span class="toc-number">3.2.</span> <span class="toc-text">深度贴图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%89%E6%BA%90%E7%A9%BA%E9%97%B4%E7%9A%84%E5%8F%98%E6%8D%A2"><span class="toc-number">3.3.</span> <span class="toc-text">光源空间的变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E8%87%B3%E6%B7%B1%E5%BA%A6%E8%B4%B4%E5%9B%BE"><span class="toc-number">3.4.</span> <span class="toc-text">渲染至深度贴图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E9%98%B4%E5%BD%B1"><span class="toc-number">3.5.</span> <span class="toc-text">渲染阴影</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE"><span class="toc-number">3.6.</span> <span class="toc-text">改进阴影贴图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B4%E5%BD%B1%E5%A4%B1%E7%9C%9F"><span class="toc-number">3.7.</span> <span class="toc-text">阴影失真</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%AC%E6%B5%AE"><span class="toc-number">3.8.</span> <span class="toc-text">悬浮</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%87%E6%A0%B7%E8%BF%87%E5%A4%9A"><span class="toc-number">3.9.</span> <span class="toc-text">采样过多</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pcf"><span class="toc-number">3.10.</span> <span class="toc-text">PCF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E4%BA%A4-vs-%E6%8A%95%E5%BD%B1"><span class="toc-number">3.11.</span> <span class="toc-text">正交 vs 投影</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84%E5%8A%A0%E8%B5%84%E6%BA%90-2"><span class="toc-number">3.12.</span> <span class="toc-text">附加资源</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%82%B9%E5%85%89%E6%BA%90%E9%98%B4%E5%BD%B1"><span class="toc-number">4.</span> <span class="toc-text">点光源阴影</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%B7%B1%E5%BA%A6%E7%AB%8B%E6%96%B9%E4%BD%93%E8%B4%B4%E5%9B%BE"><span class="toc-number">4.1.</span> <span class="toc-text">生成深度立方体贴图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%89%E7%A9%BA%E9%97%B4%E7%9A%84%E5%8F%98%E6%8D%A2"><span class="toc-number">4.2.</span> <span class="toc-text">光空间的变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text">深度着色器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%87%E5%90%91%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE"><span class="toc-number">4.4.</span> <span class="toc-text">万向阴影贴图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E7%AB%8B%E6%96%B9%E4%BD%93%E8%B4%B4%E5%9B%BE%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2"><span class="toc-number">4.5.</span> <span class="toc-text">显示立方体贴图深度缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pcf-2"><span class="toc-number">4.6.</span> <span class="toc-text">PCF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84%E5%8A%A0%E8%B5%84%E6%BA%90-3"><span class="toc-number">4.7.</span> <span class="toc-text">附加资源</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE"><span class="toc-number">5.</span> <span class="toc-text">法线贴图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE-2"><span class="toc-number">5.1.</span> <span class="toc-text">法线贴图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%BA%BF%E7%A9%BA%E9%97%B4"><span class="toc-number">5.2.</span> <span class="toc-text">切线空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%B7%A5%E8%AE%A1%E7%AE%97%E5%88%87%E7%BA%BF%E5%92%8C%E5%89%AF%E5%88%87%E7%BA%BF"><span class="toc-number">5.3.</span> <span class="toc-text">手工计算切线和副切线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%BA%BF%E7%A9%BA%E9%97%B4%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE"><span class="toc-number">5.4.</span> <span class="toc-text">切线空间法线贴图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E7%89%A9%E4%BD%93"><span class="toc-number">5.5.</span> <span class="toc-text">复杂物体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E4%B8%80%E4%BB%B6%E4%BA%8B"><span class="toc-number">5.6.</span> <span class="toc-text">最后一件事</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84%E5%8A%A0%E8%B5%84%E6%BA%90-4"><span class="toc-number">5.7.</span> <span class="toc-text">附加资源</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE"><span class="toc-number">6.</span> <span class="toc-text">视差贴图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE-2"><span class="toc-number">6.1.</span> <span class="toc-text">视差贴图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%A1%E5%B3%AD%E8%A7%86%E5%B7%AE%E6%98%A0%E5%B0%84"><span class="toc-number">6.2.</span> <span class="toc-text">陡峭视差映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%B7%AE%E9%81%AE%E8%94%BD%E6%98%A0%E5%B0%84"><span class="toc-number">6.3.</span> <span class="toc-text">视差遮蔽映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84%E5%8A%A0%E8%B5%84%E6%BA%90-5"><span class="toc-number">6.4.</span> <span class="toc-text">附加资源</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hdr"><span class="toc-number">7.</span> <span class="toc-text">HDR</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%B8%A7%E7%BC%93%E5%86%B2"><span class="toc-number">7.1.</span> <span class="toc-text">浮点帧缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%89%B2%E8%B0%83%E6%98%A0%E5%B0%84"><span class="toc-number">7.2.</span> <span class="toc-text">色调映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hdr%E6%8B%93%E5%B1%95"><span class="toc-number">7.3.</span> <span class="toc-text">HDR 拓展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84%E5%8A%A0%E8%B5%84%E6%BA%90-6"><span class="toc-number">7.4.</span> <span class="toc-text">附加资源</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%85%89"><span class="toc-number">8.</span> <span class="toc-text">泛光</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E5%8F%96%E4%BA%AE%E8%89%B2"><span class="toc-number">8.1.</span> <span class="toc-text">提取亮色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A"><span class="toc-number">8.2.</span> <span class="toc-text">高斯模糊</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%8A%E4%B8%A4%E4%B8%AA%E7%BA%B9%E7%90%86%E6%B7%B7%E5%90%88"><span class="toc-number">8.3.</span> <span class="toc-text">把两个纹理混合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84%E5%8A%A0%E8%B5%84%E6%BA%90-7"><span class="toc-number">8.4.</span> <span class="toc-text">附加资源</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/computer-science/study/opengl/2-OpenGL-Load-Model/" rel="bookmark" title="三、OpenGL模型加载">三、OpenGL模型加载</a></li><li><a href="/computer-science/study/opengl/3-OpenGL-Lighting/" rel="bookmark" title="二、OpenGL光照">二、OpenGL光照</a></li><li><a href="/computer-science/study/opengl/1-OpenGL-Introduction/" rel="bookmark" title="一、OpenGL入门">一、OpenGL入门</a></li><li class="active"><a href="/computer-science/study/opengl/5-OpenGL-Heigh-Light/" rel="bookmark" title="五、高级光照">五、高级光照</a></li><li><a href="/computer-science/study/opengl/4-OpenGL-High-Level/" rel="bookmark" title="四、高级OpenGL">四、高级OpenGL</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="鑫酱(●'◡'●)" data-src="/images/avatar.jpg"><p class="name" itemprop="name">鑫酱(●'◡'●)</p><div class="description" itemprop="description">整天摸鱼，却妄想拯救世界的技术宅</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">53</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">17</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">11</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FsbGVuR1g=" title="https:&#x2F;&#x2F;github.com&#x2F;AllenGX"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTgwNTM4MjQy" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;80538242"><i class="ic i-cloud-music"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjE0MTM5MDcxNTNAcXEuY29t" title="mailto:1413907153@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>好友</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>网址</a></li><li class="item"><a href="/travellings/" rel="section"><i class="ic i-paper-plane"></i>传送门</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/computer-science/study/opengl/4-OpenGL-High-Level/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/computer-science/study/opengl/1-OpenGL-Introduction/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/Python%E3%80%8C%E5%B7%A5%E5%8C%A0%E3%80%8D/" title="分类于 Python「工匠」">Python「工匠」</a></div><span><a href="/computer-science/study/Python%E3%80%8C%E5%B7%A5%E5%8C%A0%E3%80%8D/%E4%BA%94%E3%80%81%E8%AE%A9%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84%E6%8A%80%E5%B7%A7/" title="五、让函数返回结果的技巧">五、让函数返回结果的技巧</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/Python%E3%80%8C%E5%B7%A5%E5%8C%A0%E3%80%8D/" title="分类于 Python「工匠」">Python「工匠」</a></div><span><a href="/computer-science/study/Python%E3%80%8C%E5%B7%A5%E5%8C%A0%E3%80%8D/%E5%8D%81%E4%B8%80%E3%80%81%E9%AB%98%E6%95%88%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6/" title="十一、高效操作文件">十一、高效操作文件</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/Python%E3%80%8C%E5%B7%A5%E5%8C%A0%E3%80%8D/" title="分类于 Python「工匠」">Python「工匠」</a></div><span><a href="/computer-science/study/Python%E3%80%8C%E5%B7%A5%E5%8C%A0%E3%80%8D/%E5%8D%81%E4%B8%89%E3%80%81%E5%9C%A8%E8%BE%B9%E7%95%8C%E5%A4%84%E6%80%9D%E8%80%83/" title="十三、在边界处思考">十三、在边界处思考</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/python/" title="分类于 Python">Python</a></div><span><a href="/computer-science/study/python/Python2-Diff-Python3/" title="python2和python3差异">python2和python3差异</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/opengl/" title="分类于 OpenGL">OpenGL</a></div><span><a href="/computer-science/study/opengl/4-OpenGL-High-Level/" title="四、高级OpenGL">四、高级OpenGL</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%97%A5%E6%9C%AC%E8%AA%9E/" title="分类于 日语">日语</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%97%A5%E6%9C%AC%E8%AA%9E/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%97%A5%E6%9C%AC%E8%AA%9E/study/%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%81%AE%E6%96%87%E6%B3%95%E5%88%9D%E7%BA%A7%EF%BC%88%E4%B8%8A%EF%BC%89/" title="分类于 日语语法初级（上）">日语语法初级（上）</a></div><span><a href="/%E6%97%A5%E6%9C%AC%E8%AA%9E/study/%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%81%AE%E6%96%87%E6%B3%95%E5%88%9D%E7%BA%A7%EF%BC%88%E4%B8%8A%EF%BC%89/%E5%9B%9B%E3%80%81%E5%B0%8F%E6%9D%8E%E7%9A%84%E5%85%AC%E5%8F%B8%E7%94%9F%E6%B4%BB%E2%91%A1/" title="标准日本语初级-上">标准日本语初级-上</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%97%A5%E6%9C%AC%E8%AA%9E/" title="分类于 日语">日语</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%97%A5%E6%9C%AC%E8%AA%9E/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%97%A5%E6%9C%AC%E8%AA%9E/study/%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%81%AE%E6%96%87%E6%B3%95%E5%88%9D%E7%BA%A7%EF%BC%88%E4%B8%8A%EF%BC%89/" title="分类于 日语语法初级（上）">日语语法初级（上）</a></div><span><a href="/%E6%97%A5%E6%9C%AC%E8%AA%9E/study/%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%81%AE%E6%96%87%E6%B3%95%E5%88%9D%E7%BA%A7%EF%BC%88%E4%B8%8A%EF%BC%89/%E5%9F%BA%E6%9C%AC%E6%A0%87%E7%AD%BE/" title="基本标签">基本标签</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/Python%E3%80%8C%E5%B7%A5%E5%8C%A0%E3%80%8D/" title="分类于 Python「工匠」">Python「工匠」</a></div><span><a href="/computer-science/study/Python%E3%80%8C%E5%B7%A5%E5%8C%A0%E3%80%8D/%E4%B8%83%E3%80%81%E5%9C%B0%E9%81%93%E7%9A%84%E5%BE%AA%E7%8E%AF/" title="七、地道的循环">七、地道的循环</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/python/" title="分类于 Python">Python</a></div><span><a href="/computer-science/study/python/Python-watchdog/" title="基于 watchdog 实现自动化更新">基于 watchdog 实现自动化更新</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/python/" title="分类于 Python">Python</a></div><span><a href="/computer-science/study/python/Python-C-extension/" title="编写Python的C扩展">编写Python的C扩展</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">鑫酱(●'◡'●) @ 个人博客</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">434k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">6:34</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"computer-science/study/opengl/5-OpenGL-Heigh-Light/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>