<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="鑫酱" href="https://allengx.gitee.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="鑫酱" href="https://allengx.gitee.io/atom.xml"><link rel="alternate" type="application/json" title="鑫酱" href="https://allengx.gitee.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://allengx.gitee.io/computer-science/study/opengl/3-OpenGL-Lighting/"><title>二、OpenGL光照 - OpenGL - 学习笔记 - 计算机科学 | 个人博客 = 鑫酱 = 笔记本</title><meta name="generator" content="Hexo 5.1.1"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">二、OpenGL光照</h1><div class="meta"><span class="item" title="创建时间：2020-04-12 20:46:25"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2020-04-12T20:46:25+08:00">2020-04-12</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>34k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>31 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">个人博客</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclhtuo6nj20zk0m8ttm.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicitf0kl1j20zk0m87fe.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclfw2t96j20zk0m8x6p.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclg5ms2rj20zk0m8u0x.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicljitigmj20zk0m87fp.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclhfehz7j20zk0m8u0x.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/" itemprop="item" rel="index" title="分类于 计算机科学"><span itemprop="name">计算机科学</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/study/" itemprop="item" rel="index" title="分类于 学习笔记"><span itemprop="name">学习笔记</span></a><meta itemprop="position" content="2"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/study/opengl/" itemprop="item" rel="index" title="分类于 OpenGL"><span itemprop="name">OpenGL</span></a><meta itemprop="position" content="3"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://allengx.gitee.io/computer-science/study/opengl/3-OpenGL-Lighting/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="鑫酱(●'◡'●)"><meta itemprop="description" content="笔记本, 整天摸鱼，却妄想拯救世界的技术宅"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="鑫酱"></span><div class="body md" itemprop="articleBody"><div class="note info"><p>以下为个人学习笔记整理</p></div><h1 id="光照"><a class="anchor" href="#光照">#</a> 光照</h1><h2 id="颜色"><a class="anchor" href="#颜色">#</a> 颜色</h2><p>现实世界中有无数种颜色，每一个物体都有它们自己的颜色。我们需要使用（有限的）数值来模拟真实世界中（无限）的颜色，所以并不是所有现实世界中的颜色都可以用数值来表示的。然而我们仍能通过数值来表现出非常多的颜色，甚至你可能都不会注意到与现实的颜色有任何的差异。颜色可以数字化的由红色 (Red)、绿色 (Green) 和蓝色 (Blue) 三个分量组成，它们通常被缩写为 RGB。仅仅用这三个值就可以组合出任意一种颜色。例如，要获取一个珊瑚红 (Coral) 色的话，我们可以定义这样的一个颜色向量：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span>vec3 <span class="token function">coral</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.31f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>我们在现实生活中看到某一物体的颜色并不是这个物体真正拥有的颜色，而是它所反射的 (Reflected) 颜色。换句话说，那些不能被物体所吸收 (Absorb) 的颜色（被拒绝的颜色）就是我们能够感知到的物体的颜色。例如，太阳光能被看见的白光其实是由许多不同的颜色组合而成的（如下图所示）。如果我们将白光照在一个蓝色的玩具上，这个蓝色的玩具会吸收白光中除了蓝色以外的所有子颜色，不被吸收的蓝色光被反射到我们的眼中，让这个玩具看起来是蓝色的。下图显示的是一个珊瑚红的玩具，它以不同强度反射了多个颜色。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/02/01/light_reflection.png" alt="image"></p><p>你可以看到，白色的阳光实际上是所有可见颜色的集合，物体吸收了其中的大部分颜色。它仅反射了代表物体颜色的部分，被反射颜色的组合就是我们所感知到的颜色（此例中为珊瑚红）。</p><p>这些颜色反射的定律被直接地运用在图形领域。当我们在 OpenGL 中创建一个光源时，我们希望给光源一个颜色。在上一段中我们有一个白色的太阳，所以我们也将光源设置为白色。<mark>当我们把光源的颜色与物体的颜色值相乘，所得到的就是这个物体所反射的颜色</mark>（也就是我们所感知到的颜色）。让我们再次审视我们的玩具（这一次它还是珊瑚红），看看如何在图形学中计算出它的反射颜色。我们将这两个颜色向量作分量相乘，结果就是最终的颜色向量了：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span>vec3 <span class="token function">lightColor</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>glm<span class="token operator">::</span>vec3 <span class="token function">toyColor</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.31f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>glm<span class="token operator">::</span>vec3 result <span class="token operator">=</span> lightColor <span class="token operator">*</span> toyColor<span class="token punctuation">;</span> <span class="token comment">// = (1.0f, 0.5f, 0.31f);</span></pre></td></tr></table></figure><p>我们可以看到玩具的颜色吸收了白色光源中很大一部分的颜色，但它根据自身的颜色值对红、绿、蓝三个分量都做出了一定的反射。这也表现了现实中颜色的工作原理。由此，我们可以定义物体的颜色为物体从一个光源反射各个颜色分量的大小。现在，如果我们使用<mark>绿色的光源</mark>又会发生什么呢？</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span>vec3 <span class="token function">lightColor</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>glm<span class="token operator">::</span>vec3 <span class="token function">toyColor</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.31f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>glm<span class="token operator">::</span>vec3 result <span class="token operator">=</span> lightColor <span class="token operator">*</span> toyColor<span class="token punctuation">;</span> <span class="token comment">// = (0.0f, 0.5f, 0.0f);</span></pre></td></tr></table></figure><p>可以看到，并没有红色和蓝色的光让我们的玩具来吸收或反射。这个玩具吸收了光线中一半的绿色值，但仍然也反射了一半的绿色值。玩具现在看上去是深绿色 (Dark-greenish) 的。我们可以看到，如果我们用绿色光源来照射玩具，那么只有绿色分量能被反射和感知到，红色和蓝色都不能被我们所感知到。这样做的结果是，一个珊瑚红的玩具突然变成了深绿色物体。现在我们来看另一个例子，使用<mark>深橄榄绿色 (Dark olive-green) 的光源</mark>：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span>vec3 <span class="token function">lightColor</span><span class="token punctuation">(</span><span class="token number">0.33f</span><span class="token punctuation">,</span> <span class="token number">0.42f</span><span class="token punctuation">,</span> <span class="token number">0.18f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>glm<span class="token operator">::</span>vec3 <span class="token function">toyColor</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.31f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>glm<span class="token operator">::</span>vec3 result <span class="token operator">=</span> lightColor <span class="token operator">*</span> toyColor<span class="token punctuation">;</span> <span class="token comment">// = (0.33f, 0.21f, 0.06f);</span></pre></td></tr></table></figure><h3 id="创建一个光照场景"><a class="anchor" href="#创建一个光照场景">#</a> 创建一个光照场景</h3><p>在接下来的教程中，我们将会广泛地使用颜色来模拟现实世界中的光照效果，创造出一些有趣的视觉效果。由于我们现在将会使用光源了，我们希望将它们显示为可见的物体，并在场景中至少加入一个物体来测试模拟光照的效果。</p><p>首先我们需要一个物体来作为被投光 (Cast the light) 的对象，我们将使用前面教程中的那个著名的立方体箱子。我们还需要一个物体来代表光源在 3D 场景中的位置。简单起见，我们依然使用一个立方体来代表光源（我们已拥有立方体的顶点数据是吧？）。</p><p>填一个顶点缓冲对象 (VBO)，设定一下顶点属性指针和其它一些乱七八糟的东西现在对你来说应该很容易了，所以我们就不再赘述那些步骤了。如果你仍然觉得这很困难，我建议你复习之前的教程，并且在继续学习之前先把练习过一遍。</p><p>我们首先需要一个顶点着色器来绘制箱子。与之前的顶点着色器相比，容器的顶点位置是保持不变的（虽然这一次我们不需要纹理坐标了），因此顶点着色器中没有新的代码。我们将会使用之前教程顶点着色器的精简版：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> in vec3 aPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>uniform mat4 model<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>uniform mat4 view<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>uniform mat4 projection<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    gl_Position <span class="token operator">=</span> projection <span class="token operator">*</span> view <span class="token operator">*</span> model <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>aPos<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>记得更新你的顶点数据和属性指针使其与新的顶点着色器保持一致（当然你可以继续留着纹理数据和属性指针。在这一节中我们将不会用到它们，但有一个全新的开始也不是什么坏主意）。</p><p>因为我们还要创建一个表示灯（光源）的立方体，所以我们还要为这个灯创建一个专门的 VAO。当然我们也可以让这个灯和其它物体使用同一个 VAO，简单地对它的 model（模型）矩阵做一些变换就好了，然而接下来的教程中我们会频繁地对顶点数据和属性指针做出修改，我们并不想让这些修改影响到灯（我们只关心灯的顶点位置），因此我们有必要为灯创建一个新的 VAO。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> lightVAO<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glGenVertexArrays</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>lightVAO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>lightVAO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 只需要绑定 VBO 不用再次设置 VBO 的数据，因为箱子的 VBO 数据中已经包含了正确的立方体顶点数据</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> VBO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 设置灯立方体的顶点属性（对我们的灯来说仅仅只有位置数据）</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这段代码对你来说应该非常直观。现在我们已经创建了表示灯和被照物体箱子，我们只需要再定义一个片段着色器就行了：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>out vec4 FragColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>uniform vec3 objectColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>uniform vec3 lightColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>lightColor <span class="token operator">*</span> objectColor<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这个片段着色器从 uniform 变量中接受物体的颜色和光源的颜色。正如本节一开始所讨论的那样，我们将光源的颜色和物体（反射的）颜色相乘。这个着色器理解起来应该很容易。我们把物体的颜色设置为之前提到的珊瑚红色，并把光源设置为白色。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 在此之前不要忘记首先 use 对应的着色器程序（来设定 uniform）</span></pre></td></tr><tr><td data-num="2"></td><td><pre>lightingShader<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>lightingShader<span class="token punctuation">.</span><span class="token function">setVec3</span><span class="token punctuation">(</span><span class="token string">"objectColor"</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.31f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>lightingShader<span class="token punctuation">.</span><span class="token function">setVec3</span><span class="token punctuation">(</span><span class="token string">"lightColor"</span><span class="token punctuation">,</span>  <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>要注意的是，当我们修改顶点或者片段着色器后，灯的位置或颜色也会随之改变，这并不是我们想要的效果。我们不希望灯的颜色在接下来的教程中因光照计算的结果而受到影响，而是希望它能够与其它的计算分离。我们希望灯一直保持明亮，不受其它颜色变化的影响（这样它才更像是一个真实的光源）。</p><p>为了实现这个目标，我们需要为灯的绘制创建另外的一套着色器，从而能保证它能够在其它光照着色器发生改变的时候不受影响。顶点着色器与我们当前的顶点着色器是一样的，所以你可以直接把现在的顶点着色器用在灯上。灯的片段着色器给灯定义了一个不变的常量白色，保证了灯的颜色一直是亮的：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>out vec4 FragColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将向量的四个分量全部设置为 1.0</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>当我们想要绘制我们的物体的时候，我们需要使用刚刚定义的光照着色器来绘制箱子（或者可能是其它的物体）。当我们想要绘制灯的时候，我们会使用灯的着色器。在之后的教程里我们会逐步更新这个光照着色器，从而能够慢慢地实现更真实的效果。</p><p>使用这个灯立方体的主要目的是为了让我们知道光源在场景中的具体位置。我们通常在场景中定义一个光源的位置，但这只是一个位置，它并没有视觉意义。为了显示真正的灯，我们将表示光源的立方体绘制在与光源相同的位置。我们将使用我们为它新建的片段着色器来绘制它，让它一直处于白色的状态，不受场景中的光照影响。</p><p>我们声明一个全局 vec3 变量来表示光源在场景的世界空间坐标中的位置：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span>vec3 <span class="token function">lightPos</span><span class="token punctuation">(</span><span class="token number">1.2f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">2.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>然后我们把灯位移到这里，然后将它缩小一点，让它不那么明显：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>model <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>model <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">translate</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span> lightPos<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>model <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">scale</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.2f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>请把上述的所有代码片段放在你程序中合适的位置，这样我们就能有一个干净的光照实验场地了。如果一切顺利，运行效果将会如下图所示：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/02/01/colors_scene.png" alt="image"></p><h2 id="基础光照"><a class="anchor" href="#基础光照">#</a> 基础光照</h2><p>现实世界的光照是极其复杂的，而且会受到诸多因素的影响，这是我们有限的计算能力所无法模拟的。因此 OpenGL 的光照使用的是简化的模型，对现实的情况进行近似，这样处理起来会更容易一些，而且看起来也差不多一样。这些光照模型都是基于我们对光的物理特性的理解。其中一个模型被称<mark>为冯氏光照模型</mark> (Phong Lighting Model)。冯氏光照模型的主要结构由 3 个分量组成：<mark>环境</mark> (Ambient)、<mark>漫反射</mark> (Diffuse) 和<mark>镜面</mark> (Specular) 光照。下面这张图展示了这些光照分量看起来的样子：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/02/02/basic_lighting_phong.png" alt="image"></p><ul><li><mark>环境光照</mark> (Ambient Lighting)：即使在黑暗的情况下，世界上通常也仍然有一些光亮（月亮、远处的光），所以物体几乎永远不会是完全黑暗的。为了模拟这个，我们会使用一个环境光照常量，它永远会给物体一些颜色。</li><li><mark>漫反射光照</mark> (Diffuse Lighting)：模拟光源对物体的方向性影响 (Directional Impact)。它是冯氏光照模型中视觉上最显著的分量。物体的某一部分越是正对着光源，它就会越亮。</li><li><mark>镜面光照</mark> (Specular Lighting)：模拟有光泽物体上面出现的亮点。镜面光照的颜色相比于物体的颜色会更倾向于光的颜色。</li></ul><p>为了创建有趣的视觉场景，我们希望模拟至少这三种光照分量。我们将以最简单的一个开始：环境光照。</p><h3 id="环境光照"><a class="anchor" href="#环境光照">#</a> 环境光照</h3><p>光通常都不是来自于同一个光源，而是来自于我们周围分散的很多光源，即使它们可能并不是那么显而易见。光的一个属性是，它可以向很多方向发散并反弹，从而能够到达不是非常直接临近的点。所以，光能够在其它的表面上反射，对一个物体产生间接的影响。考虑到这种情况的算法叫做<mark>全局照明</mark> (Global Illumination) 算法，但是这种算法既开销高昂又极其复杂。</p><p>由于我们现在对那种又复杂又开销高昂的算法不是很感兴趣，所以我们将会先使用一个简化的全局照明模型，即<mark>环境光照</mark>。正如你在上一节所学到的，我们使用一个很小的常量（光照）颜色，添加到物体片段的最终颜色中，这样子的话即便场景中没有直接的光源也能看起来存在有一些发散的光。</p><p>把环境光照添加到场景里非常简单。我们用光的颜色乘以一个很小的<mark>常量环境因子</mark>，再乘以物体的颜色，然后将最终结果作为片段的颜色：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">float</span> ambientStrength <span class="token operator">=</span> <span class="token number">0.1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    vec3 ambient <span class="token operator">=</span> ambientStrength <span class="token operator">*</span> lightColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    vec3 result <span class="token operator">=</span> ambient <span class="token operator">*</span> objectColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>如果你现在运行你的程序，你会注意到冯氏光照的第一个阶段已经应用到你的物体上了。这个物体非常暗，但由于应用了环境光照（注意光源立方体没受影响是因为我们对它使用了另一个着色器），也不是完全黑的。它看起来应该像这样：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/02/02/ambient_lighting.png" alt="image"></p><h3 id="漫反射光照"><a class="anchor" href="#漫反射光照">#</a> 漫反射光照</h3><p>环境光照本身不能提供最有趣的结果，但是漫反射光照就能开始对物体产生显著的视觉影响了。漫反射光照使物体上与光线方向越接近的片段能从光源处获得更多的亮度。为了能够更好的理解漫反射光照，请看下图：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/02/02/diffuse_light.png" alt="image"></p><p>图左上方有一个光源，它所发出的光线落在物体的一个片段上。我们需要测量这个光线是以什么角度接触到这个片段的。如果光线<mark>垂直于物体表面</mark>，这束光对物体的<mark>影响会最大化</mark>（译注：更亮）。为了测量光线和片段的角度，我们使用一个叫做<mark>法向量</mark> (Normal Vector) 的东西，它是垂直于片段表面的一个向量（这里以黄色箭头表示），我们在后面再讲这个东西。这两个向量之间的角度很容易就能够通过点乘计算出来。</p><p>你可能记得在变换那一节教程里，我们知道两个单位向量的夹角越小，它们点乘的结果越倾向于 1。当两个<mark>向量的夹角为 90 度的时候，点乘会变为 0</mark>。这同样适用于 θ，θ 越大，光对片段颜色的影响就应该越小。</p><blockquote><p>注意，为了（只）得到两个向量夹角的余弦值，我们使用的是<strong>单位向量</strong>（长度为 1 的向量），所以我们需要确保所有的向量都是标准化的，否则点乘返回的就不仅仅是余弦值了（见变换）。</p></blockquote><p>点乘返回一个标量，我们可以用它计算光线对片段颜色的影响。不同片段朝向光源的方向的不同，这些片段被照亮的情况也不同。</p><p>所以，计算漫反射光照需要什么？</p><ul><li>法向量：<mark>一个垂直于顶点表面的向量</mark>。</li><li>定向的光线：作为光源的位置与片段的位置之间向量差的方向向量。为了计算这个光线，我们需要光的位置向量和片段的位置向量。</li></ul><h3 id="法向量"><a class="anchor" href="#法向量">#</a> 法向量</h3><p>法向量是<mark>一个垂直于顶点表面的</mark>（单位）向量。由于顶点本身并没有表面（它只是空间中一个独立的点），我们利用它周围的顶点来计算出这个顶点的表面。我们能够使用一个小技巧，使用叉乘对立方体所有的顶点计算法向量，但是由于 3D 立方体不是一个复杂的形状，所以我们可以简单地把法线数据手工添加到顶点数据中。更新后的顶点数据数组可以在<span class="exturl" data-url="aHR0cHM6Ly9sZWFybm9wZW5nbC5jb20vY29kZV92aWV3ZXIucGhwP2NvZGU9bGlnaHRpbmcvYmFzaWNfbGlnaHRpbmdfdmVydGV4X2RhdGE=">这里找到</span>。试着去想象一下，这些法向量真的是垂直于立方体各个平面的表面的（一个立方体由 6 个平面组成）。</p><p>由于我们向顶点数组添加了额外的数据，所以我们应该更新光照的顶点着色器：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> in vec3 aPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> in vec3 aNormal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr></table></figure><p>现在我们已经向每个顶点添加了一个法向量并更新了顶点着色器，我们还要更新顶点属性指针。注意，灯使用同样的顶点数组作为它的顶点数据，然而灯的着色器并没有使用新添加的法向量。我们不需要更新灯的着色器或者是属性的配置，但是我们必须至少修改一下顶点属性指针来适应新的顶点数组的大小：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">6</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">6</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>我们只想使用每个顶点的前三个 float，并且忽略后三个 float，所以我们只需要把步长参数改成 float 大小的 6 倍就行了。</p><blockquote><p>虽然对灯的着色器使用不能完全利用的顶点数据看起来不是那么高效，但这些顶点数据已经从箱子对象载入后开始就储存在 GPU 的内存里了，所以我们并不需要储存新数据到 GPU 内存中。这实际上比给灯专门分配一个新的 VBO 更高效了。</p></blockquote><p><mark>所有光照的计算都是在片段着色器里进行</mark>，所以我们需要将法向量由顶点着色器传递到片段着色器。我们这么做：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>out vec3 Normal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    gl_Position <span class="token operator">=</span> projection <span class="token operator">*</span> view <span class="token operator">*</span> model <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>aPos<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    Normal <span class="token operator">=</span> aNormal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="计算漫反射光照"><a class="anchor" href="#计算漫反射光照">#</a> 计算漫反射光照</h3><p>我们现在对每个顶点都有了法向量，但是我们仍然需要光源的位置向量和片段的位置向量。由于光源的位置是一个静态变量，我们可以简单地在片段着色器中把它声明为 uniform：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>uniform vec3 lightPos<span class="token punctuation">;</span></pre></td></tr></table></figure><p>然后在渲染循环中（渲染循环的外面也可以，因为它不会改变）更新 uniform。我们使用在前面声明的 lightPos 向量作为光源位置：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>lightingShader<span class="token punctuation">.</span><span class="token function">setVec3</span><span class="token punctuation">(</span><span class="token string">"lightPos"</span><span class="token punctuation">,</span> lightPos<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>最后，我们还需要片段的位置。我们会在世界空间中进行所有的光照计算，因此我们需要一个在世界空间中的顶点位置。我们可以通过把顶点位置属性乘以模型矩阵（不是观察和投影矩阵）来把它变换到世界空间坐标。这个在顶点着色器中很容易完成，所以我们声明一个输出变量，并计算它的世界空间坐标：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>out vec3 FragPos<span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="2"></td><td><pre>out vec3 Normal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    gl_Position <span class="token operator">=</span> projection <span class="token operator">*</span> view <span class="token operator">*</span> model <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>aPos<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    FragPos <span class="token operator">=</span> <span class="token function">vec3</span><span class="token punctuation">(</span>model <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>aPos<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    Normal <span class="token operator">=</span> aNormal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>最后，在片段着色器中添加相应的输入变量。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>in vec3 FragPos<span class="token punctuation">;</span></pre></td></tr></table></figure><p>现在，所有需要的变量都设置好了，我们可以在片段着色器中添加光照计算了。</p><p>我们需要做的第一件事是计算光源和片段位置之间的方向向量。前面提到，光的方向向量是光源位置向量与片段位置向量之间的向量差。你可能记得在变换教程中，我们能够简单地通过让两个向量相减的方式计算向量差。我们同样希望确保所有相关向量最后都转换为单位向量，所以我们把法线和最终的方向向量都进行标准化：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vec3 norm <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>Normal<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>vec3 lightDir <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>lightPos <span class="token operator">-</span> FragPos<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>下一步，我们对 norm 和 lightDir 向量进行点乘，计算光源对当前片段实际的漫发射影响。结果值再乘以光的颜色，得到漫反射分量。两个向量之间的角度越大，漫反射分量就会越小：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> diff <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>norm<span class="token punctuation">,</span> lightDir<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>vec3 diffuse <span class="token operator">=</span> diff <span class="token operator">*</span> lightColor<span class="token punctuation">;</span></pre></td></tr></table></figure><p>如果两个向量之间的角度大于 90 度，点乘的结果就会变成负数，这样会导致漫反射分量变为负数。为此，我们使用 max 函数返回两个参数之间较大的参数，从而保证漫反射分量不会变成负数。负数颜色的光照是没有定义的，所以最好避免它，除非你是那种古怪的艺术家。</p><p>现在我们有了环境光分量和漫反射分量，我们把它们相加，然后把结果乘以物体的颜色，来获得片段最后的输出颜色。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vec3 result <span class="token operator">=</span> <span class="token punctuation">(</span>ambient <span class="token operator">+</span> diffuse<span class="token punctuation">)</span> <span class="token operator">*</span> objectColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/02/02/basic_lighting_diffuse.png" alt="image"></p><h3 id="最后一件事"><a class="anchor" href="#最后一件事">#</a> 最后一件事</h3><p>现在我们已经把法向量从顶点着色器传到了片段着色器。可是，目前片段着色器里的计算都是在世界空间坐标中进行的。所以，我们是不是应该把法向量也转换为世界空间坐标？基本正确，但是这不是简单地把它乘以一个模型矩阵就能搞定的。</p><p>首先，法向量只是一个方向向量，不能表达空间中的特定位置。同时，法向量没有齐次坐标（顶点位置中的 w 分量）。这意味着，<mark>位移不应该影响到法向量</mark>。因此，如果我们打算把法向量乘以一个模型矩阵，我们就要从矩阵中移除位移部分，只选用模型矩阵左上角 3×3 的矩阵（注意，我们也可以把法向量的 w 分量设置为 0，再乘以 4×4 矩阵；这同样可以移除位移）。对于法向量，我们只希望对它实施缩放和旋转变换。</p><p>其次，如果模型矩阵执行了<mark>不等比缩放</mark>，<mark>顶点的改变会导致法向量<strong>不再垂直</strong>于表面了</mark>。因此，我们不能用这样的模型矩阵来变换法向量。下面的图展示了应用了不等比缩放的模型矩阵对法向量的影响：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/02/02/basic_lighting_normal_transformation.png" alt="image"></p><p>每当我们应用一个不等比缩放时（注意：等比缩放不会破坏法线，因为法线的方向没被改变，仅仅改变了法线的长度，而这很容易通过标准化来修复），法向量就不会再垂直于对应的表面了，这样光照就会被破坏。</p><p>修复这个行为的诀窍是使用一个为法向量专门定制的模型矩阵。这个矩阵称之为<mark>法线矩阵</mark> (Normal Matrix)，它使用了一些线性代数的操作来移除对法向量错误缩放的影响。如果你想知道这个矩阵是如何计算出来的，建议去阅读这个<span class="exturl" data-url="aHR0cDovL3d3dy5saWdodGhvdXNlM2QuY29tL3R1dG9yaWFscy9nbHNsLXR1dG9yaWFsL3RoZS1ub3JtYWwtbWF0cml4Lw==">文章</span>。</p><p>法线矩阵被定义为「<mark>模型矩阵左上角的逆矩阵的转置矩阵</mark>」。真是拗口，如果你不明白这是什么意思，别担心，我们还没有讨论<mark>逆矩阵</mark> (Inverse Matrix) 和<mark>转置矩阵</mark> (Transpose Matrix)。注意，大部分的资源都会将法线矩阵定义为应用到模型 - 观察矩阵 (Model-view Matrix) 上的操作，但是由于我们只在世界空间中进行操作（不是在观察空间），我们只使用模型矩阵。</p><p>在顶点着色器中，我们可以使用 inverse 和 transpose 函数自己生成这个法线矩阵，这两个函数对所有类型矩阵都有效。注意我们还要把被处理过的矩阵强制转换为 3×3 矩阵，来保证它失去了位移属性以及能够乘以 vec3 的法向量。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>Normal <span class="token operator">=</span> <span class="token function">mat3</span><span class="token punctuation">(</span><span class="token function">transpose</span><span class="token punctuation">(</span><span class="token function">inverse</span><span class="token punctuation">(</span>model<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> aNormal<span class="token punctuation">;</span></pre></td></tr></table></figure><p>在漫反射光照部分，光照表现并没有问题，这是因为我们没有对物体本身执行任何缩放操作，所以并不是必须要使用一个法线矩阵，仅仅让模型矩阵乘以法线也可以。可是，如果你进行了不等比缩放，使用法线矩阵去乘以法向量就是必不可少的了。</p><blockquote><p>即使是对于着色器来说，<mark>逆矩阵也是一个开销比较大的运算</mark>，因此，只要可能就应该避免在着色器中进行逆矩阵运算，它们必须为你场景中的每个顶点都进行这样的处理。用作学习目这样做是可以的，但是对于一个对效率有要求的应用来说，在绘制之前你最好用 CPU 计算出法线矩阵，然后通过 uniform 把值传递给着色器（像模型矩阵一样）。</p></blockquote><h3 id="镜面光照"><a class="anchor" href="#镜面光照">#</a> 镜面光照</h3><p>如果你还没被这些光照计算搞得精疲力尽，我们就再把镜面高光 (Specular Highlight) 加进来，这样冯氏光照才算完整。</p><p>和漫反射光照一样，镜面光照也是依据光的方向向量和物体的法向量来决定的，但是它也依赖于观察方向，例如玩家是从什么方向看着这个片段的。镜面光照是基于光的反射特性。如果我们想象物体表面像一面镜子一样，那么，无论我们从哪里去看那个表面所反射的光，镜面光照都会达到最大化。你可以从下面的图片看到效果：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/02/02/basic_lighting_specular_theory.png" alt="image"></p><p>我们通过反射法向量周围光的方向来计算<mark>反射向量</mark>。然后我们计算<mark>反射向量和视线方向的角度差</mark>，如果<mark>夹角越小</mark>，那么<mark>镜面光的影响就会越大</mark>。它的作用效果就是，当我们去看光被物体所反射的那个方向的时候，我们会看到一个高光。</p><p>观察向量是镜面光照附加的一个变量，我们可以使用观察者世界空间位置和片段的位置来计算它。之后，我们计算镜面光强度，用它乘以光源的颜色，再将它加上环境光和漫反射分量。</p><blockquote><p>我们选择在世界空间进行光照计算，但是大多数人趋向于在观察空间进行光照计算。在观察空间计算的好处是，观察者的位置总是 (0, 0, 0)，所以这样你直接就获得了观察者位置。可是我发现在学习的时候在世界空间中计算光照更符合直觉。如果你仍然希望在观察空间计算光照的话，你需要将所有相关的向量都用观察矩阵进行变换（记得也要改变法线矩阵）。</p></blockquote><p>为了得到观察者的世界空间坐标，我们简单地使用摄像机对象的位置坐标代替（它当然就是观察者）。所以我们把另一个 uniform 添加到片段着色器，把相应的摄像机位置坐标传给片段着色器：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>uniform vec3 viewPos<span class="token punctuation">;</span></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>lightingShader<span class="token punctuation">.</span><span class="token function">setVec3</span><span class="token punctuation">(</span><span class="token string">"viewPos"</span><span class="token punctuation">,</span> camera<span class="token punctuation">.</span>Position<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>现在我们已经获得所有需要的变量，可以计算高光强度了。首先，我们定义一个<mark>镜面强度</mark> (Specular Intensity) 变量，给镜面高光一个中等亮度颜色，让它不要产生过度的影响。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> specularStrength <span class="token operator">=</span> <span class="token number">0.5</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>如果我们把它设置为 1.0f，我们会得到一个非常亮的镜面光分量，这对于一个珊瑚色的立方体来说有点太多了。下一节教程中我们会讨论如何合理设置这些光照强度，以及它们是如何影响物体的。下一步，我们计算视线方向向量，和对应的沿着法线轴的反射向量：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vec3 viewDir <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>viewPos <span class="token operator">-</span> FragPos<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>vec3 reflectDir <span class="token operator">=</span> <span class="token function">reflect</span><span class="token punctuation">(</span><span class="token operator">-</span>lightDir<span class="token punctuation">,</span> norm<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>需要注意的是我们对 lightDir 向量进行了取反。<mark>reflect 函数要求第一个向量是<strong>从光源指向片段位置的向量</strong></mark>，但是 lightDir 当前正好相反，是从片段指向光源（由先前我们计算 lightDir 向量时，减法的顺序决定）。为了保证我们得到正确的 reflect 向量，我们通过对 lightDir 向量取反来获得相反的方向。第二个参数要求是一个法向量，所以我们提供的是已标准化的 norm 向量。</p><p>剩下要做的是计算镜面分量。下面的代码完成了这件事：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> spec <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>viewDir<span class="token punctuation">,</span> reflectDir<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>vec3 specular <span class="token operator">=</span> specularStrength <span class="token operator">*</span> spec <span class="token operator">*</span> lightColor<span class="token punctuation">;</span></pre></td></tr></table></figure><p>我们先计算视线方向与反射方向的点乘（并确保它不是负值），然后取它的 32 次幂。这个<mark> 32 是高光的反光度</mark> (Shininess)。一个物体的反光度越高，反射光的能力越强，散射得越少，高光点就会越小。在下面的图片里，你会看到不同反光度的视觉效果影响：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/02/02/basic_lighting_specular_shininess.png" alt="image"></p><p>我们不希望镜面成分过于显眼，所以我们把指数保持为 32。剩下的最后一件事情是把它加到环境光分量和漫反射分量里，再用结果乘以物体的颜色：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vec3 result <span class="token operator">=</span> <span class="token punctuation">(</span>ambient <span class="token operator">+</span> diffuse <span class="token operator">+</span> specular<span class="token punctuation">)</span> <span class="token operator">*</span> objectColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>我们现在为冯氏光照计算了全部的光照分量。根据你的视角，你可以看到类似下面的画面：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/02/02/basic_lighting_specular.png" alt="image"></p><blockquote><p>在光照着色器的早期，开发者曾经在顶点着色器中实现冯氏光照模型。在顶点着色器中做光照的优势是，相比片段来说，顶点要少得多，因此会更高效，所以（开销大的）光照计算频率会更低。然而，顶点着色器中的最终颜色值是仅仅只是那个顶点的颜色值，片段的颜色值是由插值光照颜色所得来的。结果就是这种光照看起来不会非常真实，除非使用了大量顶点。</p></blockquote><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/02/02/basic_lighting_gouruad.png" alt="image"></p><p>在顶点着色器中实现的冯氏光照模型叫做<mark> Gouraud</mark> 着色 (Gouraud Shading)，而不是冯氏着色 (<mark>Phong Shading</mark>)。记住，由于插值，这种光照看起来有点逊色。冯氏着色能产生更平滑的光照效果。</p><h2 id="材质"><a class="anchor" href="#材质">#</a> 材质</h2><p>在现实世界里，每个物体会对光产生不同的反应。比如说，钢看起来通常会比陶瓷花瓶更闪闪发光，木头箱子也不会像钢制箱子那样对光产生很强的反射。每个物体对镜面高光也有不同的反应。有些物体反射光的时候不会有太多的散射 (Scatter)，因而产生一个较小的高光点，而有些物体则会散射很多，产生一个有着更大半径的高光点。如果我们想要在 OpenGL 中模拟多种类型的物体，我们必须为每个物体分别定义一个<mark>材质</mark> (Material) 属性。</p><p>在上一节中，我们指定了一个物体和光的颜色，以及结合环境光和镜面强度分量，来定义物体的视觉输出。当描述一个物体的时候，我们可以用这三个分量来定义一个<mark>材质颜色</mark> (Material Color)：<mark>环境光照</mark> (Ambient Lighting)、<mark>漫反射光照</mark> (Diffuse Lighting) 和<mark>镜面光照</mark> (Specular Lighting)。通过为每个分量指定一个颜色，我们就能够对物体的颜色输出有着精细的控制了。现在，我们再添加<mark>反光度</mark> (Shininess) 这个分量到上述的三个颜色中，这就有我们需要的所有材质属性了：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">Material</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    vec3 ambient<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    vec3 diffuse<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    vec3 specular<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">float</span> shininess<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>uniform Material material<span class="token punctuation">;</span></pre></td></tr></table></figure><p>在片段着色器中，我们创建一个结构体 (Struct) 来储存物体的材质属性。我们也可以把它们储存为独立的 uniform 值，但是作为一个结构体来储存会更有条理一些。我们首先定义结构体的布局 (Layout)，然后使用刚创建的结构体为类型，简单地声明一个 uniform 变量。</p><p>你可以看到，我们为每个冯氏光照模型的分量都定义一个颜色向量。ambient 材质向量定义了在环境光照下这个物体反射得是什么颜色，通常这是和物体颜色相同的颜色。diffuse 材质向量定义了在漫反射光照下物体的颜色。（和环境光照一样）漫反射颜色也要设置为我们需要的物体颜色。specular 材质向量设置的是镜面光照对物体的颜色影响（或者甚至可能反射一个物体特定的镜面高光颜色）。最后，shininess 影响镜面高光的散射 / 半径。</p><ul><li><strong>ambient</strong>: 环境光照下这个物体反射得是什么颜色。</li><li><strong>diffuse</strong>: 在漫反射光照下物体的颜色。</li><li><strong>specular</strong>: 镜面光照对物体的颜色影响。</li><li><strong>shininess</strong>: 影响镜面高光的散射 / 半径。</li></ul><p>这四个元素定义了一个物体的材质，通过它们我们能够模拟很多现实世界中的材质。<span class="exturl" data-url="aHR0cDovL2RldmVybmF5LmZyZWUuZnIvY291cnMvb3BlbmdsL21hdGVyaWFscy5odG1s">devernay.free.fr</span> 上的一个表格展示了几种材质属性，它们模拟了现实世界中的真实材质。下面的图片展示了几种现实世界的材质对我们的立方体的影响：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/02/03/materials_real_world.png" alt="image"></p><p>可以看到，通过正确地指定一个物体的材质属性，我们对这个物体的感知也就不同了。效果非常明显，但是要想获得更真实的效果，我们最终需要更加复杂的形状，而不单单是一个立方体。在后面的教程中，我们会讨论更复杂的形状。</p><p>为一个物体赋予一款合适的材质是非常困难的，这需要大量实验和丰富的经验，所以由于不合适的材质而毁了物体的视觉质量是件经常发生的事。</p><p>让我们在着色器中实现这样的一个材质系统。</p><h3 id="设置材质"><a class="anchor" href="#设置材质">#</a> 设置材质</h3><p>我们在片段着色器中创建了一个材质结构体的 uniform，所以下面我们希望修改一下光照的计算来顺应新的材质属性。由于所有材质变量都储存在结构体中，我们可以从 uniform 变量 material 中访问它们：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span>    </pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 环境光</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    vec3 ambient <span class="token operator">=</span> lightColor <span class="token operator">*</span> material<span class="token punctuation">.</span>ambient<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 漫反射 </span></pre></td></tr><tr><td data-num="7"></td><td><pre>    vec3 norm <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>Normal<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    vec3 lightDir <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>lightPos <span class="token operator">-</span> FragPos<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">float</span> diff <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>norm<span class="token punctuation">,</span> lightDir<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    vec3 diffuse <span class="token operator">=</span> lightColor <span class="token operator">*</span> <span class="token punctuation">(</span>diff <span class="token operator">*</span> material<span class="token punctuation">.</span>diffuse<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">// 镜面光</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    vec3 viewDir <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>viewPos <span class="token operator">-</span> FragPos<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    vec3 reflectDir <span class="token operator">=</span> <span class="token function">reflect</span><span class="token punctuation">(</span><span class="token operator">-</span>lightDir<span class="token punctuation">,</span> norm<span class="token punctuation">)</span><span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">float</span> spec <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>viewDir<span class="token punctuation">,</span> reflectDir<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> material<span class="token punctuation">.</span>shininess<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    vec3 specular <span class="token operator">=</span> lightColor <span class="token operator">*</span> <span class="token punctuation">(</span>spec <span class="token operator">*</span> material<span class="token punctuation">.</span>specular<span class="token punctuation">)</span><span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>    vec3 result <span class="token operator">=</span> ambient <span class="token operator">+</span> diffuse <span class="token operator">+</span> specular<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>可以看到，我们现在在需要的地方访问了材质结构体中的所有属性，并且这次是根据材质的颜色来计算最终的输出颜色的。物体的每个材质属性都乘上了它们对应的<mark>光照分量</mark> (lightColor)。</p><p>我们现在可以在程序中设置适当的 uniform，对物体设置材质了。GLSL 中的结构体在设置 uniform 时并没有什么特别之处。结构体只是作为 uniform 变量的一个封装，所以如果想填充这个结构体的话，我们仍需要对每个单独的 uniform 进行设置，但这次要带上结构体名的前缀：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>lightingShader<span class="token punctuation">.</span><span class="token function">setVec3</span><span class="token punctuation">(</span><span class="token string">"material.ambient"</span><span class="token punctuation">,</span>  <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.31f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>lightingShader<span class="token punctuation">.</span><span class="token function">setVec3</span><span class="token punctuation">(</span><span class="token string">"material.diffuse"</span><span class="token punctuation">,</span>  <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.31f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>lightingShader<span class="token punctuation">.</span><span class="token function">setVec3</span><span class="token punctuation">(</span><span class="token string">"material.specular"</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>lightingShader<span class="token punctuation">.</span><span class="token function">setFloat</span><span class="token punctuation">(</span><span class="token string">"material.shininess"</span><span class="token punctuation">,</span> <span class="token number">32.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>我们将环境光和漫反射分量设置成我们想要让物体所拥有的颜色，而将镜面分量设置为一个中等亮度的颜色，我们不希望镜面分量在这个物体上过于强烈。我们将反光度保持为 32。现在我们能够程序中非常容易地修改物体的材质了。</p><p>运行程序，你应该会得到下面这样的结果：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/02/03/materials_with_material.png" alt="image"></p><h3 id="光的属性"><a class="anchor" href="#光的属性">#</a> 光的属性</h3><p>这个物体太亮了。物体过亮的原因是环境光、漫反射和镜面光这三个颜色对任何一个光源都会去全力反射。光源对环境光、漫反射和镜面光分量也具有着不同的强度。前面的教程，我们通过使用一个强度值改变环境光和镜面光强度的方式解决了这个问题。我们想做一个类似的系统，但是这次是要为每个光照分量都指定一个强度向量。如果我们假设 lightColor 是<mark> vec3 (1.0)</mark>，代码会看起来像这样：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vec3 ambient  <span class="token operator">=</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span> <span class="token operator">*</span> material<span class="token punctuation">.</span>ambient<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>vec3 diffuse  <span class="token operator">=</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>diff <span class="token operator">*</span> material<span class="token punctuation">.</span>diffuse<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>vec3 specular <span class="token operator">=</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>spec <span class="token operator">*</span> material<span class="token punctuation">.</span>specular<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>所以物体的每个材质属性对每一个光照分量都返回了最大的强度。对单个光源来说，这些 vec3 (1.0) 值同样可以分别改变，而这通常就是我们想要的。现在，物体的环境光分量完全地影响了立方体的颜色，可是环境光分量实际上不应该对最终的颜色有这么大的影响，所以我们会将光源的环境光强度设置为一个小一点的值，从而限制环境光颜色：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vec3 ambient <span class="token operator">=</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span> <span class="token operator">*</span> material<span class="token punctuation">.</span>ambient<span class="token punctuation">;</span></pre></td></tr></table></figure><p>我们可以用同样的方式修改光源的漫反射和镜面光强度。这和我们在上一节中所做的极为相似，你可以说我们已经创建了一些光照属性来影响每个单独的光照分量。我们希望为光照属性创建一个与材质结构体类似的结构体：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">Light</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    vec3 position<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    vec3 ambient<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    vec3 diffuse<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    vec3 specular<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>uniform Light light<span class="token punctuation">;</span></pre></td></tr></table></figure><p>一个光源对它的<mark> ambient</mark>、<mark>diffuse</mark> 和<mark> specular</mark> 光照有着不同的强度。环境光照通常会设置为一个比较低的强度，因为我们不希望环境光颜色太过显眼。光源的漫反射分量通常设置为光所具有的颜色，通常是一个比较明亮的白色。镜面光分量通常会保持为 vec3 (1.0)，以最大强度发光。注意我们也将光源的位置添加到了结构体中。</p><p>和材质 uniform 一样，我们需要更新片段着色器：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vec3 ambient  <span class="token operator">=</span> light<span class="token punctuation">.</span>ambient <span class="token operator">*</span> material<span class="token punctuation">.</span>ambient<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>vec3 diffuse  <span class="token operator">=</span> light<span class="token punctuation">.</span>diffuse <span class="token operator">*</span> <span class="token punctuation">(</span>diff <span class="token operator">*</span> material<span class="token punctuation">.</span>diffuse<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>vec3 specular <span class="token operator">=</span> light<span class="token punctuation">.</span>specular <span class="token operator">*</span> <span class="token punctuation">(</span>spec <span class="token operator">*</span> material<span class="token punctuation">.</span>specular<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>我们接下来在程序中设置光照强度：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>lightingShader<span class="token punctuation">.</span><span class="token function">setVec3</span><span class="token punctuation">(</span><span class="token string">"light.ambient"</span><span class="token punctuation">,</span>  <span class="token number">0.2f</span><span class="token punctuation">,</span> <span class="token number">0.2f</span><span class="token punctuation">,</span> <span class="token number">0.2f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>lightingShader<span class="token punctuation">.</span><span class="token function">setVec3</span><span class="token punctuation">(</span><span class="token string">"light.diffuse"</span><span class="token punctuation">,</span>  <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将光照调暗了一些以搭配场景</span></pre></td></tr><tr><td data-num="3"></td><td><pre>lightingShader<span class="token punctuation">.</span><span class="token function">setVec3</span><span class="token punctuation">(</span><span class="token string">"light.specular"</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/02/03/materials_light.png" alt="image"></p><h3 id="不同的光源颜色"><a class="anchor" href="#不同的光源颜色">#</a> 不同的光源颜色</h3><p>到目前为止，我们都只对光源设置了从白到灰到黑范围内的颜色，这样只会改变物体各个分量的强度，而不是它的真正颜色。由于现在能够非常容易地访问光照的属性了，我们可以随着时间改变它们的颜色，从而获得一些非常有意思的效果。由于所有的东西都在片段着色器中配置好了，修改光源的颜色非常简单，我们能够立刻创造一些很有趣的效果：</p><p>我们可以利用 sin 和 glfwGetTime 函数改变光源的环境光和漫反射颜色，从而很容易地让光源的颜色随着时间变化：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span>vec3 lightColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>lightColor<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token function">sin</span><span class="token punctuation">(</span><span class="token function">glfwGetTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>lightColor<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token function">sin</span><span class="token punctuation">(</span><span class="token function">glfwGetTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.7f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>lightColor<span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token function">sin</span><span class="token punctuation">(</span><span class="token function">glfwGetTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1.3f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>glm<span class="token operator">::</span>vec3 diffuseColor <span class="token operator">=</span> lightColor   <span class="token operator">*</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.5f</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 降低影响</span></pre></td></tr><tr><td data-num="7"></td><td><pre>glm<span class="token operator">::</span>vec3 ambientColor <span class="token operator">=</span> diffuseColor <span class="token operator">*</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.2f</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 很低的影响</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>lightingShader<span class="token punctuation">.</span><span class="token function">setVec3</span><span class="token punctuation">(</span><span class="token string">"light.ambient"</span><span class="token punctuation">,</span> ambientColor<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>lightingShader<span class="token punctuation">.</span><span class="token function">setVec3</span><span class="token punctuation">(</span><span class="token string">"light.diffuse"</span><span class="token punctuation">,</span> diffuseColor<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h2 id="光照贴图"><a class="anchor" href="#光照贴图">#</a> 光照贴图</h2><p>在上一节中，我们讨论了让每个物体都拥有自己独特的材质从而对光照做出不同的反应的方法。这样子能够很容易在一个光照的场景中给每个物体一个独特的外观，但是这仍不能对一个物体的视觉输出提供足够多的灵活性。</p><p>在上一节中，我们将整个物体的材质定义为一个整体，但现实世界中的物体通常并不只包含有一种材质，而是由多种材质所组成。想想一辆汽车：它的外壳非常有光泽，车窗会部分反射周围的环境，轮胎不会那么有光泽，所以它没有镜面高光，轮毂非常闪亮（如果你洗车了的话）。汽车同样会有漫反射和环境光颜色，它们在整个物体上也不会是一样的，汽车有着许多种不同的环境光 / 漫反射颜色。总之，这样的物体在不同的部件上都有不同的材质属性。</p><p>所以，上一节中的那个材质系统是肯定不够的，它只是一个最简单的模型，所以我们需要拓展之前的系统，引入<mark>漫反射</mark>和<mark>镜面光贴图</mark> (Map)。这允许我们对物体的漫反射分量（以及间接地对环境光分量，它们几乎总是一样的）和镜面光分量有着更精确的控制。</p><h3 id="漫反射贴图"><a class="anchor" href="#漫反射贴图">#</a> 漫反射贴图</h3><p>我们希望通过某种方式对物体的每个片段单独设置漫反射颜色。有能够让我们根据片段在物体上的位置来获取颜色值得系统吗？</p><p>这可能听起来很熟悉，而且事实上这个系统我们已经使用很长时间了。这听起来很像在之前教程中详细讨论过的纹理，而这基本就是这样：一个纹理。我们仅仅是对同样的原理使用了不同的名字：其实都是使用一张覆盖物体的图像，让我们能够逐片段索引其独立的颜色值。在光照场景中，它通常叫做一个漫反射贴图 (Diffuse Map)（3D 艺术家通常都这么叫它），它是一个表现了物体所有的漫反射颜色的纹理图像。</p><p>为了演示漫反射贴图，我们将会使用<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vYWxsZW5neC9waWNfYmVkL3Jhdy9tYXN0ZXIvaW1nLzAyLzA0L2NvbnRhaW5lcjIucG5n">下面的图片</span>，它是一个有钢边框的木箱：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/02/04/container2.png" alt="image"></p><p>在着色器中使用漫反射贴图的方法和纹理教程中是完全一样的。但这次我们会将纹理储存为 Material 结构体中的一个<mark> sampler2D</mark>。我们将之前定义的<mark> vec3 漫反射颜色向量替换为漫反射贴图</mark>。</p><blockquote><p>注意 sampler2D 是所谓的<strong>不透明类型</strong> (Opaque Type)，也就是说我们<mark>不能将它实例化</mark>，只能通过 uniform 来定义它。如果我们使用除 uniform 以外的方法（比如函数的参数）实例化这个结构体，GLSL 会抛出一些奇怪的错误。这同样也适用于任何封装了不透明类型的结构体。</p></blockquote><p>我们也移除了环境光材质颜色向量，因为环境光颜色在几乎所有情况下都等于漫反射颜色，所以我们不需要将它们分开储存：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">Material</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    sampler2D diffuse<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    vec3      specular<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">float</span>     shininess<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="7"></td><td><pre>in vec2 TexCoords<span class="token punctuation">;</span></pre></td></tr></table></figure><p>注意我们将在片段着色器中再次需要纹理坐标，所以我们声明一个额外的输入变量。接下来我们只需要从纹理中采样片段的漫反射颜色值即可：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vec3 diffuse <span class="token operator">=</span> light<span class="token punctuation">.</span>diffuse <span class="token operator">*</span> diff <span class="token operator">*</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token function">texture</span><span class="token punctuation">(</span>material<span class="token punctuation">.</span>diffuse<span class="token punctuation">,</span> TexCoords<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>不要忘记将环境光得材质颜色设置为漫反射材质颜色同样的值。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vec3 ambient <span class="token operator">=</span> light<span class="token punctuation">.</span>ambient <span class="token operator">*</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token function">texture</span><span class="token punctuation">(</span>material<span class="token punctuation">.</span>diffuse<span class="token punctuation">,</span> TexCoords<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这就是使用漫反射贴图的全部步骤了。你可以看到，这并不是什么新的东西，但这能够极大地提高视觉品质。为了让它正常工作，我们还需要使用纹理坐标更新顶点数据，将它们作为顶点属性传递到片段着色器，加载材质并绑定材质到合适的纹理单元。</p><p>更新后的顶点数据可以在<span class="exturl" data-url="aHR0cHM6Ly9sZWFybm9wZW5nbC5jb20vY29kZV92aWV3ZXIucGhwP2NvZGU9bGlnaHRpbmcvdmVydGV4X2RhdGFfdGV4dHVyZXM=">这里找到</span>。顶点数据现在包含了顶点位置、法向量和立方体顶点处的纹理坐标。让我们更新顶点着色器来以顶点属性的形式接受纹理坐标，并将它们传递到片段着色器中：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> in vec3 aPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> in vec3 aNormal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> in vec2 aTexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="6"></td><td><pre>out vec2 TexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    TexCoords <span class="token operator">=</span> aTexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>记得去更新两个 VAO 的顶点属性指针来匹配新的顶点数据，并加载箱子图像为一个纹理。在绘制箱子之前，我们希望将要用的纹理单元赋值到 material.diffuse 这个 uniform 采样器，并绑定箱子的纹理到这个纹理单元：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>lightingShader<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token string">"material.diffuse"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glActiveTexture</span><span class="token punctuation">(</span>GL_TEXTURE0<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> diffuseMap<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>使用了漫反射贴图之后，细节再一次得到惊人的提升，这次箱子有了光照开始闪闪发光（字面意思也是）了。你的箱子看起来可能像这样：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/02/04/materials_diffuse_map.png" alt="image"></p><h3 id="镜面光贴图"><a class="anchor" href="#镜面光贴图">#</a> 镜面光贴图</h3><p>你可能会注意到，镜面高光看起来有些奇怪，因为我们的物体大部分都是木头，我们知道木头不应该有这么强的镜面高光的。我们可以将物体的镜面光材质设置为 vec3 (0.0) 来解决这个问题，但这也意味着箱子钢制的边框将不再能够显示镜面高光了，我们知道钢铁应该是有一些镜面高光的。所以，我们想要让物体的某些部分以不同的强度显示镜面高光。这个问题看起来和漫反射贴图非常相似。是巧合吗？我想不是。</p><p>我们同样可以使用一个专门用于镜面高光的纹理贴图。这也就意味着我们需要生成一个黑白的（如果你想得话也可以是彩色的）纹理，来定义物体每部分的镜面光强度。下面是一个<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vYWxsZW5neC9waWNfYmVkL3Jhdy9tYXN0ZXIvaW1nLzAyLzA0L2NvbnRhaW5lcjJfc3BlY3VsYXIucG5n">镜面光贴图</span> (Specular Map) 的例子：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/02/04/container2_specular.png" alt="image"></p><p>镜面高光的强度可以通过图像每个像素的亮度来获取。镜面光贴图上的每个像素都可以由一个颜色向量来表示，比如说黑色代表颜色向量 vec3 (0.0)，灰色代表颜色向量 vec3 (0.5)。在片段着色器中，我们接下来会取样对应的颜色值并将它乘以光源的镜面强度。一个像素越「白」，乘积就会越大，物体的镜面光分量就会越亮。</p><p>由于箱子大部分都由木头所组成，而且木头材质应该没有镜面高光，所以漫反射纹理的整个木头部分全部都转换成了黑色。箱子钢制边框的镜面光强度是有细微变化的，钢铁本身会比较容易受到镜面高光的影响，而裂缝则不会。</p><blockquote><p>从实际角度来说，木头其实也有镜面高光，尽管它的反光度 (Shininess) 很小（更多的光被散射），影响也比较小，但是为了教学目的，我们可以假设木头不会对镜面光有任何反应。</p></blockquote><p>使用 Photoshop 或 Gimp 之类的工具，将漫反射纹理转换为镜面光纹理还是比较容易的，只需要剪切掉一些部分，将图像转换为黑白的，并增加亮度 / 对比度就好了。</p><h3 id="采样镜面光贴图"><a class="anchor" href="#采样镜面光贴图">#</a> 采样镜面光贴图</h3><p>镜面光贴图和其它的纹理非常类似，所以代码也和漫反射贴图的代码很类似。记得要保证正确地加载图像并生成一个纹理对象。由于我们正在同一个片段着色器中使用另一个纹理采样器，我们必须要对镜面光贴图使用一个不同的纹理单元（见纹理），所以我们在渲染之前先把它绑定到合适的纹理单元上：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>lightingShader<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token string">"material.specular"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glActiveTexture</span><span class="token punctuation">(</span>GL_TEXTURE1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> specularMap<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>接下来更新片段着色器的材质属性，让其接受一个 sampler2D 而不是 vec3 作为镜面光分量：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">Material</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    sampler2D diffuse<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    sampler2D specular<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">float</span>     shininess<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>最后我们希望采样镜面光贴图，来获取片段所对应的镜面光强度：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vec3 ambient  <span class="token operator">=</span> light<span class="token punctuation">.</span>ambient  <span class="token operator">*</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token function">texture</span><span class="token punctuation">(</span>material<span class="token punctuation">.</span>diffuse<span class="token punctuation">,</span> TexCoords<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>vec3 diffuse  <span class="token operator">=</span> light<span class="token punctuation">.</span>diffuse  <span class="token operator">*</span> diff <span class="token operator">*</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token function">texture</span><span class="token punctuation">(</span>material<span class="token punctuation">.</span>diffuse<span class="token punctuation">,</span> TexCoords<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="3"></td><td><pre>vec3 specular <span class="token operator">=</span> light<span class="token punctuation">.</span>specular <span class="token operator">*</span> spec <span class="token operator">*</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token function">texture</span><span class="token punctuation">(</span>material<span class="token punctuation">.</span>specular<span class="token punctuation">,</span> TexCoords<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>ambient <span class="token operator">+</span> diffuse <span class="token operator">+</span> specular<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>通过使用镜面光贴图我们可以可以对物体设置大量的细节，比如物体的哪些部分需要有闪闪发光的属性，我们甚至可以设置它们对应的强度。镜面光贴图能够在漫反射贴图之上给予我们更高一层的控制。</p><blockquote><p>如果你想另辟蹊径，你也可以在镜面光贴图中使用真正的颜色，不仅设置每个片段的镜面光强度，还设置了镜面高光的颜色。从现实角度来说，镜面高光的颜色大部分（甚至全部）都是由光源本身所决定的，所以这样并不能生成非常真实的视觉效果（这也是为什么图像通常是黑白的，我们只关心强度）。</p></blockquote><p>如果你现在运行程序的话，你可以清楚地看到箱子的材质现在和真实的钢制边框箱子非常类似了：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/02/04/materials_specular_map.png" alt="image"></p><p>通过使用漫反射和镜面光贴图，我们可以给相对简单的物体添加大量的细节。我们甚至可以使用<mark>法线 / 凹凸贴图</mark> (Normal/Bump Map) 或者<mark>反射贴图</mark> (Reflection Map) 给物体添加更多的细节，但这些将会留到之后的教程中。把你的箱子给你的朋友或者家人看看，并且坚信我们的箱子有一天会比现在更加漂亮！</p><h2 id="投光物"><a class="anchor" href="#投光物">#</a> 投光物</h2><p>我们目前使用的光照都来自于空间中的一个点。它能给我们不错的效果，但现实世界中，我们有很多种类的光照，每种的表现都不同。将光<mark>投射</mark> (Cast) 到物体的光源叫做投光物 (Light Caster)。在这一节中，我们将会讨论几种不同类型的投光物。学会模拟不同种类的光源是又一个能够进一步丰富场景的工具。</p><p>我们首先将会讨论<mark>定向光</mark> (Directional Light)，接下来是<mark>点光源</mark> (Point Light)，它是我们之前学习的光源的拓展，最后我们将会讨论聚光 (Spotlight)。在下一节中我们将讨论如何将这些不同种类的光照类型整合到一个场景之中。</p><h3 id="平行光"><a class="anchor" href="#平行光">#</a> 平行光</h3><p>当一个光源处于很远的地方时，来自光源的每条光线就会近似于互相平行。不论物体和 / 或者观察者的位置，看起来好像所有的<mark>光都来自于同一个方向</mark>。当我们使用一个假设光源处于无限远处的模型时，它就被称为定向光，因为它的所有光线都有着相同的方向，它与光源的位置是没有关系的。</p><p>定向光非常好的一个例子就是太阳。太阳距离我们并不是无限远，但它已经远到在光照计算中可以把它视为无限远了。所以来自太阳的所有光线将被模拟为平行光线，我们可以在下图看到：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/02/05/light_casters_directional.png" alt="image"></p><p>因为所有的光线都是平行的，所以物体与光源的相对位置是不重要的，因为对场景中每一个物体光的方向都是一致的。由于光的位置向量保持一致，场景中每个物体的光照计算将会是类似的。</p><p>我们可以定义一个光线方向向量而不是位置向量来模拟一个定向光。着色器的计算基本保持不变，但这次我们将直接使用光的<mark> direction</mark> 向量而不是通过<mark> direction</mark> 来计算<mark> lightDir</mark> 向量。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">Light</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">//vec3 position; // 使用定向光就不再需要了</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    vec3 direction<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    vec3 ambient<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    vec3 diffuse<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    vec3 specular<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  vec3 lightDir <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token operator">-</span>light<span class="token punctuation">.</span>direction<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>注意我们首先对 light.direction 向量取反。我们目前使用的光照计算需求一个从<mark>片段至光源的光线方向</mark>，但人们更习惯定义定向光为一个从光源出发的全局方向。所以我们需要对全局光照方向向量取反来改变它的方向，它现在是一个指向光源的方向向量了。而且，记得对向量进行标准化，假设输入向量为一个单位向量是很不明智的。</p><p>最终的 lightDir 向量将和以前一样用在<mark>漫反射</mark>和<mark>镜面光</mark>计算中。</p><p>为了清楚地展示定向光对多个物体具有相同的影响，我们将会再次使用坐标系统章节最后的那个箱子派对的场景。如果你错过了派对，我们先定义了十个不同的箱子位置，并对每个箱子都生成了一个不同的模型矩阵，每个模型矩阵都包含了对应的局部 - 世界坐标变换：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    glm<span class="token operator">::</span>mat4 model<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    model <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">translate</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span> cubePositions<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">float</span> angle <span class="token operator">=</span> <span class="token number">20.0f</span> <span class="token operator">*</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    model <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">rotate</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">radians</span><span class="token punctuation">(</span>angle<span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.3f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    lightingShader<span class="token punctuation">.</span><span class="token function">setMat4</span><span class="token punctuation">(</span><span class="token string">"model"</span><span class="token punctuation">,</span> model<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">glDrawArrays</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>同时，不要忘记定义光源的方向（注意我们将方向定义为从光源出发的方向，你可以很容易看到光的方向朝下）。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>lightingShader<span class="token punctuation">.</span><span class="token function">setVec3</span><span class="token punctuation">(</span><span class="token string">"light.direction"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.2f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.3f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>我们一直将光的位置和位置向量定义为 vec3，但一些人会喜欢将所有的向量都定义为 vec4。当我们将位置向量定义为一个 vec4 时，很重要的一点是要将 w 分量设置为 1.0，这样变换和投影才能正确应用。然而，当我们定义一个方向向量为 vec4 的时候，我们不想让位移有任何的效果（因为它仅仅代表的是方向），所以我们将 w 分量设置为 0.0。</p></blockquote><blockquote><p>方向向量就会像这样来表示：vec4 (0.2f, 1.0f, 0.3f, 0.0f)。这也可以作为一个快速检测光照类型的工具：你可以检测 w 分量是否等于 1.0，来检测它是否是光的位置向量；<mark>w 分量等于 0.0，则它是光的方向向量</mark>，这样就能根据这个来调整光照计算了：</p></blockquote><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span>lightVector<span class="token punctuation">.</span>w <span class="token operator">==</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token comment">// 注意浮点数据类型的误差</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token comment">// 执行定向光照计算</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>lightVector<span class="token punctuation">.</span>w <span class="token operator">==</span> <span class="token number">1.0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token comment">// 根据光源的位置做光照计算（与上一节一样）</span></pre></td></tr></table></figure><blockquote><p>你知道吗：这正是旧 OpenGL（固定函数式）决定光源是定向光还是位置光源 (Positional Light Source) 的方法，并根据它来调整光照。</p></blockquote><p>如果你现在编译程序，在场景中自由移动，你就可以看到好像有一个太阳一样的光源对所有的物体投光。你能注意到漫反射和镜面光分量的反应都好像在天空中有一个光源的感觉吗？它会看起来像这样：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/02/05/light_casters_directional_light.png" alt="image"></p><h3 id="点光源"><a class="anchor" href="#点光源">#</a> 点光源</h3><p>定向光对于照亮整个场景的全局光源是非常棒的，但除了定向光之外我们也需要一些分散在场景中的点光源 (Point Light)。点光源是处于世界中某一个位置的光源，它会朝着所有方向发光，但光线会随着距离逐渐衰减。想象作为投光物的灯泡和火把，它们都是点光源。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/02/05/light_casters_point.png" alt="image"></p><p>在之前的教程中，我们一直都在使用一个（简化的）点光源。我们在给定位置有一个光源，它会从它的光源位置开始朝着所有方向散射光线。然而，我们定义的光源模拟的是永远不会衰减的光线，这看起来像是光源亮度非常的强。在大部分的 3D 模拟中，我们都希望模拟的光源仅照亮光源附近的区域而不是整个场景。</p><p>如果你将 10 个箱子加入到上一节光照场景中，你会注意到在最后面的箱子和在灯面前的箱子都以相同的强度被照亮，并没有定义一个公式来将光随距离衰减。我们希望在后排的箱子与前排的箱子相比仅仅是被轻微地照亮。</p><h3 id="衰减"><a class="anchor" href="#衰减">#</a> 衰减</h3><p>随着光线传播距离的增长逐渐削减光的强度通常叫做<mark>衰减</mark> (Attenuation)。随距离减少光强度的一种方式是使用一个线性方程。这样的方程能够随着距离的增长线性地减少光的强度，从而让远处的物体更暗。然而，这样的线性方程通常会看起来比较假。在现实世界中，灯在近处通常会非常亮，但随着距离的增加光源的亮度一开始会下降非常快，但在远处时剩余的光强度就会下降的非常缓慢了。所以，我们需要一个不同的公式来减少光的强度。</p><p>幸运的是一些聪明的人已经帮我们解决了这个问题。下面这个公式根据片段距光源的距离计算了衰减值，之后我们会将它乘以光的强度向量：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mi>a</mi><mi>t</mi><mi>t</mi><mo>=</mo><mfrac><mn>1.0</mn><mrow><msub><mi>K</mi><mi>c</mi></msub><mo>+</mo><msub><mi>K</mi><mi>l</mi></msub><mo>∗</mo><mi>d</mi><mo>+</mo><msub><mi>K</mi><mi>q</mi></msub><mo>∗</mo><msup><mi>d</mi><mn>2</mn></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">Fatt=\frac {1.0}{K_c+K_l*d+K_q*d^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.13889em">F</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:2.293548em;vertical-align:-.972108em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:.07153em">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.07153em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.07153em">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.33610799999999996em"><span style="top:-2.5500000000000003em;margin-left:-.07153em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.01968em">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.07153em">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:-.07153em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03588em">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.740108em"><span style="top:-2.9890000000000003em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.972108em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>在这里 d 代表了片段距光源的<mark>距离</mark>。接下来为了计算衰减值，我们定义 3 个（可配置的）项：常数项 Kc、一次项 Kl 和二次项 Kq。</p><ul><li>常数项通常保持为 1.0，它的主要作用是保证<mark>分母永远不会比 1 小</mark>，否则的话在某些距离上它反而会增加强度，这肯定不是我们想要的效果。</li><li>一次项会与距离值相乘，以线性的方式减少强度。</li><li>二次项会与距离的平方相乘，让光源以二次递减的方式减少强度。二次项在距离比较小的时候影响会比一次项小很多，但当距离值比较大的时候它就会比一次项更大了。</li></ul><p>由于二次项的存在，光线会在大部分时候以线性的方式衰退，直到距离变得足够大，让二次项超过一次项，光的强度会以更快的速度下降。这样的结果就是，光在近距离时亮度很高，但随着距离变远亮度迅速降低，最后会以更慢的速度减少亮度。下面这张图显示了在 100 的距离内衰减的效果：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/02/05/attenuation.png" alt="image"></p><p>你可以看到光在近距离的时候有着最高的强度，但随着距离增长，它的强度明显减弱，并缓慢地在距离大约 100 的时候强度接近 0。这正是我们想要的。</p><h3 id="选择正确的值"><a class="anchor" href="#选择正确的值">#</a> 选择正确的值</h3><p>但是，该对这三个项设置什么值呢？正确地设定它们的值取决于很多因素：环境、希望光覆盖的距离、光的类型等。在大多数情况下，这都是经验的问题，以及适量的调整。下面这个表格显示了模拟一个（大概）真实的，覆盖特定半径（距离）的光源时，这些项可能取的一些值。第一列指定的是在给定的三项时光所能覆盖的距离。这些值是大多数光源很好的起始点，它们由 Ogre3D 的 Wiki 所提供：</p><table><thead><tr><th>距离</th><th>常数项</th><th>一次项</th><th>二次项</th></tr></thead><tbody><tr><td>7</td><td>1.0</td><td>0.7</td><td>1.8</td></tr><tr><td>13</td><td>1.0</td><td>0.35</td><td>0.44</td></tr><tr><td>20</td><td>1.0</td><td>0.22</td><td>0.20</td></tr><tr><td>32</td><td>1.0</td><td>0.14</td><td>0.07</td></tr><tr><td>50</td><td>1.0</td><td>0.09</td><td>0.032</td></tr><tr><td>65</td><td>1.0</td><td>0.07</td><td>0.017</td></tr><tr><td>100</td><td>1.0</td><td>0.045</td><td>0.0075</td></tr><tr><td>160</td><td>1.0</td><td>0.027</td><td>0.0028</td></tr><tr><td>200</td><td>1.0</td><td>0.022</td><td>0.0019</td></tr><tr><td>325</td><td>1.0</td><td>0.014</td><td>0.0007</td></tr><tr><td>600</td><td>1.0</td><td>0.007</td><td>0.0002</td></tr><tr><td>3250</td><td>1.0</td><td>0.0014</td><td>0.000007</td></tr></tbody></table><p>你可以看到，常数项 Kc 在所有的情况下都是 1.0。一次项 Kl 为了覆盖更远的距离通常都很小，二次项 Kq 甚至更小。尝试对这些值进行实验，看看它们在你的实现中有什么效果。在我们的环境中，32 到 100 的距离对大多数的光源都足够了。</p><h3 id="实现衰减"><a class="anchor" href="#实现衰减">#</a> 实现衰减</h3><p>为了实现衰减，在片段着色器中我们还需要三个额外的值：也就是公式中的常数项、一次项和二次项。它们最好储存在之前定义的 Light 结构体中。注意我们使用上一节中计算 lightDir 的方法，而不是上面定向光部分的。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">Light</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    vec3 position<span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    vec3 ambient<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    vec3 diffuse<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    vec3 specular<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">float</span> constant<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">float</span> linear<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">float</span> quadratic<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>然后我们将在 OpenGL 中设置这些项：我们希望光源能够覆盖 50 的距离，所以我们会使用表格中对应的常数项、一次项和二次项：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>lightingShader<span class="token punctuation">.</span><span class="token function">setFloat</span><span class="token punctuation">(</span><span class="token string">"light.constant"</span><span class="token punctuation">,</span>  <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>lightingShader<span class="token punctuation">.</span><span class="token function">setFloat</span><span class="token punctuation">(</span><span class="token string">"light.linear"</span><span class="token punctuation">,</span>    <span class="token number">0.09f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>lightingShader<span class="token punctuation">.</span><span class="token function">setFloat</span><span class="token punctuation">(</span><span class="token string">"light.quadratic"</span><span class="token punctuation">,</span> <span class="token number">0.032f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在片段着色器中实现衰减还是比较直接的：我们根据公式计算衰减值，之后再分别乘以环境光、漫反射和镜面光分量。</p><p>我们仍需要公式中距光源的距离，还记得我们是怎么计算一个向量的长度的吗？我们可以通过获取片段和光源之间的向量差，并获取结果向量的长度作为距离项。我们可以使用 GLSL 内建的 length 函数来完成这一点：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> distance    <span class="token operator">=</span> <span class="token function">length</span><span class="token punctuation">(</span>light<span class="token punctuation">.</span>position <span class="token operator">-</span> FragPos<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">float</span> attenuation <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token punctuation">(</span>light<span class="token punctuation">.</span>constant <span class="token operator">+</span> light<span class="token punctuation">.</span>linear <span class="token operator">*</span> distance <span class="token operator">+</span> light<span class="token punctuation">.</span>quadratic <span class="token operator">*</span> <span class="token punctuation">(</span>distance <span class="token operator">*</span> distance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>接下来，我们将包含这个衰减值到光照计算中，将它分别乘以环境光、漫反射和镜面光颜色。</p><blockquote><p>我们可以将环境光分量保持不变，让环境光照不会随着距离减少，但是如果我们使用多于一个的光源，所有的环境光分量将会开始叠加，所以在这种情况下我们也希望衰减环境光照。简单实验一下，看看什么才能在你的环境中效果最好。</p></blockquote><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>ambient  <span class="token operator">*=</span> attenuation<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre>diffuse  <span class="token operator">*=</span> attenuation<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>specular <span class="token operator">*=</span> attenuation<span class="token punctuation">;</span></pre></td></tr></table></figure><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/02/05/light_casters_point_light.png" alt="image"></p><p>你可以看到，只有前排的箱子被照亮的，距离最近的箱子是最亮的。后排的箱子一点都没有照亮，因为它们离光源实在是太远了。你可以在这里找到程序的代码。</p><p>点光源就是一个能够配置位置和衰减的光源。它是我们光照工具箱中的又一个光照类型。</p><h3 id="聚光"><a class="anchor" href="#聚光">#</a> 聚光</h3><p>我们要讨论的最后一种类型的光是<mark>聚光</mark> (Spotlight)。聚光是位于环境中某个位置的光源，它只朝一个特定方向而不是所有方向照射光线。这样的结果就是只有在聚光方向的特定半径内的物体才会被照亮，其它的物体都会保持黑暗。聚光很好的例子就是路灯或手电筒。</p><p>OpenGL 中聚光是用一个世界空间位置、一个方向和一个切光角 (Cutoff Angle) 来表示的，切光角指定了聚光的半径（译注：是圆锥的半径不是距光源距离那个半径）。对于每个片段，我们会计算片段是否位于聚光的切光方向之间（也就是在锥形内），如果是的话，我们就会相应地照亮片段。下面这张图会让你明白聚光是如何工作的：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/02/05/light_casters_spotlight_angles.png" alt="image"></p><ul><li><mark>LightDir</mark>：从片段指向光源的向量。</li><li><mark>SpotDir</mark>：聚光所指向的方向。</li><li><mark>Phiϕ</mark>：指定了聚光半径的切光角。落在这个角度之外的物体都不会被这个聚光所照亮。</li><li><mark>Thetaθ</mark>：LightDir 向量和 SpotDir 向量之间的夹角。在聚光内部的话 θ 值应该比 ϕ 值小。</li></ul><p>所以我们要做的就是计算<mark> LightDir</mark> 向量和<mark> SpotDir</mark> 向量之间的点积（还记得它会返回两个单位向量夹角的余弦值吗？），并将它与切光角 ϕ 值对比。你现在应该了解聚光究竟是什么了，下面我们将以手电筒的形式创建一个聚光。</p><h3 id="手电筒"><a class="anchor" href="#手电筒">#</a> 手电筒</h3><p><mark>手电筒</mark> (Flashlight) 是一个位于观察者位置的聚光，通常它都会瞄准玩家视角的正前方。基本上说，手电筒就是普通的聚光，但它的位置和方向会随着玩家的位置和朝向不断更新。</p><p>所以，在片段着色器中我们需要的值有聚光的位置向量（来计算光的方向向量）、聚光的方向向量和一个切光角。我们可以将它们储存在 Light 结构体中：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">Light</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    vec3  position<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    vec3  direction<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">float</span> cutOff<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>接下来我们将合适的值传到着色器中：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>lightingShader<span class="token punctuation">.</span><span class="token function">setVec3</span><span class="token punctuation">(</span><span class="token string">"light.position"</span><span class="token punctuation">,</span>  camera<span class="token punctuation">.</span>Position<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>lightingShader<span class="token punctuation">.</span><span class="token function">setVec3</span><span class="token punctuation">(</span><span class="token string">"light.direction"</span><span class="token punctuation">,</span> camera<span class="token punctuation">.</span>Front<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>lightingShader<span class="token punctuation">.</span><span class="token function">setFloat</span><span class="token punctuation">(</span><span class="token string">"light.cutOff"</span><span class="token punctuation">,</span>   glm<span class="token operator">::</span><span class="token function">cos</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">radians</span><span class="token punctuation">(</span><span class="token number">12.5f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>你可以看到，我们并没有给切光角设置一个角度值，反而是用角度值计算了一个余弦值，将余弦结果传递到片段着色器中。这样做的原因是在片段着色器中，我们会计算<mark> LightDir</mark> 和<mark> SpotDir</mark> 向量的<mark>点积</mark>，这个点积返回的将是一个余弦值而不是角度值，所以我们不能直接使用角度值和余弦值进行比较。为了获取角度值我们需要计算点积结果的反余弦，这是一个开销很大的计算。所以为了节约一点性能开销，我们将会计算切光角对应的余弦值，并将它的结果传入片段着色器中。由于这两个角度现在都由余弦角来表示了，我们可以直接对它们进行比较而不用进行任何开销高昂的计算。</p><p>接下来就是计算 θ 值，并将它和切光角 ϕ 对比，来决定是否在聚光的内部：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> theta <span class="token operator">=</span> <span class="token function">dot</span><span class="token punctuation">(</span>lightDir<span class="token punctuation">,</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token operator">-</span>light<span class="token punctuation">.</span>direction<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span>theta <span class="token operator">></span> light<span class="token punctuation">.</span>cutOff<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span>       </pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token comment">// 执行光照计算</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">else</span>  <span class="token comment">// 否则，使用环境光，让场景在聚光之外时不至于完全黑暗</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  color <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>light<span class="token punctuation">.</span>ambient <span class="token operator">*</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token function">texture</span><span class="token punctuation">(</span>material<span class="token punctuation">.</span>diffuse<span class="token punctuation">,</span> TexCoords<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>我们首先计算了 lightDir 和取反的 direction 向量（取反的是因为我们想让向量指向光源而不是从光源出发）之间的点积。记住要对所有的相关向量标准化。</p><blockquote><p>你可能奇怪为什么在 if 条件中使用的是 &gt; 符号而不是 &lt; 符号。theta 不应该比光的切光角更小才是在聚光内部吗？这并没有错，但不要忘记角度值现在都由余弦值来表示的。一个 0 度的角度表示的是 1.0 的余弦值，而一个 90 度的角度表示的是 0.0 的余弦值，你可以在下图中看到：</p></blockquote><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/02/05/light_casters_cos.png" alt="image"></p><blockquote><p>你现在可以看到，余弦值越接近 1.0，它的角度就越小。这也就解释了为什么 theta 要比切光值更大了。切光值目前设置为 12.5 的余弦，约等于 0.9978，所以在 0.9979 到 1.0 内的 theta 值才能保证片段在聚光内，从而被照亮。</p></blockquote><h3 id="平滑软化边缘"><a class="anchor" href="#平滑软化边缘">#</a> 平滑 / 软化边缘</h3><p>为了创建一种看起来边缘平滑的聚光，我们需要模拟聚光有一个<mark>内圆锥</mark> (Inner Cone) 和一个<mark>外圆锥</mark> (Outer Cone)。我们可以将内圆锥设置为上一部分中的那个圆锥，但我们也需要一个外圆锥，来让光从内圆锥逐渐减暗，直到外圆锥的边界。</p><p>为了创建一个外圆锥，我们只需要再定义一个余弦值来代表聚光方向向量和外圆锥向量（等于它的半径）的夹角。然后，如果一个片段处于内外圆锥之间，将会给它计算出一个 0.0 到 1.0 之间的强度值。如果片段在内圆锥之内，它的强度就是 1.0，如果在外圆锥之外强度值就是 0.0。</p><p>我们可以用下面这个公式来计算这个值：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>I</mi><mo>=</mo><mfrac><mrow><mi>θ</mi><mo>−</mo><mi>γ</mi></mrow><mi>ϵ</mi></mfrac></mrow><annotation encoding="application/x-tex">I=\frac{θ-γ}ϵ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.07847em">I</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:2.0574399999999997em;vertical-align:-.686em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord mathnormal">ϵ</span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.02778em">θ</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord mathnormal" style="margin-right:.05556em">γ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.686em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>这里 ϵ(Epsilon) 是内（ϕ）和外圆锥（γ）之间的余弦值差（ϵ=ϕ−γ）。最终的 I 值就是在当前片段聚光的强度。</p><p>很难去表现这个公式是怎么工作的，所以我们用一些实例值来看看：</p><table><thead><tr><th>θ</th><th>θ（角度）</th><th>ϕ（内光切）</th><th>ϕ（角度）</th><th>γ（外光切）</th><th>γ（角度）</th><th>ϵ</th><th>I</th></tr></thead><tbody><tr><td>0.87</td><td>30</td><td>0.91</td><td>25</td><td>0.82</td><td>35</td><td>0.91 - 0.82 = 0.09</td><td>0.87 - 0.82 / 0.09 = 0.56</td></tr><tr><td>0.9</td><td>26</td><td>0.91</td><td>25</td><td>0.82</td><td>35</td><td>0.91 - 0.82 = 0.09</td><td>0.9 - 0.82 / 0.09 = 0.89</td></tr><tr><td>0.97</td><td>14</td><td>0.91</td><td>25</td><td>0.82</td><td>35</td><td>0.91 - 0.82 = 0.09</td><td>0.97 - 0.82 / 0.09 = 1.67</td></tr><tr><td>0.83</td><td>34</td><td>0.91</td><td>25</td><td>0.82</td><td>35</td><td>0.91 - 0.82 = 0.09</td><td>0.83 - 0.82 / 0.09 = 0.11</td></tr><tr><td>0.64</td><td>50</td><td>0.91</td><td>25</td><td>0.82</td><td>35</td><td>0.91 - 0.82 = 0.09</td><td>0.64 - 0.82 / 0.09 = -2.0</td></tr><tr><td>0.966</td><td>15</td><td>0.9978</td><td>12.5</td><td>0.953</td><td>17.5</td><td>0.966 - 0.953 = 0.0448</td><td>0.966 - 0.953 / 0.0448 = 0.29</td></tr></tbody></table><p>你可以看到，我们基本是在内外余弦值之间根据 θ 插值。如果你仍不明白发生了什么，不必担心，只需要记住这个公式就好了，在你更聪明的时候再回来看看。</p><p>我们现在有了一个在聚光外是负的，在内圆锥内大于 1.0 的，在边缘处于两者之间的强度值了。如果我们正确地约束 (Clamp) 这个值，在片段着色器中就不再需要 if-else 了，我们能够使用计算出来的强度值直接乘以光照分量：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> theta     <span class="token operator">=</span> <span class="token function">dot</span><span class="token punctuation">(</span>lightDir<span class="token punctuation">,</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token operator">-</span>light<span class="token punctuation">.</span>direction<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">float</span> epsilon   <span class="token operator">=</span> light<span class="token punctuation">.</span>cutOff <span class="token operator">-</span> light<span class="token punctuation">.</span>outerCutOff<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">float</span> intensity <span class="token operator">=</span> <span class="token function">clamp</span><span class="token punctuation">(</span><span class="token punctuation">(</span>theta <span class="token operator">-</span> light<span class="token punctuation">.</span>outerCutOff<span class="token punctuation">)</span> <span class="token operator">/</span> epsilon<span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 将不对环境光做出影响，让它总是能有一点光</span></pre></td></tr><tr><td data-num="6"></td><td><pre>diffuse  <span class="token operator">*=</span> intensity<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>specular <span class="token operator">*=</span> intensity<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr></table></figure><p>注意我们使用了 clamp 函数，它把第一个参数约束 (Clamp) 在了 0.0 到 1.0 之间。这保证强度值不会在 [0, 1] 区间之外。</p><p>确定你将 outerCutOff 值添加到了 Light 结构体之中，并在程序中设置它的 uniform 值。下面的图片中，我们使用的内切光角是 12.5，外切光角是 17.5：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/02/05/light_casters_spotlight.png" alt="image"></p><p>啊，这样看起来就好多了。稍微对内外切光角实验一下，尝试创建一个更能符合你需求的聚光。你可以在这里找到程序的源码。</p><p>这样的手电筒 / 聚光类型的灯光非常适合恐怖游戏，结合定向光和点光源，环境就会开始被照亮了。在下一节的教程中，我们将会结合我们至今讨论的所有光照和技巧。</p><h3 id="多光源"><a class="anchor" href="#多光源">#</a> 多光源</h3><p>我们在前面的教程中已经学习了许多关于 OpenGL 中光照的知识，其中包<mark>括冯氏着色</mark> (Phong Shading)、<mark>材质</mark> (Material)、<mark>光照贴图</mark> (Lighting Map) 以及不同种类的投光物 (Light Caster)。在这一节中，我们将结合之前学过的所有知识，创建一个包含六个光源的场景。我们将模拟一个类似太阳的<mark>定向光</mark> (Directional Light) 光源，四个分散在场景中的<mark>点光源</mark> (Point Light)，以及一个<mark>手电筒</mark> (Flashlight)。</p><p>为了在场景中使用多个光源，我们希望将光照计算封装到 GLSL 函数中。这样做的原因是，每一种光源都需要一种不同的计算方法，而一旦我们想对多个光源进行光照计算时，代码很快就会变得非常复杂。如果我们只在 main 函数中进行所有的这些计算，代码很快就会变得难以理解。</p><p>GLSL 中的函数和 C 函数很相似，它有一个函数名、一个返回值类型，如果函数不是在 main 函数之前声明的，我们还必须在代码文件顶部声明一个原型。我们对每个光照类型都创建一个不同的函数：定向光、点光源和聚光。</p><p>当我们在场景中使用多个光源时，通常使用以下方法：我们需要有一个单独的颜色向量代表片段的输出颜色。对于每一个光源，它对片段的贡献颜色将会加到片段的输出颜色向量上。所以场景中的每个光源都会计算它们各自对片段的影响，并结合为一个最终的输出颜色。大体的结构会像是这样：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>out vec4 FragColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token comment">// 定义一个输出颜色值</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  vec3 output<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token comment">// 将定向光的贡献加到输出中</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  output <span class="token operator">+=</span> <span class="token function">someFunctionToCalculateDirectionalLight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token comment">// 对所有的点光源也做相同的事情</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nr_of_point_lights<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    output <span class="token operator">+=</span> <span class="token function">someFunctionToCalculatePointLight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token comment">// 也加上其它的光源（比如聚光）</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  output <span class="token operator">+=</span> <span class="token function">someFunctionToCalculateSpotLight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>  FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>实际的代码对每一种实现都可能不同，但大体的结构都是差不多的。我们定义了几个函数，用来计算每个光源的影响，并将最终的结果颜色加到输出颜色向量上。例如，如果两个光源都很靠近一个片段，那么它们所结合的贡献将会形成一个比单个光源照亮时更加明亮的片段。</p><h3 id="定向光"><a class="anchor" href="#定向光">#</a> 定向光</h3><p>我么需要在片段着色器中定义一个函数来计算定向光对相应片段的贡献：它接受一些参数并计算一个定向光照颜色。</p><p>首先，我们需要定义一个定向光源最少所需要的变量。我们可以将这些变量储存在一个叫做 DirLight 的结构体中，并将它定义为一个 uniform。需要的变量在上一节中都介绍过：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">DirLight</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    vec3 direction<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    vec3 ambient<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    vec3 diffuse<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    vec3 specular<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="8"></td><td><pre>uniform DirLight dirLight<span class="token punctuation">;</span></pre></td></tr></table></figure><p>接下来我们可以将 dirLight 传入一个有着一下原型的函数。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vec3 <span class="token function">CalcDirLight</span><span class="token punctuation">(</span>DirLight light<span class="token punctuation">,</span> vec3 normal<span class="token punctuation">,</span> vec3 viewDir<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>和 C/C++ 一样，如果我们想调用一个函数（这里是在 main 函数中调用），这个函数需要在调用者的行数之前被定义过。在这个例子中我们更喜欢在 main 函数以下定义函数，所以上面要求就不满足了。所以，我们需要在 main 函数之上定义函数的原型，这和 C 语言中是一样的。</p><p>你可以看到，这个函数需要一个 DirLight 结构体和其它两个向量来进行计算。如果你认真完成了上一节的话，这个函数的内容应该理解起来很容易：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vec3 <span class="token function">CalcDirLight</span><span class="token punctuation">(</span>DirLight light<span class="token punctuation">,</span> vec3 normal<span class="token punctuation">,</span> vec3 viewDir<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    vec3 lightDir <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token operator">-</span>light<span class="token punctuation">.</span>direction<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 漫反射着色</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">float</span> diff <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>normal<span class="token punctuation">,</span> lightDir<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 镜面光着色</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    vec3 reflectDir <span class="token operator">=</span> <span class="token function">reflect</span><span class="token punctuation">(</span><span class="token operator">-</span>lightDir<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">float</span> spec <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>viewDir<span class="token punctuation">,</span> reflectDir<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> material<span class="token punctuation">.</span>shininess<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// 合并结果</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    vec3 ambient  <span class="token operator">=</span> light<span class="token punctuation">.</span>ambient  <span class="token operator">*</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token function">texture</span><span class="token punctuation">(</span>material<span class="token punctuation">.</span>diffuse<span class="token punctuation">,</span> TexCoords<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    vec3 diffuse  <span class="token operator">=</span> light<span class="token punctuation">.</span>diffuse  <span class="token operator">*</span> diff <span class="token operator">*</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token function">texture</span><span class="token punctuation">(</span>material<span class="token punctuation">.</span>diffuse<span class="token punctuation">,</span> TexCoords<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    vec3 specular <span class="token operator">=</span> light<span class="token punctuation">.</span>specular <span class="token operator">*</span> spec <span class="token operator">*</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token function">texture</span><span class="token punctuation">(</span>material<span class="token punctuation">.</span>specular<span class="token punctuation">,</span> TexCoords<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">return</span> <span class="token punctuation">(</span>ambient <span class="token operator">+</span> diffuse <span class="token operator">+</span> specular<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>我们基本上只是从上一节中复制了代码，并使用函数参数的两个向量来计算定向光的贡献向量。最终环境光、漫反射和镜面光的贡献将会合并为单个颜色向量返回。</p><h3 id="点光源-2"><a class="anchor" href="#点光源-2">#</a> 点光源</h3><p>和定向光一样，我们也希望定义一个用于计算点光源对相应片段贡献，以及衰减，的函数。同样，我们定义一个包含了点光源所需所有变量的结构体：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">PointLight</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    vec3 position<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">float</span> constant<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">float</span> linear<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">float</span> quadratic<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    vec3 ambient<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    vec3 diffuse<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    vec3 specular<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">NR_POINT_LIGHTS <span class="token number">4</span></span></span></pre></td></tr><tr><td data-num="13"></td><td><pre>uniform PointLight pointLights<span class="token punctuation">[</span>NR_POINT_LIGHTS<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>你可以看到，我们在 GLSL 中使用了预处理指令来定义了我们场景中点光源的数量。接着我们使用了这个<mark> NR_POINT_LIGHTS</mark> 常量来创建了一个<mark> PointLight</mark> 结构体的数组。GLSL 中的数组和 C 数组一样，可以使用一对方括号来创建。现在我们有四个待填充数据的 PointLight 结构体。</p><blockquote><p>我们也可以定义一个大的结构体（而不是为每种类型的光源定义不同的结构体），包含所有不同种光照类型所需的变量，并将这个结构体用到所有的函数中，只需要忽略用不到的变量就行了。然而，我个人觉得当前的方法会更直观一点，不仅能够节省一些代码，而且由于不是所有光照类型都需要所有的变量，这样也能节省一些内存。</p></blockquote><p>点光源函数的原型如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vec3 <span class="token function">CalcPointLight</span><span class="token punctuation">(</span>PointLight light<span class="token punctuation">,</span> vec3 normal<span class="token punctuation">,</span> vec3 fragPos<span class="token punctuation">,</span> vec3 viewDir<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这个函数从参数中获取所需的所有数据，并返回一个代表该点光源对片段的颜色贡献的 vec3。我们再一次聪明地从之前的教程中复制粘贴代码，完成了下面这样的函数：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vec3 <span class="token function">CalcPointLight</span><span class="token punctuation">(</span>PointLight light<span class="token punctuation">,</span> vec3 normal<span class="token punctuation">,</span> vec3 fragPos<span class="token punctuation">,</span> vec3 viewDir<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    vec3 lightDir <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>light<span class="token punctuation">.</span>position <span class="token operator">-</span> fragPos<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 漫反射着色</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">float</span> diff <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>normal<span class="token punctuation">,</span> lightDir<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 镜面光着色</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    vec3 reflectDir <span class="token operator">=</span> <span class="token function">reflect</span><span class="token punctuation">(</span><span class="token operator">-</span>lightDir<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">float</span> spec <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>viewDir<span class="token punctuation">,</span> reflectDir<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> material<span class="token punctuation">.</span>shininess<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// 衰减</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">float</span> distance    <span class="token operator">=</span> <span class="token function">length</span><span class="token punctuation">(</span>light<span class="token punctuation">.</span>position <span class="token operator">-</span> fragPos<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">float</span> attenuation <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token punctuation">(</span>light<span class="token punctuation">.</span>constant <span class="token operator">+</span> light<span class="token punctuation">.</span>linear <span class="token operator">*</span> distance <span class="token operator">+</span> </pre></td></tr><tr><td data-num="12"></td><td><pre>                 light<span class="token punctuation">.</span>quadratic <span class="token operator">*</span> <span class="token punctuation">(</span>distance <span class="token operator">*</span> distance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">// 合并结果</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    vec3 ambient  <span class="token operator">=</span> light<span class="token punctuation">.</span>ambient  <span class="token operator">*</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token function">texture</span><span class="token punctuation">(</span>material<span class="token punctuation">.</span>diffuse<span class="token punctuation">,</span> TexCoords<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    vec3 diffuse  <span class="token operator">=</span> light<span class="token punctuation">.</span>diffuse  <span class="token operator">*</span> diff <span class="token operator">*</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token function">texture</span><span class="token punctuation">(</span>material<span class="token punctuation">.</span>diffuse<span class="token punctuation">,</span> TexCoords<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    vec3 specular <span class="token operator">=</span> light<span class="token punctuation">.</span>specular <span class="token operator">*</span> spec <span class="token operator">*</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token function">texture</span><span class="token punctuation">(</span>material<span class="token punctuation">.</span>specular<span class="token punctuation">,</span> TexCoords<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    ambient  <span class="token operator">*=</span> attenuation<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    diffuse  <span class="token operator">*=</span> attenuation<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    specular <span class="token operator">*=</span> attenuation<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">return</span> <span class="token punctuation">(</span>ambient <span class="token operator">+</span> diffuse <span class="token operator">+</span> specular<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>将这些功能抽象到这样一个函数中的优点是，我们能够不用重复的代码而很容易地计算多个点光源的光照了。在 main 函数中，我们只需要创建一个循环，遍历整个点光源数组，对每个点光源调用<mark> CalcPointLight</mark> 就可以了。</p><h3 id="合并结果"><a class="anchor" href="#合并结果">#</a> 合并结果</h3><p>现在我们已经定义了一个计算定向光的函数和一个计算点光源的函数了，我们可以将它们合并放到 main 函数中。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 属性</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    vec3 norm <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>Normal<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    vec3 viewDir <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>viewPos <span class="token operator">-</span> FragPos<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// 第一阶段：定向光照</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    vec3 result <span class="token operator">=</span> <span class="token function">CalcDirLight</span><span class="token punctuation">(</span>dirLight<span class="token punctuation">,</span> norm<span class="token punctuation">,</span> viewDir<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// 第二阶段：点光源</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NR_POINT_LIGHTS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        result <span class="token operator">+=</span> <span class="token function">CalcPointLight</span><span class="token punctuation">(</span>pointLights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> norm<span class="token punctuation">,</span> FragPos<span class="token punctuation">,</span> viewDir<span class="token punctuation">)</span><span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">// 第三阶段：聚光</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">//result += CalcSpotLight(spotLight, norm, FragPos, viewDir);    </span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>每个光源类型都将它们的贡献加到了最终的输出颜色上，直到所有的光源都处理完了。最终的颜色包含了场景中所有光源的颜色影响所合并的结果。如果你想的话，你也可以实现一个聚光，并将它的效果加到输出颜色中。我们会将 CalcSpotLight 函数留给读者作为练习。</p><p>设置定向光结构体的 uniform 应该非常熟悉了，但是你可能会在想我们该如何设置点光源的 uniform 值，因为点光源的 uniform 现在是一个 PointLight 的数组了。这并不是我们以前讨论过的话题。</p><p>很幸运的是，这并不是很复杂，设置一个结构体数组的 uniform 和设置一个结构体的 uniform 是很相似的，但是这一次在访问 uniform 位置的时候，我们需要定义对应的数组下标值：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>lightingShader<span class="token punctuation">.</span><span class="token function">setFloat</span><span class="token punctuation">(</span><span class="token string">"pointLights[0].constant"</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在这里我们索引了 pointLights 数组中的第一个 PointLight，并获取了 constant 变量的位置。但这也意味着不幸的是我们必须对这四个点光源手动设置 uniform 值，这让点光源本身就产生了 28 个 uniform 调用，非常冗长。你也可以尝试将这些抽象出去一点，定义一个点光源类，让它来为你设置 uniform 值，但最后你仍然要用这种方式设置所有光源的 uniform 值。</p><p>别忘了，我们还需要为每个点光源定义一个位置向量，所以我们让它们在场景中分散一点。我们会定义另一个 glm::vec3 数组来包含点光源的位置：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span>vec3 pointLightPositions<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span> <span class="token number">0.7f</span><span class="token punctuation">,</span>  <span class="token number">0.2f</span><span class="token punctuation">,</span>  <span class="token number">2.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span> <span class="token number">2.3f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3.3f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">4.0f</span><span class="token punctuation">,</span>  <span class="token number">2.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">12.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>  <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3.0f</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>接下来我们从 pointLights 数组中索引对应的 PointLight，将它的 position 值设置为刚刚定义的位置值数组中的其中一个。同时我们还要保证现在绘制的是四个灯立方体而不是仅仅一个。只要对每个灯物体创建一个不同的模型矩阵就可以了，和我们之前对箱子的处理类似。</p><p>如果你还使用了手电筒的话，所有光源组合的效果将看起来和下图差不多：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/02/06/multiple_lights_combined.png" alt="image"></p><p>你可以看到，很显然天空中有一个全局照明（像一个太阳），我们有四个光源分散在场景中，以及玩家视角的手电筒。看起来是不是非常不错？</p><p>上面图片中的所有光源都是使用上一节中所使用的默认属性，但如果你愿意实验这些数值的话，你能够得到很多有意思的结果。艺术家和关卡设计师通常都在编辑器中不断的调整这些光照参数，保证光照与环境相匹配。在我们刚刚创建的简单光照环境中，你可以简单地调整一下光源的属性，创建很多有意思的视觉效果：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/02/06/multiple_lights_atmospheres.png" alt="image"></p><p>上图四种效果<span class="exturl" data-url="aHR0cHM6Ly9sZWFybm9wZW5nbC5jb20vY29kZV92aWV3ZXIucGhwP2NvZGU9bGlnaHRpbmcvbXVsdGlwbGVfbGlnaHRzLWV4ZXJjaXNlMg==">参数代码</span></p><p>我们也改变了清屏的颜色来更好地反应光照。你可以看到，只需要简单地调整一些光照参数，你就能创建完全不同的氛围。</p><p>相信你现在已经对 OpenGL 的光照有很好的理解了。有了目前所学的这些知识，我们已经可以创建出丰富有趣的环境和氛围了。尝试实验一下不同的值，创建出你自己的氛围吧。</p><h2 id="复习"><a class="anchor" href="#复习">#</a> 复习</h2><p>恭喜您已经学习到了这个地方！辛苦啦！不知道你有没有注意到，总的来说我们在学习光照教程的时候关于 OpenGL 本身并没有什么新东西，除了想访问 uniform 数组这样细枝末节的知识。目前为止的所有教程都是关于使用一些技巧或者公式来操作着色器，达到真实的光照效果。这再一次想你展示了着色器的威力。着色器是非常灵活的，你也亲眼见证了我们仅仅使用一些 3D 向量和可配置的变量就能够创造出惊人的图像这一点。</p><p>在前面的几个教程中，你学习了颜色、冯氏光照模型（包括环境光照、漫反射光照和镜面光照）、物体的材质、可配置的光照属性、漫反射和镜面光贴图、不同种类的光，并且学习了怎样将所有所学知识融会贯通，合并到一个程序当中。记得去实验一下不同的光照、材质颜色、光照属性，并且试着利用你无穷的创造力创建自己的环境。</p><p>在下一节当中，我们在我们的场景当中加入更高级的形状，这些形状将会在我们之前讨论过的光照模型中非常好看。</p><h3 id="词汇表"><a class="anchor" href="#词汇表">#</a> 词汇表</h3><ul><li><mark>颜色向量 (Color Vector)</mark>：一个通过红绿蓝 (RGB) 分量的组合描绘大部分真实颜色的向量。一个物体的颜色实际上是该物体所不能吸收的反射颜色分量。</li><li><mark>冯氏光照模型 (Phong Lighting Model)</mark>：一个通过计算环境光，漫反射，和镜面光分量的值来估计真实光照的模型。</li><li><mark>环境光照 (Ambient Lighting)</mark>：通过给每个没有被光照的物体很小的亮度，使其不是完全黑暗的，从而对全局光照进行估计。</li><li><mark>漫反射着色 (Diffuse Shading)</mark>：一个顶点 / 片段与光线方向越接近，光照会越强。使用了法向量来计算角度。</li><li><mark>法向量 (Normal Vector)</mark>：一个垂直于平面的单位向量。</li><li><mark>法线矩阵 (Normal Matrix)</mark>：一个 3x3 矩阵，或者说是没有平移的模型（或者模型 - 观察）矩阵。它也被以某种方式修改（逆转置），从而在应用非统一缩放时，保持法向量朝向正确的方向。否则法向量会在使用非统一缩放时被扭曲。</li><li><mark>镜面光照 (Specular Lighting)</mark>：当观察者视线靠近光源在表面的反射线时会显示的镜面高光。镜面光照是由观察者的方向，光源的方向和设定高光分散量的反光度值三个量共同决定的。</li><li><mark>冯氏着色 (Phong Shading)</mark>：冯氏光照模型应用在片段着色器。</li><li><mark>Gouraud 着色 (Gouraud shading)</mark>：冯氏光照模型应用在顶点着色器上。在使用很少数量的顶点时会产生明显的瑕疵。会得到效率提升但是损失了视觉质量。</li><li><mark>GLSL 结构体 (GLSL struct)</mark>：一个类似于 C 的结构体，用作着色器变量的容器。大部分时间用来管理输入 / 输出 /uniform。</li><li><mark>材质 (Material)</mark>：一个物体反射的环境光，漫反射，镜面光颜色。这些东西设定了物体所拥有的颜色。</li><li><mark>光照属性 (Light (properties))</mark>：一个光的环境光，漫反射，镜面光的强度。可以使用任何颜色值，对每一个冯氏分量 (Phong Component) 定义光源发出的颜色 / 强度。</li><li><mark>漫反射贴图 (Diffuse Map)</mark>：一个设定了每个片段中漫反射颜色的纹理图片。</li><li><mark>镜面光贴图 (Specular Map)</mark>：一个设定了每一个片段的镜面光强度 / 颜色的纹理贴图。仅在物体的特定区域显示镜面高光。</li><li><mark>定向光 (Directional Light)</mark>：只有一个方向的光源。它被建模为不管距离有多长所有光束都是平行而且其方向向量在整个场景中保持不变。</li><li><mark>点光源 (Point Light)</mark>：一个在场景中有位置的，光线逐渐衰减的光源。</li><li><mark>衰减 (Attenuation)</mark>：光随着距离减少强度的过程，通常使用在点光源和聚光下。</li><li><mark>聚光 (Spotlight)</mark>：一个被定义为在某一个方向上的锥形的光源。</li><li><mark>手电筒 (Flashlight)</mark>：一个摆放在观察者视角的聚光。</li><li><mark>GLSL uniform 数组 (GLSL Uniform Array)</mark>：一个 uniform 值数组。它的工作原理和 C 语言数组大致一样，只是不能动态分配内存。</li></ul></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2020-10-26 10:33:45" itemprop="dateModified" datetime="2020-10-26T10:33:45+08:00">2020-10-26</time> </span><span id="computer-science/study/opengl/3-OpenGL-Lighting/" class="item leancloud_visitors" data-flag-title="二、OpenGL光照" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 充电</button><p>请我[恰饭]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="鑫酱(●'◡'●) 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="鑫酱(●'◡'●) 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>鑫酱(●'◡'●) <i class="ic i-at"><em>@</em></i>鑫酱</li><li class="link"><strong>本文链接：</strong> <a href="https://allengx.gitee.io/computer-science/study/opengl/3-OpenGL-Lighting/" title="二、OpenGL光照">https://allengx.gitee.io/computer-science/study/opengl/3-OpenGL-Lighting/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/computer-science/study/opengl/1-OpenGL-Introduction/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclhfehz7j20zk0m8u0x.jpg" title="一、OpenGL入门"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> OpenGL</span><h3>一、OpenGL入门</h3></a></div><div class="item right"><a href="/computer-science/study/opengl/2-OpenGL-Load-Model/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicivghyooj20zk0m8dir.jpg" title="三、OpenGL模型加载"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> OpenGL</span><h3>三、OpenGL模型加载</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%89%E7%85%A7"><span class="toc-number">1.</span> <span class="toc-text">光照</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%9C%E8%89%B2"><span class="toc-number">1.1.</span> <span class="toc-text">颜色</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%85%89%E7%85%A7%E5%9C%BA%E6%99%AF"><span class="toc-number">1.1.1.</span> <span class="toc-text">创建一个光照场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7"><span class="toc-number">1.2.</span> <span class="toc-text">基础光照</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7"><span class="toc-number">1.2.1.</span> <span class="toc-text">环境光照</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%AB%E5%8F%8D%E5%B0%84%E5%85%89%E7%85%A7"><span class="toc-number">1.2.2.</span> <span class="toc-text">漫反射光照</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%95%E5%90%91%E9%87%8F"><span class="toc-number">1.2.3.</span> <span class="toc-text">法向量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%BC%AB%E5%8F%8D%E5%B0%84%E5%85%89%E7%85%A7"><span class="toc-number">1.2.4.</span> <span class="toc-text">计算漫反射光照</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E4%B8%80%E4%BB%B6%E4%BA%8B"><span class="toc-number">1.2.5.</span> <span class="toc-text">最后一件事</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E9%9D%A2%E5%85%89%E7%85%A7"><span class="toc-number">1.2.6.</span> <span class="toc-text">镜面光照</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%90%E8%B4%A8"><span class="toc-number">1.3.</span> <span class="toc-text">材质</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%9D%90%E8%B4%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">设置材质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%89%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.2.</span> <span class="toc-text">光的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E5%85%89%E6%BA%90%E9%A2%9C%E8%89%B2"><span class="toc-number">1.3.3.</span> <span class="toc-text">不同的光源颜色</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%89%E7%85%A7%E8%B4%B4%E5%9B%BE"><span class="toc-number">1.4.</span> <span class="toc-text">光照贴图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%AB%E5%8F%8D%E5%B0%84%E8%B4%B4%E5%9B%BE"><span class="toc-number">1.4.1.</span> <span class="toc-text">漫反射贴图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E9%9D%A2%E5%85%89%E8%B4%B4%E5%9B%BE"><span class="toc-number">1.4.2.</span> <span class="toc-text">镜面光贴图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%87%E6%A0%B7%E9%95%9C%E9%9D%A2%E5%85%89%E8%B4%B4%E5%9B%BE"><span class="toc-number">1.4.3.</span> <span class="toc-text">采样镜面光贴图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%95%E5%85%89%E7%89%A9"><span class="toc-number">1.5.</span> <span class="toc-text">投光物</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%8C%E5%85%89"><span class="toc-number">1.5.1.</span> <span class="toc-text">平行光</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E5%85%89%E6%BA%90"><span class="toc-number">1.5.2.</span> <span class="toc-text">点光源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%B0%E5%87%8F"><span class="toc-number">1.5.3.</span> <span class="toc-text">衰减</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%80%BC"><span class="toc-number">1.5.4.</span> <span class="toc-text">选择正确的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%A1%B0%E5%87%8F"><span class="toc-number">1.5.5.</span> <span class="toc-text">实现衰减</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%85%89"><span class="toc-number">1.5.6.</span> <span class="toc-text">聚光</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E7%94%B5%E7%AD%92"><span class="toc-number">1.5.7.</span> <span class="toc-text">手电筒</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E6%BB%91%E8%BD%AF%E5%8C%96%E8%BE%B9%E7%BC%98"><span class="toc-number">1.5.8.</span> <span class="toc-text">平滑 &#x2F; 软化边缘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%85%89%E6%BA%90"><span class="toc-number">1.5.9.</span> <span class="toc-text">多光源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E5%90%91%E5%85%89"><span class="toc-number">1.5.10.</span> <span class="toc-text">定向光</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E5%85%89%E6%BA%90-2"><span class="toc-number">1.5.11.</span> <span class="toc-text">点光源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E7%BB%93%E6%9E%9C"><span class="toc-number">1.5.12.</span> <span class="toc-text">合并结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E4%B9%A0"><span class="toc-number">1.6.</span> <span class="toc-text">复习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%8D%E6%B1%87%E8%A1%A8"><span class="toc-number">1.6.1.</span> <span class="toc-text">词汇表</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/computer-science/study/opengl/2-OpenGL-Load-Model/" rel="bookmark" title="三、OpenGL模型加载">三、OpenGL模型加载</a></li><li class="active"><a href="/computer-science/study/opengl/3-OpenGL-Lighting/" rel="bookmark" title="二、OpenGL光照">二、OpenGL光照</a></li><li><a href="/computer-science/study/opengl/1-OpenGL-Introduction/" rel="bookmark" title="一、OpenGL入门">一、OpenGL入门</a></li><li><a href="/computer-science/study/opengl/5-OpenGL-Heigh-Light/" rel="bookmark" title="五、高级光照">五、高级光照</a></li><li><a href="/computer-science/study/opengl/4-OpenGL-High-Level/" rel="bookmark" title="四、高级OpenGL">四、高级OpenGL</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="鑫酱(●'◡'●)" data-src="/images/avatar.jpg"><p class="name" itemprop="name">鑫酱(●'◡'●)</p><div class="description" itemprop="description">整天摸鱼，却妄想拯救世界的技术宅</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">43</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">16</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">11</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FsbGVuR1g=" title="https:&#x2F;&#x2F;github.com&#x2F;AllenGX"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTgwNTM4MjQy" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;80538242"><i class="ic i-cloud-music"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjE0MTM5MDcxNTNAcXEuY29t" title="mailto:1413907153@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>好友</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>网址</a></li><li class="item"><a href="/travellings/" rel="section"><i class="ic i-paper-plane"></i>传送门</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/computer-science/study/opengl/1-OpenGL-Introduction/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/computer-science/study/opengl/2-OpenGL-Load-Model/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E6%97%A5%E6%9C%AC%E8%AA%9E/" title="分类于 日语">日语</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%97%A5%E6%9C%AC%E8%AA%9E/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%97%A5%E6%9C%AC%E8%AA%9E/study/%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%81%AE%E6%96%87%E6%B3%95%E5%88%9D%E7%BA%A7%EF%BC%88%E4%B8%8A%EF%BC%89/" title="分类于 日语语法初级（上）">日语语法初级（上）</a></div><span><a href="/%E6%97%A5%E6%9C%AC%E8%AA%9E/study/%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%81%AE%E6%96%87%E6%B3%95%E5%88%9D%E7%BA%A7%EF%BC%88%E4%B8%8A%EF%BC%89/%E4%B8%89%E3%80%81%E5%B0%8F%E6%9D%8E%E5%9C%A8%E7%AE%B1%E6%A0%B9/" title="标准日本语初级-上">标准日本语初级-上</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/Python%E3%80%8C%E5%B7%A5%E5%8C%A0%E3%80%8D/" title="分类于 Python「工匠」">Python「工匠」</a></div><span><a href="/computer-science/study/Python%E3%80%8C%E5%B7%A5%E5%8C%A0%E3%80%8D/%E5%8D%81%E3%80%81%E5%81%9A%E4%B8%80%E4%B8%AA%E7%B2%BE%E9%80%9A%E8%A7%84%E5%88%99%E7%9A%84%E7%8E%A9%E5%AE%B6/" title="十、做一个精通规则的玩家">十、做一个精通规则的玩家</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/redis/" title="分类于 Redis">Redis</a></div><span><a href="/computer-science/study/redis/1-Redis-Introduction/" title="一、redis新手入门">一、redis新手入门</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/python/" title="分类于 Python">Python</a></div><span><a href="/computer-science/study/python/Python-watchdog/" title="基于 watchdog 实现自动化更新">基于 watchdog 实现自动化更新</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/python/" title="分类于 Python">Python</a></div><span><a href="/computer-science/study/python/Python-HotFix/" title="Python HotFix 热更新">Python HotFix 热更新</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/redis/" title="分类于 Redis">Redis</a></div><span><a href="/computer-science/study/redis/2-Redis-Distribute-Subscribe/" title="二、redis发布订阅">二、redis发布订阅</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/Python%E3%80%8C%E5%B7%A5%E5%8C%A0%E3%80%8D/" title="分类于 Python「工匠」">Python「工匠」</a></div><span><a href="/computer-science/study/Python%E3%80%8C%E5%B7%A5%E5%8C%A0%E3%80%8D/%E5%85%AD%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" title="六、异常处理">六、异常处理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/redis/" title="分类于 Redis">Redis</a></div><span><a href="/computer-science/study/redis/4-Redis-Data-Security-And-Performance/" title="四、redis数据安全及性能保障">四、redis数据安全及性能保障</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/opengl/" title="分类于 OpenGL">OpenGL</a></div><span><a href="/computer-science/study/opengl/1-OpenGL-Introduction/" title="一、OpenGL入门">一、OpenGL入门</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/opengl/" title="分类于 OpenGL">OpenGL</a></div><span><a href="/computer-science/study/opengl/2-OpenGL-Load-Model/" title="三、OpenGL模型加载">三、OpenGL模型加载</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">鑫酱(●'◡'●) @ 个人博客</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">416k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">6:18</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"computer-science/study/opengl/3-OpenGL-Lighting/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>