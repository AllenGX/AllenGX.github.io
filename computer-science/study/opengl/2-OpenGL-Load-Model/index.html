<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="鑫酱" href="https://allengx.gitee.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="鑫酱" href="https://allengx.gitee.io/atom.xml"><link rel="alternate" type="application/json" title="鑫酱" href="https://allengx.gitee.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://allengx.gitee.io/computer-science/study/opengl/2-OpenGL-Load-Model/"><title>三、OpenGL模型加载 - OpenGL - 学习笔记 - 计算机科学 | 个人博客 = 鑫酱 = 笔记本</title><meta name="generator" content="Hexo 5.1.1"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">三、OpenGL模型加载</h1><div class="meta"><span class="item" title="创建时间：2020-04-12 20:46:25"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2020-04-12T20:46:25+08:00">2020-04-12</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>17k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>16 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">个人博客</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipeyonbf9j20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipevgoki5j20zk0m84qp.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipesx5fdwj20zk0m81kx.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipewkhf1zj20zk0m81kx.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giciub8ja1j20zk0m81ky.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipexbei4hj20zk0m8npd.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/" itemprop="item" rel="index" title="分类于 计算机科学"><span itemprop="name">计算机科学</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/study/" itemprop="item" rel="index" title="分类于 学习笔记"><span itemprop="name">学习笔记</span></a><meta itemprop="position" content="2"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/study/opengl/" itemprop="item" rel="index" title="分类于 OpenGL"><span itemprop="name">OpenGL</span></a><meta itemprop="position" content="3"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://allengx.gitee.io/computer-science/study/opengl/2-OpenGL-Load-Model/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="鑫酱(●'◡'●)"><meta itemprop="description" content="笔记本, 整天摸鱼，却妄想拯救世界的技术宅"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="鑫酱"></span><div class="body md" itemprop="articleBody"><div class="note info"><p>以下为个人学习笔记整理</p></div><h1 id="模型加载"><a class="anchor" href="#模型加载">#</a> 模型加载</h1><h2 id="assimp"><a class="anchor" href="#assimp">#</a> Assimp</h2><p>到目前为止的所有场景中，我们一直都在滥用我们的箱子朋友，但时间久了甚至是我们最好的朋友也会感到无聊。在日常的图形程序中，通常都会使用非常复杂且好玩的模型，它们比静态的箱子要好看多了。然而，和箱子对象不同，我们不太能够对像是房子、汽车或者人形角色这样的复杂形状手工定义所有的顶点、法线和纹理坐标。我们想要的是将这些模型 (Model) 导入 (Import) 到程序当中。模型通常都由 3D 艺术家在<mark> Blender</mark>、<mark>3DS Max</mark> 或者<mark> Maya</mark> 这样的工具中精心制作。</p><p>这些所谓的<mark> 3D 建模工具</mark> (3D Modeling Tool) 可以让艺术家创建复杂的形状，并使用一种叫做<mark> UV 映射</mark> (uv-mapping) 的手段来应用贴图。这些工具将会在导出到模型文件的时候<mark>自动生成所有的顶点坐标</mark>、<mark>顶点法线</mark>以及<mark>纹理坐标</mark>。这样子艺术家们即使不了解图形技术细节的情况下，也能拥有一套强大的工具来构建高品质的模型了。所有的技术细节都隐藏在了导出的模型文件中。但是，作为图形开发者，我们就必须要了解这些技术细节了。</p><p>所以，我们的工作就是解析这些导出的模型文件以及提取所有有用的信息，将它们储存为 OpenGL 能够理解的格式。一个很常见的问题是，模型的文件格式有很多种，每一种都会以它们自己的方式来导出模型数据。像是 Wavefront 的.obj 这样的模型格式，只包含了<mark>模型数据</mark>以及<mark>材质信息</mark>，像是模型颜色和漫反射 / 镜面光贴图。而以 XML 为基础的 Collada 文件格式则非常的丰富，包含模型、光照、多种材质、动画数据、摄像机、完整的场景信息等等。Wavefront 的.obj 格式通常被认为是一个易于解析的模型格式。建议至少去 Wavefront 的 wiki 页面上看看文件格式的信息是如何封装的。这应该能让你认识到模型文件的基本结构。</p><p>总而言之，不同种类的文件格式有很多，它们之间通常并没有一个通用的结构。所以如果我们想从这些文件格式中导入模型的话，我们必须要去自己对每一种需要导入的文件格式写一个导入器。很幸运的是，正好有一个库专门处理这个问题。</p><h3 id="模型加载库"><a class="anchor" href="#模型加载库">#</a> 模型加载库</h3><p>一个非常流行的模型导入库是<mark> Assimp</mark>，它是 Open Asset Import Library（开放的资产导入库）的缩写。Assimp 能够导入很多种不同的模型文件格式（并也能够导出部分的格式），它会将所有的模型数据加载至 Assimp 的通用数据结构中。当 Assimp 加载完模型之后，我们就能够从 Assimp 的数据结构中提取我们所需的所有数据了。由于 Assimp 的数据结构保持不变，不论导入的是什么种类的文件格式，它都能够将我们从这些不同的文件格式中抽象出来，用同一种方式访问我们需要的数据。</p><p>当使用 Assimp 导入一个模型的时候，它通常会将整个模型加载进一个<mark>场景</mark> (Scene) 对象，它会包含导入的模型 / 场景中的所有数据。Assimp 会将场景载入为一系列的节点 (Node)，每个节点包含了场景对象中所储存数据的索引，每个节点都可以有任意数量的子节点。Assimp 数据结构的（简化）模型如下：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/03/01/assimp_structure.png" alt="image"></p><ul><li>和材质和<mark>网格</mark> (Mesh) 一样，所有的场景 / 模型数据都包含在 Scene 对象中。Scene 对象也包含了场景根节点的引用。</li><li>场景的 Root node（根节点）可能包含子节点（和其它的节点一样），它会有一系列指向场景对象中 mMeshes 数组中储存的网格数据的索引。Scene 下的 mMeshes 数组储存了真正的 Mesh 对象，节点中的 mMeshes 数组保存的只是场景中网格数组的索引。</li><li><mark>一个 Mesh 对象本身包含了渲染所需要的所有相关数据</mark>，像是顶点位置、法向量、纹理坐标、面 (Face) 和物体的材质。</li><li>一个网格包含了多个面。<mark>Face 代表的是物体的渲染图元</mark> (Primitive)（三角形、方形、点）。一个面包含了组成图元的顶点的索引。由于顶点和索引是分开的，使用一个索引缓冲来渲染是非常简单的（见你好，三角形）。</li><li>最后，一个网格也包含了一个<mark> Material</mark> 对象，它包含了一些函数能让我们获取物体的材质属性，比如说颜色和纹理贴图（比如漫反射和镜面光贴图）。</li></ul><p>所以，我们需要做的第一件事是将一个物体加载到 Scene 对象中，遍历节点，获取对应的 Mesh 对象（我们需要递归搜索每个节点的子节点），并处理每个 Mesh 对象来获取顶点数据、索引以及它的材质属性。最终的结果是一系列的网格数据，我们会将它们包含在一个 Model 对象中。</p><blockquote><p>网格<br>当使用建模工具对物体建模的时候，艺术家通常不会用单个形状创建出整个模型。通常每个模型都由几个子模型 / 形状组合而成。组合模型的每个单独的形状就叫做一个网格 (Mesh)。比如说有一个人形的角色：艺术家通常会将头部、四肢、衣服、武器建模为分开的组件，并将这些网格组合而成的结果表现为最终的模型。<mark>一个网格是我们在 OpenGL 中绘制物体所需的最小单位</mark>（顶点数据、索引和材质属性）。一个模型（通常）会包括多个网格。</p></blockquote><p>在下一节中，我们将创建我们自己的 Model 和 Mesh 类来加载并使用刚刚介绍的结构储存导入后的模型。如果我们想要绘制一个模型，我们不需要将<mark>整个</mark>模型渲染为一个整体，只需要渲染组成模型的每个独立的网格就可以了。然而，在我们开始导入模型之前，我们首先需要将 Assimp 包含到我们的工程当中。</p><h3 id="构建assimp"><a class="anchor" href="#构建assimp">#</a> 构建 Assimp</h3><p>你可以在 Assimp 的<span class="exturl" data-url="aHR0cDovL2Fzc2ltcC5zb3VyY2Vmb3JnZS5uZXQvbWFpbl9kb3dubG9hZHMuaHRtbA==">下载页面</span>中选择相应的版本。在写作时使用的 Assimp 最高版本为 3.1.1。我们建议你自己编译 Assimp 库，因为它们的预编译库在大部分系统上都是不能运行的。如果你忘记如何使用 CMake 自己编译一个库的话，可以复习创建窗口小节。</p><p>构建 Assimp 时可能会出现一些问题，所以我会将它们的解决方案列在这里，便于大家排除错误：</p><ul><li>CMake 在读取配置列表时，不断报出 DirectX 库丢失的错误。报错如下：</li></ul><blockquote><p>Could not locate DirectX<br>CMake Error at cmake-modules/FindPkgMacros.cmake:110 (message):<br>Required library DirectX not found! Install the library (including dev packages)<br>and try again. If the library is already installed, set the missing variables<br>manually in cmake.</p></blockquote><p>这个问题的解决方案是安装 DirectX SDK，如果你之前没安装过的话。你可以从<span class="exturl" data-url="aHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS9lbi11cy9kb3dubG9hZC9kZXRhaWxzLmFzcHg/aWQ9NjgxMg==">这里下载 SDK</span>。</p><ul><li>安装 DirectX SDK 时，可能遇到一个错误码为 s1023 的错误。这种情况下，请在安装 SDK 之前根据这个先卸载 C++ Redistributable package (s)。</li><li>一旦配置完成，你就可以生成解决方案文件了，打开解决方案文件并编译 Assimp 库（可以编译为 Debug 版本也可以编译为 Release 版本，只要能工作就行）。</li><li>使用默认配置构建的 Assimp 是一个动态库 (Dynamic Library)，所以我们需要包含所生成的 assimp.dll 文件以及程序的二进制文件。你可以简单地将 DLL 复制到我们程序可执行文件的同一目录中。</li><li>Assimp 编译之后，生成的库和 DLL 文件位于 code/Debug 或者 code/Release 文件夹中。</li><li>接着把编译好的 LIB 文件和 DLL 文件拷贝到工程的相应目录下，并在解决方案中链接它们。并且记得把 Assimp 的头文件也复制到你的 include 目录中（头文件可以在从 Assimp 中下载的 include 目录里找到）。</li></ul><blockquote><p>如果你想让 Assimp 使用多线程来获得更高的性能，你可以使用 Boost 库来编译 Assimp。你可以在它们的安装页面找到完整的安装介绍。</p></blockquote><h2 id="网格"><a class="anchor" href="#网格">#</a> 网格</h2><p>通过使用 Assimp，我们可以加载不同的模型到程序中，但是载入后它们都被储存为<mark> Assimp 的数据结构</mark>。我们最终仍要将这些数据转换为 OpenGL 能够理解的格式，这样才能渲染这个物体。我们从上一节中学到，网格 (Mesh) 代表的是单个的可绘制实体，我们现在先来定义一个我们自己的网格类。</p><p>首先我们来回顾一下我们目前学到的知识，想想一个网格最少需要什么数据。一个网格应该至少需要一系列的顶点，每个顶点包含一个位置向量、一个法向量和一个纹理坐标向量。一个网格还应该包含用于索引绘制的索引以及纹理形式的材质数据（漫反射 / 镜面光贴图）。</p><p>既然我们有了一个网格类的最低需求，我们可以在 OpenGL 中定义一个顶点了：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">Vertex</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    glm<span class="token operator">::</span>vec3 Position<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    glm<span class="token operator">::</span>vec3 Normal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    glm<span class="token operator">::</span>vec2 TexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>我们将所有需要的向量储存到一个叫做 Vertex 的结构体中，我们可以用它来索引每个顶点属性。除了 Vertex 结构体之外，我们还需要将纹理数据整理到一个 Texture 结构体中。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">Texture</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    string type<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>我们储存了纹理的 id 以及它的类型，比如是漫反射贴图或者是镜面光贴图。</p><p>知道了顶点和纹理的实现，我们可以开始定义网格类的结构了：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Mesh</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token comment">/*  网格数据  */</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        vector<span class="token operator">&lt;</span>Vertex<span class="token operator">></span> vertices<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token operator">></span> indices<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        vector<span class="token operator">&lt;</span>Texture<span class="token operator">></span> textures<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">/*  函数  */</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token function">Mesh</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>Vertex<span class="token operator">></span> vertices<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token operator">></span> indices<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>Texture<span class="token operator">></span> textures<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">void</span> <span class="token function">Draw</span><span class="token punctuation">(</span>Shader shader<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">/*  渲染数据  */</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> VAO<span class="token punctuation">,</span> VBO<span class="token punctuation">,</span> EBO<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">/*  函数  */</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">void</span> <span class="token function">setupMesh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>你可以看到这个类并不复杂。在构造器中，我们将所有必须的数据赋予了网格，我们在 setupMesh 函数中初始化缓冲，并最终使用 Draw 函数来绘制网格。注意我们将一个着色器传入了 Draw 函数中，将着色器传入网格类中可以让我们在绘制之前设置一些 uniform（像是链接采样器到纹理单元）。</p><p>构造器的内容非常易于理解。我们只需要使用构造器的参数设置类的公有变量就可以了。我们在构造器中还调用了 setupMesh 函数：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">Mesh</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>Vertex<span class="token operator">></span> vertices<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token operator">></span> indices<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>Texture<span class="token operator">></span> textures<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">this</span><span class="token operator">-></span>vertices <span class="token operator">=</span> vertices<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">this</span><span class="token operator">-></span>indices <span class="token operator">=</span> indices<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">this</span><span class="token operator">-></span>textures <span class="token operator">=</span> textures<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">setupMesh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里没什么可说的。我们接下来讨论 setupMesh 函数。</p><h3 id="初始化"><a class="anchor" href="#初始化">#</a> 初始化</h3><p>由于有了构造器，我们现在有一大列的网格数据用于渲染。在此之前我们还必须配置正确的缓冲，并通过顶点属性指针定义顶点着色器的布局。现在你应该对这些概念都很熟悉了，但我们这次会稍微有一点变动，使用结构体中的顶点数据：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">setupMesh</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">glGenVertexArrays</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>VAO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>VBO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>EBO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>VAO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> VBO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> vertices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Vertex<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>vertices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> EBO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> indices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="14"></td><td><pre>                 <span class="token operator">&amp;</span>indices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token comment">// 顶点位置</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   </pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Vertex<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token comment">// 顶点法线</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   </pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Vertex<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">offsetof</span><span class="token punctuation">(</span>Vertex<span class="token punctuation">,</span> Normal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token comment">// 顶点纹理坐标</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   </pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Vertex<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">offsetof</span><span class="token punctuation">(</span>Vertex<span class="token punctuation">,</span> TexCoords<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>代码应该和你所想得没什么不同，但有了 Vertex 结构体的帮助，我们使用了一些小技巧。</p><p>C++ 结构体有一个很棒的特性，它们的内存布局是连续的 (Sequential)。也就是说，如果我们将结构体作为一个数据数组使用，那么它将会以顺序排列结构体的变量，这将会直接转换为我们在数组缓冲中所需要的 float（实际上是字节）数组。比如说，如果我们有一个填充后的 Vertex 结构体，那么它的内存布局将会等于：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>Vertex vertex<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>vertex<span class="token punctuation">.</span>Position  <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.2f</span><span class="token punctuation">,</span> <span class="token number">0.4f</span><span class="token punctuation">,</span> <span class="token number">0.6f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>vertex<span class="token punctuation">.</span>Normal    <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>vertex<span class="token punctuation">.</span>TexCoords <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">vec2</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// = [0.2f, 0.4f, 0.6f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f];</span></pre></td></tr></table></figure><p>由于有了这个有用的特性，我们能够直接传入一大列的 Vertex 结构体的指针作为缓冲的数据，它们将会完美地转换为 glBufferData 所能用的参数：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> vertices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Vertex<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>vertices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>自然 sizeof 运算也可以用在结构体上来计算它的字节大小。这个应该是 32 字节的（8 个 float * 每个 4 字节）。</p><p>结构体的另外一个很好的用途是它的预处理指令 offsetof (s, m)，它的第一个参数是一个结构体，第二个参数是这个结构体中变量的名字。这个宏会返回那个变量距结构体头部的字节偏移量 (Byte Offset)。这正好可以用在定义 glVertexAttribPointer 函数中的偏移参数：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Vertex<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">offsetof</span><span class="token punctuation">(</span>Vertex<span class="token punctuation">,</span> Normal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>偏移量现在是使用<mark> offsetof</mark> 来定义了，在这里它会将法向量的字节偏移量设置为结构体中法向量的偏移量，也就是 3 个 float，即 12 字节。注意，我们同样将步长参数设置为了 Vertex 结构体的大小。</p><p>使用这样的一个结构体不仅能够提供可读性更高的代码，也允许我们很容易地拓展这个结构。如果我们希望添加另一个顶点属性，我们只需要将它添加到结构体中就可以了。由于它的灵活性，渲染的代码不会被破坏。</p><h3 id="渲染"><a class="anchor" href="#渲染">#</a> 渲染</h3><p>我们需要为 Mesh 类定义最后一个函数，它的 Draw 函数。在真正渲染这个网格之前，我们需要在调用 glDrawElements 函数之前先绑定相应的纹理。然而，这实际上有些困难，我们一开始并不知道这个网格（如果有的话）有多少纹理、纹理是什么类型的。所以我们该如何在着色器中设置纹理单元和采样器呢？</p><p>为了解决这个问题，我们需要设定一个命名标准：每个漫反射纹理被命名为<mark> texture_diffuseN</mark>，每个镜面光纹理应该被命名为<mark> texture_specularN</mark>，其中 N 的范围是 1 到纹理采样器最大允许的数字。比如说我们对某一个网格有 3 个漫反射纹理，2 个镜面光纹理，它们的纹理采样器应该之后会被调用：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>uniform sampler2D texture_diffuse1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>uniform sampler2D texture_diffuse2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>uniform sampler2D texture_diffuse3<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>uniform sampler2D texture_specular1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>uniform sampler2D texture_specular2<span class="token punctuation">;</span></pre></td></tr></table></figure><p>根据这个标准，我们可以在着色器中定义任意需要数量的纹理采样器，如果一个网格真的包含了（这么多）纹理，我们也能知道它们的名字是什么。根据这个标准，我们也能在一个网格中处理任意数量的纹理，开发者也可以自由选择需要使用的数量，他只需要定义正确的采样器就可以了（虽然定义少的话会有点浪费绑定和 uniform 调用）。</p><blockquote><p>像这样的问题有很多种不同的解决方案。如果你不喜欢这个解决方案，你可以自己想一个你自己的解决办法。</p></blockquote><p>最终的渲染代码是这样的：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">Draw</span><span class="token punctuation">(</span>Shader shader<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> diffuseNr <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> specularNr <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> textures<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token function">glActiveTexture</span><span class="token punctuation">(</span>GL_TEXTURE0 <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在绑定之前激活相应的纹理单元</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 获取纹理序号（diffuse_textureN 中的 N）</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        string number<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        string name <span class="token operator">=</span> textures<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>type<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span>name <span class="token operator">==</span> <span class="token string">"texture_diffuse"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            number <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>diffuseNr<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>name <span class="token operator">==</span> <span class="token string">"texture_specular"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            number <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">to_string</span><span class="token punctuation">(</span>specularNr<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>        shader<span class="token punctuation">.</span><span class="token function">setFloat</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"material."</span> <span class="token operator">+</span> name <span class="token operator">+</span> number<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> textures<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token function">glActiveTexture</span><span class="token punctuation">(</span>GL_TEXTURE0<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token comment">// 绘制网格</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>VAO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token function">glDrawElements</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> indices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GL_UNSIGNED_INT<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>我们首先计算了每个纹理类型的 N - 分量，并将其拼接到纹理类型字符串上，来获取对应的 uniform 名称。接下来我们查找对应的采样器，将它的位置值设置为当前激活的纹理单元，并绑定纹理。这也是我们在 Draw 函数中需要着色器的原因。我们也将 &quot;material.&quot; 添加到了最终的 uniform 名称中，因为我们希望将纹理储存在一个材质结构体中（这在每个实现中可能都不同）。</p><blockquote><p>注意我们在将漫反射计数器和镜面光计数器插入 stringstream 时，对它们进行了递增。在 C<ins> 中，这个递增操作：variable</ins> 将会返回变量本身，之后再递增，而 ++variable 则是先递增，再返回值。在我们的例子中是首先将原本的计数器值插入 stringstream，之后再递增它，供下一次循环使用。</p></blockquote><h2 id="模型"><a class="anchor" href="#模型">#</a> 模型</h2><p>现在是时候接触 Assimp 并创建实际的加载和转换代码了。这个教程的目标是创建另一个类来完整地表示一个模型，或者说是包含多个网格，甚至是多个物体的模型。一个包含木制阳台、塔楼、甚至游泳池的房子可能仍会被加载为一个模型。我们会使用 Assimp 来加载模型，并将它转换 (Translate) 至多个在上一节中创建的 Mesh 对象。</p><p>事不宜迟，我会先把 Model 类的结构给你：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Model</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">/*  函数   */</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token function">Model</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token function">loadModel</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">void</span> <span class="token function">Draw</span><span class="token punctuation">(</span>Shader shader<span class="token punctuation">)</span><span class="token punctuation">;</span>   </pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">private</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">/*  模型数据  */</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        vector<span class="token operator">&lt;</span>Mesh<span class="token operator">></span> meshes<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        string directory<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">/*  函数   */</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">void</span> <span class="token function">loadModel</span><span class="token punctuation">(</span>string path<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">void</span> <span class="token function">processNode</span><span class="token punctuation">(</span>aiNode <span class="token operator">*</span>node<span class="token punctuation">,</span> <span class="token keyword">const</span> aiScene <span class="token operator">*</span>scene<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        Mesh <span class="token function">processMesh</span><span class="token punctuation">(</span>aiMesh <span class="token operator">*</span>mesh<span class="token punctuation">,</span> <span class="token keyword">const</span> aiScene <span class="token operator">*</span>scene<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        vector<span class="token operator">&lt;</span>Texture<span class="token operator">></span> <span class="token function">loadMaterialTextures</span><span class="token punctuation">(</span>aiMaterial <span class="token operator">*</span>mat<span class="token punctuation">,</span> aiTextureType type<span class="token punctuation">,</span>string typeName<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>Model 类包含了一个 Mesh 对象的 vector（译注：这里指的是 C++ 中的 vector 模板类，之后遇到均不译），构造器需要我们给它一个文件路径。在构造器中，它会直接通过 loadModel 来加载文件。私有函数将会处理 Assimp 导入过程中的一部分，我们很快就会介绍它们。我们还将储存文件路径的目录，在之后加载纹理的时候还会用到它。</p><p>Draw 函数没有什么特别之处，基本上就是遍历了所有网格，并调用它们各自的 Draw 函数。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">Draw</span><span class="token punctuation">(</span>Shader shader<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> meshes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        meshes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Draw</span><span class="token punctuation">(</span>shader<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="导入3d模型到opengl"><a class="anchor" href="#导入3d模型到opengl">#</a> 导入 3D 模型到 OpenGL</h3><p>要想导入一个模型，并将它转换到我们自己的数据结构中的话，首先我们需要包含 Assimp 对应的头文件，这样编译器就不会抱怨我们了。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assimp/Importer.hpp></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assimp/scene.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assimp/postprocess.h></span></span></pre></td></tr></table></figure><p>首先需要调用的函数是 loadModel，它会从构造器中直接调用。在 loadModel 中，我们使用 Assimp 来加载模型至 Assimp 的一个叫做 scene 的数据结构中。你可能还记得在模型加载章节的第一节教程中，这是 Assimp 数据接口的根对象。一旦我们有了这个场景对象，我们就能访问到加载后的模型中所有所需的数据了。</p><p>Assimp 很棒的一点在于，它抽象掉了加载不同文件格式的所有技术细节，只需要一行代码就能完成所有的工作：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>Assimp<span class="token operator">::</span>Importer importer<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">const</span> aiScene <span class="token operator">*</span>scene <span class="token operator">=</span> importer<span class="token punctuation">.</span><span class="token function">ReadFile</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> aiProcess_Triangulate <span class="token operator">|</span> aiProcess_FlipUVs<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>我们首先声明了 Assimp 命名空间内的一个 Importer，之后调用了它的 ReadFile 函数。这个函数需要一个文件路径，它的第二个参数是一些后期处理 (Post-processing) 的选项。除了加载文件之外，Assimp 允许我们设定一些选项来强制它对导入的数据做一些额外的计算或操作。通过设定<mark> aiProcess_Triangulate</mark>，我们告诉 Assimp，如果模型不是（全部）由三角形组成，<mark>它需要将模型所有的图元形状变换为三角形</mark>。<mark>aiProcess_FlipUVs</mark> 将在处理的时候翻<mark>转 y 轴的纹理坐标</mark>（你可能还记得我们在纹理教程中说过，在 OpenGL 中大部分的图像的 y 轴都是反的，所以这个后期处理选项将会修复这个）。其它一些比较有用的选项有：</p><ul><li><mark>aiProcess_GenNormals</mark>：如果模型不包含法向量的话，就为每个顶点创建法线。</li><li><mark>aiProcess_SplitLargeMeshes</mark>：将比较大的网格分割成更小的子网格，如果你的渲染有最大顶点数限制，只能渲染较小的网格，那么它会非常有用。</li><li><mark>aiProcess_OptimizeMeshes</mark>：和上个选项相反，它会将多个小网格拼接为一个大的网格，减少绘制调用从而进行优化。</li></ul><p>Assimp 提供了很多有用的后期处理指令，你可以在这里找到全部的指令。实际上使用 Assimp 加载模型是非常容易的（你也可以看到）。困难的是之后使用返回的场景对象将加载的数据转换到一个 Mesh 对象的数组。</p><p>完整的 loadModel 函数将会是这样的：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">loadModel</span><span class="token punctuation">(</span>string path<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    Assimp<span class="token operator">::</span>Importer import<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">const</span> aiScene <span class="token operator">*</span>scene <span class="token operator">=</span> import<span class="token punctuation">.</span><span class="token function">ReadFile</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> aiProcess_Triangulate <span class="token operator">|</span> aiProcess_FlipUVs<span class="token punctuation">)</span><span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>scene <span class="token operator">||</span> scene<span class="token operator">-></span>mFlags <span class="token operator">&amp;</span> AI_SCENE_FLAGS_INCOMPLETE <span class="token operator">||</span> <span class="token operator">!</span>scene<span class="token operator">-></span>mRootNode<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ERROR::ASSIMP::"</span> <span class="token operator">&lt;&lt;</span> import<span class="token punctuation">.</span><span class="token function">GetErrorString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    directory <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> path<span class="token punctuation">.</span><span class="token function">find_last_of</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token function">processNode</span><span class="token punctuation">(</span>scene<span class="token operator">-></span>mRootNode<span class="token punctuation">,</span> scene<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在我们加载了模型之后，我们会检查场景和其根节点不为 null，并且检查了它的一个标记 (Flag)，来查看返回的数据是不是不完整的。如果遇到了任何错误，我们都会通过导入器的 GetErrorString 函数来报告错误并返回。我们也获取了文件路径的目录路径。</p><p>如果什么错误都没有发生，我们希望处理场景中的所有节点，所以我们将第一个节点（根节点）传入了递归的 processNode 函数。因为每个节点（可能）包含有多个子节点，我们希望首先处理参数中的节点，再继续处理该节点所有的子节点，以此类推。这正符合一个递归结构，所以我们将定义一个递归函数。递归函数在做一些处理之后，使用不同的参数递归调用这个函数自身，直到某个条件被满足停止递归。在我们的例子中退出条件 (Exit Condition) 是所有的<mark>节点都被处理完毕</mark>。</p><p>你可能还记得 Assimp 的结构中，每个节点包含了一系列的网格索引，每个索引指向场景对象中的那个特定网格。我们接下来就想去获取这些网格索引，获取每个网格，处理每个网格，接着对每个节点的子节点重复这一过程。processNode 函数的内容如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">processNode</span><span class="token punctuation">(</span>aiNode <span class="token operator">*</span>node<span class="token punctuation">,</span> <span class="token keyword">const</span> aiScene <span class="token operator">*</span>scene<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 处理节点所有的网格（如果有的话）</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> node<span class="token operator">-></span>mNumMeshes<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        aiMesh <span class="token operator">*</span>mesh <span class="token operator">=</span> scene<span class="token operator">-></span>mMeshes<span class="token punctuation">[</span>node<span class="token operator">-></span>mMeshes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre>        meshes<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">processMesh</span><span class="token punctuation">(</span>mesh<span class="token punctuation">,</span> scene<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         </pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// 接下来对它的子节点重复这一过程</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> node<span class="token operator">-></span>mNumChildren<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token function">processNode</span><span class="token punctuation">(</span>node<span class="token operator">-></span>mChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> scene<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>我们首先检查每个节点的网格索引，并索引场景的 mMeshes 数组来获取对应的网格。返回的网格将会传递到 processMesh 函数中，它会返回一个 Mesh 对象，我们可以将它存储在 meshes 列表 /vector。</p><p>所有网格都被处理之后，我们会遍历节点的所有子节点，并对它们调用相同的 processMesh 函数。当一个节点不再有任何子节点之后，这个函数将会停止执行。</p><blockquote><p>认真的读者可能会发现，我们可以基本上忘掉处理任何的节点，只需要遍历场景对象的所有网格，就不需要为了索引做这一堆复杂的东西了。我们仍这么做的原因是，使用节点的最初想法是将网格之间定义一个父子关系。通过这样递归地遍历这层关系，我们就能将某个网格定义为另一个网格的父网格了。<br>这个系统的一个使用案例是，当你想位移一个汽车的网格时，你可以保证它的所有子网格（比如引擎网格、方向盘网格、轮胎网格）都会随着一起位移。这样的系统能够用父子关系很容易地创建出来。</p></blockquote><blockquote><p>然而，现在我们并没有使用这样一种系统，但如果你想对你的网格数据有更多的控制，通常都是建议使用这一种方法的。这种类节点的关系毕竟是由创建了这个模型的艺术家所定义。</p></blockquote><p>下一步就是将 Assimp 的数据解析到上一节中创建的 Mesh 类中。</p><h3 id="从assimp到网格"><a class="anchor" href="#从assimp到网格">#</a> 从 Assimp 到网格</h3><p>将一个 aiMesh 对象转化为我们自己的网格对象不是那么困难。我们要做的只是访问网格的相关属性并将它们储存到我们自己的对象中。processMesh 函数的大体结构如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>Mesh <span class="token function">processMesh</span><span class="token punctuation">(</span>aiMesh <span class="token operator">*</span>mesh<span class="token punctuation">,</span> <span class="token keyword">const</span> aiScene <span class="token operator">*</span>scene<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    vector<span class="token operator">&lt;</span>Vertex<span class="token operator">></span> vertices<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    vector<span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token operator">></span> indices<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    vector<span class="token operator">&lt;</span>Texture<span class="token operator">></span> textures<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> mesh<span class="token operator">-></span>mNumVertices<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        Vertex vertex<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 处理顶点位置、法线和纹理坐标</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        vertices<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>vertex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token comment">// 处理索引</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token comment">// 处理材质</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>mesh<span class="token operator">-></span>mMaterialIndex <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">return</span> <span class="token function">Mesh</span><span class="token punctuation">(</span>vertices<span class="token punctuation">,</span> indices<span class="token punctuation">,</span> textures<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>处理网格的过程主要有三部分：获取所有的顶点数据，获取它们的网格索引，并获取相关的材质数据。处理后的数据将会储存在三个 vector 当中，我们会利用它们构建一个 Mesh 对象，并返回它到函数的调用者那里。</p><p>获取顶点数据非常简单，我们定义了一个 Vertex 结构体，我们将在每个迭代之后将它加到<mark> vertices</mark> 数组中。我们会遍历网格中的所有顶点（使用 mesh-&gt;mNumVertices 来获取）。在每个迭代中，我们希望使用所有的相关数据填充这个结构体。顶点的位置是这样处理的：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span>vec3 vector<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre>vector<span class="token punctuation">.</span>x <span class="token operator">=</span> mesh<span class="token operator">-></span>mVertices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>vector<span class="token punctuation">.</span>y <span class="token operator">=</span> mesh<span class="token operator">-></span>mVertices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>vector<span class="token punctuation">.</span>z <span class="token operator">=</span> mesh<span class="token operator">-></span>mVertices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>z<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre>vertex<span class="token punctuation">.</span>Position <span class="token operator">=</span> vector<span class="token punctuation">;</span></pre></td></tr></table></figure><p>注意我们为了传输 Assimp 的数据，我们定义了一个 vec3 的临时变量。使用这样一个临时变量的原因是 Assimp 对向量、矩阵、字符串等都有自己的一套数据类型，它们并不能完美地转换到 GLM 的数据类型中。</p><blockquote><p>Assimp 将它的顶点位置数组叫做 mVertices，这其实并不是那么直观。</p></blockquote><p>处理法线的步骤也是差不多的：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vector<span class="token punctuation">.</span>x <span class="token operator">=</span> mesh<span class="token operator">-></span>mNormals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>vector<span class="token punctuation">.</span>y <span class="token operator">=</span> mesh<span class="token operator">-></span>mNormals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>vector<span class="token punctuation">.</span>z <span class="token operator">=</span> mesh<span class="token operator">-></span>mNormals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>z<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>vertex<span class="token punctuation">.</span>Normal <span class="token operator">=</span> vector<span class="token punctuation">;</span></pre></td></tr></table></figure><p>纹理坐标的处理也大体相似，但 Assimp 允许一个模型在一个顶点上有最多 8 个不同的纹理坐标，我们不会用到那么多，我们只关心第一组纹理坐标。我们同样也想检查网格是否真的包含了纹理坐标（可能并不会一直如此）</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span>mesh<span class="token operator">-></span>mTextureCoords<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 网格是否有纹理坐标？</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    glm<span class="token operator">::</span>vec2 vec<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    vec<span class="token punctuation">.</span>x <span class="token operator">=</span> mesh<span class="token operator">-></span>mTextureCoords<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre>    vec<span class="token punctuation">.</span>y <span class="token operator">=</span> mesh<span class="token operator">-></span>mTextureCoords<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    vertex<span class="token punctuation">.</span>TexCoords <span class="token operator">=</span> vec<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">else</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    vertex<span class="token punctuation">.</span>TexCoords <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">vec2</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>vertex 结构体现在已经填充好了需要的顶点属性，我们会在迭代的最后将它压入 vertices 这个 vector 的尾部。这个过程会对每个网格的顶点都重复一遍 (<mark>vertices.push_back</mark>)。</p><h3 id="索引"><a class="anchor" href="#索引">#</a> 索引</h3><p>Assimp 的接口定义了每个网格都有一个<mark>面 (Face) 数组</mark>，每个面代表了一个图元，在我们的例子中（由于使用了<mark> aiProcess_Triangulate</mark> 选项）<mark>它总是三角形</mark>。一个面包含了多个索引，它们定义了在每个图元中，我们应该绘制哪个顶点，并以什么顺序绘制，所以如果我们遍历了所有的面，并储存了面的索引到 indices 这个 vector 中就可以了。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> mesh<span class="token operator">-></span>mNumFaces<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    aiFace face <span class="token operator">=</span> mesh<span class="token operator">-></span>mFaces<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> face<span class="token punctuation">.</span>mNumIndices<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        indices<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>face<span class="token punctuation">.</span>mIndices<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>所有的外部循环都结束了，我们现在有了一系列的顶点和索引数据，它们可以用来通过<mark> glDrawElements</mark> 函数来绘制网格。然而，为了结束这个话题，并且对网格提供一些细节，我们还需要处理网格的材质。</p><h3 id="材质"><a class="anchor" href="#材质">#</a> 材质</h3><p>和节点一样，一个网格只包含了一个指向材质对象的索引。如果想要获取网格真正的材质，我们还需要索引场景的<mark> mMaterials</mark> 数组。网格材质索引位于它的 mMaterialIndex 属性中，我们同样可以用它来检测一个网格是否包含有材质：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span>mesh<span class="token operator">-></span>mMaterialIndex <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    aiMaterial <span class="token operator">*</span>material <span class="token operator">=</span> scene<span class="token operator">-></span>mMaterials<span class="token punctuation">[</span>mesh<span class="token operator">-></span>mMaterialIndex<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    vector<span class="token operator">&lt;</span>Texture<span class="token operator">></span> diffuseMaps <span class="token operator">=</span> <span class="token function">loadMaterialTextures</span><span class="token punctuation">(</span>material<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="5"></td><td><pre>                                        aiTextureType_DIFFUSE<span class="token punctuation">,</span> <span class="token string">"texture_diffuse"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    textures<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>textures<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> diffuseMaps<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> diffuseMaps<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    vector<span class="token operator">&lt;</span>Texture<span class="token operator">></span> specularMaps <span class="token operator">=</span> <span class="token function">loadMaterialTextures</span><span class="token punctuation">(</span>material<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="8"></td><td><pre>                                        aiTextureType_SPECULAR<span class="token punctuation">,</span> <span class="token string">"texture_specular"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    textures<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>textures<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> specularMaps<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> specularMaps<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>我们首先从场景的 mMaterials 数组中获取 aiMaterial 对象。接下来我们希望加载网格的漫反射和 / 或镜面光贴图。一个材质对象的内部对每种纹理类型都存储了一个纹理位置数组。不同的纹理类型都以 aiTextureType_为前缀。我们使用一个叫做<mark> loadMaterialTextures</mark> 的工具函数来从材质中获取纹理。这个函数将会返回一个<mark> Texture</mark> 结构体的 vector，我们将在模型的 textures vector 的尾部之后存储它。</p><p>loadMaterialTextures 函数遍历了给定纹理类型的所有纹理位置，获取了纹理的文件位置，并加载并和生成了纹理，将信息储存在了一个 Vertex 结构体中。它看起来会像这样：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vector<span class="token operator">&lt;</span>Texture<span class="token operator">></span> <span class="token function">loadMaterialTextures</span><span class="token punctuation">(</span>aiMaterial <span class="token operator">*</span>mat<span class="token punctuation">,</span> aiTextureType type<span class="token punctuation">,</span> string typeName<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    vector<span class="token operator">&lt;</span>Texture<span class="token operator">></span> textures<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> mat<span class="token operator">-></span><span class="token function">GetTextureCount</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        aiString str<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        mat<span class="token operator">-></span><span class="token function">GetTexture</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        Texture texture<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        texture<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token function">TextureFromFile</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">C_Str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> directory<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        texture<span class="token punctuation">.</span>type <span class="token operator">=</span> typeName<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        texture<span class="token punctuation">.</span>path <span class="token operator">=</span> str<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        textures<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>texture<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">return</span> textures<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>我们首先通过 GetTextureCount 函数检查储存在材质中纹理的数量，这个函数需要一个纹理类型。我们会使用 GetTexture 获取每个纹理的文件位置，它会将结果储存在一个 aiString 中。我们接下来使用另外一个叫做 TextureFromFile 的工具函数，它将会（用 stb_image.h）加载一个纹理并返回该纹理的 ID。如果你不确定这样的代码是如何写出来的话，可以查看最后的完整代码。</p><blockquote><p>注意，我们假设了模型文件中纹理文件的路径是相对于模型文件的本地 (Local) 路径，比如说与模型文件处于同一目录下。我们可以将纹理位置字符串拼接到之前（在 loadModel 中）获取的目录字符串上，来获取完整的纹理路径（这也是为什么 GetTexture 函数也需要一个目录字符串）。</p></blockquote><blockquote><p>在网络上找到的某些模型会对纹理位置使用绝对 (Absolute) 路径，这就不能在每台机器上都工作了。在这种情况下，你可能会需要手动修改这个文件，来让它对纹理使用本地路径（如果可能的话）。</p></blockquote><h3 id="重大优化"><a class="anchor" href="#重大优化">#</a> 重大优化</h3><p>这还没有完全结束，因为我们还想做出一个重大的（但不是完全必须的）优化。大多数场景都会在多个网格中重用部分纹理。还是想想一个房子，它的墙壁有着花岗岩的纹理。这个纹理也可以被应用到地板、天花板、楼梯、桌子，甚至是附近的一口井上。加载纹理并不是一个开销不大的操作，在我们当前的实现中，即便同样的纹理已经被加载过很多遍了，对每个网格仍会加载并生成一个新的纹理。这很快就会变成模型加载实现的性能瓶颈。</p><p>所以我们会对模型的代码进行调整，将所有加载过的纹理全局储存，每当我们想加载一个纹理的时候，首先去检查它有没有被加载过。如果有的话，我们会直接使用那个纹理，并跳过整个加载流程，来为我们省下很多处理能力。为了能够比较纹理，我们还需要储存它们的路径：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">Texture</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    string type<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    aiString path<span class="token punctuation">;</span>  <span class="token comment">// 我们储存纹理的路径用于与其它纹理进行比较</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>接下来我们将所有加载过的纹理储存在另一个 vector 中，在模型类的顶部声明为一个私有变量：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vector<span class="token operator">&lt;</span>Texture<span class="token operator">></span> textures_loaded<span class="token punctuation">;</span></pre></td></tr></table></figure><p>之后，在 loadMaterialTextures 函数中，我们希望将纹理的路径与储存在 textures_loaded 这个 vector 中的所有纹理进行比较，看看当前纹理的路径是否与其中的一个相同。如果是的话，则跳过纹理加载 / 生成的部分，直接使用定位到的纹理结构体为网格的纹理。更新后的函数如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vector<span class="token operator">&lt;</span>Texture<span class="token operator">></span> <span class="token function">loadMaterialTextures</span><span class="token punctuation">(</span>aiMaterial <span class="token operator">*</span>mat<span class="token punctuation">,</span> aiTextureType type<span class="token punctuation">,</span> string typeName<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    vector<span class="token operator">&lt;</span>Texture<span class="token operator">></span> textures<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> mat<span class="token operator">-></span><span class="token function">GetTextureCount</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        aiString str<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        mat<span class="token operator">-></span><span class="token function">GetTexture</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">bool</span> skip <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> textures_loaded<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">if</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">strcmp</span><span class="token punctuation">(</span>textures_loaded<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>path<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> str<span class="token punctuation">.</span><span class="token function">C_Str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                textures<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>textures_loaded<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                skip <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>skip<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">&#123;</span>   <span class="token comment">// 如果纹理还没有被加载，则加载它</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            Texture texture<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            texture<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token function">TextureFromFile</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">C_Str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> directory<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            texture<span class="token punctuation">.</span>type <span class="token operator">=</span> typeName<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            texture<span class="token punctuation">.</span>path <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">C_Str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            textures<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>texture<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            textures_loaded<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>texture<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 添加到已加载的纹理中</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token keyword">return</span> textures<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>所以现在我们不仅有了个灵活的模型加载系统，我们也获得了一个加载对象很快的优化版本。</p><h3 id="和箱子模型告别"><a class="anchor" href="#和箱子模型告别">#</a> 和箱子模型告别</h3><p>所以，让我们导入一个由真正的艺术家所创造的模型，替代我这个天才的作品（你要承认，这些箱子可能是你看过的最漂亮的立方体了），测试一下我们的实现吧。由于我不想让我占太多的功劳，我会偶尔让别的艺术家也加入我们，这次我们将会加载 Crytek 的游戏孤岛危机 (Crysis) 中的原版纳米装 (Nanosuit)。这个模型被输出为一个.obj 文件以及一个.mtl 文件，.mtl 文件包含了模型的漫反射、镜面光和法线贴图（这个会在后面学习到），你可以在<span class="exturl" data-url="aHR0cHM6Ly9sZWFybm9wZW5nbC1jbi5naXRodWIuaW8vZGF0YS9uYW5vc3VpdC5yYXI=">这里下载到</span>（稍微修改之后的）模型，注意所有的纹理和模型文件应该位于同一个目录下，以供加载纹理。</p><blockquote><p>你从本网站中下载到的版本是修改过的版本，每个纹理的路径都被修改为了一个本地的相对路径，而不是原资源的绝对路径。</p></blockquote><p>现在在代码中，声明一个 Model 对象，将模型的文件位置传入。接下来模型应该会自动加载并（如果没有错误的话）在渲染循环中使用它的 Draw 函数来绘制物体，这样就可以了。不再需要缓冲分配、属性指针和渲染指令，只需要一行代码就可以了。接下来如果你创建一系列着色器，其中片段着色器仅仅输出物体的漫反射纹理颜色，最终的结果看上去会是这样的：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/03/03/model_diffuse.png" alt="image"></p><p>我们可以变得更有创造力一点，根据我们之前在光照教程中学过的知识，引入两个点光源到渲染方程中，结合镜面光贴图，我们能得到很惊人的效果。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/03/03/model_lighting.png" alt="image"></p><p>甚至我都必须要承认这个可能是比一直使用的箱子要好看多了。使用 Assimp，你能够加载互联网上的无数模型。有很多资源网站都提供了多种格式的免费 3D 模型供你下载。但还是要注意，有些模型会不能正常地载入，<mark>纹理的路径会出现问题</mark>，或者 Assimp 并<mark>不支持它的格式</mark>。</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2020-10-26 10:33:45" itemprop="dateModified" datetime="2020-10-26T10:33:45+08:00">2020-10-26</time> </span><span id="computer-science/study/opengl/2-OpenGL-Load-Model/" class="item leancloud_visitors" data-flag-title="三、OpenGL模型加载" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 充电</button><p>请我[恰饭]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="鑫酱(●'◡'●) 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="鑫酱(●'◡'●) 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>鑫酱(●'◡'●) <i class="ic i-at"><em>@</em></i>鑫酱</li><li class="link"><strong>本文链接：</strong> <a href="https://allengx.gitee.io/computer-science/study/opengl/2-OpenGL-Load-Model/" title="三、OpenGL模型加载">https://allengx.gitee.io/computer-science/study/opengl/2-OpenGL-Load-Model/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/computer-science/study/opengl/3-OpenGL-Lighting/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclh5u05ej20zk0m87df.jpg" title="二、OpenGL光照"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> OpenGL</span><h3>二、OpenGL光照</h3></a></div><div class="item right"><a href="/computer-science/study/micro-service/kubernetes/Kubernetes-Introduction/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipew28b65j20zk0m8hdt.jpg" title="Kubernetes简介"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> K8s</span><h3>Kubernetes简介</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.</span> <span class="toc-text">模型加载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#assimp"><span class="toc-number">1.1.</span> <span class="toc-text">Assimp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD%E5%BA%93"><span class="toc-number">1.1.1.</span> <span class="toc-text">模型加载库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BAassimp"><span class="toc-number">1.1.2.</span> <span class="toc-text">构建 Assimp</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E6%A0%BC"><span class="toc-number">1.2.</span> <span class="toc-text">网格</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.2.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93"><span class="toc-number">1.2.2.</span> <span class="toc-text">渲染</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A53d%E6%A8%A1%E5%9E%8B%E5%88%B0opengl"><span class="toc-number">1.3.1.</span> <span class="toc-text">导入 3D 模型到 OpenGL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8Eassimp%E5%88%B0%E7%BD%91%E6%A0%BC"><span class="toc-number">1.3.2.</span> <span class="toc-text">从 Assimp 到网格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.3.</span> <span class="toc-text">索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%90%E8%B4%A8"><span class="toc-number">1.3.4.</span> <span class="toc-text">材质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%A4%A7%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.5.</span> <span class="toc-text">重大优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C%E7%AE%B1%E5%AD%90%E6%A8%A1%E5%9E%8B%E5%91%8A%E5%88%AB"><span class="toc-number">1.3.6.</span> <span class="toc-text">和箱子模型告别</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/computer-science/study/opengl/2-OpenGL-Load-Model/" rel="bookmark" title="三、OpenGL模型加载">三、OpenGL模型加载</a></li><li><a href="/computer-science/study/opengl/3-OpenGL-Lighting/" rel="bookmark" title="二、OpenGL光照">二、OpenGL光照</a></li><li><a href="/computer-science/study/opengl/1-OpenGL-Introduction/" rel="bookmark" title="一、OpenGL入门">一、OpenGL入门</a></li><li><a href="/computer-science/study/opengl/5-OpenGL-Heigh-Light/" rel="bookmark" title="五、高级光照">五、高级光照</a></li><li><a href="/computer-science/study/opengl/4-OpenGL-High-Level/" rel="bookmark" title="四、高级OpenGL">四、高级OpenGL</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="鑫酱(●'◡'●)" data-src="/images/avatar.jpg"><p class="name" itemprop="name">鑫酱(●'◡'●)</p><div class="description" itemprop="description">整天摸鱼，却妄想拯救世界的技术宅</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">60</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">18</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">13</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FsbGVuR1g=" title="https:&#x2F;&#x2F;github.com&#x2F;AllenGX"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTgwNTM4MjQy" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;80538242"><i class="ic i-cloud-music"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjE0MTM5MDcxNTNAcXEuY29t" title="mailto:1413907153@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>好友</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>网址</a></li><li class="item"><a href="/travellings/" rel="section"><i class="ic i-paper-plane"></i>传送门</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/computer-science/study/opengl/3-OpenGL-Lighting/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/computer-science/study/micro-service/kubernetes/Kubernetes-Introduction/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/task-list/" title="分类于 任务清单">任务清单</a></div><span><a href="/computer-science/task-list/plan-table/" title="计划表">计划表</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/Python%E3%80%8C%E5%B7%A5%E5%8C%A0%E3%80%8D/" title="分类于 Python「工匠」">Python「工匠」</a></div><span><a href="/computer-science/study/Python%E3%80%8C%E5%B7%A5%E5%8C%A0%E3%80%8D/%E4%B8%80%E3%80%81%E5%8F%98%E9%87%8F/" title="一、变量">一、变量</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/Python%E3%80%8C%E5%B7%A5%E5%8C%A0%E3%80%8D/" title="分类于 Python「工匠」">Python「工匠」</a></div><span><a href="/computer-science/study/Python%E3%80%8C%E5%B7%A5%E5%8C%A0%E3%80%8D/%E5%9B%9B%E3%80%81%E5%AE%B9%E5%99%A8%E7%9A%84%E9%97%A8%E9%81%93/" title="四、容器的门道">四、容器的门道</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/Python%E3%80%8C%E5%B7%A5%E5%8C%A0%E3%80%8D/" title="分类于 Python「工匠」">Python「工匠」</a></div><span><a href="/computer-science/study/Python%E3%80%8C%E5%B7%A5%E5%8C%A0%E3%80%8D/%E5%85%AB%E3%80%81%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E6%8A%80%E5%B7%A7/" title="八、装饰器的技巧">八、装饰器的技巧</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/micro-service/" title="分类于 微服务">微服务</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/micro-service/istio/" title="分类于 Istio">Istio</a></div><span><a href="/computer-science/study/micro-service/istio/Istio-Introduction-And-Service-Mesh/" title="Istio简介&amp;&amp;服务网格">Istio简介&&服务网格</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%97%A5%E6%9C%AC%E8%AA%9E/" title="分类于 日语">日语</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%97%A5%E6%9C%AC%E8%AA%9E/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/%E6%97%A5%E6%9C%AC%E8%AA%9E/study/%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%81%AE%E6%96%87%E6%B3%95%E5%88%9D%E7%BA%A7%EF%BC%88%E4%B8%8A%EF%BC%89/" title="分类于 日语语法初级（上）">日语语法初级（上）</a></div><span><a href="/%E6%97%A5%E6%9C%AC%E8%AA%9E/study/%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%81%AE%E6%96%87%E6%B3%95%E5%88%9D%E7%BA%A7%EF%BC%88%E4%B8%8A%EF%BC%89/%E5%85%AD%E3%80%81%E5%86%8D%E8%A7%81%EF%BC%81%E6%97%A5%E6%9C%AC/" title="标准日本语初级-上">标准日本语初级-上</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/opengl/" title="分类于 OpenGL">OpenGL</a></div><span><a href="/computer-science/study/opengl/4-OpenGL-High-Level/" title="四、高级OpenGL">四、高级OpenGL</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/python/" title="分类于 Python">Python</a></div><span><a href="/computer-science/study/python/Python-HotFix/" title="Python HotFix 热更新">Python HotFix 热更新</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/python/" title="分类于 Python">Python</a></div><span><a href="/computer-science/study/python/Python-Build-In/" title="python内建函数">python内建函数</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/Python%E3%80%8C%E5%B7%A5%E5%8C%A0%E3%80%8D/" title="分类于 Python「工匠」">Python「工匠」</a></div><span><a href="/computer-science/study/Python%E3%80%8C%E5%B7%A5%E5%8C%A0%E3%80%8D/%E4%B9%9D%E3%80%81%E6%A8%A1%E5%9D%97/" title="九、模块">九、模块</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">鑫酱(●'◡'●) @ 个人博客</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">460k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">6:58</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"computer-science/study/opengl/2-OpenGL-Load-Model/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>