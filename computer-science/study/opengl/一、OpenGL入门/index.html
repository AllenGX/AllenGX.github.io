<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="鑫酱" href="https://allengx.gitee.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="鑫酱" href="https://allengx.gitee.io/atom.xml"><link rel="alternate" type="application/json" title="鑫酱" href="https://allengx.gitee.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.1.6"><meta name="description" content="你知道的太多了"><link rel="canonical" href="https://allengx.gitee.io/computer-science/study/opengl/%E4%B8%80%E3%80%81OpenGL%E5%85%A5%E9%97%A8/"><title>一、OpenGL入门 - OpenGL - 学习笔记 - 计算机科学 | 个人博客 = 鑫酱 = 笔记本</title><meta name="generator" content="Hexo 5.1.1"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">一、OpenGL入门</h1><div class="meta"><span class="item" title="创建时间：2020-04-12 20:46:25"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2020-04-12T20:46:25+08:00">2020-04-12</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>73k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>1:07</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">个人博客</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclfdu6exj20zk0m87hw.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipeu7txpzj20zk0m81kx.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipexj2jgzj20zk0m8b09.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipew8gmvyj20zk0m87wh.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipeubcbajj20zk0m8h1h.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclg5ms2rj20zk0m8u0x.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main id="main"><div class="inner"><div id="content" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span> <i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/" itemprop="item" rel="index" title="分类于 计算机科学"><span itemprop="name">计算机科学</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/study/" itemprop="item" rel="index" title="分类于 学习笔记"><span itemprop="name">学习笔记</span></a><meta itemprop="position" content="2"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/study/opengl/" itemprop="item" rel="index" title="分类于 OpenGL"><span itemprop="name">OpenGL</span></a><meta itemprop="position" content="3"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://allengx.gitee.io/computer-science/study/opengl/%E4%B8%80%E3%80%81OpenGL%E5%85%A5%E9%97%A8/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Allen guo"><meta itemprop="description" content="笔记本, 你知道的太多了"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="鑫酱"></span><div class="body md" itemprop="articleBody"><div class="note info"><p>以下为个人学习笔记整理</p></div><h1 id="环境搭建"><a class="anchor" href="#环境搭建">#</a> 环境搭建</h1><h2 id="状态机"><a class="anchor" href="#状态机">#</a> 状态机</h2><p>OpenGL 自身是一个巨大的状态机 (State Machine)：<mark>一系列的变量描述 OpenGL 此刻应当如何运行</mark>。OpenGL 的状态通常被称为 OpenGL 上下文 (Context)。我们通常使用如下途径去更改 OpenGL 状态：设置选项，操作缓冲。最后，我们使用当前 OpenGL 上下文来渲染。</p><p>假设当我们想告诉 OpenGL 去画线段而不是三角形的时候，我们通过改变一些上下文变量来改变 OpenGL 状态，从而告诉 OpenGL 如何去绘图。一旦我们改变了 OpenGL 的状态为绘制线段，下一个绘制命令就会画出线段而不是三角形。</p><p>当使用 OpenGL 的时候，我们会遇到一些状态设置函数 (State-changing Function)，这类函数将会改变上下文。以及状态使用函数 (State-using Function)，这类函数会根据当前 OpenGL 的状态执行一些操作。只要你记住 OpenGL 本质上是个大状态机，就能更容易理解它的大部分特性。</p><h2 id="简要工作流程"><a class="anchor" href="#简要工作流程">#</a> 简要工作流程</h2><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 创建对象</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> objectId <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glGenObject</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>objectId<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 绑定对象至上下文</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">glBindObject</span><span class="token punctuation">(</span>GL_WINDOW_TARGET<span class="token punctuation">,</span> objectId<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">glSetObjectOption</span><span class="token punctuation">(</span>GL_WINDOW_TARGET<span class="token punctuation">,</span> GL_OPTION_WINDOW_WIDTH<span class="token punctuation">,</span> <span class="token number">800</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">glSetObjectOption</span><span class="token punctuation">(</span>GL_WINDOW_TARGET<span class="token punctuation">,</span> GL_OPTION_WINDOW_HEIGHT<span class="token punctuation">,</span> <span class="token number">600</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// 将上下文对象设回默认</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token function">glBindObject</span><span class="token punctuation">(</span>GL_WINDOW_TARGET<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这一小段代码展现了你以后使用 OpenGL 时常见的工作流。我们首先创建一个对象，<mark>然后用一个 id 保存它的引用</mark>（实际数据被储存在后台）。然后我们将对象绑定至上下文的目标位置（例子中窗口对象目标的位置被定义成<mark> GL_WINDOW_TARGET</mark>）。接下来我们设置窗口的选项。<mark>最后我们将目标位置的对象 id 设回 0，解绑这个对象</mark>。设置的选项将被保存在 objectId 所引用的对象中，一旦我们重新绑定这个对象到<mark> GL_WINDOW_TARGET</mark> 位置，这些选项就会重新生效。</p><h2 id="opengl和glfw"><a class="anchor" href="#opengl和glfw">#</a> OpenGL 和 GLFW</h2><p>在我们画出出色的效果之前，首先要做的就是创建一个 OpenGL 上下文 (Context) 和一个用于显示的窗口。然而，<mark>这些操作在每个系统上都是不一样的，OpenGL 有目的地从这些操作抽象 (Abstract) 出去</mark>。这意味着我们不得不自己处理创建窗口，定义 OpenGL 上下文以及处理用户输入。</p><p>幸运的是，有一些库已经提供了我们所需的功能，其中一部分是特别针对 OpenGL 的。这些库节省了我们书写操作系统相关代码的时间，提供给我们一个窗口和上下文用来渲染。最流行的几个库有 GLUT，SDL，SFML 和 GLFW。在教程里我们将使用 GLFW。</p><p><mark>GLFW 是一个专门针对 OpenGL 的 C 语言库</mark>，它提供了一些渲染物体所需的最低限度的接口。它允许用户创建 OpenGL 上下文，定义窗口参数以及处理用户输入。</p><h2 id="glad"><a class="anchor" href="#glad">#</a> GLAD</h2><p>因为 OpenGL 只是一个标准 / 规范，具体的实现是由驱动开发商针对特定显卡实现的。由于 OpenGL 驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。所以任务就落在了开发者身上，开发者需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。取得地址的方法因平台而异，在 Windows 上会是类似这样：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 定义函数原型</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>GL_GENBUFFERS<span class="token punctuation">)</span> <span class="token punctuation">(</span>GLsizei<span class="token punctuation">,</span> GLuint<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 找到正确的函数并赋值给函数指针</span></pre></td></tr><tr><td data-num="4"></td><td><pre>GL_GENBUFFERS glGenBuffers  <span class="token operator">=</span> <span class="token punctuation">(</span>GL_GENBUFFERS<span class="token punctuation">)</span><span class="token function">wglGetProcAddress</span><span class="token punctuation">(</span><span class="token string">"glGenBuffers"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 现在函数可以被正常调用了</span></pre></td></tr><tr><td data-num="6"></td><td><pre>GLuint buffer<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>你可以看到代码非常复杂，而且很繁琐，我们需要对每个可能使用的函数都要重复这个过程。<mark>幸运的是，有些库能简化此过程，其中 GLAD 是目前最新，也是最流行的库</mark>。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">gladLoadGLLoader</span><span class="token punctuation">(</span><span class="token punctuation">(</span>GLADloadproc<span class="token punctuation">)</span>glfwGetProcAddress<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Failed to initialize GLAD"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>我们给 GLAD 传入了用来加载系统相关的 OpenGL 函数指针地址的函数。<mark>GLFW 给我们的是 glfwGetProcAddress，它根据我们编译的系统定义了正确的函数。</mark></p><p>上述环境配置参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC82NGZlNGE0YzFlZDg=">OpenGL 学习笔记（一）使用 VS2017 和 CMake 配置 GLFW 和 GLAD</span></p><hr><h1 id="introduction"><a class="anchor" href="#introduction">#</a> introduction</h1><h2 id="hello-window"><a class="anchor" href="#hello-window">#</a> Hello Window</h2><p>在我们开始渲染之前还有一件重要的事情要做，我们必须告诉 OpenGL 渲染窗口的尺寸大小，即视口 (Viewport)，这样 OpenGL 才只能知道怎样根据窗口大小显示数据和坐标。我们可以通过调用 glViewport 函数来设置窗口的维度 (Dimension)：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glViewport</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">800</span><span class="token punctuation">,</span> <span class="token number">600</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>OpenGL 幕后使用 glViewport 中定义的位置和宽高进行 2D 坐标的转换，将 OpenGL 中的位置坐标转换为你的屏幕坐标。例如，OpenGL 中的坐标 (-0.5, 0.5) 有可能（最终）被映射为屏幕中的坐标 (200,450)。注意，处理过的 OpenGL 坐标范围只为 - 1 到 1，<mark>因此我们事实上将 (-1 到 1) 范围内的坐标映射到 (0, 800) 和 (0, 600)</mark>。</p><p>我们还需要注册这个函数，告诉 GLFW 我们希望每当窗口调整大小的时候调用这个函数：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glfwSetFramebufferSizeCallback</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> framebuffer_size_callback<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>我们还可以将我们的函数注册到其它很多的回调函数中。比如说，我们可以创建一个回调函数来处理手柄输入变化，处理错误消息等。<mark>我们会在创建窗口之后，渲染循环初始化之前注册这些回调函数</mark>。</p><h3 id="渲染循环"><a class="anchor" href="#渲染循环">#</a> 渲染循环</h3><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">glfwWindowShouldClose</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">glfwSwapBuffers</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">glfwPollEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ul><li>glfwWindowShouldClose 函数在我们每次循环的开始前检查一次 GLFW 是否被要求退出，<mark>如果是的话该函数返回 true 然后渲染循环便结束了</mark>，之后为我们就可以关闭应用程序了。</li><li><mark>glfwPollEvents 函数检查有没有触发什么事件</mark>（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数（可以通过回调方法手动设置）。</li><li>glfwSwapBuffers 函数会交换颜色缓冲（它是一个储存着 GLFW 窗口每一个像素颜色值的大缓冲），<mark>它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上</mark>。</li></ul><h4 id="双缓冲double-buffer"><a class="anchor" href="#双缓冲double-buffer">#</a> 双缓冲 (Double Buffer)</h4><p>应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。前缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在后缓冲上绘制。<mark>当所有的渲染指令执行完毕后，我们交换 (Swap) 前缓冲和后缓冲</mark>，这样图像就立即呈显出来，之前提到的不真实感就消除了。</p><h3 id="释放资源"><a class="anchor" href="#释放资源">#</a> 释放资源</h3><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glfwTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="输入"><a class="anchor" href="#输入">#</a> 输入</h3><p>我们同样也希望能够在 GLFW 中实现一些输入控制，这可以通过使用 GLFW 的几个输入函数来完成。我们将会使用 GLFW 的<mark> glfwGetKey</mark> 函数，它需要一个窗口以及一个按键作为输入。这个函数将会返回这个按键是否正在被按下。我们将创建一个 processInput 函数来让所有的输入代码保持整洁。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">processInput</span><span class="token punctuation">(</span>GLFWwindow <span class="token operator">*</span>window<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">glfwGetKey</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> GLFW_KEY_ESCAPE<span class="token punctuation">)</span> <span class="token operator">==</span> GLFW_PRESS<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token function">glfwSetWindowShouldClose</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>我们接下来在渲染循环的每一个迭代中调用 processInput：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">glfwWindowShouldClose</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">processInput</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">glfwSwapBuffers</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">glfwPollEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="渲染"><a class="anchor" href="#渲染">#</a> 渲染</h3><p>我们要把所有的渲染 (Rendering) 操作放到渲染循环中，因为我们想让这些渲染指令在每次渲染循环迭代的时候都能被执行。代码将会是这样的：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 渲染循环</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">glfwWindowShouldClose</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token comment">// input</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token comment">// -----</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token function">processInput</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token comment">// render</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token comment">// ------</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token function">glClearColor</span><span class="token punctuation">(</span><span class="token number">0.2f</span><span class="token punctuation">,</span> <span class="token number">0.3f</span><span class="token punctuation">,</span> <span class="token number">0.3f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>	<span class="token comment">// glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>	<span class="token comment">// -------------------------------------------------------------------------------</span></pre></td></tr><tr><td data-num="15"></td><td><pre>	<span class="token function">glfwSwapBuffers</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	<span class="token function">glfwPollEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>我们可以通过调用 glClear 函数来清空屏幕的颜色缓冲，它接受一个缓冲位 (Buffer Bit) 来指定要清空的缓冲，可能的缓冲位有<mark> GL_COLOR_BUFFER_BIT</mark>，<mark>GL_DEPTH_BUFFER_BIT</mark> 和<mark> GL_STENCIL_BUFFER_BIT</mark>。由于现在我们只关心颜色值，所以我们只清空颜色缓冲。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>注意，除了 glClear 之外，我们还调用了 glClearColor 来设置清空屏幕所用的颜色。<mark>当调用 glClear 函数，清除颜色缓冲之后，整个颜色缓冲都会被填充为 glClearColor 里所设置的颜色</mark>。在这里，我们将屏幕设置为了类似黑板的深蓝绿色。</p><hr><h2 id="hello-triangle"><a class="anchor" href="#hello-triangle">#</a> Hello Triangle</h2><p>在学习此节之前，建议将这三个单词先记下来：</p><ul><li>顶点数组对象：Vertex Array Object，VAO</li><li>顶点缓冲对象：Vertex Buffer Object，VBO</li><li>索引缓冲对象：Element Buffer Object，EBO 或 Index Buffer Object，IBO</li></ul><p>在 OpenGL 中，任何事物都在 3D 空间中，而屏幕和窗口却是 2D 像素数组，这导致 OpenGL 的大部分工作都是关于把 3D 坐标转变为适应你屏幕的 2D 像素。<mark>3D 坐标转为 2D 坐标的处理过程是由 OpenGL 的图形渲染管线（Graphics Pipeline，大多译为管线</mark>，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：<mark>第一部分把你的 3D 坐标转换为 2D 坐标，第二部分是把 2D 坐标转变为实际的有颜色的像素</mark>。这个教程里，我们会简单地讨论一下图形渲染管线，以及如何利用它创建一些漂亮的像素。</p><p>2D 坐标和像素也是不同的，2D 坐标精确表示一个点在 2D 空间中的位置，而 2D 像素是这个点的近似值，<mark>2D 像素受到你的屏幕 / 窗口分辨率的限制</mark>。</p><p>下面，你会看到一个图形渲染管线的每个阶段的抽象展示。要注意蓝色部分代表的是我们可以注入自定义的着色器的部分。</p><p><img data-src="https://learnopengl-cn.github.io/img/01/04/pipeline.png" alt="image"></p><p>第一个部分是顶点着色器 (Vertex Shader)，它把一个单独的顶点作为输入。<mark>顶点着色器主要的目的是把 3D 坐标转为另一种 3D 坐标</mark>，同时顶点着色器允许我们对顶点属性进行一些基本处理。</p><p>图元装配 (Primitive Assembly) 阶段将顶点着色器输出的所有顶点作为输入（如果是 GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状；本节例子中是一个三角形。</p><p>图元装配阶段的输出会传递给几何着色器 (Geometry Shader)。几何着色器把图元形式的一系列顶点的集合作为输入，<mark>它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状</mark>。例子中，它生成了另一个三角形。</p><p>几何着色器的输出会被传入<mark>光栅化阶段</mark> (Rasterization Stage)，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器 (Fragment Shader) 使用的片段 (Fragment)。在片段着色器运行之前会执行裁切 (Clipping)。<mark>裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率</mark>。</p><blockquote><h5 id="注opengl中的一个片段是opengl渲染一个像素所需的所有数据"><a class="anchor" href="#注opengl中的一个片段是opengl渲染一个像素所需的所有数据">#</a> 注：OpenGL 中的一个片段是 OpenGL 渲染一个像素所需的所有数据。</h5></blockquote><p><mark>片段着色器</mark>的主要目的是<mark>计算一个像素的最终颜色</mark>，这也是所有 OpenGL 高级效果产生的地方。通常，片段着色器包含 3D 场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。</p><p>在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做<mark> Alpha 测试和混合 (Blending) 阶段</mark>。这个阶段检测片段的对应的深度（和模板 (Stencil)）值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查 alpha 值（alpha 值定义了一个物体的透明度）并对物体进行混合 (Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。</p><p>可以看到，图形渲染管线非常复杂，它包含很多可配置的部分。然而，对于大多数场合，<mark>我们只需要配置顶点和片段着色器就行了</mark>。几何着色器是可选的，通常使用它默认的着色器就行了。</p><p>在现代 OpenGL 中，<mark>我们必须定义至少一个顶点着色器和一个片段着色器</mark>（因为 GPU 中没有默认的顶点 / 片段着色器）。出于这个原因，刚开始学习现代 OpenGL 的时候可能会非常困难，因为在你能够渲染自己的第一个三角形之前已经需要了解一大堆知识了。在本节结束你最终渲染出你的三角形的时候，你也会了解到非常多的图形编程知识。</p><h3 id="顶点输入"><a class="anchor" href="#顶点输入">#</a> 顶点输入</h3><p>开始绘制图形之前，我们必须先给 OpenGL 输入一些顶点数据。OpenGL 是一个 3D 图形库，所以我们在 OpenGL 中指定的所有坐标都是 3D 坐标（x、y 和 z）。OpenGL 不是简单地把所有的 3D 坐标变换为屏幕上的 2D 像素；<mark>OpenGL 仅当 3D 坐标在 3 个轴（x、y 和 z）上都为 - 1.0 到 1.0 的范围内时才处理它</mark>。所有在所谓的标准化设备坐标 (Normalized Device Coordinates) 范围内的坐标才会最终呈现在屏幕上（在这个范围以外的坐标都不会显示）。</p><p>顶点定义（三角形为例）：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> vertices<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>     <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>     <span class="token number">0.0f</span><span class="token punctuation">,</span>  <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>标准化设备坐标 (Normalized Device Coordinates, NDC)</p><p>一旦你的顶点坐标已经在顶点着色器中处理过，它们就应该是标准化设备坐标了，标准化设备坐标是一个 x、y 和 z 值在 - 1.0 到 1.0 的一小段空间。任何落在范围外的坐标都会被丢弃 / 裁剪，不会显示在你的屏幕上。下面你会看到我们定义的在标准化设备坐标中的三角形 (忽略 z 轴)：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/04/ndc.png" alt="image"></p><p>与通常的屏幕坐标不同，y 轴正方向为向上，(0, 0) 坐标是这个图像的中心，而不是左上角。最终你希望所有 (变换过的) 坐标都在这个坐标空间中，否则它们就不可见了。</p><p>你的标准化设备坐标接着会变换为<mark>屏幕空间坐标</mark> (Screen-space Coordinates)，这是使用你通过 glViewport 函数提供的数据，进行<mark>视口变换</mark> (Viewport Transform) 完成的。<mark>所得的屏幕空间坐标又会被变换为片段输入到片段着色器中</mark>。</p><p>我们通过<mark>顶点缓冲对象</mark> (Vertex Buffer Objects, VBO) 管理这个内存，它会在 GPU 内存（通常被称为显存）中储存大量顶点。使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。从 CPU 把数据发送到显卡相对较慢，所以只要可能我们都要尝试尽量一次性发送尽可能多的数据。当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。</p><p>顶点缓冲对象是我们在 OpenGL 教程中第一个出现的 OpenGL 对象。就像 OpenGL 中的其它对象一样，这个缓冲有一个独一无二的 ID，所以我们可以使用 glGenBuffers 函数和一个缓冲 ID 生成一个 VBO 对象：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> VBO<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>VBO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>OpenGL 有很多缓冲对象类型，顶点缓冲对象的缓冲类型是<mark> GL_ARRAY_BUFFER</mark>。OpenGL 允许我们同时绑定多个缓冲，只要它们是不同的缓冲类型。我们可以使用<mark> glBindBuffer</mark> 函数把新创建的缓冲绑定<mark>到 GL_ARRAY_BUFFER</mark> 目标上：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> VBO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>从这一刻起，我们使用的任何（在<mark> GL_ARRAY_BUFFER</mark> 目标上的）缓冲调用都会用来配置当前绑定的缓冲 (VBO)。然后我们可以调用<mark> glBufferData</mark> 函数，它会把之前定义的顶点数据复制到缓冲的内存中：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>vertices<span class="token punctuation">)</span><span class="token punctuation">,</span> vertices<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>glBufferData 是一个专门用来把用户定义的数据复制到当前绑定缓冲的函数。它的第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到<mark> GL_ARRAY_BUFFER</mark> 目标上。第二个参数指定传输数据的大小 (以字节为单位)；用一个简单的 sizeof 计算出顶点数据大小就行。第三个参数是我们希望发送的实际数据。</p><p>第四个参数指定了我们希望显卡如何管理给定的数据。它有三种形式：</p><ul><li>GL_STATIC_DRAW ：数据不会或几乎不会改变。</li><li>GL_DYNAMIC_DRAW：数据会被改变很多。</li><li>GL_STREAM_DRAW ：数据每次绘制时都会改变。</li></ul><p>如果三角形的位置数据不会改变，每次渲染调用时都保持原样，则它的使用类型最好是<mark> GL_STATIC_DRAW</mark>。如果，比如说一个缓冲中的数据将频繁被改变，那么使用的类型就是<mark> GL_DYNAMIC_DRAW</mark> 或<mark> GL_STREAM_DRAW</mark>，这样就能确保显卡把数据放在能够高速写入的内存部分。</p><h3 id="顶点着色器"><a class="anchor" href="#顶点着色器">#</a> 顶点着色器</h3><p>我们需要做的第一件事是用着色器语言 GLSL (OpenGL Shading Language) 编写顶点着色器，然后编译这个着色器，这样我们就可以在程序中使用它了。下面你会看到一个非常基础的 GLSL 顶点着色器的源代码：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">460</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> in vec3 aPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    gl_Position <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>aPos<span class="token punctuation">.</span>x<span class="token punctuation">,</span> aPos<span class="token punctuation">.</span>y<span class="token punctuation">,</span> aPos<span class="token punctuation">.</span>z<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>可以看到，GLSL 看起来很像 C 语言。每个着色器都起始于一个版本声明。OpenGL 3.3 以及和更高版本中，GLSL 版本号和 OpenGL 的版本是匹配的（<mark>比如说 GLSL 420 版本对应于 OpenGL 4.2</mark>）。我们同样明确表示我们会使用核心模式。</p><p>下一步，<mark>使用 in 关键字，在顶点着色器中声明所有的输入顶点属性</mark> (Input Vertex Attribute)。现在我们只关心位置 (Position) 数据，所以我们只需要一个顶点属性。GLSL 有一个向量数据类型，它包含 1 到 4 个 float 分量，包含的数量可以从它的后缀数字看出来。由于每个顶点都有一个 3D 坐标，我们就创建一个 vec3 输入变量 aPos。我们同样也通过 layout (location = 0) 设定了输入变量的位置值 (Location) 你后面会看到为什么我们会需要这个位置值。</p><h4 id="向量vector"><a class="anchor" href="#向量vector">#</a> 向量 (Vector)</h4><p>在图形编程中我们经常会使用向量这个数学概念，因为它简明地表达了任意空间中的位置和方向，并且它有非常有用的数学属性。在 GLSL 中一个向量有最多 4 个分量，每个分量值都代表空间中的一个坐标，它们可以通过 vec.x、vec.y、vec.z 和 vec.w 来获取。注意 vec.w 分量不是用作表达空间中的位置的（我们处理的是 3D 不是 4D），而是用在所谓<mark>透视除法</mark> (Perspective Division) 上。我们会在后面的教程中更详细地讨论向量。</p><p>为了设置顶点着色器的输出，我们必须把位置数据赋值给预定义的 gl_Position 变量，它在幕后是 vec4 类型的。在 main 函数的最后，我们将 gl_Position 设置的值会成为该顶点着色器的输出。由于我们的输入是一个 3 分量的向量，我们必须把它转换为 4 分量的。我们可以把 vec3 的数据作为 vec4 构造器的参数，同时把 w 分量设置为 1.0f（我们会在后面解释为什么）来完成这一任务。</p><p>当前这个顶点着色器可能是我们能想到的最简单的顶点着色器了，因为我们对输入数据什么都没有处理就把它传到着色器的输出了。在真实的程序里输入数据通常都不是标准化设备坐标，所以我们首先必须先把它们转换至 OpenGL 的可视区域内。</p><h3 id="编译着色器"><a class="anchor" href="#编译着色器">#</a> 编译着色器</h3><p>我们已经写了一个顶点着色器源码（储存在一个 C 的字符串中），但是为了能够让 OpenGL 使用它，我们必须在运行时动态编译它的源码。</p><p>我们首先要做的是创建一个着色器对象，注意还是用 ID 来引用的。所以我们储存这个顶点着色器为 unsigned int，然后用 glCreateShader 创建这个着色器：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> vertexShader<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>vertexShader <span class="token operator">=</span> <span class="token function">glCreateShader</span><span class="token punctuation">(</span>GL_VERTEX_SHADER<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>我们把需要创建的着色器类型以参数形式提供给 glCreateShader。由于我们正在创建一个顶点着色器，传递的参数是<mark> GL_VERTEX_SHADER</mark>。</p><p>下一步我们把这个着色器源码附加到着色器对象上，然后编译它：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glShaderSource</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>vertexShaderSource<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glCompileShader</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>你可能会希望检测在调用 glCompileShader 后编译是否成功了，如果没成功的话，你还会希望知道错误是什么，这样你才能修复它们。检测编译时错误可以通过以下代码来实现：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span>  success<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">char</span> infoLog<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glGetShaderiv</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">,</span> GL_COMPILE_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>首先我们定义一个整型变量来表示是否成功编译，还定义了一个储存错误消息（如果有的话）的容器。然后我们用 glGetShaderiv 检查是否编译成功。如果编译失败，我们会用 glGetShaderInfoLog 获取错误消息，然后打印它。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">glGetShaderInfoLog</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> infoLog<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span> <span class="token operator">&lt;&lt;</span> infoLog <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="片段着色器"><a class="anchor" href="#片段着色器">#</a> 片段着色器</h3><p>片段着色器 (Fragment Shader) 是第二个也是最后一个我们打算创建的用于渲染三角形的着色器。片段着色器所做的是计算像素最后的颜色输出。为了让事情更简单，我们的片段着色器将会一直输出橘黄色。</p><p>在计算机图形中颜色被表示为有 4 个元素的数组：红色、绿色、蓝色和 alpha (透明度) 分量，通常缩写为 RGBA。当在 OpenGL 或 GLSL 中定义一个颜色的时候，我们把颜色每个分量的强度设置在 0.0 到 1.0 之间。比如说我们设置红为 1.0f，绿为 1.0f，我们会得到两个颜色的混合色，即黄色。这三种颜色分量的不同调配可以生成超过 1600 万种不同的颜色！</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>out vec4 FragColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.2f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>片段着色器只需要一个输出变量，这个变量是一个 4 分量向量，它表示的是最终的输出颜色，我们应该自己将其计算出来。我们可以用 out 关键字声明输出变量，这里我们命名为 FragColor。下面，我们将一个 alpha 值为 1.0 (1.0 代表完全不透明) 的橘黄色的 vec4 赋值给颜色输出。</p><p>编译片段着色器的过程与顶点着色器类似，只不过我们使用<mark> GL_FRAGMENT_SHADER</mark> 常量作为着色器类型：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> fragmentShader<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>fragmentShader <span class="token operator">=</span> <span class="token function">glCreateShader</span><span class="token punctuation">(</span>GL_FRAGMENT_SHADER<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glShaderSource</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fragmentShaderSource<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glCompileShader</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="着色器程序"><a class="anchor" href="#着色器程序">#</a> 着色器程序</h4><p>着色器程序对象 (Shader Program Object) 是多个着色器合并之后并最终链接完成的版本。如果要使用刚才编译的着色器我们必须把它们链接 (Link) 为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。已激活着色器程序的着色器将在我们发送渲染调用的时候被使用。</p><p>当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当输出和输入不匹配的时候，你会得到一个连接错误。</p><p>创建一个程序对象很简单：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> shaderProgram<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>shaderProgram <span class="token operator">=</span> <span class="token function">glCreateProgram</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>glCreateProgram 函数创建一个程序，并返回新创建程序对象的 ID 引用。现在我们需要把之前编译的着色器附加到程序对象上，然后用 glLinkProgram 链接它们：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glAttachShader</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">,</span> vertexShader<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glAttachShader</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">,</span> fragmentShader<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glLinkProgram</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>代码应该很清楚，我们把着色器附加到了程序上，然后用 glLinkProgram 链接。</p><p>就像着色器的编译一样，我们也可以检测链接着色器程序是否失败，并获取相应的日志。与上面不同，我们不会调用 glGetShaderiv 和 glGetShaderInfoLog，现在我们使用：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glGetProgramiv</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">,</span> GL_LINK_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">glGetProgramInfoLog</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> infoLog<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>得到的结果就是一个程序对象，我们可以调用 glUseProgram 函数，用刚创建的程序对象作为它的参数，以激活这个程序对象：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glUseProgram</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在 glUseProgram 函数调用之后，每个着色器调用和渲染调用都会使用这个程序对象（也就是之前写的着色器) 了。</p><p>对了，在把着色器对象链接到程序对象以后，记得删除着色器对象，我们不再需要它们了：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glDeleteShader</span><span class="token punctuation">(</span>vertexShader<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glDeleteShader</span><span class="token punctuation">(</span>fragmentShader<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>现在，我们已经把输入顶点数据发送给了 GPU，并指示了 GPU 如何在顶点和片段着色器中处理它。就快要完成了，但还没结束，OpenGL 还不知道它该如何解释内存中的顶点数据，以及它该如何将顶点数据链接到顶点着色器的属性上。我们需要告诉 OpenGL 怎么做。</p><h4 id="链接顶点属性"><a class="anchor" href="#链接顶点属性">#</a> 链接顶点属性</h4><p>顶点着色器允许我们指定任何以顶点属性为形式的输入。这使其具有很强的灵活性的同时，它还的确意味着我们必须<mark>手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性</mark>。所以，我们必须在渲染前指定 OpenGL 该如何解释顶点数据。</p><p>我们的顶点缓冲数据会被解析为下面这样子 (三角形三个顶点)：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/04/vertex_attribute_pointer.png" alt="image"></p><ul><li>位置数据被储存为 32 位（4 字节）浮点值。</li><li>每个位置包含 3 个这样的值。</li><li>在这 3 个值之间没有空隙（或其他值）。这几个值在数组中紧密排列 (Tightly Packed)。</li><li>数据中第一个值在缓冲开始的位置。</li></ul><p>有了这些信息我们就可以使用<mark> glVertexAttribPointer</mark> 函数告诉 OpenGL 该如何解析顶点数据（应用到逐个顶点属性上）了：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>glVertexAttribPointer 函数的参数非常多，所以我会逐一介绍它们：</p><ul><li>第一个参数指定我们要配置的顶点属性。还记得我们在顶点着色器中使用 layout (location = 0) 定义了 position 顶点属性的位置值 (Location) 吗？它可以把顶点属性的位置值设置为 0。因为我们希望把数据传递到这一个顶点属性中，所以这里我们传入 0。</li><li>第二个参数指定顶点属性的大小。顶点属性是一个 vec3，它由 3 个值组成，所以大小是 3。</li><li>第三个参数指定数据的类型，这里是 GL_FLOAT (GLSL 中 vec * 都是由浮点数值组成的)。</li><li>下个参数定义我们是否希望数据被标准化 (Normalize)。如果我们设置为 GL_TRUE，所有数据都会被映射到 0（对于有符号型 signed 数据是 - 1）到 1 之间。我们把它设置为 GL_FALSE。</li><li>第五个参数叫做步长 (Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在 3 个 float 之后，我们把步长设置为 3 * sizeof (float)。要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以设置为 0 来让 OpenGL 决定具体步长是多少（只有当数值是紧密排列时才可用）。一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔，我们在后面会看到更多的例子（译注：这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组 0 位置之间有多少字节）。</li><li>最后一个参数的类型是 void*，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量 (Offset)。由于位置数据在数组的开头，所以这里是 0。我们会在后面详细解释这个参数。</li></ul><p>每个顶点属性从一个 VBO 管理的内存中获得它的数据，而具体是从哪个 VBO（程序中可以有多个 VBO）获取则是通过在调用 glVetexAttribPointer 时绑定到<mark> GL_ARRAY_BUFFER</mark> 的 VBO 决定的。由于在调用 glVetexAttribPointer 之前绑定的是先前定义的 VBO 对象，顶点属性 0 表示现在会链接到它的顶点数据。</p><p>现在我们已经定义了 OpenGL 该如何解释顶点数据，我们现在应该使用 glEnableVertexAttribArray，以顶点属性位置值作为参数，启用顶点属性；顶点属性默认是禁用的。自此，所有东西都已经设置好了：我们使用一个顶点缓冲对象将顶点数据初始化至缓冲中，建立了一个顶点和一个片段着色器，并告诉了 OpenGL 如何把顶点数据链接到顶点着色器的顶点属性上。在 OpenGL 中绘制一个物体，代码会像是这样：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 0. 复制顶点数组到缓冲中供 OpenGL 使用</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> VBO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>vertices<span class="token punctuation">)</span><span class="token punctuation">,</span> vertices<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 1. 设置顶点属性指针</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 2. 当我们渲染一个物体时要使用着色器程序</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">glUseProgram</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// 3. 绘制物体</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token function">someOpenGLFunctionThatDrawsOurTriangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>每当我们绘制一个物体的时候都必须重复这一过程。这看起来可能不多，但是如果有超过 5 个顶点属性，上百个不同物体呢（这其实并不罕见）。绑定正确的缓冲对象，为每个物体配置所有顶点属性很快就变成一件麻烦事。有没有一些方法可以使我们把所有这些状态配置储存在一个对象中，并且可以通过绑定这个对象来恢复状态呢？</p><h4 id="顶点数组对象"><a class="anchor" href="#顶点数组对象">#</a> 顶点数组对象</h4><p>顶点数组对象 (Vertex Array Object, VAO) 可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个 VAO 中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的 VAO 就行了。这使在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的 VAO 就行了。刚刚设置的所有状态都将存储在 VAO 中</p><p>一个顶点数组对象会储存以下这些内容：</p><ul><li>glEnableVertexAttribArray 和 glDisableVertexAttribArray 的调用。</li><li>通过 glVertexAttribPointer 设置的顶点属性配置。</li><li>通过 glVertexAttribPointer 调用与顶点属性关联的顶点缓冲对象。</li></ul><p><img data-src="https://learnopengl-cn.github.io/img/01/04/vertex_array_objects.png" alt="image"></p><p>创建一个 VAO 和创建一个 VBO 很类似：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> VAO<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glGenVertexArrays</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>VAO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>要想使用 VAO，要做的只是使用 glBindVertexArray 绑定 VAO。从绑定之后起，我们应该绑定和配置对应的 VBO 和属性指针，之后解绑 VAO 供之后使用。当我们打算绘制一个物体的时候，我们只要在绘制物体前简单地把 VAO 绑定到希望使用的设定上就行了。这段代码应该看起来像这样：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//..:: 初始化代码（只运行一次 (除非你的物体频繁改变)） :: ..</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 1. 绑定 VAO</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>VAO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 2. 把顶点数组复制到缓冲中供 OpenGL 使用</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> VBO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>vertices<span class="token punctuation">)</span><span class="token punctuation">,</span> vertices<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 3. 设置顶点属性指针</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">//..:: 绘制代码（渲染循环中） :: ..</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment">// 4. 绘制物体</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token function">glUseProgram</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>VAO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token function">someOpenGLFunctionThatDrawsOurTriangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>就这么多了！前面做的一切都是等待这一刻，一个储存了我们顶点属性配置和应使用的 VBO 的顶点数组对象。一般当你打算绘制多个物体时，你首先要生成 / 配置所有的 VAO（和必须的 VBO 及属性指针)，然后储存它们供后面使用。<mark>当我们打算绘制物体的时候就拿出相应的 VAO，绑定它，绘制完物体后，再解绑 VAO</mark>。</p><h3 id="我们一直期待的三角形"><a class="anchor" href="#我们一直期待的三角形">#</a> 我们一直期待的三角形</h3><p>要想绘制我们想要的物体，OpenGL 给我们提供了 glDrawArrays 函数，它使用当前激活的着色器，之前定义的顶点属性配置，和 VBO 的顶点数据（通过 VAO 间接绑定）来绘制图元。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glUseProgram</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>VAO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glDrawArrays</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>glDrawArrays 函数第一个参数是我们打算绘制的 OpenGL 图元的类型。由于我们在一开始时说过，我们希望绘制的是一个三角形，这里传递 GL_TRIANGLES 给它。第二个参数指定了顶点数组的起始索引，我们这里填 0。最后一个参数指定我们打算绘制多少个顶点，这里是 3（我们只从我们的数据中渲染一个三角形，它只有 3 个顶点长）。</p><p>现在尝试编译代码，如果弹出了任何错误，回头检查你的代码。如果你编译通过了，你应该看到下面的结果：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/04/hellotriangle.png" alt="image"></p><h4 id="索引缓冲对象"><a class="anchor" href="#索引缓冲对象">#</a> 索引缓冲对象</h4><p>在渲染顶点这一话题上我们还有最后一个需要讨论的东西 —— 索引缓冲对象 (Element Buffer Object，EBO，也叫 Index Buffer Object，IBO)。要解释索引缓冲对象的工作方式最好还是举个例子：假设我们不再绘制一个三角形而是绘制一个矩形。我们可以绘制两个三角形来组成一个矩形（OpenGL 主要处理三角形）。这会生成下面的顶点的集合：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> vertices<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 第一个三角形</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>   <span class="token comment">// 右上角</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>  <span class="token comment">// 右下角</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>  <span class="token comment">// 左上角</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 第二个三角形</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>  <span class="token comment">// 右下角</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token comment">// 左下角</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span>   <span class="token comment">// 左上角</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>可以看到，有几个顶点叠加了。我们指定了右下角和左上角两次！一个矩形只有 4 个而不是 6 个顶点，这样就产生 50% 的额外开销。当我们有包括上千个三角形的模型之后这个问题会更糟糕，这会产生一大堆浪费。更好的解决方案是只储存不同的顶点，并设定绘制这些顶点的顺序。这样子我们只要储存 4 个顶点就能绘制矩形了，之后只要指定绘制的顺序就行了。如果 OpenGL 提供这个功能就好了，对吧？</p><p>很幸运，索引缓冲对象的工作方式正是这样的。和顶点缓冲对象一样，EBO 也是一个缓冲，它专门储存索引，OpenGL 调用这些顶点的索引来决定该绘制哪个顶点。所谓的<mark>索引绘制</mark> (Indexed Drawing) 正是我们问题的解决方案。首先，我们先要定义（不重复的）顶点，和绘制出矩形所需的索引：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> vertices<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>   <span class="token comment">// 右上角</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>  <span class="token comment">// 右下角</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token comment">// 左下角</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span>   <span class="token comment">// 左上角</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> indices<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 注意索引从 0 开始！</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token comment">// 第一个三角形</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span>  <span class="token comment">// 第二个三角形</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>你可以看到，当时用索引的时候，我们只定义了 4 个顶点，而不是 6 个。下一步我们需要创建索引缓冲对象：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> EBO<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>EBO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>与 VBO 类似，我们先绑定 EBO 然后用 glBufferData 把索引复制到缓冲里。同样，和 VBO 类似，我们会把这些函数调用放在绑定和解绑函数调用之间，只不过这次我们把缓冲的类型定义为<mark> GL_ELEMENT_ARRAY_BUFFER</mark>。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> EBO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>indices<span class="token punctuation">)</span><span class="token punctuation">,</span> indices<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>要注意的是，我们传递了 GL_ELEMENT_ARRAY_BUFFER 当作缓冲目标。最后一件要做的事是<mark>用 glDrawElements 来替换 glDrawArrays 函数</mark>，来指明我们从索引缓冲渲染。使用<strong> glDrawElements</strong> 时，我们会使用当前绑定的索引缓冲对象中的索引进行绘制：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> EBO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glDrawElements</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> GL_UNSIGNED_INT<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>第一个参数指定了我们绘制的模式，这个和 glDrawArrays 的一样。第二个参数是我们打算绘制顶点的个数，这里填 6，也就是说我们一共需要绘制 6 个顶点。第三个参数是索引的类型，这里是 GL_UNSIGNED_INT。最后一个参数里我们可以指定 EBO 中的偏移量（或者传递一个索引数组，但是这是当你不在使用索引缓冲对象的时候），但是我们会在这里填写 0。</p><p>glDrawElements 函数从当前绑定到 GL_ELEMENT_ARRAY_BUFFER 目标的 EBO 中获取索引。这意味着我们必须在每次要用索引渲染一个物体时绑定相应的 EBO，这还是有点麻烦。不过顶点数组对象同样可以保存索引缓冲对象的绑定状态。VAO 绑定时正在绑定的索引缓冲对象会被保存为 VAO 的元素缓冲对象。绑定 VAO 的同时也会自动绑定 EBO。</p><p><img data-src="https://learnopengl-cn.github.io/img/01/04/vertex_array_objects_ebo.png" alt="image"></p><p>最后的初始化和绘制代码现在看起来像这样：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//..:: 初始化代码 :: ..</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 1. 绑定顶点数组对象</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>VAO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 2. 把我们的顶点数组复制到一个顶点缓冲中，供 OpenGL 使用</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> VBO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>vertices<span class="token punctuation">)</span><span class="token punctuation">,</span> vertices<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 3. 复制我们的索引数组到一个索引缓冲中，供 OpenGL 使用</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> EBO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ELEMENT_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>indices<span class="token punctuation">)</span><span class="token punctuation">,</span> indices<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// 4. 设定顶点属性指针</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token comment">//..:: 绘制代码（渲染循环中） :: ..</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token function">glUseProgram</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>VAO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token function">glDrawElements</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> GL_UNSIGNED_INT<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token function">glBindVertexArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>运行程序会获得下面这样的图片的结果。左侧图片看应该起来很熟悉，而右侧的则是使用线框模式 (Wireframe Mode) 绘制的。线框矩形可以显示出矩形的确是由两个三角形组成的。</p><p><img data-src="https://learnopengl-cn.github.io/img/01/04/hellotriangle2.png" alt="image"></p><p>线框模式 (Wireframe Mode)</p><p>要想用线框模式绘制你的三角形，你可以通过 glPolygonMode (GL_FRONT_AND_BACK, GL_LINE) 函数配置 OpenGL 如何绘制图元。第一个参数表示我们打算将其应用到所有的三角形的正面和背面，第二个参数告诉我们用线来绘制。之后的绘制调用会一直以线框模式绘制三角形，直到我们用 glPolygonMode (GL_FRONT_AND_BACK, GL_FILL) 将其设置回默认模式。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glPolygonMode</span><span class="token punctuation">(</span>GL_FRONT_AND_BACK<span class="token punctuation">,</span> GL_LINE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 线框模式</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glPolygonMode</span><span class="token punctuation">(</span>GL_FRONT_AND_BACK<span class="token punctuation">,</span> GL_FILL<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 默认模式</span></pre></td></tr></table></figure><hr><h2 id="着色器"><a class="anchor" href="#着色器">#</a> 着色器</h2><p>着色器 (Shader) 是运行在<mark> GPU</mark> 上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。从基本意义上来说，着色器只是一种把输入转化为输出的程序。<mark>着色器也是一种非常独立的程序，因为它们之间不能相互通信</mark>；它们之间唯一的沟通只有通过输入和输出。</p><h3 id="着色器语言glsl"><a class="anchor" href="#着色器语言glsl">#</a> 着色器语言 GLSL</h3><p>着色器是使用一种叫 GLSL 的类 C 语言写成的。GLSL 是为图形计算量身定制的，它包含一些针对向量和矩阵操作的有用特性。</p><p>着色器的开头总是要声明版本，接着是输入和输出变量、uniform 和 main 函数。每个着色器的入口点都是 main 函数，在这个函数中我们处理所有的输入变量，并将结果输出到输出变量中。如果你不知道什么是 uniform 也不用担心，我们后面会进行讲解。</p><p>一个典型的着色器有下面的结构：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression">version_number</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>in type in_variable_name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>in type in_variable_name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>out type out_variable_name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>uniform type uniform_name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token comment">// 处理输入并进行一些图形操作</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token comment">// 输出处理过的结果到输出变量</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  out_variable_name <span class="token operator">=</span> weird_stuff_we_processed<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>当我们特别谈论到顶点着色器的时候，每个输入变量也叫<mark>顶点属性</mark> (Vertex Attribute)。我们能声明的顶点属性是有上限的，它一般由硬件来决定。OpenGL 确保至少有<mark> 16</mark> 个包含 4 分量的顶点属性可用，但是有些硬件或许允许更多的顶点属性，你可以查询 GL_MAX_VERTEX_ATTRIBS 来获取具体的上限：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> nrAttributes<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glGetIntegerv</span><span class="token punctuation">(</span>GL_MAX_VERTEX_ATTRIBS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>nrAttributes<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Maximum nr of vertex attributes supported: "</span> <span class="token operator">&lt;&lt;</span> nrAttributes <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="数据类型"><a class="anchor" href="#数据类型">#</a> 数据类型</h3><p>和其他编程语言一样，GLSL 有数据类型可以来指定变量的种类。GLSL 中包含 C 等其它语言大部分的默认基础数据类型：<mark>int、float、double、uint 和 bool</mark>。GLSL 也有两种容器类型，它们会在这个教程中使用很多，分别是<mark>向量</mark> (Vector) 和<mark>矩阵</mark> (Matrix)，其中矩阵我们会在之后的教程里再讨论。</p><h4 id="向量"><a class="anchor" href="#向量">#</a> 向量</h4><p>GLSL 中的向量是一个可以包含有<mark> 1、2、3 或者 4</mark> 个分量的容器，分量的类型可以是前面默认基础类型的任意一个。它们可以是下面的形式（n 代表分量的数量）：</p><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>vecn</td><td>包含 n 个 float 分量的默认向量</td></tr><tr><td>bvecn</td><td>包含 n 个 bool 分量的向量</td></tr><tr><td>ivecn</td><td>包含 n 个 int 分量的向量</td></tr><tr><td>uvecn</td><td>包含 n 个 unsigned int 分量的向量</td></tr><tr><td>dvecn</td><td>包含 n 个 double 分量的向量</td></tr></tbody></table><p>一个向量的分量可以通过 vec.x 这种方式获取，这里 x 是指这个向量的第一个分量。你可以分别使用.x、.y、.z 和.w 来获取它们的第 1、2、3、4 个分量。GLSL 也允许你对颜色使用<mark> rgba</mark>，或是对纹理坐标使用<mark> stpq</mark> 访问相同的分量。</p><p>向量这一数据类型也允许一些有趣而灵活的分量选择方式，叫做<mark>重组</mark> (Swizzling)。重组允许这样的语法：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vec2 someVec<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>vec4 differentVec <span class="token operator">=</span> someVec<span class="token punctuation">.</span>xyxx<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>vec3 anotherVec <span class="token operator">=</span> differentVec<span class="token punctuation">.</span>zyw<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>vec4 otherVec <span class="token operator">=</span> someVec<span class="token punctuation">.</span>xxxx <span class="token operator">+</span> anotherVec<span class="token punctuation">.</span>yxzy<span class="token punctuation">;</span></pre></td></tr></table></figure><p>你可以使用上面<mark> 4 个字母任意组合</mark>来创建一个和原来向量一样长的（同类型）新向量，只要原来向量有那些分量即可；然而，你<mark>不允许在一个 vec2 向量中去获取.z 元素</mark>。我们也可以把一个向量作为一个参数传给不同的向量构造函数，以减少需求参数的数量。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vec2 vect <span class="token operator">=</span> <span class="token function">vec2</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.7</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>vec4 result <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>vect<span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>vec4 otherResult <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>xyz<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="输入与输出"><a class="anchor" href="#输入与输出">#</a> 输入与输出</h4><p>GLSL 定义了<mark> in</mark> 和<mark> out</mark> 关键字专门来实现数据交流与传递。每个着色器使用这两个关键字设定输入和输出，只要一个输出变量与下一个着色器阶段的输入匹配，它就会传递下去。但在顶点和片段着色器中会有点不同。</p><p><mark>顶点着色器</mark>需要为它的输入提供一个额外的 layout 标识，这样我们才能把它链接到顶点数据。</p><blockquote><p>你也可以忽略 layout (location = 0) 标识符，通过在 OpenGL 代码中使用 glGetAttribLocation 查询属性位置值 (Location)，但是我更喜欢在着色器中设置它们，这样会更容易理解而且节省你（和 OpenGL）的工作量。</p></blockquote><p>另一个例外是<mark>片段着色器</mark>，它需要一个 vec4 颜色输出变量，因为片段着色器需要生成一个最终输出的颜色。如果你在片段着色器没有定义输出颜色，OpenGL 会把你的物体渲染为<mark>黑色（或白色</mark>）。</p><p>所以，如果我们打算从一个着色器向另一个着色器发送数据，我们必须在发送方着色器中声明一个输出，在接收方着色器中声明一个类似的输入。<mark>当类型和名字都一样</mark>的时候，OpenGL 就会把两个变量链接到一起，它们之间就能发送数据了（这是在链接程序对象时完成的）。为了展示这是如何工作的，我们会稍微改动一下之前教程里的那个着色器，让顶点着色器为片段着色器决定颜色。</p><h5 id="顶点着色器-2"><a class="anchor" href="#顶点着色器-2">#</a> 顶点着色器</h5><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> in vec3 aPos<span class="token punctuation">;</span> <span class="token comment">// 位置变量的属性位置值为 0</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>out vec4 vertexColor<span class="token punctuation">;</span> <span class="token comment">// 为片段着色器指定一个颜色输出</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    gl_Position <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>aPos<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注意我们如何把一个 vec3 作为 vec4 的构造器的参数</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    vertexColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 把输出变量设置为暗红色</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h5 id="片段着色器-2"><a class="anchor" href="#片段着色器-2">#</a> 片段着色器</h5><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>out vec4 FragColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>in vec4 vertexColor<span class="token punctuation">;</span> <span class="token comment">// 从顶点着色器传来的输入变量（名称相同、类型相同）</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    FragColor <span class="token operator">=</span> vertexColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>你可以看到我们在顶点着色器中声明了一个 vertexColor 变量作为 vec4 输出，并在片段着色器中声明了一个类似的 vertexColor。<mark>由于它们名字相同且类型相同，片段着色器中的 vertexColor 就和顶点着色器中的 vertexColor 链接了</mark>。由于我们在顶点着色器中将颜色设置为深红色，最终的片段也是深红色的。下面的图片展示了输出结果：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/05/shaders.png" alt="image"></p><h4 id="uniform"><a class="anchor" href="#uniform">#</a> Uniform</h4><p><mark>Uniform 是一种从 CPU 中的应用向 GPU 中的着色器发送数据的方式</mark>，但 uniform 和顶点属性有些不同。首先，<mark>uniform 是全局的 (Global)</mark>。全局意味着 uniform 变量必须在每个着色器程序对象都是<mark>独一无二</mark>的，而且它可以被着色器程序的<mark>任意着色器</mark>在<mark>任意阶段</mark>访问。第二，无论你把 uniform 值设置成什么，uniform 会<mark>一直保存它们的数据</mark>，直到它们被重置或更新。</p><p>我们可以在一个着色器中添加 uniform 关键字至类型和变量名前来声明一个 GLSL 的 uniform。从此处开始我们就可以在着色器中使用新声明的 uniform 了。我们来看看这次是否能通过 uniform 设置三角形的颜色：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>out vec4 FragColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>uniform vec4 ourColor<span class="token punctuation">;</span> <span class="token comment">// 在 OpenGL 程序代码中设定这个变量</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    FragColor <span class="token operator">=</span> ourColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>我们在片段着色器中声明了一个 uniform vec4 的 ourColor，并把片段着色器的输出颜色设置为 uniform 值的内容。因为 uniform 是全局变量，我们可以在任何着色器中定义它们，而无需通过顶点着色器作为中介。顶点着色器中不需要这个 uniform，所以我们不用在那里定义它。</p><p><strong>如果你声明了一个 uniform 却在 GLSL 代码中没用过，编译器会<mark>静默移除这个变量</mark>，导致最后编译出的版本中并不会包含它，这可能导致几个非常麻烦的错误，记住这点！</strong></p><p>这个 uniform 现在还是空的；我们还没有给它添加任何数据，所以下面我们就做这件事。我们首先需要找到着色器中 uniform 属性的索引 / 位置值。当我们得到 uniform 的索引 / 位置值后，我们就可以更新它的值了。这次我们不去给像素传递单独一个颜色，而是让它随着时间改变颜色：</p><pre><code>float timeValue = glfwGetTime();
float greenValue = (sin(timeValue) / 2.0f) + 0.5f;
int vertexColorLocation = glGetUniformLocation(shaderProgram, &quot;ourColor&quot;);
glUseProgram(shaderProgram);
glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);
</code></pre><p>首先我们通过 glfwGetTime () 获取运行的秒数。然后我们使用 sin 函数让颜色在 0.0 到 1.0 之间改变，最后将结果储存到 greenValue 里。</p><p>接着，我们用<mark> glGetUniformLocation</mark> 查询 uniform ourColor 的位置值。我们为查询函数提供着色器程序和 uniform 的名字（这是我们希望获得的位置值的来源）。如果 glGetUniformLocation 返回 - 1 就代表没有找到这个位置值。最后，我们可以通过<mark> glUniform4f</mark> 函数设置 uniform 值。注意，<mark>查询</mark> uniform 地址不要求你之前使用过着色器程序，但是<mark>更新</mark>一个 uniform 之前你必须先使用程序（调用 glUseProgram)，因为它是在当前激活的着色器程序中设置 uniform 的。</p><blockquote><p>uniform 必须先激活后才能修改，查询不需要激活，但修改必须先激活。<mark>glUseProgram</mark> 方法激活</p></blockquote><p>因为 OpenGL 在其核心是一个 C 库，所以它不支持类型重载，在函数参数不同的时候就要为其定义新的函数；glUniform 是一个典型例子。这个函数有一个特定的后缀，标识设定的 uniform 的类型。可能的后缀有：</p><table><thead><tr><th>后缀</th><th>含义</th></tr></thead><tbody><tr><td>f</td><td>函数需要一个 float 作为它的值</td></tr><tr><td>i</td><td>函数需要一个 int 作为它的值</td></tr><tr><td>ui</td><td>函数需要一个 unsigned int 作为它的值</td></tr><tr><td>3f</td><td>函数需要 3 个 float 作为它的值</td></tr><tr><td>fv</td><td>函数需要一个 float 向量 / 数组作为它的值</td></tr></tbody></table><p>每当你打算配置一个 OpenGL 的选项时就可以简单地根据这些规则选择适合你的数据类型的重载函数。在我们的例子里，我们希望分别设定 uniform 的 4 个 float 值，所以我们通过<mark> glUniform4f</mark> 传递我们的数据 (注意，我们也可以使用<mark> fv</mark> 版本)。</p><p>现在你知道如何设置 uniform 变量的值了，我们可以使用它们来渲染了。如果我们打算让颜色慢慢变化，我们就要在游戏循环的每一次迭代中（所以他会逐帧改变）更新这个 uniform，否则三角形就不会改变颜色。下面我们就计算 greenValue 然后每个渲染迭代都更新这个 uniform：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">glfwWindowShouldClose</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 输入</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">processInput</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 渲染</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// 清除颜色缓冲</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">glClearColor</span><span class="token punctuation">(</span><span class="token number">0.2f</span><span class="token punctuation">,</span> <span class="token number">0.3f</span><span class="token punctuation">,</span> <span class="token number">0.3f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">// 记得激活着色器</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token function">glUseProgram</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token comment">// 更新 uniform 颜色</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">float</span> timeValue <span class="token operator">=</span> <span class="token function">glfwGetTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">float</span> greenValue <span class="token operator">=</span> <span class="token function">sin</span><span class="token punctuation">(</span>timeValue<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2.0f</span> <span class="token operator">+</span> <span class="token number">0.5f</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">int</span> vertexColorLocation <span class="token operator">=</span> <span class="token function">glGetUniformLocation</span><span class="token punctuation">(</span>shaderProgram<span class="token punctuation">,</span> <span class="token string">"ourColor"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token function">glUniform4f</span><span class="token punctuation">(</span>vertexColorLocation<span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> greenValue<span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token comment">// 绘制三角形</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>VAO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token function">glDrawArrays</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token comment">// 交换缓冲并查询 IO 事件</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token function">glfwSwapBuffers</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token function">glfwPollEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><span class="exturl" data-url="aHR0cHM6Ly9sZWFybm9wZW5nbC1jbi5naXRodWIuaW8vaW1nLzAxLzA1L3NoYWRlcnMubXA0">效果视频</span></p><h3 id="更多属性"><a class="anchor" href="#更多属性">#</a> 更多属性</h3><p>如果我们要改变每个定点属性，就需要设置多个 uniform。下面介绍一种解决办法。</p><p>在前面的教程中，我们了解了如何填充 VBO、配置顶点属性指针以及如何把它们都储存到一个 VAO 里。这次，我们同样打算把颜色数据加进顶点数据中。我们将把颜色数据添加为 3 个 float 值至 vertices 数组。我们将把三角形的三个角分别指定为红色、绿色和蓝色：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> vertices<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 位置              // 颜色</span></pre></td></tr><tr><td data-num="3"></td><td><pre>     <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>  <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>   <span class="token comment">// 右下</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>  <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>   <span class="token comment">// 左下</span></pre></td></tr><tr><td data-num="5"></td><td><pre>     <span class="token number">0.0f</span><span class="token punctuation">,</span>  <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>  <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span>    <span class="token comment">// 顶部</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>由于现在有更多的数据要发送到顶点着色器，我们有必要去调整一下顶点着色器，使它能够接收颜色值作为一个顶点属性输入。需要注意的是我们用<mark> layout</mark> 标识符来把<mark> aColor</mark> 属性的位置值设置为 1：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> in vec3 aPos<span class="token punctuation">;</span>   <span class="token comment">// 位置变量的属性位置值为 0 </span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> in vec3 aColor<span class="token punctuation">;</span> <span class="token comment">// 颜色变量的属性位置值为 1</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>out vec3 ourColor<span class="token punctuation">;</span> <span class="token comment">// 向片段着色器输出一个颜色</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    gl_Position <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>aPos<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    ourColor <span class="token operator">=</span> aColor<span class="token punctuation">;</span> <span class="token comment">// 将 ourColor 设置为我们从顶点数据那里得到的输入颜色</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>由于我们不再使用 uniform 来传递片段的颜色了，现在使用<mark> ourColor</mark> 输出变量，我们必须再修改一下片段着色器：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>out vec4 FragColor<span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="3"></td><td><pre>in vec3 ourColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>ourColor<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>因为我们添加了另一个顶点属性，并且更新了 VBO 的内存，我们就必须重新配置顶点属性指针。更新后的 VBO 内存中的数据现在看起来像这样：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/05/vertex_attribute_pointer_interleaved.png" alt="image"></p><p>知道了现在使用的布局，我们就可以使用 glVertexAttribPointer 函数更新顶点格式，</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 位置属性</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">6</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 颜色属性</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">6</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>由于我们现在有了两个顶点属性，我们不得不重新计算步长值。为获得数据队列中下一个属性值（比如位置向量的下个 x 分量）我们必须向右移动<mark> 6 个 float</mark>，其中 3 个是位置值，另外 3 个是颜色值。这使我们的步长值为 6 乘以 float 的字节数（=24 字节）。<br>同样，这次我们必须指定一个<mark>偏移量</mark>。对于每个顶点来说，位置顶点属性在前，所以它的偏移量是 0。颜色属性紧随位置数据之后，所以偏移量就是<mark> 3 * sizeof (float)</mark>，用字节来计算就是 12 字节。</p><p>运行程序你应该会看到如下结果：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/05/shaders3.png" alt="image"></p><p>这个图片可能不是你所期望的那种，因为我们只提供了 3 个颜色，而不是我们现在看到的大调色板。这是在片段着色器中进行的所谓<mark>片段插值</mark> (Fragment Interpolation) 的结果。当渲染一个三角形时，<mark>光栅化</mark> (Rasterization) 阶段通常会造成<mark>比原指定顶点更多的片段</mark>。光栅会根据每个片段在三角形形状上所处相对位置决定这些片段的位置。<br>基于这些位置，它会插值 (Interpolate) 所有片段着色器的输入变量。比如说，我们有一个线段，上面的端点是绿色的，下面的端点是蓝色的。如果一个片段着色器在线段的 70% 的位置运行，它的颜色输入属性就会是一个绿色和蓝色的线性结合；更精确地说就是<mark> 30% 蓝 + 70% 绿</mark>。</p><p>这正是在这个三角形中发生了什么。我们有 3 个顶点，和相应的 3 个颜色，从这个三角形的像素来看它可能包含 50000 左右的片段，片段着色器为这些像素进行插值颜色。如果你仔细看这些颜色就应该能明白了：红首先变成到紫再变为蓝色。片段插值会被应用到片段着色器的所有输入属性上。</p><h3 id="我们自己的着色器类"><a class="anchor" href="#我们自己的着色器类">#</a> 我们自己的着色器类</h3><p>编写、编译、管理着色器是件麻烦事。在着色器主题的最后，我们会写一个类来让我们的生活轻松一点，它可以从硬盘读取着色器，然后编译并链接它们，并对它们进行错误检测，这就变得很好用了。这也会让你了解该如何封装目前所学的知识到一个抽象对象中。</p><p>我们会把着色器类全部放在在头文件里，主要是为了学习用途，当然也方便移植。我们先来添加必要的 include，并定义类结构：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">SHADER_H</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">SHADER_H</span></span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;glad/glad.h></span><span class="token expression"><span class="token punctuation">;</span> </span><span class="token comment">// 包含 glad 来获取所有的必须 OpenGL 头文件</span></span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream></span></span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream></span></span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Shader</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">public</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">// 程序 ID</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> ID<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token comment">// 构造器读取并构建着色器</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token function">Shader</span><span class="token punctuation">(</span><span class="token keyword">const</span> GLchar<span class="token operator">*</span> vertexPath<span class="token punctuation">,</span> <span class="token keyword">const</span> GLchar<span class="token operator">*</span> fragmentPath<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token comment">// 使用 / 激活程序</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token comment">//uniform 工具函数</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">setBool</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>name<span class="token punctuation">,</span> <span class="token keyword">bool</span> value<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">setInt</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>name<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>   </pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">setFloat</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>name<span class="token punctuation">,</span> <span class="token keyword">float</span> value<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></pre></td></tr></table></figure><p>着色器类储存了着色器程序的 ID。它的构造器需要顶点和片段着色器源代码的文件路径，这样我们就可以把源码的文本文件储存在硬盘上了。除此之外，为了让我们的生活更轻松一点，还加入了一些工具函数：<mark>use 用来激活着色器程序</mark>，所有的<mark> set… 函数能够查询一个 unform 的位置值并设置它的值</mark>。</p><h3 id="从文件读取"><a class="anchor" href="#从文件读取">#</a> 从文件读取</h3><p>我们使用 cpp 文件流读取着色器内容，储存到几个 string 对象里：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">Shader</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> vertexPath<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> fragmentPath<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 1. 从文件路径中获取顶点 / 片段着色器</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    std<span class="token operator">::</span>string vertexCode<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    std<span class="token operator">::</span>string fragmentCode<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    std<span class="token operator">::</span>ifstream vShaderFile<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    std<span class="token operator">::</span>ifstream fShaderFile<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// 保证 ifstream 对象可以抛出异常：</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    vShaderFile<span class="token punctuation">.</span><span class="token function">exceptions</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>ifstream<span class="token operator">::</span>failbit <span class="token operator">|</span> std<span class="token operator">::</span>ifstream<span class="token operator">::</span>badbit<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    fShaderFile<span class="token punctuation">.</span><span class="token function">exceptions</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>ifstream<span class="token operator">::</span>failbit <span class="token operator">|</span> std<span class="token operator">::</span>ifstream<span class="token operator">::</span>badbit<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">try</span> </pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// 打开文件</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        vShaderFile<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>vertexPath<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        fShaderFile<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>fragmentPath<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        std<span class="token operator">::</span>stringstream vShaderStream<span class="token punctuation">,</span> fShaderStream<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token comment">// 读取文件的缓冲内容到数据流中</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        vShaderStream <span class="token operator">&lt;&lt;</span> vShaderFile<span class="token punctuation">.</span><span class="token function">rdbuf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        fShaderStream <span class="token operator">&lt;&lt;</span> fShaderFile<span class="token punctuation">.</span><span class="token function">rdbuf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       </pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token comment">// 关闭文件处理器</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        vShaderFile<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        fShaderFile<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token comment">// 转换数据流到 string</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        vertexCode   <span class="token operator">=</span> vShaderStream<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        fragmentCode <span class="token operator">=</span> fShaderStream<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     </pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token keyword">catch</span><span class="token punctuation">(</span>std<span class="token operator">::</span>ifstream<span class="token operator">::</span>failure e<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> vShaderCode <span class="token operator">=</span> vertexCode<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> fShaderCode <span class="token operator">=</span> fragmentCode<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span></pre></td></tr></table></figure><p>下一步，我们需要编译和链接着色器。注意，我们也将检查编译 / 链接是否失败，如果失败则打印编译时错误，调试的时候这些错误输出会及其重要（你总会需要这些错误日志的）：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 2. 编译着色器</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> vertex<span class="token punctuation">,</span> fragment<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> success<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">char</span> infoLog<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 顶点着色器</span></pre></td></tr><tr><td data-num="7"></td><td><pre>vertex <span class="token operator">=</span> <span class="token function">glCreateShader</span><span class="token punctuation">(</span>GL_VERTEX_SHADER<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">glShaderSource</span><span class="token punctuation">(</span>vertex<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>vShaderCode<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token function">glCompileShader</span><span class="token punctuation">(</span>vertex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// 打印编译错误（如果有的话）</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token function">glGetShaderiv</span><span class="token punctuation">(</span>vertex<span class="token punctuation">,</span> GL_COMPILE_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token function">glGetShaderInfoLog</span><span class="token punctuation">(</span>vertex<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> infoLog<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span> <span class="token operator">&lt;&lt;</span> infoLog <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment">// 片段着色器也类似</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token comment">// 着色器程序</span></pre></td></tr><tr><td data-num="22"></td><td><pre>ID <span class="token operator">=</span> <span class="token function">glCreateProgram</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token function">glAttachShader</span><span class="token punctuation">(</span>ID<span class="token punctuation">,</span> vertex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token function">glAttachShader</span><span class="token punctuation">(</span>ID<span class="token punctuation">,</span> fragment<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token function">glLinkProgram</span><span class="token punctuation">(</span>ID<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token comment">// 打印连接错误（如果有的话）</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token function">glGetProgramiv</span><span class="token punctuation">(</span>ID<span class="token punctuation">,</span> GL_LINK_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token function">glGetProgramInfoLog</span><span class="token punctuation">(</span>ID<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> infoLog<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span> <span class="token operator">&lt;&lt;</span> infoLog <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token comment">// 删除着色器，它们已经链接到我们的程序中了，已经不再需要了</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token function">glDeleteShader</span><span class="token punctuation">(</span>vertex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token function">glDeleteShader</span><span class="token punctuation">(</span>fragment<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>use 函数非常简单：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">glUseProgram</span><span class="token punctuation">(</span>ID<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>uniform 的 setter 函数也很类似：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">setBool</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>name<span class="token punctuation">,</span> <span class="token keyword">bool</span> value<span class="token punctuation">)</span> <span class="token keyword">const</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">glUniform1i</span><span class="token punctuation">(</span><span class="token function">glGetUniformLocation</span><span class="token punctuation">(</span>ID<span class="token punctuation">,</span> name<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">void</span> <span class="token function">setInt</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>name<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token keyword">const</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">glUniform1i</span><span class="token punctuation">(</span><span class="token function">glGetUniformLocation</span><span class="token punctuation">(</span>ID<span class="token punctuation">,</span> name<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">void</span> <span class="token function">setFloat</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>name<span class="token punctuation">,</span> <span class="token keyword">float</span> value<span class="token punctuation">)</span> <span class="token keyword">const</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token function">glUniform1f</span><span class="token punctuation">(</span><span class="token function">glGetUniformLocation</span><span class="token punctuation">(</span>ID<span class="token punctuation">,</span> name<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>现在我们就写完了一个完整的着色器类。使用这个着色器类很简单；只要创建一个着色器对象，从那一点开始我们就可以开始使用了：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>Shader <span class="token function">ourShader</span><span class="token punctuation">(</span><span class="token string">"path/to/shaders/shader.vs"</span><span class="token punctuation">,</span> <span class="token string">"path/to/shaders/shader.fs"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    ourShader<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    ourShader<span class="token punctuation">.</span><span class="token function">setFloat</span><span class="token punctuation">(</span><span class="token string">"someUniform"</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">DrawStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>我们把顶点和片段着色器储存为两个叫做 shader.vs 和 shader.fs 的文件。你可以使用自己喜欢的名字命名着色器文件；我自己觉得用.vs 和.fs 作为扩展名很直观。</p><p>你可以在这里找到使用新着色器类的源代码。注意你可以点击源码中的着色器文件路径来查看每一个着色器的源代码。</p><h2 id="纹理"><a class="anchor" href="#纹理">#</a> 纹理</h2><p>我们已经了解到，我们可以为每个顶点添加颜色来增加图形的细节，从而创建出有趣的图像。但是，如果想让图形看起来更真实，我们就必须有足够多的顶点，从而指定足够多的颜色。这将会产生很多额外开销，因为每个模型都会需求更多的顶点，每个顶点又需求一个颜色属性。</p><p>艺术家和程序员更喜欢使用<mark>纹理</mark> (Texture)。纹理是一个 2D 图片（甚至也有 1D 和 3D 的纹理），它可以用来添加物体的细节；你可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到你的 3D 的房子上，这样你的房子看起来就像有砖墙外表了。因为我们可以在一张图片上插入非常多的细节，这样就可以让物体非常精细而不用指定额外的顶点。</p><blockquote><p>除了图像以外，纹理也可以被用来储存大量的<mark>数据</mark>，这些数据可以发送到着色器上。</p></blockquote><p>为了能够把纹理映射 (Map) 到三角形上，我们需要指定三角形的<mark>每个顶点各自对应纹理的哪个部分</mark>。这样每个顶点就会关联着一个<mark>纹理坐标</mark> (Texture Coordinate)，用来标明该从纹理图像的哪个部分采样（译注：采集片段颜色）。之后在图形的其它片段上进行<mark>片段插值</mark> (Fragment Interpolation)。</p><p>纹理坐标在 x 和 y 轴上，范围为 0 到 1 之间（注意我们使用的是 2D 纹理图像）。使用纹理坐标获取纹理颜色叫做<mark>采样</mark> (Sampling)。纹理坐标起始于 (0, 0)，也就是纹理图片的左下角，终始于 (1, 1)，即纹理图片的右上角。下面的图片展示了我们是如何把纹理坐标映射到三角形上的。</p><p><img data-src="https://learnopengl-cn.github.io/img/01/06/tex_coords.png" alt="image"></p><p>我们为三角形指定了 3 个纹理坐标点。如上图所示，我们希望三角形的左下角对应纹理的左下角，因此我们把三角形左下角顶点的纹理坐标设置为 (0, 0)；三角形的上顶点对应于图片的上中位置所以我们把它的纹理坐标设置为 (0.5, 1.0)；同理右下方的顶点设置为 (1, 0)。我们只要给<mark>顶点着色器传递这三个纹理坐标</mark>就行了，接下来它们会被传片段着色器中，它会为每个片段进行纹理坐标的插值。</p><p>纹理坐标看起来就像这样：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> texCoords<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token comment">// 左下角</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token comment">// 右下角</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span> <span class="token comment">// 上中</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>对纹理采样的解释非常宽松，它可以采用几种不同的插值方式。所以我们需要自己告诉 OpenGL 该怎样对纹理<mark>采样</mark>。</p><h3 id="纹理环绕方式"><a class="anchor" href="#纹理环绕方式">#</a> 纹理环绕方式</h3><p>纹理坐标的范围通常是从 (0, 0) 到 (1, 1)，那如果我们把纹理坐标设置在<mark>范围之外</mark>会发生什么？OpenGL 默认的行为是<mark>重复这个纹理图像</mark>（我们基本上忽略浮点纹理坐标的整数部分），但 OpenGL 提供了更多的选择：</p><table><thead><tr><th>环绕方式</th><th>描述</th></tr></thead><tbody><tr><td>GL_REPEAT</td><td>对纹理的默认行为。重复纹理图像。</td></tr><tr><td>GL_MIRRORED_REPEAT</td><td>和 GL_REPEAT 一样，但每次重复图片是镜像放置的。</td></tr><tr><td>GL_CLAMP_TO_EDGE</td><td>纹理坐标会被约束在 0 到 1 之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。</td></tr><tr><td>GL_CLAMP_TO_BORDER</td><td>超出的坐标为用户指定的边缘颜色。</td></tr></tbody></table><p>当纹理坐标超出默认范围时，每个选项都有不同的视觉效果输出。我们来看看这些纹理图像的例子：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/06/texture_wrapping.png" alt="image"></p><p>前面提到的每个选项都可以使用<mark> glTexParameter</mark> 函数对单独的一个坐标轴设置（s、t（如果是使用 3D 纹理那么还有一个 r）它们和 x、y、z 是等价的）：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_WRAP_S<span class="token punctuation">,</span> GL_MIRRORED_REPEAT<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_WRAP_T<span class="token punctuation">,</span> GL_MIRRORED_REPEAT<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>第一个参数指定了<mark>纹理目标</mark>；我们使用的是 2D 纹理，因此纹理目标是<mark> GL_TEXTURE_2D</mark>。第二个参数需要我们指定设置的选项与应用的<mark>纹理轴</mark>。我们打算配置的是 WRAP 选项，并且指定 S 和 T 轴。最后一个参数需要我们传递一个<mark>环绕方式</mark> (Wrapping)，在这个例子中 OpenGL 会给当前激活的纹理设定纹理环绕方式为 GL_MIRRORED_REPEAT。</p><p>如果我们选择<mark> GL_CLAMP_TO_BORDER</mark> 选项，我们还需要指定一个<mark>边缘的颜色</mark>。这需要使用<mark> glTexParameter</mark> 函数的 fv 后缀形式，用 GL_TEXTURE_BORDER_COLOR 作为它的选项，并且传递一个 float 数组作为边缘的颜色值：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> borderColor<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glTexParameterfv</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_BORDER_COLOR<span class="token punctuation">,</span> borderColor<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="纹理过滤"><a class="anchor" href="#纹理过滤">#</a> 纹理过滤</h3><p>纹理坐标不依赖于分辨率 (Resolution)，它可以是任意浮点值，所以 OpenGL 需要知道怎样将<mark>纹理像素</mark> (Texture Pixel，也叫 Texel，译注 1) 映射到<mark>纹理坐标</mark>。当你有一个很大的物体但是纹理的分辨率很低的时候这就变得很重要了。你可能已经猜到了，OpenGL 也有对于<mark>纹理过滤</mark> (Texture Filtering) 的选项。纹理过滤有很多个选项，但是现在我们只讨论最重要的两种：GL_NEAREST 和 GL_LINEAR。</p><blockquote><p>Texture Pixel 也叫 Texel，你可以想象你打开一张.jpg 格式图片，不断放大你会发现它是由无数像素点组成的，这个点就是纹理像素；注意不要和纹理坐标搞混，纹理坐标是你给模型顶点设置的那个数组，OpenGL 以这个顶点的纹理坐标数据去查找纹理图像上的像素，然后进行采样提取纹理像素的颜色。(纹理像素是某点对应的颜色，纹理坐标是告诉 GPU 需要去图片中的哪个位置进行颜色采样)</p></blockquote><p><mark>GL_NEAREST</mark>（也叫邻近过滤，Nearest Neighbor Filtering）是 OpenGL 默认的纹理过滤方式。当设置为 GL_NEAREST 的时候，OpenGL 会选择中心点最接近纹理坐标的那个像素。下图中你可以看到四个像素，加号代表纹理坐标。左上角那个纹理像素的中心<mark>距离纹理坐标最近</mark>，所以它会被选择为样本颜色：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/06/filter_nearest.png" alt="image"></p><p><mark>GL_LINEAR</mark>（也叫线性过滤，(Bi) linear Filtering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。下图中你可以看到返回的颜色是<mark>邻近像素的混合色</mark>：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/06/filter_linear.png" alt="image"></p><p>那么这两种纹理过滤方式有怎样的视觉效果呢？让我们看看在一个很大的物体上应用一张低分辨率的纹理会发生什么吧（纹理被放大了，每个纹理像素都能看到）：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/06/texture_filtering.png" alt="image"></p><p>GL_NEAREST 产生了颗粒状的图案，我们能够清晰看到组成纹理的像素，而 GL_LINEAR 能够产生更平滑的图案，很难看出单个的纹理像素。GL_LINEAR 可以产生更真实的输出，但有些开发者更喜欢 8-bit 风格，所以他们会用 GL_NEAREST 选项。</p><p>当进行放大 (Magnify) 和缩小 (Minify) 操作的时候可以设置纹理过滤的选项，比如你可以在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。我们需要使用<mark> glTexParameter</mark> 函数为放大和缩小指定过滤方式。这段代码看起来会和纹理环绕方式的设置很相似：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_MIN_FILTER<span class="token punctuation">,</span> GL_NEAREST<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_MAG_FILTER<span class="token punctuation">,</span> GL_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="多级渐远纹理"><a class="anchor" href="#多级渐远纹理">#</a> 多级渐远纹理</h3><p>想象一下，假设我们有一个包含着上千物体的大房间，每个物体上都有纹理。有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率。由于远处的物体可能只产生很少的片段，OpenGL 从高分辨率纹理中为这些片段获取正确的颜色值就很困难，因为它需要对一个跨过纹理很大部分的片段只拾取一个纹理颜色。在小物体上这会产生不真实的感觉，更不用说对它们使用高分辨率纹理浪费内存的问题了。</p><p>OpenGL 使用一种叫做<mark>多级渐远纹理</mark> (Mipmap) 的概念来解决这个问题，它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL 会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。让我们看一下多级渐远纹理是什么样子的：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/06/mipmaps.png" alt="image"></p><p>手工为每个纹理图像创建一系列多级渐远纹理很麻烦，幸好 OpenGL 有一个<mark> glGenerateMipmaps</mark> 函数，在创建完一个纹理后调用它 OpenGL 就会承担接下来的所有工作了。后面的教程中你会看到该如何使用它。</p><p>在渲染中切换多级渐远纹理级别 (Level) 时，OpenGL 在两个不同级别的多级渐远纹理层之间会产生不真实的生硬边界。就像普通的纹理过滤一样，切换多级渐远纹理级别时你也<mark>可以在两个不同<strong>多级渐远纹理级别</strong>之间使用 NEAREST 和 LINEAR 过滤</mark>。为了指定不同多级渐远纹理级别之间的过滤方式，你可以使用下面四个选项中的一个代替原有的过滤方式：</p><table><thead><tr><th>过滤方式</th><th>描述</th></tr></thead><tbody><tr><td>GL_NEAREST_MIPMAP_NEAREST</td><td>使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样</td></tr><tr><td>GL_LINEAR_MIPMAP_NEAREST</td><td>使用最邻近的多级渐远纹理级别，并使用线性插值进行采样</td></tr><tr><td>GL_NEAREST_MIPMAP_LINEAR</td><td>在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样</td></tr><tr><td>GL_LINEAR_MIPMAP_LINEAR</td><td>在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样</td></tr></tbody></table><p>就像纹理过滤一样，我们可以使用<mark> glTexParameteri</mark> 将过滤方式设置为前面四种提到的方法之一：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_MIN_FILTER<span class="token punctuation">,</span> GL_LINEAR_MIPMAP_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_MAG_FILTER<span class="token punctuation">,</span> GL_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>一个常见的错误是，将放大过滤的选项设置为多级渐远纹理过滤选项之一。这样没有任何效果，<mark>因为多级渐远纹理主要是使用在纹理被<strong>缩小</strong>的情况下的</mark>：纹理放大不会使用多级渐远纹理，为放大过滤设置多级渐远纹理的选项会产生一个 GL_INVALID_ENUM 错误代码。</p></blockquote><h3 id="加载与创建纹理"><a class="anchor" href="#加载与创建纹理">#</a> 加载与创建纹理</h3><p>使用纹理之前要做的第一件事是把它们加载到我们的应用中。纹理图像可能被储存为各种各样的格式，每种都有自己的数据结构和排列，所以我们如何才能把这些图像加载到应用中呢？一个解决方案是选一个需要的文件格式，比如.PNG，然后自己写一个图像加载器，把图像转化为字节序列。写自己的图像加载器虽然不难，但仍然挺麻烦的，而且如果要支持更多文件格式呢？你就不得不为每种你希望支持的格式写加载器了。</p><p>另一个解决方案也许是一种更好的选择，使用一个支持多种流行格式的图像加载库来为我们解决这个问题。比如说我们要用的<mark> stb_image.h</mark> 库。</p><h4 id="stb_imageh"><a class="anchor" href="#stb_imageh">#</a> stb_image.h</h4><p>stb_image.h 是 Sean Barrett 的一个非常流行的单头文件图像加载库，它能够加载大部分流行的文件格式，并且能够很简单得整合到你的工程之中。stb_image.h 可以在这里下载。下载这一个头文件，将它以 stb_image.h 的名字加入你的工程，并另创建一个新的 cpp 文件，输入以下代码：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">STB_IMAGE_IMPLEMENTATION</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stb_image.h"</span></span></pre></td></tr></table></figure><p>通过定义 STB_IMAGE_IMPLEMENTATION，预处理器会修改头文件，让其只包含相关的函数定义源码，等于是将这个头文件变为一个 .cpp 文件了。现在只需要在你的程序中包含 stb_image.h 并编译就可以了。</p><p>下面的教程中，我们会使用一张木箱的图片。要使用 stb_image.h 加载图片，我们需要使用它的<mark> stbi_load</mark> 函数：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> nrChannels<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>data <span class="token operator">=</span> <span class="token function">stbi_load</span><span class="token punctuation">(</span><span class="token string">"container.jpg"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>width<span class="token punctuation">,</span> <span class="token operator">&amp;</span>height<span class="token punctuation">,</span> <span class="token operator">&amp;</span>nrChannels<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这个函数首先接受一个图像文件的位置作为输入。接下来它需要三个 int 作为它的第二、第三和第四个参数，stb_image.h 将会用图像的宽度、高度和颜色通道的个数填充这三个变量。我们之后生成纹理的时候会用到的图像的宽度和高度的。</p><h3 id="生成纹理"><a class="anchor" href="#生成纹理">#</a> 生成纹理</h3><p>和之前生成的 OpenGL 对象一样，纹理也是使用 ID 引用的。让我们来创建一个：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> texture<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glGenTextures</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>texture<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>glGenTextures 函数首先需要输入生成纹理的数量，然后把它们储存在第二个参数的 unsigned int 数组中（我们的例子中只是单独的一个 unsigned int），就像其他对象一样，我们需要绑定它，让之后任何的纹理指令都可以配置当前绑定的纹理：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> texture<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>现在纹理已经绑定了，我们可以使用前面载入的图片数据生成一个纹理了。纹理可以通过 glTexImage2D 来生成：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glTexImage2D</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RGB<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RGB<span class="token punctuation">,</span> GL_UNSIGNED_BYTE<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glGenerateMipmap</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ul><li>第一个参数指定了<mark>纹理目标</mark> (Target)。设置为 GL_TEXTURE_2D 意味着会生成与当前绑定的纹理对象在同一个目标上的纹理（任何绑定到 GL_TEXTURE_1D 和 GL_TEXTURE_3D 的纹理不会受到影响）。</li><li>第二个参数为纹理指定<mark>多级渐远纹理的级别</mark>，如果你希望单独手动设置每个多级渐远纹理的级别的话。这里我们填 0，也就是基本级别。</li><li>第三个参数告诉 OpenGL 我们希望把<mark>纹理储存为何种格式</mark>。我们的图像只有 RGB 值，因此我们也把纹理储存为 RGB 值。</li><li>第四个和第五个参数设置最终的纹理的<mark>宽度</mark>和<mark>高度</mark>。我们之前加载图像的时候储存了它们，所以我们使用对应的变量。</li><li>下个参数应该总是被设为 0（历史遗留的问题）。</li><li>第七第八个参数定义了<mark>源图的格式</mark>和<mark>数据类型</mark>。我们使用 RGB 值加载这个图像，并把它们储存为 char (byte) 数组，我们将会传入对应值。<br>最后一个参数是真正的图像数据。</li></ul><p>当调用<mark> glTexImage2D</mark> 时，当前绑定的纹理对象就会被附加上纹理图像。然而，目前只有<mark>基本级别</mark> (Base-level) 的纹理图像被加载了，如果要使用多级渐远纹理，我们必须手动设置所有不同的图像（不断递增第二个参数）。或者，直接在生成纹理之后调用<mark> glGenerateMipmap</mark>。这会为当前绑定的纹理<mark>自动生成</mark>所有需要的<mark>多级渐远纹理</mark>。</p><p>生成了纹理和相应的多级渐远纹理后，释放图像的内存是一个很好的习惯。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">stbi_image_free</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>生成一个纹理的过程应该看起来像这样：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> texture<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glGenTextures</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>texture<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> texture<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 为当前绑定的纹理对象设置环绕、过滤方式</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_WRAP_S<span class="token punctuation">,</span> GL_REPEAT<span class="token punctuation">)</span><span class="token punctuation">;</span>   </pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_WRAP_T<span class="token punctuation">,</span> GL_REPEAT<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_MIN_FILTER<span class="token punctuation">,</span> GL_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_MAG_FILTER<span class="token punctuation">,</span> GL_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// 加载并生成纹理</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">int</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> nrChannels<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>data <span class="token operator">=</span> <span class="token function">stbi_load</span><span class="token punctuation">(</span><span class="token string">"container.jpg"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>width<span class="token punctuation">,</span> <span class="token operator">&amp;</span>height<span class="token punctuation">,</span> <span class="token operator">&amp;</span>nrChannels<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token function">glTexImage2D</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RGB<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RGB<span class="token punctuation">,</span> GL_UNSIGNED_BYTE<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token function">glGenerateMipmap</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token keyword">else</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Failed to load texture"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token function">stbi_image_free</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="应用纹理"><a class="anchor" href="#应用纹理">#</a> 应用纹理</h3><p>后面的这部分我们会使用 glDrawElements 绘制「你好，三角形」教程最后一部分的矩形。我们需要告知 OpenGL 如何采样纹理，所以我们必须使用纹理坐标更新顶点数据：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> vertices<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">//     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -</span></pre></td></tr><tr><td data-num="3"></td><td><pre>     <span class="token number">0.5f</span><span class="token punctuation">,</span>  <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>   <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>   <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span>   <span class="token comment">// 右上</span></pre></td></tr><tr><td data-num="4"></td><td><pre>     <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>   <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>   <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>   <span class="token comment">// 右下</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>   <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span>   <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>   <span class="token comment">// 左下</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span>  <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>   <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>   <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span>    <span class="token comment">// 左上</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>由于我们添加了一个额外的顶点属性，我们必须告诉 OpenGL 我们新的顶点格式：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/06/vertex_attribute_pointer_interleaved_textures.png" alt="image"></p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">8</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">6</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>注意，我们同样需要调整前面两个顶点属性的步长参数为<mark> 8 * sizeof (float)</mark>。</p><p>接着我们需要调整顶点着色器使其能够接受顶点坐标为一个顶点属性，并把坐标传给片段着色器：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> in vec3 aPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> in vec3 aColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> in vec2 aTexCoord<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>out vec3 ourColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>out vec2 TexCoord<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    gl_Position <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>aPos<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    ourColor <span class="token operator">=</span> aColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    TexCoord <span class="token operator">=</span> aTexCoord<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>片段着色器应该接下来会把输出变量 TexCoord 作为输入变量。</p><p>片段着色器也应该能访问纹理对象，但是我们怎样能把纹理对象传给片段着色器呢？GLSL 有一个供纹理对象使用的内建数据类型，叫做<mark>采样器</mark> (Sampler)，它以纹理类型作为后缀，比如 sampler1D、sampler3D，或在我们的例子中的 sampler2D。我们可以简单声明一个 uniform sampler2D 把一个纹理添加到片段着色器中，稍后我们会把纹理赋值给这个 uniform。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>out vec4 FragColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>in vec3 ourColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>in vec2 TexCoord<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>uniform sampler2D ourTexture<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>ourTexture<span class="token punctuation">,</span> TexCoord<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>我们使用 GLSL 内建的 texture 函数来采样纹理的颜色，它第一个参数是纹理采样器，第二个参数是对应的纹理坐标。texture 函数会使用之前设置的纹理参数对相应的颜色值进行采样。这个片段着色器的输出就是纹理的（插值）纹理坐标上的 (过滤后的) 颜色。</p><p>现在只剩下在调用 glDrawElements 之前绑定纹理了，它会自动把纹理赋值给片段着色器的采样器：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> texture<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>VAO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glDrawElements</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> GL_UNSIGNED_INT<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>如果你跟着这个教程正确地做完了，你会看到下面的图像：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/06/textures2.png" alt="image"></p><p>我们还可以把得到的纹理颜色与顶点颜色混合，来获得更有趣的效果。我们只需把纹理颜色与顶点颜色在片段着色器中相乘来混合二者的颜色：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>FragColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>ourTexture<span class="token punctuation">,</span> TexCoord<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>ourColor<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="纹理单元"><a class="anchor" href="#纹理单元">#</a> 纹理单元</h3><p>你可能会奇怪为什么 sampler2D 变量是个 uniform，我们却不用 glUniform 给它赋值。使用 glUniform1i，我们可以给纹理采样器分配一个位置值，这样的话我们能够在一个片段着色器中设置多个纹理。一个纹理的位置值通常称为一个纹理单元 (Texture Unit)。<mark>一个纹理的默认纹理单元是 0</mark>，它是<mark>默认</mark>的<mark>激活</mark>纹理单元，所以教程前面部分我们没有分配一个位置值。</p><p>纹理单元的主要目的是让我们在着色器中可以使用多于一个的纹理。通过把纹理单元赋值给采样器，我们可以一次绑定多个纹理，只要我们首先激活对应的纹理单元。就像 glBindTexture 一样，我们可以使用 glActiveTexture 激活纹理单元，传入我们需要使用的纹理单元：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glActiveTexture</span><span class="token punctuation">(</span>GL_TEXTURE0<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在绑定纹理之前先激活纹理单元</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> texture<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>激活纹理单元之后，接下来的 glBindTexture 函数调用会绑定这个纹理到当前激活的纹理单元，纹理单元 GL_TEXTURE0<mark> 默认总是被激活</mark>，所以我们在前面的例子里当我们使用 glBindTexture 的时候，无需激活任何纹理单元。</p><blockquote><p>OpenGL 至少保证有<mark> 16</mark> 个纹理单元供你使用，也就是说你可以激活从 GL_TEXTURE0 到 GL_TEXTRUE15。它们都是按顺序定义的，所以我们也可以通过 GL_TEXTURE0 + 8 的方式获得 GL_TEXTURE8，这在当我们需要循环一些纹理单元的时候会很有用。</p></blockquote><p>我们仍然需要编辑片段着色器来接收另一个采样器。这应该相对来说非常直接了：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>uniform sampler2D texture1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>uniform sampler2D texture2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">mix</span><span class="token punctuation">(</span><span class="token function">texture</span><span class="token punctuation">(</span>texture1<span class="token punctuation">,</span> TexCoord<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">texture</span><span class="token punctuation">(</span>texture2<span class="token punctuation">,</span> TexCoord<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>最终输出颜色现在是两个纹理的结合。GLSL 内建的<mark> mix</mark> 函数需要接受两个值作为参数，并对它们根据第三个参数进行线性插值。如果第三个值是 0.0，它会返回第一个输入；如果是 1.0，会返回第二个输入值。0.2 会返回 80% 的第一个输入颜色和 20% 的第二个输入颜色，即返回两个纹理的混合色。</p><p>我们现在需要载入并创建另一个纹理；你应该对这些步骤很熟悉了。记得创建另一个纹理对象，载入图片，使用 glTexImage2D 生成最终纹理。对于第二个纹理我们使用一张你学习 OpenGL 时的面部表情图片。</p><p>为了使用第二个纹理（以及第一个），我们必须改变一点渲染流程，先绑定两个纹理到对应的纹理单元，然后定义哪个 uniform 采样器对应哪个纹理单元：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glActiveTexture</span><span class="token punctuation">(</span>GL_TEXTURE0<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> texture1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glActiveTexture</span><span class="token punctuation">(</span>GL_TEXTURE1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> texture2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>VAO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">glDrawElements</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> GL_UNSIGNED_INT<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>我们还要通过使用<mark> glUniform1i</mark> 设置每个采样器的方式告诉 OpenGL 每个着色器采样器属于哪个纹理单元。我们只需要设置一次即可，所以这个会放在渲染循环的前面：</p><pre><code>ourShader.use(); // 别忘记在激活着色器前先设置uniform！
glUniform1i(glGetUniformLocation(ourShader.ID, &quot;texture1&quot;), 0); // 手动设置
ourShader.setInt(&quot;texture2&quot;, 1); // 或者使用着色器类设置

while(...) 
&#123;
    [...]
&#125;
</code></pre><p>通过使用 glUniform1i 设置采样器，我们保证了每个 uniform 采样器对应着正确的纹理单元。你应该能得到下面的结果：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/06/textures_combined.png" alt="image"></p><p>你可能注意到纹理上下颠倒了！这是因为 OpenGL 要求 y 轴 0.0 坐标是在图片的底部的，但是图片的 y 轴 0.0 坐标通常在顶部。很幸运，stb_image.h 能够在图像加载时帮助我们翻转 y 轴，只需要在加载任何图像前加入以下语句即可：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">stbi_set_flip_vertically_on_load</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在让 stb_image.h 在加载图片时翻转 y 轴之后你就应该能够获得下面的结果了：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/06/textures_combined2.png" alt="image"></p><h2 id="变换"><a class="anchor" href="#变换">#</a> 变换</h2><h3 id="向量-2"><a class="anchor" href="#向量-2">#</a> 向量</h3><p>下面你会看到 3 个向量，每个向量在 2D 图像中都用一个箭头 (x, y) 表示。我们在 2D 图片中展示这些向量，因为这样子会更直观一点。你可以把这些 2D 向量当做 z 坐标为 0 的 3D 向量。由于向量表示的是方向，起始于何处并不会改变它的值。下图我们可以看到向量 v¯ 和 w¯ 是相等的，尽管他们的起始点不同：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/07/vectors.png" alt="image"></p><p>数学家喜欢在字母上面加一横表示向量，比如说 v¯。当用在公式中时它们通常是这样的：</p><pre><code class="language-math">\bar&#123;v&#125;=\begin&#123;pmatrix&#125;
   x \\
   y \\
   z  \end&#123;pmatrix&#125;
</code></pre><p>由于向量是一个方向，所以有些时候会很难形象地将它们用位置 (Position) 表示出来。为了让其更为直观，我们通常设定这个方向的<mark>原点为 (0, 0, 0)</mark>，然后指向一个方向，对应一个点，使其变为位置向量 (Position Vector)（你也可以把起点设置为其他的点，然后说：这个向量从这个点起始指向另一个点）。比如说位置向量 (3, 5) 在图像中的起点会是 (0, 0)，并会指向 (3, 5)。我们可以使用向量在 2D 或 3D 空间中表示方向与位置.</p><p>和普通数字一样，我们也可以用向量进行多种运算（其中一些你可能已经看到过了）。</p><h3 id="向量与标量运算"><a class="anchor" href="#向量与标量运算">#</a> 向量与标量运算</h3><p>标量 (Scalar) 只是一个数字（或者说是仅有一个分量的向量）。当把一个向量加 / 减 / 乘 / 除一个标量，我们可以简单的把向量的每个分量分别进行该运算。对于加法来说会像这样:</p><pre><code class="language-math">\begin&#123;pmatrix&#125;
   1 \\
   2 \\
   3  \end&#123;pmatrix&#125;+x
   =  \begin&#123;pmatrix&#125;
   1+x \\
   2+y \\
   3+z  \end&#123;pmatrix&#125;
</code></pre><p>其中的 + 可以是 +，-，・或 ÷，其中・是乘号。注意－和 ÷ 运算时不能颠倒（标量 -/÷ 向量），因为颠倒的运算是没有定义的。</p><pre><code class="language-math">-\bar&#123;v&#125;=-
\begin&#123;pmatrix&#125;
   v_x \\
   v_y \\
   v_z  \end&#123;pmatrix&#125;=
   \begin&#123;pmatrix&#125;
   -v_x \\
   -v_y \\
   -v_z  \end&#123;pmatrix&#125;
</code></pre><h3 id="向量加减"><a class="anchor" href="#向量加减">#</a> 向量加减</h3><p>向量的加法可以被定义为是<mark>分量</mark>的 (Component-wise) 相加，即将一个向量中的每一个分量加上另一个向量的对应分量：</p><pre><code class="language-math">\bar&#123;v&#125;=
\begin&#123;pmatrix&#125;
   1 \\
   2 \\
   3  \end&#123;pmatrix&#125;,
   \bar&#123;k&#125;=
\begin&#123;pmatrix&#125;
   4 \\
   5 \\
   6  \end&#123;pmatrix&#125;\to
   \bar&#123;v&#125;+\bar&#123;k&#125;
\begin&#123;pmatrix&#125;
   1+4 \\
   2+5 \\
   3+6  \end&#123;pmatrix&#125;=
\begin&#123;pmatrix&#125;
   5 \\
   7 \\
   9  \end&#123;pmatrix&#125;
</code></pre><p>向量 v = (4, 2) 和 k = (1, 2) 可以直观地表示为：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/07/vectors_addition.png" alt="image"></p><p>就像普通数字的加减一样，向量的减法等于加上第二个向量的相反向量：</p><pre><code class="language-math">\bar&#123;v&#125;=
\begin&#123;pmatrix&#125;
   1 \\
   2 \\
   3  \end&#123;pmatrix&#125;,
   \bar&#123;k&#125;=
\begin&#123;pmatrix&#125;
   4 \\
   5 \\
   6  \end&#123;pmatrix&#125;\to
   \bar&#123;v&#125;+-\bar&#123;k&#125;
   =\begin&#123;pmatrix&#125;
   1+(-4) \\
   2+(-5) \\
   3+(-6)  \end&#123;pmatrix&#125;=
\begin&#123;pmatrix&#125;
   -3 \\
   -3 \\
   -3  \end&#123;pmatrix&#125;
</code></pre><p>两个向量的相减会得到这两个向量指向位置的差。这在我们想要获取两点的差会非常有用。</p><p><img data-src="https://learnopengl-cn.github.io/img/01/07/vectors_subtraction.png" alt="image"></p><h3 id="长度"><a class="anchor" href="#长度">#</a> 长度</h3><p>我们使用<mark>勾股定理</mark> (Pythagoras Theorem) 来获取向量的长度 (Length)/ 大小 (Magnitude)。如果你把向量的 x 与 y 分量画出来，该向量会和 x 与 y 分量为边形成一个三角形:</p><p><img data-src="https://learnopengl-cn.github.io/img/01/07/vectors_triangle.png" alt="image"></p><p>因为两条边（x 和 y）是已知的，如果希望知道斜边 v¯ 的长度，我们可以直接通过勾股定理来计算：</p><pre><code class="language-math">
\|\bar&#123;v&#125;\|=\sqrt&#123;x^&#123;2&#125;+y^&#123;2&#125;&#125;

</code></pre><pre><code class="language-math">\|\bar&#123;v&#125;\|表示向量\bar&#123;v&#125;的长度，我们也可以加上z^&#123;2&#125;把这个公式拓展到三维空间。

例子中向量(4, 2)的长度等于：

\|\bar&#123;v&#125;\|=\sqrt&#123;4^&#123;2&#125;+2^&#123;2&#125;&#125;=\sqrt&#123;16+4&#125;=\sqrt&#123;20&#125;=4.47

结果是4.47。

有一个特殊类型的向量叫做单位向量(Unit Vector)。
单位向量有一个特别的性质——它的长度是1。

我们可以用任意向量的每个分量除以向量的长度得到它的单位向量\hat&#123;n&#125;：

\hat&#123;n&#125;=\cfrac&#123;\bar&#123;v&#125;&#125;&#123;\|\bar&#123;v&#125;\|&#125;

</code></pre><p>我们把这种方法叫做一个<mark>向量的标准化</mark> (Normalizing)。<mark>单位向量</mark>头上有一个 ^ 样子的记号。通常单位向量会变得很有用，特别是在我们只关心方向不关心长度的时候（如果改变向量的长度，它的方向并不会改变）。</p><h3 id="向量相乘"><a class="anchor" href="#向量相乘">#</a> 向量相乘</h3><p>两个向量相乘是一种很奇怪的情况。普通的乘法在向量上是没有定义的，因为它在视觉上是没有意义的。但是在相乘的时候我们有两种特定情况可以选择：一个是<mark>点乘</mark> (Dot Product)，记作：</p><pre><code class="language-math">\bar&#123;v&#125; \cdotp \bar&#123;k&#125;

</code></pre><p>另一个是<mark>叉乘</mark> (CrossProduct)，记作：</p><pre><code class="language-math">\bar&#123;v&#125; × \bar&#123;k&#125;

</code></pre><h3 id="点乘"><a class="anchor" href="#点乘">#</a> 点乘</h3><p>两个向量的点乘等于它们的<mark>数乘结果乘以两个向量之间夹角的余弦值</mark>。可能听起来有点费解，我们来看一下公式：</p><pre><code class="language-math">\bar&#123;v&#125; \cdotp \bar&#123;k&#125;=\|\bar&#123;v&#125;\| \cdotp \|\bar&#123;k&#125;\|\cdotp\cos\theta

</code></pre><p>它们之间的夹角记作<em> θ</em><br>。为什么这很有用？想象如果 v 和 k 都是单位向量，它们的长度会等于 1。这样公式会有效简化成：</p><pre><code class="language-math">\bar&#123;v&#125; \cdotp \bar&#123;k&#125;=1 \cdotp 1\cdotp\cos\theta=\cos\theta
</code></pre><p>现在<mark>点积</mark>只定义了两个向量的夹角。你也许记得 90 度的余弦值是 0，0 度的余弦值是 1。使用点乘可以很容易测试两个向量是否正交 (Orthogonal) 或平行（正交意味着两个向量互为直角）。如果你想要了解更多关于正弦或余弦函数的知识，我推荐你看可汗学院的基础三角学视频。</p><blockquote><p>你也可以通过点乘的结果计算两个非单位向量的夹角，点乘的结果除以两个向量的长度之积，得到的结果就是夹角的余弦值，即 cosθ。译注：通过上面点乘定义式可推出：</p></blockquote><pre><code class="language-math">\cos\theta=
\cfrac&#123;\bar&#123;v&#125; \cdotp \bar&#123;k&#125;&#125;
&#123;\|\bar&#123;v&#125;\| \cdotp \|\bar&#123;k&#125;\|&#125;

</code></pre><p>所以，我们该如何计算点乘呢？点乘是通过将对应分量逐个相乘，然后再把所得积相加来计算的。两个单位向量的（你可以验证它们的长度都为 1）点乘会像是这样：</p><pre><code class="language-math">\begin&#123;pmatrix&#125;
   0.6 \\
   -0.8 \\
   0  \end&#123;pmatrix&#125;
   \cdotp
\begin&#123;pmatrix&#125;
   0 \\
   1 \\
   0  \end&#123;pmatrix&#125;
   =
   (0.6∗0)+(−0.8∗1)+(0∗0)=−0.8
</code></pre><p>要计算两个单位向量间的夹角，我们可以使用反余弦函数:</p><pre><code class="language-math">cos^&#123;-1&#125;
</code></pre><p>可得结果是 143.1 度。现在我们很快就计算出了这两个向量的夹角。点乘会在计算光照的时候非常有用。</p><h3 id="叉乘"><a class="anchor" href="#叉乘">#</a> 叉乘</h3><p>叉乘只在 3D 空间中有定义，它需要<mark>两个不平行向量</mark>作为输入，生成一个<mark>正交</mark>于两个输入向量的第三个向量。如果输入的两个向量也是正交的，那么叉乘之后将会产生 3 个互相正交的向量。接下来的教程中这会非常有用。下面的图片展示了 3D 空间中叉乘的样子：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/07/vectors_crossproduct.png" alt="image"></p><blockquote><p>正交：和另外两个向量垂直</p></blockquote><p>不同于其他运算，如果你没有钻研过线性代数，可能会觉得叉乘很反直觉，所以只记住公式就没问题啦（记不住也没问题）。下面你会看到两个正交向量 A 和 B 叉积：</p><pre><code class="language-math">
\begin&#123;pmatrix&#125;
   A_x \\
   A_y \\
   A_z  \end&#123;pmatrix&#125;
   ×
\begin&#123;pmatrix&#125;
   B_x \\
   B_y \\
   B_z  \end&#123;pmatrix&#125;
   =
\begin&#123;pmatrix&#125;
   A_y \cdotp B_z - A_z \cdotp B_y \\
   A_z \cdotp B_x - A_x \cdotp B_z \\
   A_x \cdotp B_y - A_y \cdotp B_x  \end&#123;pmatrix&#125;
</code></pre><p>是不是看起来毫无头绪？不过只要你按照步骤来了，你就能得到一个正交于两个输入向量的第三个向量。</p><h3 id="矩阵"><a class="anchor" href="#矩阵">#</a> 矩阵</h3><p>现在我们已经讨论了向量的全部内容，是时候看看矩阵了！简单来说矩阵就是一个矩形的数字、符号或表达式数组。矩阵中每一项叫做矩阵的元素 (Element)。下面是一个 2×3 矩阵的例子：</p><pre><code class="language-math">\begin&#123;bmatrix&#125;
   1 &amp; 2 &amp; 3 \\
   4 &amp; 5 &amp; 6
\end&#123;bmatrix&#125;
</code></pre><p>矩阵可以通过 (i, j) 进行索引，i 是行，j 是列，这就是上面的矩阵叫做 2×3 矩阵的原因（3 列 2 行，也叫做矩阵的<mark>维度</mark> (Dimension)）。这与你在索引 2D 图像时的 (x, y) 相反，获取 4 的索引是 (2, 1)（第二行，第一列）（译注：如果是图像索引应该是 (1, 2)，先算列，再算行）。</p><p>矩阵基本也就是这些了，它就是一个矩形的数学表达式阵列。和向量一样，矩阵也有非常漂亮的数学属性。矩阵有几个运算，分别是：<mark>矩阵加法、减法和乘法</mark>。</p><p>矩阵与标量之间的加减定义如下：</p><pre><code class="language-math">\begin&#123;bmatrix&#125;
   1 &amp; 2  \\
   3 &amp; 4 
\end&#123;bmatrix&#125;
+
3
=
\begin&#123;bmatrix&#125;
   1 +3 &amp; 2+3 \\
   3 +3 &amp; 4+3
\end&#123;bmatrix&#125;
=
\begin&#123;bmatrix&#125;
   4 &amp; 5 \\
   6 &amp; 7
\end&#123;bmatrix&#125;
</code></pre><p>标量值要加到矩阵的每一个元素上。矩阵与标量的减法也相似：</p><pre><code class="language-math">\begin&#123;bmatrix&#125;
   1 &amp; 2  \\
   3 &amp; 4 
\end&#123;bmatrix&#125;
-3=
\begin&#123;bmatrix&#125;
   1 -3 &amp; 2 -3 \\
   3 -3 &amp; 4 -3
\end&#123;bmatrix&#125;
=
\begin&#123;bmatrix&#125;
   -2 &amp; -1 \\
   0 &amp; 1
\end&#123;bmatrix&#125;
</code></pre><p>矩阵与矩阵之间的加减就是两个矩阵对应元素的加减运算，所以总体的规则和与标量运算是差不多的，只不过在相同索引下的元素才能进行运算。这也就是说加法和减法只对同维度的矩阵才是有定义的。一个 3×2 矩阵和一个 2×3 矩阵（或一个 3×3 矩阵与 4×4 矩阵）是不能进行加减的。我们看看两个 2×2 矩阵是怎样相加的：</p><pre><code class="language-math">\begin&#123;bmatrix&#125;
   1 &amp; 2  \\
   3 &amp; 4 
\end&#123;bmatrix&#125;+
\begin&#123;bmatrix&#125;
   5 &amp; 6  \\
   7 &amp; 8 
\end&#123;bmatrix&#125;
=
\begin&#123;bmatrix&#125;
   1 + 5 &amp; 2 + 6 \\
   3 + 7 &amp; 4 + 8
\end&#123;bmatrix&#125;
=
\begin&#123;bmatrix&#125;
   4 &amp; 8 \\
   10 &amp; 12
\end&#123;bmatrix&#125;
</code></pre><p>同样的法则也适用于减法：</p><pre><code class="language-math">\begin&#123;bmatrix&#125;
   4 &amp; 2  \\
   1 &amp; 6 
\end&#123;bmatrix&#125;-
\begin&#123;bmatrix&#125;
   2 &amp; 4  \\
   0 &amp; 1 
\end&#123;bmatrix&#125;
=
\begin&#123;bmatrix&#125;
   4-2 &amp; 2-4 \\
   1-0 &amp; 6-1
\end&#123;bmatrix&#125;
=
\begin&#123;bmatrix&#125;
   2 &amp; -2 \\
   1 &amp; 5
\end&#123;bmatrix&#125;
</code></pre><h3 id="矩阵的数乘"><a class="anchor" href="#矩阵的数乘">#</a> 矩阵的数乘</h3><p>和矩阵与标量的加减一样，矩阵与标量之间的乘法也是矩阵的每一个元素分别乘以该标量。下面的例子展示了乘法的过程：</p><pre><code class="language-math">2\cdotp
\begin&#123;bmatrix&#125;
   1 &amp; 2  \\
   3 &amp; 4 
\end&#123;bmatrix&#125;
=
\begin&#123;bmatrix&#125;
   2\cdotp1 &amp; 2\cdotp2 \\
   2\cdotp3 &amp; 2\cdotp4
\end&#123;bmatrix&#125;
=
\begin&#123;bmatrix&#125;
   2 &amp; 4 \\
   6 &amp; 8
\end&#123;bmatrix&#125;
</code></pre><p>现在我们也就能明白为什么这些单独的数字要叫做标量 (Scalar) 了。简单来说，标量就是用它的值缩放 (Scale) 矩阵的所有元素（译注：注意 Scalar 是由 Scale + -ar 演变过来的）。前面那个例子中，所有的元素都被放大了 2 倍。</p><p>到目前为止都还好，我们的例子都不复杂。不过矩阵与矩阵的乘法就不一样了。</p><h3 id="矩阵相乘"><a class="anchor" href="#矩阵相乘">#</a> 矩阵相乘</h3><p>矩阵之间的乘法不见得有多复杂，但的确很难让人适应。矩阵乘法基本上意味着遵照规定好的法则进行相乘。当然，相乘还有一些限制：</p><ul><li>只有当左侧矩阵的列数与右侧矩阵的行数相等，两个矩阵才能相乘。</li><li>矩阵相乘不遵守交换律 (Commutative)，也就是说 A⋅B≠B⋅A。</li></ul><p>我们先看一个两个 2×2 矩阵相乘的例子：</p><pre><code class="language-math">\begin&#123;bmatrix&#125;
   1 &amp; 2  \\
   3 &amp; 4 
\end&#123;bmatrix&#125;
\cdotp
\begin&#123;bmatrix&#125;
   5 &amp; 6  \\
   7 &amp; 8 
\end&#123;bmatrix&#125;
=
\begin&#123;bmatrix&#125;
   1\cdotp5+2\cdotp7 &amp; 1\cdotp6+2\cdotp8 \\
   3\cdotp5+4\cdotp7 &amp; 3\cdotp6+4\cdotp8 
\end&#123;bmatrix&#125;
=
\begin&#123;bmatrix&#125;
   19 &amp; 22 \\
   43 &amp; 50
\end&#123;bmatrix&#125;
</code></pre><p>现在你可能会在想了：天哪，刚刚到底发生了什么？矩阵的乘法是一系列乘法和加法组合的结果，它使用到了左侧矩阵的行和右侧矩阵的列。我们可以看下面的图片：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/07/matrix_multiplication.png" alt="image"></p><h3 id="矩阵与向量相乘"><a class="anchor" href="#矩阵与向量相乘">#</a> 矩阵与向量相乘</h3><p>目前为止，通过这些教程我们已经相当了解向量了。我们用向量来表示位置，表示颜色，甚至是纹理坐标。让我们更深入了解一下向量，它其实就是一个 N×1 矩阵，N 表示向量分量的个数（也叫 N 维 (N-dimensional) 向量）。如果你仔细思考一下就会明白。向量和矩阵一样都是一个数字序列，但它只有 1 列。那么，这个新的定义对我们有什么帮助呢？如果我们有一个 M×N 矩阵，我们可以用这个矩阵乘以我们的 N×1 向量，因为这个矩阵的列数等于向量的行数，所以它们就能相乘。</p><p>但是为什么我们会关心矩阵能否乘以一个向量？好吧，正巧，很多有趣的 2D/3D 变换都可以放在一个矩阵中，用这个矩阵乘以我们的向量将<mark>变换</mark> (Transform) 这个向量。如果你仍然有些困惑，我们来看一些例子，你很快就能明白了。</p><h3 id="单位矩阵"><a class="anchor" href="#单位矩阵">#</a> 单位矩阵</h3><p>在 OpenGL 中，由于某些原因我们通常使用 4×4 的变换矩阵，而其中最重要的原因就是大部分的向量都是<mark> 4 分量</mark>的。我们能想到的最简单的变换矩阵就是单位矩阵 (Identity Matrix)。单位矩阵是一个除了对角线以外都是 0 的 N×N 矩阵。在下式中可以看到，这种变换矩阵使一个向量完全不变：</p><pre><code class="language-math">\begin&#123;bmatrix&#125;
   1 &amp; 0  &amp; 0  &amp; 0  \\
   0 &amp; 1  &amp; 0  &amp; 0  \\
   0 &amp; 0  &amp; 1  &amp; 0  \\
   0 &amp; 0  &amp; 0  &amp; 1  
\end&#123;bmatrix&#125;
\cdotp
\begin&#123;bmatrix&#125;
   1 \\
   2 \\
   3 \\
   4 
\end&#123;bmatrix&#125;
=
\begin&#123;bmatrix&#125;
     1\cdotp1 \\
   1\cdotp2 \\
   1\cdotp3 \\
   1\cdotp4 
\end&#123;bmatrix&#125;
=
\begin&#123;bmatrix&#125;
   1 \\
   2 \\
   3 \\
   4 
\end&#123;bmatrix&#125;
</code></pre><h3 id="缩放"><a class="anchor" href="#缩放">#</a> 缩放</h3><p>对一个向量进行缩放 (Scaling) 就是对向量的长度进行缩放，而保持它的方向不变。由于我们进行的是 2 维或 3 维操作，我们可以分别定义一个有 2 或 3 个缩放变量的向量，每个变量缩放一个轴 (x、y 或 z)。</p><p>我们先来尝试缩放向量 v=(3,2)。我们可以把向量沿着 x 轴缩放 0.5，使它的宽度缩小为原来的二分之一；我们将沿着 y 轴把向量的高度缩放为原来的两倍。我们看看把向量缩放 (0.5, 2) 倍所获得的 s 是什么样的：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/07/vectors_scale.png" alt="image"></p><p>我们刚刚的缩放操作是<mark>不均匀</mark> (Non-uniform) 缩放，因为每个轴的缩放因子 (Scaling Factor) 都不一样。如果每个轴的缩放因子都一样那么就叫<mark>均匀缩放</mark> (Uniform Scale)。</p><p>我们下面会构造一个变换矩阵来为我们提供缩放功能。我们从单位矩阵了解到，每个对角线元素会分别与向量的对应元素相乘。如果我们把 1 变为 3 会怎样？这样子的话，我们就把向量的每个元素乘以 3 了，这事实上就把向量缩放 3 倍。如果我们把缩放变量表示为 (S1,S2,S3) 我们可以为任意向量 (x,y,z) 定义一个缩放矩阵：</p><pre><code class="language-math">\begin&#123;bmatrix&#125;
   S_1 &amp; 0  &amp; 0  &amp; 0  \\
   0 &amp; S_2  &amp; 0  &amp; 0  \\
   0 &amp; 0  &amp; S_3  &amp; 0  \\
   0 &amp; 0  &amp; 0  &amp; 1  
\end&#123;bmatrix&#125;
\cdotp
\begin&#123;pmatrix&#125;
   x \\
   y \\
   z \\
   1 
\end&#123;pmatrix&#125;
=
\begin&#123;pmatrix&#125;
   S_1\cdotp x\\
   S_2\cdotp y \\
   S_3\cdotp z \\
   1 
\end&#123;pmatrix&#125;
</code></pre><p>注意，第四个缩放向量仍然是 1，因为在 3D 空间中缩放 w 分量是无意义的。w 分量另有其他用途，在后面我们会看到。</p><h3 id="位移"><a class="anchor" href="#位移">#</a> 位移</h3><p>和缩放矩阵一样，在 4×4 矩阵上有几个特别的位置用来执行特定的操作，对于位移来说它们是第四列最上面的 3 个值。如果我们把位移向量表示为 (Tx,Ty,Tz)，我们就能把位移矩阵定义为：</p><pre><code class="language-math">\begin&#123;bmatrix&#125;
   1 &amp; 0  &amp; 0  &amp; T_x  \\
   0 &amp; 1  &amp; 0  &amp; T_y  \\
   0 &amp; 0  &amp; 1  &amp; T_z  \\
   0 &amp; 0  &amp; 0  &amp; 1  
\end&#123;bmatrix&#125;
\cdotp
\begin&#123;pmatrix&#125;
   x \\
   y \\
   z \\
   1 
\end&#123;pmatrix&#125;
=
\begin&#123;pmatrix&#125;
   x+T_x\\
   y+T_y \\
   z+T_z \\
   1 
\end&#123;pmatrix&#125;
</code></pre><blockquote><p><strong>齐次坐标</strong> (Homogeneous Coordinates)</p></blockquote><blockquote><p>向量的 w 分量也叫齐次坐标。想要从齐次向量得到 3D 向量，我们可以把 x、y 和 z 坐标分别除以 w 坐标。我们通常不会注意这个问题，因为 w 分量通常是 1.0。使用齐次坐标有几点好处：它允许我们在 3D 向量上进行位移（如果没有 w 分量我们是不能位移向量的），而且下一章我们会用 w 值创建 3D 视觉效果。</p></blockquote><blockquote><p>如果一个向量的齐次坐标是 0，这个坐标就是方向向量 (Direction Vector)，因为 w 坐标是 0，这个向量就不能位移（译注：这也就是我们说的不能位移一个方向） 。</p></blockquote><h3 id="旋转"><a class="anchor" href="#旋转">#</a> 旋转</h3><blockquote><p>大多数旋转函数需要用弧度制的角，但幸运的是角度制的角也可以很容易地转化为弧度制的：</p></blockquote><blockquote><ul><li>弧度转角度：角度 = 弧度 * (180.0f / PI)</li><li>角度转弧度：弧度 = 角度 * (PI / 180.0f)</li></ul></blockquote><blockquote><p>PI 约等于 3.14159265359。</p></blockquote><p>转半圈会旋转 360/2 = 180 度，向右旋转 1/5 圈表示向右旋转 360/5 = 72 度。下图中展示的 2D 向量 v 是由 k 向右旋转 72 度所得的：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/07/vectors_angle.png" alt="image"></p><p>在 3D 空间中旋转需要定义一个<mark>角</mark>和一个<mark>旋转轴</mark> (Rotation Axis)。物体会沿着给定的旋转轴旋转特定角度。如果你想要更形象化的感受，可以试试向下看着一个特定的旋转轴，同时将你的头部旋转一定角度。当 2D 向量在 3D 空间中旋转时，我们把旋转轴设为 z 轴（尝试想象这种情况）。</p><p>旋转矩阵在 3D 空间中每个单位轴都有不同定义，旋转角度用 θ 表示：</p><p>沿 x 轴旋转：</p><pre><code class="language-math">\begin&#123;bmatrix&#125;
   1 &amp; 0  &amp; 0  &amp; 0  \\
   0 &amp; \cos\theta  &amp; -\sin\theta  &amp; 0  \\
   0 &amp; \sin\theta  &amp; \cos\theta  &amp; 0  \\
   0 &amp; 0  &amp; 0  &amp; 1  
\end&#123;bmatrix&#125;
\cdotp
\begin&#123;pmatrix&#125;
   x \\
   y \\
   z \\
   1 
\end&#123;pmatrix&#125;
=
\begin&#123;pmatrix&#125;
    x\\
   \cos\theta\cdotp y-\sin\theta\cdotp z \\
   \sin\theta\cdotp y +\cos\theta\cdotp z\\
   1 
\end&#123;pmatrix&#125;
</code></pre><p>沿 y 轴旋转：</p><pre><code class="language-math">\begin&#123;bmatrix&#125;
   \cos\theta &amp; 0  &amp; \sin\theta  &amp; 0  \\
   0 &amp; 1  &amp; 0  &amp; 0  \\
   -\sin\theta  &amp; 0 &amp; \cos\theta  &amp; 0  \\
   0 &amp; 0  &amp; 0  &amp; 1  
\end&#123;bmatrix&#125;
\cdotp
\begin&#123;pmatrix&#125;
   x \\
   y \\
   z \\
   1 
\end&#123;pmatrix&#125;
=
\begin&#123;pmatrix&#125;
   \cos\theta\cdotp x-\sin\theta\cdotp y \\
   y\\
   -\sin\theta\cdotp x +\cos\theta\cdotp y\\
   1 
\end&#123;pmatrix&#125;
</code></pre><p>沿 z 轴旋转：</p><pre><code class="language-math">\begin&#123;bmatrix&#125;
   \cos\theta &amp; -\sin\theta  &amp; 0  &amp; 0  \\
   \sin\theta &amp; \cos\theta  &amp; 0  &amp; 0  \\
   0 &amp; 0  &amp; 1  &amp; 0  \\
   0 &amp; 0  &amp; 0  &amp; 1  
\end&#123;bmatrix&#125;
\cdotp
\begin&#123;pmatrix&#125;
   x \\
   y \\
   z \\
   1 
\end&#123;pmatrix&#125;
=
\begin&#123;pmatrix&#125;
   \cos\theta\cdotp x-\sin\theta\cdotp y \\
   \sin\theta\cdotp x +\cos\theta\cdotp y\\
   z\\
   1 
\end&#123;pmatrix&#125;
</code></pre><p>利用旋转矩阵我们可以把任意位置向量沿一个单位旋转轴进行旋转。也可以将多个矩阵复合，比如先沿着 x 轴旋转再沿着 y 轴旋转。但是这会很快导致一个问题 ——<mark> 万向节死锁</mark>（Gimbal Lock，可以看看这个<span class="exturl" data-url="aHR0cHM6Ly92LnlvdWt1LmNvbS92X3Nob3cvaWRfWE56a3lPVEl5TVRJPS5odG1s">视频（优酷）</span>来了解）。在这里我们不会讨论它的细节，但是对于 3D 空间中的旋转，一个更好的模型是沿着任意的一个轴，比如单位向量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0.662</mn><mo separator="true">,</mo><mn>0.2</mn><mo separator="true">,</mo><mn>0.7222</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0.662, 0.2, 0.7222)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mord">6</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">7</span><span class="mord">2</span><span class="mord">2</span><span class="mord">2</span><span class="mclose">)</span></span></span></span> 旋转，而不是对一系列旋转矩阵进行复合。这样的一个（超级麻烦的）矩阵是存在的，见下面这个公式，其中 (Rx,Ry,Rz) 代表任意旋转轴：</p><pre><code class="language-math">\begin&#123;bmatrix&#125;
\cos\theta+&#123;R_x&#125;^2(1-\cos\theta) &amp;
R_xR_y(1-\cos\theta)-R_z\sin\theta &amp;
R_xR_y(1-cos\theta)+R_y\sin\theta &amp;
0
\\
R_yR_z(1-\cos\theta)+R_z\sin\theta &amp;
\cos\theta+&#123;R_y&#125;^2(1-\cos\theta) &amp;
R_yR_z(1-cos\theta)-R_z\sin\theta &amp;
0
\\
R_zR_x(1-\cos\theta)-R_y\sin\theta &amp;
R_zR_y(1-cos\theta)+R_x\sin\theta &amp;
\cos\theta+&#123;R_z&#125;^2(1-\cos\theta) &amp;
0
\\
0 &amp; 0 &amp; 0 &amp; 1
\end&#123;bmatrix&#125;
</code></pre><p>避免万向节死锁的真正解决方案是使用<mark>四元数</mark> (Quaternion)，它不仅更安全，而且计算会更有效率。四元数可能会在后面的教程中讨论。</p><blockquote><p>对四元数的理解会用到非常多的数学知识。如果你想了解四元数与 3D 旋转之间的关系，可以来阅读我的<span class="exturl" data-url="aHR0cHM6Ly9rcmFzamV0LmdpdGh1Yi5pby9xdWF0ZXJuaW9uL3F1YXRlcm5pb24ucGRm">教程</span>。如果你对万向节死锁的概念仍不是那么清楚，可以来阅读我教程的<span class="exturl" data-url="aHR0cHM6Ly9rcmFzamV0LmdpdGh1Yi5pby9xdWF0ZXJuaW9uL2JvbnVzX2dpbWJhbF9sb2NrLnBkZg=="> Bonus 章节</span>。</p></blockquote><blockquote><p>现在 3Blue1Brown 也已经开始了一个四元数的视频系列，他采用球极平面投影 (Stereographic Projection) 的方式将四元数投影到 3D 空间，同样有助于理解四元数的概念（仍在更新中）：<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1kNEVnYmdUbTBCZw==">https://www.youtube.com/watch?v=d4EgbgTm0Bg</span></p></blockquote><h3 id="矩阵的组合"><a class="anchor" href="#矩阵的组合">#</a> 矩阵的组合</h3><pre><code class="language-math">Trans.Scale=
\begin&#123;bmatrix&#125;
1 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 1 &amp; 0 &amp; 2 \\
0 &amp; 0 &amp; 1 &amp; 3 \\
0 &amp; 0 &amp; 0 &amp; 1
\end&#123;bmatrix&#125;
\cdotp
\begin&#123;bmatrix&#125;
2 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 2 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 2 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end&#123;bmatrix&#125;
=
\begin&#123;bmatrix&#125;
2 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 2 &amp; 0 &amp; 2 \\
0 &amp; 0 &amp; 2 &amp; 3 \\
0 &amp; 0 &amp; 0 &amp; 1
\end&#123;bmatrix&#125;
</code></pre><p><mark>注意</mark>，当矩阵相乘时我们<strong>先</strong>写<mark>位移</mark><strong>再</strong>写<mark>缩放变换</mark>的。矩阵乘法是不遵守交换律的，这意味着它们的顺序很重要。当矩阵相乘时，在最右边的矩阵是第一个与向量相乘的，所以你应该从右向左读这个乘法。建议您在组合矩阵时，<strong>先</strong>进行<mark>缩放</mark>操作，然后是<mark>旋转</mark>，<strong>最后</strong>才是<mark>位移</mark>，否则它们会（消极地）互相影响。比如，如果你先位移再缩放，位移的向量也会同样被缩放（译注：比如向某方向移动 2 米，2 米也许会被缩放成 1 米）！</p><p>用最终的变换矩阵左乘我们的向量会得到以下结果：</p><pre><code class="language-math">\begin&#123;bmatrix&#125;
2 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 2 &amp; 0 &amp; 2 \\
0 &amp; 0 &amp; 2 &amp; 3 \\
0 &amp; 0 &amp; 0 &amp; 1
\end&#123;bmatrix&#125;
\cdotp
\begin&#123;bmatrix&#125;
x  \\
y  \\
z  \\
1 
\end&#123;bmatrix&#125;
=
\begin&#123;bmatrix&#125;
2x+1 \\
2y+2 \\
2z+3 \\
1 
\end&#123;bmatrix&#125;
</code></pre><h3 id="实践"><a class="anchor" href="#实践">#</a> 实践</h3><h3 id="glm"><a class="anchor" href="#glm">#</a> GLM</h3><p>GLM 是 OpenGL Mathematics 的缩写，它是一个只有头文件的库，也就是说我们只需包含对应的头文件就行了，不用链接和编译。GLM 可以在它们的网站上<span class="exturl" data-url="aHR0cHM6Ly9zb3VyY2Vmb3JnZS5uZXQvcHJvamVjdHMvb2dsLW1hdGgvZmlsZXMvbGF0ZXN0L2Rvd25sb2Fk">下载</span>。把头文件的根目录复制到你的 includes 文件夹，然后你就可以使用这个库了。</p><p>我们需要的 GLM 的大多数功能都可以从下面这 3 个头文件中找到：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;glm/glm.hpp></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;glm/gtc/matrix_transform.hpp></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;glm/gtc/type_ptr.hpp></span></span></pre></td></tr></table></figure><p>我们来看看是否可以利用我们刚学的变换知识把一个向量 (1, 0, 0) 位移 (1, 1, 0) 个单位（注意，我们把它定义为一个 glm::vec4 类型的值，齐次坐标设定为 1.0）：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span>vec4 <span class="token function">vec</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 译注：下面就是矩阵初始化的一个例子，如果使用的是 0.9.9 及以上版本</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 下面这行代码就需要改为:</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// glm::mat4 trans = glm::mat4(1.0f)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 之后将不再进行提示</span></pre></td></tr><tr><td data-num="6"></td><td><pre>glm<span class="token operator">::</span>mat4 trans<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>trans <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">translate</span><span class="token punctuation">(</span>trans<span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>vec <span class="token operator">=</span> trans <span class="token operator">*</span> vec<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> vec<span class="token punctuation">.</span>x <span class="token operator">&lt;&lt;</span> vec<span class="token punctuation">.</span>y <span class="token operator">&lt;&lt;</span> vec<span class="token punctuation">.</span>z <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span></pre></td></tr></table></figure><p>我们先用 GLM 内建的向量类定义一个叫做<mark> vec</mark> 的向量。接下来定义一个 mat4 类型的 trans，默认是一个 4×4 单位矩阵。下一步是创建一个变换矩阵，我们是把单位矩阵和一个位移向量传递给 glm::translate 函数来完成这个工作的（然后用给定的矩阵乘以位移矩阵就能获得最后需要的矩阵）。<br>之后我们把向量乘以位移矩阵并且输出最后的结果。如果你仍记得位移矩阵是如何工作的话，得到的向量应该是 (1 + 1, 0 + 1, 0 + 0)，也就是 (2, 1, 0)。这个代码片段将会输出 210，所以这个位移矩阵是正确的。</p><p>我们来做些更有意思的事情，让我们来旋转和缩放之前教程中的那个箱子。首先我们把箱子逆时针旋转 90 度。然后缩放 0.5 倍，使它变成原来的一半大。我们先来创建变换矩阵：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span>mat4 trans<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>trans <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">rotate</span><span class="token punctuation">(</span>trans<span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">radians</span><span class="token punctuation">(</span><span class="token number">90.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>trans <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">scale</span><span class="token punctuation">(</span>trans<span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>首先，我们把箱子在每个轴都缩放到 0.5 倍，然后沿 z 轴旋转 90 度。GLM 希望它的角度是弧度制的 (Radian)，所以我们使用 glm::radians 将角度转化为弧度。注意有纹理的那面矩形是在 XY 平面上的，所以我们需要把它绕着 z 轴旋转。因为我们把这个矩阵传递给了 GLM 的每个函数，GLM 会自动将矩阵相乘，返回的结果是一个包括了多个变换的变换矩阵。</p><p>下一个大问题是：如何把矩阵传递给着色器？我们在前面简单提到过 GLSL 里也有一个 mat4 类型。所以我们将修改顶点着色器让其接收一个 mat4 的 uniform 变量，然后再用矩阵 uniform 乘以位置向量：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> in vec3 aPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> in vec2 aTexCoord<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>out vec2 TexCoord<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>uniform mat4 transform<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    gl_Position <span class="token operator">=</span> transform <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>aPos<span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    TexCoord <span class="token operator">=</span> <span class="token function">vec2</span><span class="token punctuation">(</span>aTexCoord<span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token number">1.0</span> <span class="token operator">-</span> aTexCoord<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在把位置向量传给 gl_Position 之前，我们先添加一个 uniform，并且将其与变换矩阵相乘。我们的箱子现在应该是原来的二分之一大小并（向左）旋转了 90 度。当然，我们仍需要把变换矩阵传递给着色器：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> transformLoc <span class="token operator">=</span> <span class="token function">glGetUniformLocation</span><span class="token punctuation">(</span>ourShader<span class="token punctuation">.</span>ID<span class="token punctuation">,</span> <span class="token string">"transform"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glUniformMatrix4fv</span><span class="token punctuation">(</span>transformLoc<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">value_ptr</span><span class="token punctuation">(</span>trans<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>我们首先查询 uniform 变量的地址，然后用有 Matrix4fv 后缀的 glUniform 函数把矩阵数据发送给着色器。第一个参数你现在应该很熟悉了，它是 uniform 的位置值。第二个参数告诉 OpenGL 我们将要发送多少个矩阵，这里是 1。第三个参数询问我们我们是否希望对我们的矩阵进行置换 (Transpose)，也就是说交换我们矩阵的行和列。OpenGL 开发者通常使用一种内部矩阵布局，叫做列主序 (Column-major Ordering) 布局。GLM 的默认布局就是列主序，所以并不需要置换矩阵，我们填 GL_FALSE。最后一个参数是真正的矩阵数据，但是 GLM 并不是把它们的矩阵储存为 OpenGL 所希望接受的那种，因此我们要先用 GLM 的自带的函数 value_ptr 来变换这些数据。</p><p>我们创建了一个变换矩阵，在顶点着色器中声明了一个 uniform，并把矩阵发送给了着色器，着色器会变换我们的顶点坐标。最后的结果应该看起来像这样：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/07/transformations.png" alt="image"></p><p>完美！我们的箱子向左侧旋转，并是原来的一半大小，所以变换成功了。我们现在做些更有意思的，看看我们是否可以让箱子随着时间旋转，我们还会重新把箱子放在窗口的右下角。要让箱子随着时间推移旋转，我们必须在游戏循环中更新变换矩阵，因为它在每一次渲染迭代中都要更新。我们使用 GLFW 的时间函数来获取不同时间的角度：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span>mat4 trans<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>trans <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">translate</span><span class="token punctuation">(</span>trans<span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>trans <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">rotate</span><span class="token punctuation">(</span>trans<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token function">glfwGetTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h2 id="坐标系统"><a class="anchor" href="#坐标系统">#</a> 坐标系统</h2><p>在上一个教程中，我们学习了如何有效地利用矩阵的变换来对所有顶点进行变换。OpenGL 希望在每次顶点着色器运行后，我们可见的所有顶点都为<mark>标准化设备坐标</mark> (Normalized Device Coordinate, NDC)。也就是说，<mark>每个顶点的 x，y，z 坐标都应该在 - 1.0 到 1.0 之间</mark>，超出这个坐标范围的顶点都将不可见。我们通常会自己设定一个坐标的范围，之后再在顶点着色器中将这些坐标变换为标准化设备坐标。然后将这些标准化设备坐标传入光栅器 (Rasterizer)，将它们变换为屏幕上的二维坐标或像素。</p><p>将坐标变换为标准化设备坐标，接着再转化为屏幕坐标的过程通常是分步进行的，也就是类似于流水线那样子。在流水线中，物体的顶点在最终转化为屏幕坐标之前还会被变换到多个坐标系统 (Coordinate System)。将物体的坐标变换到几个过渡坐标系 (Intermediate Coordinate System) 的优点在于，在这些特定的坐标系统中，一些操作或运算更加方便和容易，这一点很快就会变得很明显。对我们来说比较重要的总共有 5 个不同的坐标系统：</p><ul><li>局部空间 (Local Space，或者称为物体空间 (Object Space))</li><li>世界空间 (World Space)</li><li>观察空间 (View Space，或者称为视觉空间 (Eye Space))</li><li>裁剪空间 (Clip Space)</li><li>屏幕空间 (Screen Space)</li></ul><h3 id="概述"><a class="anchor" href="#概述">#</a> 概述</h3><p>为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是<mark>模型</mark> (Model)、<mark>观察</mark> (View)、<mark>投影</mark> (Projection) 三个矩阵。我们的顶点坐标起始于<mark>局部空间</mark> (Local Space)，在这里它称为<mark>局部坐标</mark> (Local Coordinate)，它在之后会变为<mark>世界坐标</mark> (World Coordinate)，<mark>观察坐标</mark> (View Coordinate)，<mark>裁剪坐标</mark> (Clip Coordinate)，并最后以<mark>屏幕坐标</mark> (Screen Coordinate) 的形式结束。下面的这张图展示了整个流程以及各个变换过程做了什么：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/08/coordinate_systems.png" alt="image"></p><ul><li>局部坐标是对象相对于局部原点的坐标，也是物体<mark>起始的坐标</mark>。</li><li>下一步是将局部坐标变换为世界空间坐标，世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其它物体一起相对于世界的原点进行摆放。</li><li>接下来我们将世界坐标变换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的。</li><li>坐标到达观察空间之后，我们需要将其投影到裁剪坐标。裁剪坐标会被处理至 - 1.0 到 1.0 的范围内，并判断哪些顶点将会出现在屏幕上。</li><li>最后，我们将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换 (Viewport Transform) 的过程。视口变换将位于 - 1.0 到 1.0 范围的坐标变换到由 glViewport 函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段。</li></ul><p>你可能已经大致了解了每个坐标空间的作用。我们之所以将顶点变换到各个不同的空间的原因是有些操作在特定的坐标系统中才有意义且更方便。例如，当需要对物体进行修改的时候，在局部空间中来操作会更说得通；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等。如果我们愿意，我们也可以定义一个直接从局部空间变换到裁剪空间的变换矩阵，但那样会失去很多灵活性。</p><h3 id="局部空间"><a class="anchor" href="#局部空间">#</a> 局部空间</h3><p>局部空间是指物体所在的坐标空间，即对象最开始所在的地方。想象你在一个建模软件（比如说 Blender）中创建了一个立方体。你创建的立方体的原点有可能位于 (0, 0, 0)，即便它有可能最后在程序中处于完全不同的位置。甚至有可能你创建的所有模型都以 (0, 0, 0) 为初始位置（译注：然而它们会最终出现在世界的不同位置）。所以，你的模型的所有顶点都是在局部空间中：它们相对于你的物体来说都是局部的。</p><p>我们一直使用的那个箱子的顶点是被设定在 - 0.5 到 0.5 的坐标范围中，(0, 0) 是它的原点。这些都是局部坐标。</p><h3 id="世界空间"><a class="anchor" href="#世界空间">#</a> 世界空间</h3><p>如果我们将我们所有的物体导入到程序当中，它们有可能会全挤在世界的原点 (0, 0, 0) 上，这并不是我们想要的结果。我们想为每一个物体定义一个位置，从而能在更大的世界当中放置它们。世界空间中的坐标正如其名：是指顶点相对于（游戏）世界的坐标。如果你希望将物体分散在世界上摆放（特别是非常真实的那样），这就是你希望物体变换到的空间。物体的坐标将会从局部变换到世界空间；该变换是由模型矩阵 (Model Matrix) 实现的。</p><p>模型矩阵是一种变换矩阵，它能通过对物体进行位移、缩放、旋转来将它置于它本应该在的位置或朝向。你可以将它想像为变换一个房子，你需要先将它缩小（它在局部空间中太大了），并将其位移至郊区的一个小镇，然后在 y 轴上往左旋转一点以搭配附近的房子。你也可以把上一节将箱子到处摆放在场景中用的那个矩阵大致看作一个模型矩阵；我们将箱子的局部坐标变换到场景 / 世界中的不同位置。</p><h3 id="观察空间"><a class="anchor" href="#观察空间">#</a> 观察空间</h3><p>观察空间经常被人们称之<mark> OpenGL 的摄像机</mark> (Camera)（所以有时也称为摄像机空间 (Camera Space) 或视觉空间 (Eye Space)）。观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果。因此观察空间就是从摄像机的视角所观察到的空间。而这通常是由一系列的位移和旋转的组合来完成，平移 / 旋转场景从而使得特定的对象被变换到摄像机的前方。这些组合在一起的变换通常存储在一个观察矩阵 (View Matrix) 里，它被用来将世界坐标变换到观察空间。在下一节中我们将深入讨论如何创建一个这样的观察矩阵来模拟一个摄像机。</p><h3 id="裁剪空间"><a class="anchor" href="#裁剪空间">#</a> 裁剪空间</h3><p>在一个顶点着色器运行的最后，OpenGL 期望所有的坐标都能落在一个特定的范围内，<mark>且任何在这个范围之外的点都应该被裁剪掉 (Clipped)。被裁剪掉的坐标就会被忽略</mark>，所以剩下的坐标就将变为屏幕上可见的片段。这也就是裁剪空间 (Clip Space) 名字的由来。</p><p>因为将所有可见的坐标都指定在 - 1.0 到 1.0 的范围内不是很直观，所以我们会指定自己的坐标集 (Coordinate Set) 并将它变换回标准化设备坐标系，就像 OpenGL 期望的那样。</p><p>为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个投影矩阵 (Projection Matrix)，它指定了一个范围的坐标，比如在每个维度上的 - 1000 到 1000。投影矩阵接着会将在这个指定的范围内的坐标变换为标准化设备坐标的范围 (-1.0, 1.0)。所有在范围外的坐标不会被映射到在 - 1.0 到 1.0 的范围之间，所以会被裁剪掉。在上面这个投影矩阵所指定的范围内，坐标 (1250, 500, 750) 将是不可见的，这是由于它的 x 坐标超出了范围，它被转化为一个大于 1.0 的标准化设备坐标，所以被裁剪掉了。</p><blockquote><p>如果只是图元 (Primitive)，例如三角形，的一部分超出了裁剪体积 (Clipping Volume)，则 OpenGL 会重新构建这个三角形为一个或多个三角形让其能够适合这个裁剪范围。</p></blockquote><p>由投影矩阵创建的<mark>观察箱</mark> (Viewing Box) 被称为平截头体 (Frustum)，每个出现在平截头体范围内的坐标都会最终出现在用户的屏幕上。将特定范围内的坐标转化到标准化设备坐标系的过程（而且它很容易被映射到 2D 观察空间坐标）被称之为<mark>投影</mark> (Projection)，因为使用投影矩阵能将 3D 坐标投影 (Project) 到很容易映射到 2D 的标准化设备坐标系中。</p><p>一旦所有顶点被变换到裁剪空间，最终的操作 ——<mark> 透视除法</mark> (Perspective Division) 将会执行，在这个过程中我们将位置向量的 x，y，z 分量分别除以向量的齐次 w 分量；<mark>透视除法是将 4D 裁剪空间坐标变换为 3D 标准化设备坐标的过程</mark>。这一步会在每一个顶点着色器运行的最后被自动执行。</p><p>在这一阶段之后，最终的坐标将会被映射到屏幕空间中（使用 glViewport 中的设定），并被变换成片段。</p><p>将观察坐标变换为裁剪坐标的投影矩阵可以为两种不同的形式，每种形式都定义了不同的平截头体。我们可以选择创建一个<mark>正射投影矩阵</mark> (Orthographic Projection Matrix) 或一个<mark>透视投影矩阵</mark> (Perspective Projection Matrix)。</p><blockquote><p>既：<mark>正交摄像机</mark>和<mark>透视摄像机</mark></p></blockquote><h3 id="正射投影"><a class="anchor" href="#正射投影">#</a> 正射投影</h3><p>正射投影矩阵定义了一个类似立方体的平截头箱，它定义了一个裁剪空间，在这空间之外的顶点都会被裁剪掉。创建一个正射投影矩阵需要指定可见平截头体的宽、高和长度。在使用正射投影矩阵变换至裁剪空间之后处于这个平截头体内的所有坐标将不会被裁剪掉。它的平截头体看起来像一个容器：<br><img data-src="https://learnopengl-cn.github.io/img/01/08/orthographic_frustum.png" alt="image"></p><p>上面的平截头体定义了可见的坐标，它由由宽、高、近 (Near) 平面和远 (Far) 平面所指定。任何出现在近平面之前或远平面之后的坐标都会被裁剪掉。正射平截头体直接将平截头体内部的所有坐标映射为标准化设备坐标，因为每个向量的 w 分量都没有进行改变；如果 w 分量等于 1.0，透视除法则不会改变这个坐标。</p><p>要创建一个正射投影矩阵，我们可以使用 GLM 的内置函数 glm::ortho：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span><span class="token function">ortho</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">800.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">600.0f</span><span class="token punctuation">,</span> <span class="token number">0.1f</span><span class="token punctuation">,</span> <span class="token number">100.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ul><li>前两个参数指定了平截头体的左右坐标</li><li>第三和第四参数指定了平截头体的底部和顶部。</li><li>然后第五和第六个参数则定义了近平面和远平面的距离。</li></ul><p>通过前四个参数我们定义了近平面和远平面的大小，这个投影矩阵会将处于这些 x，y，z 值范围内的坐标变换为标准化设备坐标。</p><p>正射投影矩阵直接将坐标映射到 2D 平面中，即你的屏幕，但实际上一个直接的投影矩阵会产生不真实的结果，因为这个投影没有<mark>将透视 (Perspective) 考虑进去</mark>。所以我们需要透视投影矩阵来解决这个问题。</p><h3 id="透视投影"><a class="anchor" href="#透视投影">#</a> 透视投影</h3><p>如果你曾经体验过实际生活给你带来的景象，你就会注意到离你越远的东西看起来更小。这个奇怪的效果称之为透视 (Perspective)。透视的效果在我们看一条无限长的高速公路或铁路时尤其明显，正如下面图片显示的那样：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/08/perspective.png" alt="image"></p><p>正如你看到的那样，由于透视，这两条线在很远的地方看起来会相交。这正是透视投影想要模仿的效果，它是使用<mark>透视投影矩阵</mark>来完成的。这个投影矩阵将给定的平截头体范围映射到裁剪空间，除此之外还修改了每个顶点坐标的<mark> w</mark> 值，从而使得离观察者越远的顶点坐标 w 分量越大。被变换到裁剪空间的坐标都会在 - w 到 w 的范围之间（任何大于这个范围的坐标都会被裁剪掉）。OpenGL 要求所有可见的坐标都落在 - 1.0 到 1.0 范围内，作为顶点着色器最后的输出，因此，一旦坐标在裁剪空间内之后，透视除法就会被应用到裁剪空间坐标上：</p><pre><code class="language-math">out=
\begin&#123;pmatrix&#125;
   x/w \\
   y/w \\
   z/w 
\end&#123;pmatrix&#125;
</code></pre><p>顶点坐标的每个分量都会除以它的 w 分量，距离观察者越远顶点坐标就会越小。这是也是 w 分量非常重要的另一个原因，它能够帮助我们进行透视投影。最后的结果坐标就是处于标准化设备空间中的。如果你对正射投影矩阵和透视投影矩阵是如何计算的很感兴趣（且不会对数学感到恐惧的话）我推荐这篇由 Songho 写的<span class="exturl" data-url="aHR0cDovL3d3dy5zb25naG8uY2Evb3BlbmdsL2dsX3Byb2plY3Rpb25tYXRyaXguaHRtbA==">文章</span>。</p><p>在 GLM 中可以这样创建一个透视投影矩阵：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span>mat4 proj <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">perspective</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">radians</span><span class="token punctuation">(</span><span class="token number">45.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>width<span class="token operator">/</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>height<span class="token punctuation">,</span> <span class="token number">0.1f</span><span class="token punctuation">,</span> <span class="token number">100.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>同样，glm::perspective 所做的其实就是创建了一个定义了可视空间的大平截头体，任何在这个平截头体以外的东西最后都不会出现在裁剪空间体积内，并且将会受到裁剪。一个透视平截头体可以被看作一个不均匀形状的箱子，在这个箱子内部的每个坐标都会被映射到裁剪空间上的一个点。下面是一张透视平截头体的图片：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/08/perspective_frustum.png" alt="image"></p><ul><li>它的第一个参数定义了 fov 的值，它表示的是<mark>视野</mark> (Field of View)，并且设置了观察空间的大小。如果想要一个真实的观察效果，它的值通常设置为<mark> 45.0f</mark>，但想要一个末日风格的结果你可以将其设置一个更大的值。</li><li>第二个参数设置了宽高比，由视口的宽除以高所得。</li><li>第三和第四个参数设置了平截头体的近和远平面。我们通常设置近距离为<mark> 0.1f</mark>，而远距离设为<mark> 100.0f</mark>。所有在近平面和远平面内且处于平截头体内的顶点都会被渲染。</li></ul><blockquote><p>当你把透视矩阵的 near 值设置太大时（如 10.0f），OpenGL 会将靠近摄像机的坐标（在 0.0f 和 10.0f 之间）都裁剪掉，这会导致一个你在游戏中很熟悉的视觉效果：<mark>在太过靠近一个物体的时候你的视线会直接穿过去</mark>。</p></blockquote><p>当使用<mark>正射投影</mark>时，每一个顶点坐标都会直接映射到裁剪空间中而<mark>不经过任何精细的透视除法</mark>（它仍然会进行透视除法，只是 w 分量没有被改变（它保持为 1），因此没有起作用）。因为正射投影没有使用透视，远处的物体不会显得更小，所以产生奇怪的视觉效果。由于这个原因，正射投影主要用于二维渲染以及一些建筑或工程的程序，在这些场景中我们更希望顶点不会被透视所干扰。某些如 Blender 等进行三维建模的软件有时在建模时也会使用正射投影，因为它在各个维度下都更准确地描绘了每个物体。下面你能够看到在 Blender 里面使用两种投影方式的对比：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/08/perspective_orthographic.png" alt="image"></p><p>你可以看到，使用透视投影的话，远处的顶点看起来比较小，而在正射投影中每个顶点距离观察者的距离都是一样的。</p><h3 id="把它们都组合到一起"><a class="anchor" href="#把它们都组合到一起">#</a> 把它们都组合到一起</h3><p>我们为上述的每一个步骤都创建了一个变换矩阵：模型矩阵、观察矩阵和投影矩阵。一个顶点坐标将会根据以下过程被变换到裁剪坐标:</p><pre><code class="language-math">V_&#123;clip&#125;=
M_&#123;projection&#125; \cdotp 
M_&#123;view&#125; \cdotp 
M_&#123;model&#125;\cdotp 
V_&#123;local&#125;
</code></pre><p>注意矩阵运算的顺序是相反的（记住我们需要<mark>从右往左</mark>阅读矩阵的乘法）。最后的顶点应该被赋值到顶点着色器中的<mark> gl_Position</mark>，OpenGL 将会自动进行透视除法和裁剪。</p><blockquote><p>然后呢？</p></blockquote><blockquote><p>顶点着色器的输出要求所有的顶点都在裁剪空间内，这正是我们刚才使用变换矩阵所做的。OpenGL 然后对裁剪坐标执行透视除法从而将它们变换到标准化设备坐标。OpenGL 会使用 glViewPort 内部的参数来将标准化设备坐标映射到屏幕坐标，每个坐标都关联了一个屏幕上的点（在我们的例子中是一个 800x600 的屏幕）。这个过程称为<mark>视口变换</mark>。</p></blockquote><h3 id="进入3d"><a class="anchor" href="#进入3d">#</a> 进入 3D</h3><p>在开始进行 3D 绘图时，我们首先创建一个<mark>模型矩阵</mark>。这个模型矩阵包含了位移、缩放与旋转操作，它们会被应用到所有物体的顶点上，以变换它们到全局的世界空间。让我们变换一下我们的平面，将其绕着 x 轴旋转，使它看起来像放在地上一样。这个模型矩阵看起来是这样的：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span>mat4 model<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>model <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">rotate</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">radians</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">55.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>通过将顶点坐标乘以这个模型矩阵，我们将该顶点坐标变换到世界坐标。我们的平面看起来就是在地板上，代表全局世界里的平面。</p><p>接下来我们需要创建一个观察矩阵。我们想要在场景里面稍微往后移动，以使得物体变成可见的（当在世界空间时，我们位于原点 (0,0,0)）。要想在场景里面移动，先仔细想一想下面这个句子：</p><blockquote><p>将摄像机向后移动，和将整个场景向前移动是一样的。</p></blockquote><p>这正是观察矩阵所做的，我们以相反于摄像机移动的方向移动整个场景。因为我们想要往后移动，并且 OpenGL 是一个<mark>右手坐标系</mark> (Right-handed System)，所以我们需要沿着 z 轴的正方向移动。我们会通过将场景沿着 z 轴负方向平移来实现。它会给我们一种我们在往后移动的感觉。</p><blockquote><p>右手坐标系 (Right-handed System)</p></blockquote><blockquote><p>按照惯例，OpenGL 是一个右手坐标系。简单来说，就是正 x 轴在你的右手边，正 y 轴朝上，而正 z 轴是朝向后方的。想象你的屏幕处于三个轴的中心，则正 z 轴穿过你的屏幕朝向你。坐标系画起来如下：</p></blockquote><p><img data-src="https://learnopengl-cn.github.io/img/01/08/coordinate_systems_right_handed.png" alt="image"></p><blockquote><p>为了理解为什么被称为右手坐标系，按如下的步骤做：</p></blockquote><blockquote><ul><li>沿着正 y 轴方向伸出你的右臂，手指着上方。</li><li>大拇指指向右方。</li><li>食指指向上方。</li><li>中指向下弯曲 90 度。</li></ul></blockquote><blockquote><p>如果你的动作正确，那么你的大拇指指向正 x 轴方向，食指指向正 y 轴方向，中指指向正 z 轴方向。如果你用左臂来做这些动作，你会发现 z 轴的方向是相反的。这个叫做左手坐标系，它被 DirectX 广泛地使用。注意在标准化设备坐标系中 OpenGL 实际上使用的是左手坐标系（投影矩阵交换了左右手）。</p></blockquote><p>在下一个教程中我们将会详细讨论如何在场景中移动。就目前来说，观察矩阵是这样的：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span>mat4 view<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 注意，我们将矩阵向我们要进行移动场景的反方向移动。</span></pre></td></tr><tr><td data-num="3"></td><td><pre>view <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">translate</span><span class="token punctuation">(</span>view<span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3.0f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>最后我们需要做的是定义一个投影矩阵。我们希望在场景中使用透视投影，所以像这样声明一个投影矩阵：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span>mat4 projection<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>projection <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">perspective</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">radians</span><span class="token punctuation">(</span><span class="token number">45.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> screenWidth <span class="token operator">/</span> screenHeight<span class="token punctuation">,</span> <span class="token number">0.1f</span><span class="token punctuation">,</span> <span class="token number">100.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>既然我们已经创建了变换矩阵，我们应该将它们传入着色器。首先，让我们在顶点着色器中声明一个 uniform 变换矩阵然后将它乘以顶点坐标：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> in vec3 aPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="4"></td><td><pre>uniform mat4 model<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>uniform mat4 view<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>uniform mat4 projection<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// 注意乘法要从右向左读</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    gl_Position <span class="token operator">=</span> projection <span class="token operator">*</span> view <span class="token operator">*</span> model <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>aPos<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>我们还应该将矩阵传入着色器（这通常在每次的渲染迭代中进行，因为变换矩阵会经常变动）：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> modelLoc <span class="token operator">=</span> <span class="token function">glGetUniformLocation</span><span class="token punctuation">(</span>ourShader<span class="token punctuation">.</span>ID<span class="token punctuation">,</span> <span class="token string">"model"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glUniformMatrix4fv</span><span class="token punctuation">(</span>modelLoc<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">value_ptr</span><span class="token punctuation">(</span>model<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// 观察矩阵和投影矩阵与之类似</span></pre></td></tr></table></figure><p>我们的顶点坐标已经使用模型、观察和投影矩阵进行变换了，最终的物体应该会：</p><ul><li>稍微向后倾斜至地板方向。</li><li>离我们有一些距离。</li><li>有透视效果（顶点越远，变得越小）。</li></ul><p>让我们检查一下结果是否满足这些要求：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/08/coordinate_systems_result.png" alt="image"></p><h3 id="更多的3d"><a class="anchor" href="#更多的3d">#</a> 更多的 3D</h3><p>到目前为止，我们一直都在使用一个 2D 平面，而且甚至是在 3D 空间里！所以，让我们大胆地拓展我们的 2D 平面为一个 3D 立方体。要想渲染一个立方体，我们一共需要 36 个顶点（6 个面 x 每个面有 2 个三角形组成 x 每个三角形有 3 个顶点），这 36 个顶点的位置你可以从<span class="exturl" data-url="aHR0cHM6Ly9sZWFybm9wZW5nbC5jb20vY29kZV92aWV3ZXIucGhwP2NvZGU9Z2V0dGluZy1zdGFydGVkL2N1YmVfdmVydGljZXM=">这里获取</span>。</p><p>为了有趣一点，我们将让立方体随着时间旋转：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>model <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">rotate</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token function">glfwGetTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> glm<span class="token operator">::</span><span class="token function">radians</span><span class="token punctuation">(</span><span class="token number">50.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>然后我们使用 glDrawArrays 来绘制立方体，但这一次总共有 36 个顶点。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glDrawArrays</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这的确有点像是一个立方体，但又有种说不出的奇怪。立方体的某些本应被遮挡住的面被绘制在了这个立方体其他面之上。之所以这样是因为 OpenGL 是一个三角形一个三角形地来绘制你的立方体的，所以即便之前那里有东西它也会覆盖之前的像素。因为这个原因，有些三角形会被绘制在其它三角形上面，虽然它们本不应该是被覆盖的。</p><p>幸运的是，OpenGL 存储深度信息在一个叫做<mark> Z 缓冲</mark> (Z-buffer) 的缓冲中，它允许 OpenGL 决定何时覆盖一个像素而何时不覆盖。通过使用 Z 缓冲，我们可以配置 OpenGL 来进行深度测试。</p><h3 id="z缓冲"><a class="anchor" href="#z缓冲">#</a> Z 缓冲</h3><p>OpenGL 存储它的所有深度信息于一个 Z 缓冲 (Z-buffer) 中，也被称为深度缓冲 (Depth Buffer)。GLFW 会自动为你生成这样一个缓冲（就像它也有一个颜色缓冲来存储输出图像的颜色）。深度值存储在每个片段里面（作为片段的 z 值），当片段想要输出它的颜色时，OpenGL 会将它的深度值和 z 缓冲进行比较，<mark>如果当前的片段在其它片段之后，它将会被丢弃</mark>，<mark>否则将会覆盖</mark>。这个过程称为深度测试 (Depth Testing)，它是由 OpenGL 自动完成的。</p><p>然而，如果我们想要确定 OpenGL 真的执行了深度测试，首先我们要告诉 OpenGL 我们想要启用深度测试；它默认是关闭的。我们可以通过 glEnable 函数来开启深度测试。glEnable 和 glDisable 函数允许我们启用或禁用某个 OpenGL 功能。这个功能会一直保持启用 / 禁用状态，直到另一个调用来禁用 / 启用它。现在我们想启用深度测试，需要开启 GL_DEPTH_TEST：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glEnable</span><span class="token punctuation">(</span>GL_DEPTH_TEST<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>因为我们使用了深度测试，我们也想要在每次渲染迭代之前清除深度缓冲（否则前一帧的深度信息仍然保存在缓冲中）。就像清除颜色缓冲一样，我们可以通过在 glClear 函数中指定 DEPTH_BUFFER_BIT 位来清除深度缓冲：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT <span class="token operator">|</span> GL_DEPTH_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="更多的立方体"><a class="anchor" href="#更多的立方体">#</a> 更多的立方体！</h3><p>现在我们想在屏幕上显示 10 个立方体。每个立方体看起来都是一样的，区别在于它们在世界的位置及旋转角度不同。立方体的图形布局已经定义好了，所以当渲染更多物体的时候我们不需要改变我们的缓冲数组和属性数组，我们唯一需要做的只是改变每个对象的模型矩阵来将立方体变换到世界坐标系中。</p><p>首先，让我们为每个立方体定义一个位移向量来指定它在世界空间的位置。我们将在一个 glm::vec3 数组中定义 10 个立方体位置：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span>vec3 cubePositions<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>  <span class="token number">0.0f</span><span class="token punctuation">,</span>  <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="3"></td><td><pre>  glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span> <span class="token number">2.0f</span><span class="token punctuation">,</span>  <span class="token number">5.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">15.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="4"></td><td><pre>  glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1.5f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.2f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.5f</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  </pre></td></tr><tr><td data-num="5"></td><td><pre>  glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">3.8f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">12.3f</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  </pre></td></tr><tr><td data-num="6"></td><td><pre>  glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span> <span class="token number">2.4f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.4f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3.5f</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  </pre></td></tr><tr><td data-num="7"></td><td><pre>  glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1.7f</span><span class="token punctuation">,</span>  <span class="token number">3.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">7.5f</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  </pre></td></tr><tr><td data-num="8"></td><td><pre>  glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span> <span class="token number">1.3f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.5f</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  </pre></td></tr><tr><td data-num="9"></td><td><pre>  glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span> <span class="token number">1.5f</span><span class="token punctuation">,</span>  <span class="token number">2.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.5f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="10"></td><td><pre>  glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span> <span class="token number">1.5f</span><span class="token punctuation">,</span>  <span class="token number">0.2f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.5f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="11"></td><td><pre>  glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1.3f</span><span class="token punctuation">,</span>  <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.5f</span><span class="token punctuation">)</span>  </pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>现在，在游戏循环中，我们调用 glDrawArrays 10 次，但这次在我们渲染之前每次传入一个不同的模型矩阵到顶点着色器中。我们将会在游戏循环中创建一个小的循环用不同的模型矩阵渲染我们的物体 10 次。注意我们也对每个箱子加了一点旋转：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>VAO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  glm<span class="token operator">::</span>mat4 model<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  model <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">translate</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span> cubePositions<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">float</span> angle <span class="token operator">=</span> <span class="token number">20.0f</span> <span class="token operator">*</span> i<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre>  model <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">rotate</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">radians</span><span class="token punctuation">(</span>angle<span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.3f</span><span class="token punctuation">,</span> <span class="token number">0.5f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  ourShader<span class="token punctuation">.</span><span class="token function">setMat4</span><span class="token punctuation">(</span><span class="token string">"model"</span><span class="token punctuation">,</span> model<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token function">glDrawArrays</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这段代码将会在每次新立方体绘制出来的时候更新模型矩阵，如此总共重复 10 次。然后我们应该就能看到一个拥有 10 个正在奇葩地旋转着的立方体的世界。</p><p><img data-src="https://learnopengl-cn.github.io/img/01/08/coordinate_systems_multiple_objects.png" alt="image"></p><h2 id="摄像机"><a class="anchor" href="#摄像机">#</a> 摄像机</h2><h3 id="摄像机观察空间"><a class="anchor" href="#摄像机观察空间">#</a> 摄像机 / 观察空间</h3><p>当我们讨论<mark>摄像机 / 观察空间</mark> (Camera/View Space) 的时候，是在讨论以摄像机的视角作为场景原点时场景中所有的顶点坐标：观察矩阵把所有的世界坐标变换为相对于摄像机位置与方向的观察坐标。要定义一个摄像机，我们需要它在世界空间中的<mark>位置</mark>、<mark>观察的方向</mark>、一个指向它右测的向量以及一个指向它上方的向量。细心的读者可能已经注意到我们实际上创建了一个三个单位轴相互垂直的、以摄像机的位置为原点的坐标系。</p><p><img data-src="https://learnopengl-cn.github.io/img/01/09/camera_axes.png" alt="image"></p><h3 id="1-摄像机位置"><a class="anchor" href="#1-摄像机位置">#</a> 1. 摄像机位置</h3><p>获取摄像机位置很简单。摄像机位置简单来说就是世界空间中一个指向摄像机位置的向量。我们把摄像机位置设置为上一节中的那个相同的位置：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span>vec3 cameraPos <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">3.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>不要忘记正 z 轴是从屏幕指向你的，如果我们希望摄像机向后移动，我们就沿着 z 轴的正方向移动。</p></blockquote><h3 id="2-摄像机方向"><a class="anchor" href="#2-摄像机方向">#</a> 2. 摄像机方向</h3><p>下一个需要的向量是摄像机的方向，这里指的是摄像机指向哪个方向。现在我们让摄像机指向场景原点：(0, 0, 0)。还记得如果将两个矢量相减，我们就能得到这两个矢量的差吗？用场景原点向量减去摄像机位置向量的结果就是摄像机的<mark>指向向量</mark>。由于我们知道摄像机指向<mark> z 轴负方向</mark>，但我们希望方向向量 (Direction Vector) 指向摄像机的 z 轴正方向。如果我们交换相减的顺序，我们就会获得一个指向摄像机正 z 轴方向的向量：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span>vec3 cameraTarget <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>glm<span class="token operator">::</span>vec3 cameraDirection <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">normalize</span><span class="token punctuation">(</span>cameraPos <span class="token operator">-</span> cameraTarget<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="3-x轴"><a class="anchor" href="#3-x轴">#</a> 3. X 轴</h3><p>我们需要的另一个向量是一个<mark>右向量</mark> (Right Vector)，它代表摄像机空间的 x 轴的正方向。为获取右向量我们需要先使用一个小技巧：先定义一个<mark>上向量</mark> (Up Vector)。接下来把上向量和第二步得到的方向向量进行<mark>叉乘</mark>。两个向量叉乘的结果会同时垂直于两向量，因此我们会得到指向 x 轴正方向的那个向量（<mark>如果我们<strong>交换</strong>两个向量叉乘的顺序就会得到相反的指向<strong> x 轴负方向</strong>的向量</mark>）：</p><pre><code>glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f); 
glm::vec3 cameraRight = glm::normalize(glm::cross(up, cameraDirection));
</code></pre><h4 id="4-y轴"><a class="anchor" href="#4-y轴">#</a> 4. Y 轴</h4><p>现在我们已经有了 x 轴向量和 z 轴向量，获取一个指向摄像机的正 y 轴向量就相对简单了：我们把右向量和方向向量进行叉乘：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span>vec3 cameraUp <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">cross</span><span class="token punctuation">(</span>cameraDirection<span class="token punctuation">,</span> cameraRight<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在叉乘和一些小技巧的帮助下，我们创建了所有构成观察 / 摄像机空间的向量。对于想学到更多数学原理的读者，提示一下，在线性代数中这个处理叫做<mark>格拉姆 — 施密特正交化</mark> (Gram-Schmidt Process)。使用这些摄像机向量我们就可以创建一个 LookAt 矩阵了，它在创建摄像机的时候非常有用。</p><h3 id="look-at"><a class="anchor" href="#look-at">#</a> Look At</h3><p>使用矩阵的好处之一是如果你使用 3 个相互垂直（或非线性）的轴定义了一个坐标空间，你可以用这 3 个轴外加一个平移向量来创建一个矩阵，并且你可以用这个矩阵乘以任何向量来将其变换到那个坐标空间。这正是 LookAt 矩阵所做的，现在我们有了 3 个相互垂直的轴和一个定义摄像机空间的位置坐标，我们可以创建我们自己的 LookAt 矩阵了：</p><pre><code class="language-math">LookAt=
\begin&#123;bmatrix&#125;
   R_x &amp; R_y  &amp; R_z  &amp; 0  \\
   U_x &amp; U_y  &amp; U_z  &amp; 0  \\
   D_x &amp; D_y  &amp; D_z  &amp; 0  \\
   0 &amp; 0  &amp; 0  &amp; 1  
\end&#123;bmatrix&#125;
*
\begin&#123;bmatrix&#125;
   1 &amp; 0  &amp; 0  &amp; -P_x  \\
   0 &amp; 1  &amp; 0  &amp; -P_y  \\
   0 &amp; 0  &amp; 1  &amp; -P_z  \\
   0 &amp; 0  &amp; 0  &amp; 1  
\end&#123;bmatrix&#125;
</code></pre><p>其中 R 是右向量 (<mark>X 轴</mark>)，U 是上向量 (<mark>Z 轴</mark>)，D 是方向向量 P 是摄像机位置向量。注意，位置向量是相反的，因为我们最终希望把世界平移到与我们自身移动的相反方向。把这个 LookAt 矩阵作为观察矩阵可以很高效地把所有世界坐标变换到刚刚定义的观察空间。LookAt 矩阵就像它的名字表达的那样：它会创建一个看着 (Look at) 给定目标的观察矩阵。</p><p>幸运的是，GLM 已经提供了这些支持。我们要做的只是定义一个摄像机位置，一个目标位置和一个表示世界空间中的上向量的向量（我们计算右向量使用的那个上向量）。接着 GLM 就会创建一个 LookAt 矩阵，我们可以把它当作我们的观察矩阵：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span>mat4 view<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>view <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">lookAt</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">3.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="3"></td><td><pre>           glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="4"></td><td><pre>           glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>glm::LookAt 函数需要一个<mark>位置</mark>、<mark>目标</mark>和<mark>上向量</mark>。它会创建一个和在上一节使用的一样的观察矩阵。</p><p>在讨论用户输入之前，我们先来做些有意思的事，把我们的摄像机在场景中旋转。我们会将摄像机的注视点保持在 (0, 0, 0)。</p><p>我们需要用到一点三角学的知识来在每一帧创建一个 x 和 z 坐标，它会代表圆上的一点，我们将会使用它作为摄像机的位置。通过重新计算 x 和 y 坐标，我们会遍历圆上的所有点，这样摄像机就会绕着场景旋转了。我们预先定义这个圆的半径 radius，在每次渲染迭代中使用 GLFW 的 glfwGetTime 函数重新创建观察矩阵，来扩大这个圆。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> radius <span class="token operator">=</span> <span class="token number">10.0f</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">float</span> camX <span class="token operator">=</span> <span class="token function">sin</span><span class="token punctuation">(</span><span class="token function">glfwGetTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> radius<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">float</span> camZ <span class="token operator">=</span> <span class="token function">cos</span><span class="token punctuation">(</span><span class="token function">glfwGetTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> radius<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>glm<span class="token operator">::</span>mat4 view<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>view <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">lookAt</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span>camX<span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> camZ<span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="自由移动"><a class="anchor" href="#自由移动">#</a> 自由移动</h3><p>让摄像机绕着场景转的确很有趣，但是让我们自己移动摄像机会更有趣！首先我们必须设置一个摄像机系统，所以在我们的程序前面定义一些摄像机变量很有用：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span>vec3 cameraPos   <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>  <span class="token number">3.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>glm<span class="token operator">::</span>vec3 cameraFront <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>glm<span class="token operator">::</span>vec3 cameraUp    <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span>  <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>LookAt 函数现在成了：</p><pre><code>view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);
</code></pre><p>我们首先将摄像机位置设置为之前定义的 cameraPos。方向是当前的位置加上我们刚刚定义的方向向量。这样能保证无论我们怎么移动，摄像机都会注视着目标方向。让我们摆弄一下这些向量，在按下某些按钮时更新 cameraPos 向量。</p><p>我们已经为 GLFW 的键盘输入定义过一个 processInput 函数了，我们来新添加几个需要检查的按键命令：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">processInput</span><span class="token punctuation">(</span>GLFWwindow <span class="token operator">*</span>window<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">float</span> cameraSpeed <span class="token operator">=</span> <span class="token number">0.05f</span><span class="token punctuation">;</span> <span class="token comment">// adjust accordingly</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">glfwGetKey</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> GLFW_KEY_W<span class="token punctuation">)</span> <span class="token operator">==</span> GLFW_PRESS<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        cameraPos <span class="token operator">+=</span> cameraSpeed <span class="token operator">*</span> cameraFront<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">glfwGetKey</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> GLFW_KEY_S<span class="token punctuation">)</span> <span class="token operator">==</span> GLFW_PRESS<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        cameraPos <span class="token operator">-=</span> cameraSpeed <span class="token operator">*</span> cameraFront<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">glfwGetKey</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> GLFW_KEY_A<span class="token punctuation">)</span> <span class="token operator">==</span> GLFW_PRESS<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        cameraPos <span class="token operator">-=</span> glm<span class="token operator">::</span><span class="token function">normalize</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">cross</span><span class="token punctuation">(</span>cameraFront<span class="token punctuation">,</span> cameraUp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> cameraSpeed<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">glfwGetKey</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> GLFW_KEY_D<span class="token punctuation">)</span> <span class="token operator">==</span> GLFW_PRESS<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        cameraPos <span class="token operator">+=</span> glm<span class="token operator">::</span><span class="token function">normalize</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">cross</span><span class="token punctuation">(</span>cameraFront<span class="token punctuation">,</span> cameraUp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> cameraSpeed<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>当我们按下 WASD 键的任意一个，摄像机的位置都会相应更新。如果我们希望向前或向后移动，我们就把位置向量加上或减去方向向量。如果我们希望向左右移动，我们使用叉乘来创建一个右向量 (Right Vector)，并沿着它相应移动就可以了。这样就创建了使用摄像机时熟悉的<mark>横移</mark> (Strafe) 效果。</p><p>注意，我们对右向量进行了标准化。如果我们没对这个向量进行标准化，最后的叉乘结果会根据 cameraFront 变量返回大小不同的向量。如果我们不对向量进行标准化，我们就得根据摄像机的朝向不同加速或减速移动了，但如果进行了标准化移动就是匀速的。</p><h3 id="移动速度"><a class="anchor" href="#移动速度">#</a> 移动速度</h3><p>目前我们的移动速度是个常量。理论上没什么问题，但是实际情况下根据处理器的能力不同，有些人可能会比其他人每秒绘制更多帧，也就是以更高的频率调用 processInput 函数。结果就是，根据配置的不同，有些人可能移动很快，而有些人会移动很慢。当你发布你的程序的时候，你必须确保它在所有硬件上移动速度都一样。</p><p>图形程序和游戏通常会跟踪一个<mark>时间差</mark> (Deltatime) 变量，它储存了渲染上一帧所用的时间。我们把所有速度都去乘以 deltaTime 值。结果就是，如果我们的 deltaTime 很大，就意味着上一帧的渲染花费了更多时间，所以这一帧的速度需要变得更高来平衡渲染所花去的时间。使用这种方法时，无论你的电脑快还是慢，摄像机的速度都会相应平衡，这样每个用户的体验就都一样了。</p><p>我们跟踪两个全局变量来计算出 deltaTime 值：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> deltaTime <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span> <span class="token comment">// 当前帧与上一帧的时间差</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">float</span> lastFrame <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span> <span class="token comment">// 上一帧的时间</span></pre></td></tr></table></figure><p>在每一帧中我们计算出新的 deltaTime 以备后用。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> currentFrame <span class="token operator">=</span> <span class="token function">glfwGetTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>deltaTime <span class="token operator">=</span> currentFrame <span class="token operator">-</span> lastFrame<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>lastFrame <span class="token operator">=</span> currentFrame<span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="视角移动"><a class="anchor" href="#视角移动">#</a> 视角移动</h3><p>只用键盘移动没什么意思。特别是我们还不能转向，移动很受限制。是时候加入鼠标了！</p><p>为了能够改变视角，我们需要根据鼠标的输入改变 cameraFront 向量。然而，根据鼠标移动改变方向向量有点复杂，需要一些三角学知识。如果你对三角学知之甚少，别担心，你可以跳过这一部分，直接复制粘贴我们的代码；当你想了解更多的时候再回来看。</p><h3 id="欧拉角"><a class="anchor" href="#欧拉角">#</a> 欧拉角</h3><p>欧拉角 (Euler Angle) 是可以表示 3D 空间中任何旋转的 3 个值，由莱昂哈德・欧拉 (Leonhard Euler) 在 18 世纪提出。一共有 3 种欧拉角：<mark>俯仰角</mark> (Pitch)、<mark>偏航角</mark> (Yaw) 和<mark>滚转角</mark> (Roll)，下面的图片展示了它们的含义：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/09/camera_pitch_yaw_roll.png" alt="image"></p><p><mark>俯仰角</mark>是描述我们如何往<mark>上或往下看</mark>的角，可以在第一张图中看到。第二张图展示了<mark>偏航角</mark>，偏航角表示我们<mark>往左和往右看</mark>的程度。<mark>滚转角</mark>代表我们如何<mark>翻滚摄像机</mark>，通常在太空飞船的摄像机中使用。每个欧拉角都有一个值来表示，把三个角结合起来我们就能够计算 3D 空间中任何的旋转向量了。</p><p>对于我们的摄像机系统来说，我们只关心俯仰角和偏航角，所以我们不会讨论滚转角。给定一个俯仰角和偏航角，我们可以把它们转换为一个代表新的方向向量的 3D 向量。俯仰角和偏航角转换为方向向量的处理需要一些三角学知识，我们先从最基本的情况开始：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/09/camera_triangle.png" alt="image"></p><p>如果我们把斜边边长定义为 1，我们就能知道邻边的长度是 cos x/h=cos x/1=cos x，它的对边是 sin y/h=sin y/1=sin y。这样我们获得了能够得到 x 和 y 方向长度的通用公式，它们取决于所给的角度。我们使用它来计算方向向量的分量：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/09/camera_pitch.png" alt="image"></p><p>这个三角形看起来和前面的三角形很像，所以如果我们想象自己在 xz 平面上，看向 y 轴，我们可以基于第一个三角形计算来计算它的长度 /y 方向的强度 (Strength)（我们往上或往下看多少）。从图中我们可以看到对于一个给定俯仰角的 y 值等于 sin θ：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>direction<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token function">sin</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">radians</span><span class="token punctuation">(</span>pitch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注意我们先把角度转为弧度</span></pre></td></tr></table></figure><p>这里我们只更新了 y 值，仔细观察 x 和 z 分量也被影响了。从三角形中我们可以看到它们的值等于：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>direction<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token function">cos</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">radians</span><span class="token punctuation">(</span>pitch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>direction<span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token function">cos</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">radians</span><span class="token punctuation">(</span>pitch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>看看我们是否能够为偏航角找到需要的分量：</p><p><img data-src="https://learnopengl-cn.github.io/img/01/09/camera_yaw.png" alt="image"></p><p>就像俯仰角的三角形一样，我们可以看到 x 分量取决于 cos (yaw) 的值，z 值同样取决于偏航角的正弦值。把这个加到前面的值中，会得到基于俯仰角和偏航角的方向向量：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>direction<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token function">cos</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">radians</span><span class="token punctuation">(</span>pitch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">cos</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">radians</span><span class="token punctuation">(</span>yaw<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 译注：direction 代表摄像机的前轴 (Front)，这个前轴是和本文第一幅图片的第二个摄像机的方向向量是相反的</span></pre></td></tr><tr><td data-num="2"></td><td><pre>direction<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token function">sin</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">radians</span><span class="token punctuation">(</span>pitch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>direction<span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token function">cos</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">radians</span><span class="token punctuation">(</span>pitch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">sin</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">radians</span><span class="token punctuation">(</span>yaw<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这样我们就有了一个可以把俯仰角和偏航角转化为用来自由旋转视角的摄像机的 3 维方向向量了。你可能会奇怪：我们怎么得到俯仰角和偏航角？</p><h3 id="鼠标输入"><a class="anchor" href="#鼠标输入">#</a> 鼠标输入</h3><p>偏航角和俯仰角是通过鼠标（或手柄）移动获得的，水平的移动影响偏航角，竖直的移动影响俯仰角。它的原理就是，储存上一帧鼠标的位置，在当前帧中我们当前计算鼠标位置与上一帧的位置相差多少。如果水平 / 竖直差别越大那么俯仰角或偏航角就改变越大，也就是摄像机需要移动更多的距离。</p><p>首先我们要告诉 GLFW，它应该隐藏光标，并捕捉 (Capture) 它。捕捉光标表示的是，如果焦点在你的程序上（译注：即表示你正在操作这个程序，Windows 中拥有焦点的程序标题栏通常是有颜色的那个，而失去焦点的程序标题栏则是灰色的），光标应该停留在窗口中（除非程序失去焦点或者退出）。我们可以用一个简单地配置调用来完成：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glfwSetInputMode</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> GLFW_CURSOR<span class="token punctuation">,</span> GLFW_CURSOR_DISABLED<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在调用这个函数之后，无论我们怎么去移动鼠标，光标都不会显示了，它也不会离开窗口。对于 FPS 摄像机系统来说非常完美。</p><p>为了计算俯仰角和偏航角，我们需要让 GLFW<mark> 监听鼠标移动事件 (mouse_callback)</mark>。（和键盘输入相似）我们会用一个回调函数来完成，函数的原型如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">mouse_callback</span><span class="token punctuation">(</span>GLFWwindow<span class="token operator">*</span> window<span class="token punctuation">,</span> <span class="token keyword">double</span> xpos<span class="token punctuation">,</span> <span class="token keyword">double</span> ypos<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这里的 xpos 和 ypos 代表当前鼠标的位置。当我们用 GLFW 注册了回调函数之后，鼠标一移动<mark> mouse_callback</mark> 函数就会被调用：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glfwSetCursorPosCallback</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> mouse_callback<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在处理 FPS 风格摄像机的鼠标输入的时候，我们必须在最终获取方向向量之前做下面这几步：</p><ul><li>计算鼠标距上一帧的<mark>偏移量</mark>。</li><li>把偏移量添加到<mark>摄像机的俯仰角</mark>和<mark>偏航角</mark>中。</li><li>对偏航角和俯仰角进行<mark>最大</mark>和<mark>最小值</mark>的<mark>限制</mark>。</li><li>计算<mark>方向向量</mark>。</li></ul><p>第一步是计算鼠标自上一帧的偏移量。我们必须先在程序中储存上一帧的鼠标位置，我们把它的初始值设置为屏幕的中心（屏幕的尺寸是 800x600）：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> lastX <span class="token operator">=</span> <span class="token number">400</span><span class="token punctuation">,</span> lastY <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>然后在鼠标的回调函数中我们计算当前帧和上一帧鼠标位置的偏移量：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> xoffset <span class="token operator">=</span> xpos <span class="token operator">-</span> lastX<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">float</span> yoffset <span class="token operator">=</span> lastY <span class="token operator">-</span> ypos<span class="token punctuation">;</span> <span class="token comment">// 注意这里是相反的，因为 y 坐标是从底部往顶部依次增大的</span></pre></td></tr><tr><td data-num="3"></td><td><pre>lastX <span class="token operator">=</span> xpos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>lastY <span class="token operator">=</span> ypos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">float</span> sensitivity <span class="token operator">=</span> <span class="token number">0.05f</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>xoffset <span class="token operator">*=</span> sensitivity<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>yoffset <span class="token operator">*=</span> sensitivity<span class="token punctuation">;</span></pre></td></tr></table></figure><p>注意我们把偏移量乘以了 sensitivity（灵敏度）值。如果我们忽略这个值，鼠标移动就会太大了；你可以自己实验一下，找到适合自己的灵敏度值。</p><p>接下来我们把偏移量加到全局变量 pitch 和 yaw 上：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>yaw   <span class="token operator">+=</span> xoffset<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>pitch <span class="token operator">+=</span> yoffset<span class="token punctuation">;</span></pre></td></tr></table></figure><p>第三步，我们需要给摄像机添加一些限制，这样摄像机就不会发生奇怪的移动了（这样也会避免一些奇怪的问题）。对于俯仰角，要让用户不能看向高于 89 度的地方（在 90 度时视角会发生逆转，所以我们把 89 度作为极限），同样也不允许小于 - 89 度。这样能够保证用户只能看到天空或脚下，但是不能超越这个限制。我们可以在值超过限制的时候将其改为极限值来实现：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span>pitch <span class="token operator">></span> <span class="token number">89.0f</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  pitch <span class="token operator">=</span>  <span class="token number">89.0f</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span>pitch <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">89.0f</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  pitch <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">89.0f</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>注意我们没有给偏航角设置限制，这是因为我们不希望限制用户的水平旋转。当然，给偏航角设置限制也很容易，如果你愿意可以自己实现。</p><p>第四也是最后一步，就是通过俯仰角和偏航角来计算以得到真正的方向向量：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span>vec3 front<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>front<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token function">cos</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">radians</span><span class="token punctuation">(</span>pitch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">cos</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">radians</span><span class="token punctuation">(</span>yaw<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>front<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token function">sin</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">radians</span><span class="token punctuation">(</span>pitch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>front<span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token function">cos</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">radians</span><span class="token punctuation">(</span>pitch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">sin</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">radians</span><span class="token punctuation">(</span>yaw<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>cameraFront <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">normalize</span><span class="token punctuation">(</span>front<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>计算出来的方向向量就会包含根据鼠标移动计算出来的所有旋转了。由于 cameraFront 向量已经包含在 GLM 的 lookAt 函数中，我们这就没什么问题了。</p><p>如果你现在运行代码，你会发现在窗口第一次获取焦点的时候摄像机会突然跳一下。这个问题产生的原因是，在你的鼠标移动进窗口的那一刻，鼠标回调函数就会被调用，这时候的 xpos 和 ypos 会等于鼠标刚刚进入屏幕的那个位置。这通常是一个距离屏幕中心很远的地方，因而产生一个很大的偏移量，所以就会跳了。我们可以简单的使用一个 bool 变量检验我们是否是第一次获取鼠标输入，如果是，那么我们先把鼠标的初始位置更新为 xpos 和 ypos 值，这样就能解决这个问题；接下来的鼠标移动就会使用刚进入的鼠标位置坐标来计算偏移量了：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span>firstMouse<span class="token punctuation">)</span> <span class="token comment">// 这个 bool 变量初始时是设定为 true 的</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    lastX <span class="token operator">=</span> xpos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    lastY <span class="token operator">=</span> ypos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    firstMouse <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>最后的代码应该是这样的：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">mouse_callback</span><span class="token punctuation">(</span>GLFWwindow<span class="token operator">*</span> window<span class="token punctuation">,</span> <span class="token keyword">double</span> xpos<span class="token punctuation">,</span> <span class="token keyword">double</span> ypos<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>firstMouse<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        lastX <span class="token operator">=</span> xpos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        lastY <span class="token operator">=</span> ypos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        firstMouse <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">float</span> xoffset <span class="token operator">=</span> xpos <span class="token operator">-</span> lastX<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">float</span> yoffset <span class="token operator">=</span> lastY <span class="token operator">-</span> ypos<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre>    lastX <span class="token operator">=</span> xpos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    lastY <span class="token operator">=</span> ypos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">float</span> sensitivity <span class="token operator">=</span> <span class="token number">0.05</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    xoffset <span class="token operator">*=</span> sensitivity<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    yoffset <span class="token operator">*=</span> sensitivity<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>    yaw   <span class="token operator">+=</span> xoffset<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    pitch <span class="token operator">+=</span> yoffset<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>pitch <span class="token operator">></span> <span class="token number">89.0f</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        pitch <span class="token operator">=</span> <span class="token number">89.0f</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>pitch <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">89.0f</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        pitch <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">89.0f</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre>    glm<span class="token operator">::</span>vec3 front<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    front<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token function">cos</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">radians</span><span class="token punctuation">(</span>yaw<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">cos</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">radians</span><span class="token punctuation">(</span>pitch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    front<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token function">sin</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">radians</span><span class="token punctuation">(</span>pitch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    front<span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token function">sin</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">radians</span><span class="token punctuation">(</span>yaw<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">cos</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">radians</span><span class="token punctuation">(</span>pitch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    cameraFront <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">normalize</span><span class="token punctuation">(</span>front<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="缩放-2"><a class="anchor" href="#缩放-2">#</a> 缩放</h3><p>作为我们摄像机系统的一个附加内容，我们还会来实现一个缩放 (Zoom) 接口。在之前的教程中我们说视野 (Field of View) 或 fov 定义了我们可以看到场景中多大的范围。当视野变小时，场景投影出来的空间就会减小，产生放大 (Zoom In) 了的感觉。我们会使用鼠标的滚轮来放大。与鼠标移动、键盘输入一样，我们需要一个鼠标滚轮的回调函数：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">scroll_callback</span><span class="token punctuation">(</span>GLFWwindow<span class="token operator">*</span> window<span class="token punctuation">,</span> <span class="token keyword">double</span> xoffset<span class="token punctuation">,</span> <span class="token keyword">double</span> yoffset<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">if</span><span class="token punctuation">(</span>fov <span class="token operator">>=</span> <span class="token number">1.0f</span> <span class="token operator">&amp;&amp;</span> fov <span class="token operator">&lt;=</span> <span class="token number">45.0f</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    fov <span class="token operator">-=</span> yoffset<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">if</span><span class="token punctuation">(</span>fov <span class="token operator">&lt;=</span> <span class="token number">1.0f</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    fov <span class="token operator">=</span> <span class="token number">1.0f</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">if</span><span class="token punctuation">(</span>fov <span class="token operator">>=</span> <span class="token number">45.0f</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    fov <span class="token operator">=</span> <span class="token number">45.0f</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>当滚动鼠标滚轮的时候，yoffset 值代表我们竖直滚动的大小。当 scroll_callback 函数被调用后，我们改变全局变量 fov 变量的内容。因为 45.0f 是默认的视野值，我们将会把缩放级别 (Zoom Level) 限制在 1.0f 到 45.0f。</p><p>我们现在在每一帧都必须把透视投影矩阵上传到 GPU，但现在使用 fov 变量作为它的视野：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>projection <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">perspective</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">radians</span><span class="token punctuation">(</span>fov<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">800.0f</span> <span class="token operator">/</span> <span class="token number">600.0f</span><span class="token punctuation">,</span> <span class="token number">0.1f</span><span class="token punctuation">,</span> <span class="token number">100.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>最后不要忘记注册鼠标滚轮的回调函数：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glfwSetScrollCallback</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> scroll_callback<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>注意，使用欧拉角的摄像机系统并不完美。根据你的视角限制或者是配置，你仍然可能引入<mark>万向节死锁</mark>问题。最好的摄像机系统是使用<mark>四元数</mark> (Quaternions) 的，但我们将会把这个留到后面讨论。（译注：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N5YmVyY3Nlci9PcGVuR0xfM18zX1R1dG9yaWFsX1RyYW5zbGF0aW9uL2Jsb2IvbWFzdGVyL1R1dG9yaWFsJTIwMTclMjBSb3RhdGlvbnMubWQ=">这里可以查看四元数摄像机的实现</span>）</p></blockquote><h3 id="摄像机类"><a class="anchor" href="#摄像机类">#</a> 摄像机类</h3><p>接下来的教程中，我们将会一直使用一个摄像机来浏览场景，从各个角度观察结果。然而，由于一个摄像机会占用每篇教程很大的篇幅，我们将会从细节抽象出来，创建我们自己的摄像机对象，它会完成大多数的工作，而且还会提供一些附加的功能。与着色器教程不同，我们不会带你一步一步创建摄像机类，我们只会提供你一份（有完整注释的）代码，如果你想知道它的内部构造的话可以自己去阅读。</p><p>和着色器对象一样，我们把摄像机类写在一个单独的头文件中。<span class="exturl" data-url="aHR0cHM6Ly9sZWFybm9wZW5nbC5jb20vY29kZV92aWV3ZXJfZ2gucGhwP2NvZGU9aW5jbHVkZXMvbGVhcm5vcGVuZ2wvY2FtZXJhLmg=">你可以在这里找到它</span>，你现在应该能够理解所有的代码了。我们建议您至少看一看这个类，看看如何创建一个自己的摄像机类。</p><blockquote><p>注意 glm 矩阵中第一个下标是列，第二个下标才是行。即：</p></blockquote><pre><code>rotation[0][0] = xaxis.x; // 第一列，第一行
rotation[0][2] = zaxis.x; // 第一列，第三行
</code></pre><h2 id="复习"><a class="anchor" href="#复习">#</a> 复习</h2><h3 id="词汇表"><a class="anchor" href="#词汇表">#</a> 词汇表</h3><ul><li><strong>OpenGL</strong>： 一个定义了函数布局和输出的图形 API 的正式规范。</li><li><strong>GLAD</strong>： 一个拓展加载库，用来为我们加载并设定所有 OpenGL 函数指针，从而让我们能够使用所有（现代）OpenGL 函数。</li><li><strong>视口 (Viewport)</strong>： 我们需要渲染的窗口。</li><li><strong>图形管线 (Graphics Pipeline)</strong>： 一个顶点在呈现为像素之前经过的全部过程。</li><li><strong>着色器 (Shader)</strong>： 一个运行在显卡上的小型程序。很多阶段的图形管道都可以使用自定义的着色器来代替原有的功能。</li><li><strong>标准化设备坐标 (Normalized Device Coordinates, NDC)</strong>： 顶点在通过在剪裁坐标系中剪裁与透视除法后最终呈现在的坐标系。所有位置在 NDC 下 - 1.0 到 1.0 的顶点将不会被丢弃并且可见。</li><li><strong>顶点缓冲对象 (Vertex Buffer Object)</strong>： 一个调用显存并存储所有顶点数据供显卡使用的缓冲对象。</li><li><strong>顶点数组对象 (Vertex Array Object)</strong>： 存储缓冲区和顶点属性状态。</li><li><strong>索引缓冲对象 (Element Buffer Object)</strong>： 一个存储索引供索引化绘制使用的缓冲对象。</li><li><strong>Uniform</strong>： 一个特殊类型的 GLSL 变量。它是全局的（在一个着色器程序中每一个着色器都能够访问 uniform 变量），并且只需要被设定一次。</li><li><strong>纹理 (Texture)</strong>： 一种包裹着物体的特殊类型图像，给物体精细的视觉效果。</li><li><strong>纹理缠绕 (Texture Wrapping)</strong>： 定义了一种当纹理顶点超出范围 (0, 1) 时指定 OpenGL 如何采样纹理的模式。</li><li><strong>纹理过滤 (Texture Filtering)</strong>： 定义了一种当有多种纹素选择时指定 OpenGL 如何采样纹理的模式。这通常在纹理被放大情况下发生。</li><li><strong>多级渐远纹理 (Mipmaps)</strong>： 被存储的材质的一些缩小版本，根据距观察者的距离会使用材质的合适大小。</li><li><strong>stb_image.h</strong>： 图像加载库。</li><li><strong>纹理单元 (Texture Units)</strong>： 通过绑定纹理到不同纹理单元从而允许多个纹理在同一对象上渲染。</li><li><strong>向量 (Vector)</strong>： 一个定义了在空间中方向和 / 或位置的数学实体。</li><li><strong>矩阵 (Matrix)</strong>： 一个矩形阵列的数学表达式。</li><li><strong>GLM</strong>： 一个为 OpenGL 打造的数学库。</li><li><strong>局部空间 (Local Space)</strong>： 一个物体的初始空间。所有的坐标都是相对于物体的原点的。</li><li><strong>世界空间 (World Space)</strong>： 所有的坐标都相对于全局原点。</li><li><strong>观察空间 (View Space)</strong>： 所有的坐标都是从摄像机的视角观察的。</li><li><strong>裁剪空间 (Clip Space)</strong>： 所有的坐标都是从摄像机视角观察的，但是该空间应用了投影。这个空间应该是一个顶点坐标最终的空间，作为顶点着色器的输出。OpenGL 负责处理剩下的事情（裁剪 / 透视除法）。</li><li><strong>屏幕空间 (Screen Space)</strong>： 所有的坐标都由屏幕视角来观察。坐标的范围是从 0 到屏幕的宽 / 高。</li><li><strong>LookAt 矩阵</strong>： 一种特殊类型的观察矩阵，它创建了一个坐标系，其中所有坐标都根据从一个位置正在观察目标的用户旋转或者平移。</li><li><strong>欧拉角 (Euler Angles)</strong>： 被定义为偏航角 (Yaw)，俯仰角 (Pitch)，和滚转角 (Roll) 从而允许我们通过这三个值构造任何 3D 方向。</li></ul></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2020-09-19 18:43:06" itemprop="dateModified" datetime="2020-09-19T18:43:06+08:00">2020-09-19</time> </span><span id="computer-science/study/opengl/一、OpenGL入门/" class="item leancloud_visitors" data-flag-title="一、OpenGL入门" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Allen guo 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Allen guo 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="Allen guo 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Allen guo <i class="ic i-at"><em>@</em></i>鑫酱</li><li class="link"><strong>本文链接：</strong> <a href="https://allengx.gitee.io/computer-science/study/opengl/%E4%B8%80%E3%80%81OpenGL%E5%85%A5%E9%97%A8/" title="一、OpenGL入门">https://allengx.gitee.io/computer-science/study/opengl/一、OpenGL入门/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="nav"><div class="item left"><a href="/computer-science/study/opengl/%E4%BA%94%E3%80%81%E9%AB%98%E7%BA%A7%E5%85%89%E7%85%A7/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclh3brzpj20zk0m8ann.jpg" title="五、高级光照"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> OpenGL</span><h3>五、高级光照</h3></a></div><div class="item right"><a href="/computer-science/study/opengl/%E4%BA%8C%E3%80%81OpenGL%E5%85%89%E7%85%A7/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipexw3o58j20zk0m8e81.jpg" title="二、OpenGL光照"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> OpenGL</span><h3>二、OpenGL光照</h3></a></div></div><div class="wrap" id="comments" data-id="computer-science/study/opengl/一、OpenGL入门/"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">1.</span> <span class="toc-text">环境搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">1.1.</span> <span class="toc-text">状态机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%A6%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">简要工作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#opengl%E5%92%8Cglfw"><span class="toc-number">1.3.</span> <span class="toc-text">OpenGL 和 GLFW</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#glad"><span class="toc-number">1.4.</span> <span class="toc-text">GLAD</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#introduction"><span class="toc-number">2.</span> <span class="toc-text">introduction</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#hello-window"><span class="toc-number">2.1.</span> <span class="toc-text">Hello Window</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.1.1.</span> <span class="toc-text">渲染循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E7%BC%93%E5%86%B2double-buffer"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">双缓冲 (Double Buffer)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90"><span class="toc-number">2.1.2.</span> <span class="toc-text">释放资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5"><span class="toc-number">2.1.3.</span> <span class="toc-text">输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93"><span class="toc-number">2.1.4.</span> <span class="toc-text">渲染</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hello-triangle"><span class="toc-number">2.2.</span> <span class="toc-text">Hello Triangle</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8opengl%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E7%89%87%E6%AE%B5%E6%98%AFopengl%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E5%83%8F%E7%B4%A0%E6%89%80%E9%9C%80%E7%9A%84%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE"><span class="toc-number">2.2.0.0.1.</span> <span class="toc-text">注：OpenGL 中的一个片段是 OpenGL 渲染一个像素所需的所有数据。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5"><span class="toc-number">2.2.1.</span> <span class="toc-text">顶点输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">2.2.2.</span> <span class="toc-text">顶点着色器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E9%87%8Fvector"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">向量 (Vector)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">2.2.3.</span> <span class="toc-text">编译着色器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%87%E6%AE%B5%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">2.2.4.</span> <span class="toc-text">片段着色器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">着色器程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E9%A1%B6%E7%82%B9%E5%B1%9E%E6%80%A7"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">链接顶点属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.4.3.</span> <span class="toc-text">顶点数组对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%91%E4%BB%AC%E4%B8%80%E7%9B%B4%E6%9C%9F%E5%BE%85%E7%9A%84%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-number">2.2.5.</span> <span class="toc-text">我们一直期待的三角形</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.5.1.</span> <span class="toc-text">索引缓冲对象</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">2.3.</span> <span class="toc-text">着色器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8%E8%AF%AD%E8%A8%80glsl"><span class="toc-number">2.3.1.</span> <span class="toc-text">着色器语言 GLSL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.2.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E9%87%8F"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">向量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">输入与输出</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8-2"><span class="toc-number">2.3.2.2.1.</span> <span class="toc-text">顶点着色器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%87%E6%AE%B5%E7%9D%80%E8%89%B2%E5%99%A8-2"><span class="toc-number">2.3.2.2.2.</span> <span class="toc-text">片段着色器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniform"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">Uniform</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E5%B1%9E%E6%80%A7"><span class="toc-number">2.3.3.</span> <span class="toc-text">更多属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%91%E4%BB%AC%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9D%80%E8%89%B2%E5%99%A8%E7%B1%BB"><span class="toc-number">2.3.4.</span> <span class="toc-text">我们自己的着色器类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96"><span class="toc-number">2.3.5.</span> <span class="toc-text">从文件读取</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%B9%E7%90%86"><span class="toc-number">2.4.</span> <span class="toc-text">纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%B9%E7%90%86%E7%8E%AF%E7%BB%95%E6%96%B9%E5%BC%8F"><span class="toc-number">2.4.1.</span> <span class="toc-text">纹理环绕方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%B9%E7%90%86%E8%BF%87%E6%BB%A4"><span class="toc-number">2.4.2.</span> <span class="toc-text">纹理过滤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E6%B8%90%E8%BF%9C%E7%BA%B9%E7%90%86"><span class="toc-number">2.4.3.</span> <span class="toc-text">多级渐远纹理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%88%9B%E5%BB%BA%E7%BA%B9%E7%90%86"><span class="toc-number">2.4.4.</span> <span class="toc-text">加载与创建纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#stb_imageh"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">stb_image.h</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E7%BA%B9%E7%90%86"><span class="toc-number">2.4.5.</span> <span class="toc-text">生成纹理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%BA%B9%E7%90%86"><span class="toc-number">2.4.6.</span> <span class="toc-text">应用纹理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%B9%E7%90%86%E5%8D%95%E5%85%83"><span class="toc-number">2.4.7.</span> <span class="toc-text">纹理单元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E6%8D%A2"><span class="toc-number">2.5.</span> <span class="toc-text">变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E9%87%8F-2"><span class="toc-number">2.5.1.</span> <span class="toc-text">向量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E4%B8%8E%E6%A0%87%E9%87%8F%E8%BF%90%E7%AE%97"><span class="toc-number">2.5.2.</span> <span class="toc-text">向量与标量运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E5%8A%A0%E5%87%8F"><span class="toc-number">2.5.3.</span> <span class="toc-text">向量加减</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E5%BA%A6"><span class="toc-number">2.5.4.</span> <span class="toc-text">长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E7%9B%B8%E4%B9%98"><span class="toc-number">2.5.5.</span> <span class="toc-text">向量相乘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E4%B9%98"><span class="toc-number">2.5.6.</span> <span class="toc-text">点乘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%89%E4%B9%98"><span class="toc-number">2.5.7.</span> <span class="toc-text">叉乘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5"><span class="toc-number">2.5.8.</span> <span class="toc-text">矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E7%9A%84%E6%95%B0%E4%B9%98"><span class="toc-number">2.5.9.</span> <span class="toc-text">矩阵的数乘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%B9%98"><span class="toc-number">2.5.10.</span> <span class="toc-text">矩阵相乘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E4%B8%8E%E5%90%91%E9%87%8F%E7%9B%B8%E4%B9%98"><span class="toc-number">2.5.11.</span> <span class="toc-text">矩阵与向量相乘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BD%8D%E7%9F%A9%E9%98%B5"><span class="toc-number">2.5.12.</span> <span class="toc-text">单位矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%A9%E6%94%BE"><span class="toc-number">2.5.13.</span> <span class="toc-text">缩放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E7%A7%BB"><span class="toc-number">2.5.14.</span> <span class="toc-text">位移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC"><span class="toc-number">2.5.15.</span> <span class="toc-text">旋转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E7%9A%84%E7%BB%84%E5%90%88"><span class="toc-number">2.5.16.</span> <span class="toc-text">矩阵的组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5"><span class="toc-number">2.5.17.</span> <span class="toc-text">实践</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#glm"><span class="toc-number">2.5.18.</span> <span class="toc-text">GLM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.6.</span> <span class="toc-text">坐标系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.6.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">2.6.2.</span> <span class="toc-text">局部空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%96%E7%95%8C%E7%A9%BA%E9%97%B4"><span class="toc-number">2.6.3.</span> <span class="toc-text">世界空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E7%A9%BA%E9%97%B4"><span class="toc-number">2.6.4.</span> <span class="toc-text">观察空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%81%E5%89%AA%E7%A9%BA%E9%97%B4"><span class="toc-number">2.6.5.</span> <span class="toc-text">裁剪空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%B0%84%E6%8A%95%E5%BD%B1"><span class="toc-number">2.6.6.</span> <span class="toc-text">正射投影</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1"><span class="toc-number">2.6.7.</span> <span class="toc-text">透视投影</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%8A%E5%AE%83%E4%BB%AC%E9%83%BD%E7%BB%84%E5%90%88%E5%88%B0%E4%B8%80%E8%B5%B7"><span class="toc-number">2.6.8.</span> <span class="toc-text">把它们都组合到一起</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%85%A53d"><span class="toc-number">2.6.9.</span> <span class="toc-text">进入 3D</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E7%9A%843d"><span class="toc-number">2.6.10.</span> <span class="toc-text">更多的 3D</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#z%E7%BC%93%E5%86%B2"><span class="toc-number">2.6.11.</span> <span class="toc-text">Z 缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E7%9A%84%E7%AB%8B%E6%96%B9%E4%BD%93"><span class="toc-number">2.6.12.</span> <span class="toc-text">更多的立方体！</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%91%84%E5%83%8F%E6%9C%BA"><span class="toc-number">2.7.</span> <span class="toc-text">摄像机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%91%84%E5%83%8F%E6%9C%BA%E8%A7%82%E5%AF%9F%E7%A9%BA%E9%97%B4"><span class="toc-number">2.7.1.</span> <span class="toc-text">摄像机 &#x2F; 观察空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%91%84%E5%83%8F%E6%9C%BA%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.7.2.</span> <span class="toc-text">1. 摄像机位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%91%84%E5%83%8F%E6%9C%BA%E6%96%B9%E5%90%91"><span class="toc-number">2.7.3.</span> <span class="toc-text">2. 摄像机方向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-x%E8%BD%B4"><span class="toc-number">2.7.4.</span> <span class="toc-text">3. X 轴</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-y%E8%BD%B4"><span class="toc-number">2.7.4.1.</span> <span class="toc-text">4. Y 轴</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#look-at"><span class="toc-number">2.7.5.</span> <span class="toc-text">Look At</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E7%94%B1%E7%A7%BB%E5%8A%A8"><span class="toc-number">2.7.6.</span> <span class="toc-text">自由移动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E9%80%9F%E5%BA%A6"><span class="toc-number">2.7.7.</span> <span class="toc-text">移动速度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E8%A7%92%E7%A7%BB%E5%8A%A8"><span class="toc-number">2.7.8.</span> <span class="toc-text">视角移动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E8%A7%92"><span class="toc-number">2.7.9.</span> <span class="toc-text">欧拉角</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E8%BE%93%E5%85%A5"><span class="toc-number">2.7.10.</span> <span class="toc-text">鼠标输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%A9%E6%94%BE-2"><span class="toc-number">2.7.11.</span> <span class="toc-text">缩放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%91%84%E5%83%8F%E6%9C%BA%E7%B1%BB"><span class="toc-number">2.7.12.</span> <span class="toc-text">摄像机类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E4%B9%A0"><span class="toc-number">2.8.</span> <span class="toc-text">复习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%8D%E6%B1%87%E8%A1%A8"><span class="toc-number">2.8.1.</span> <span class="toc-text">词汇表</span></a></li></ol></li></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/computer-science/study/opengl/%E4%B8%80%E3%80%81OpenGL%E5%85%A5%E9%97%A8/" rel="bookmark" title="一、OpenGL入门">一、OpenGL入门</a></li><li><a href="/computer-science/study/opengl/%E4%B8%89%E3%80%81OpenGL%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD/" rel="bookmark" title="三、OpenGL模型加载">三、OpenGL模型加载</a></li><li><a href="/computer-science/study/opengl/%E4%BA%8C%E3%80%81OpenGL%E5%85%89%E7%85%A7/" rel="bookmark" title="二、OpenGL光照">二、OpenGL光照</a></li><li><a href="/computer-science/study/opengl/%E4%BA%94%E3%80%81%E9%AB%98%E7%BA%A7%E5%85%89%E7%85%A7/" rel="bookmark" title="五、高级光照">五、高级光照</a></li><li><a href="/computer-science/study/opengl/%E5%9B%9B%E3%80%81%E9%AB%98%E7%BA%A7OpenGL/" rel="bookmark" title="四、高级OpenGL">四、高级OpenGL</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Allen guo" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Allen guo</p><div class="description" itemprop="description">你知道的太多了</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">20</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">10</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FsbGVuR1g=" title="https:&#x2F;&#x2F;github.com&#x2F;AllenGX"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTgwNTM4MjQy" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;80538242"><i class="ic i-cloud-music"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjE0MTM5MDcxNTNAcXEuY29t" title="mailto:1413907153@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>网址</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/computer-science/study/opengl/%E4%BA%94%E3%80%81%E9%AB%98%E7%BA%A7%E5%85%89%E7%85%A7/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/computer-science/study/opengl/%E4%BA%8C%E3%80%81OpenGL%E5%85%89%E7%85%A7/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Allen guo @ 个人博客</span></div><div><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">334k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">5:04</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"https://allengx.gitee.io/computer-science/study/opengl/%E4%B8%80%E3%80%81OpenGL%E5%85%A5%E9%97%A8/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 ${query} ，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return e===LOCAL.path}]}</script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/velocity-animate@1.5.2/velocity.min.js,npm/velocity-animate@1.5.2/velocity.ui.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.1.6"></script></body></html>