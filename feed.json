{
    "version": "https://jsonfeed.org/version/1",
    "title": "鑫酱",
    "subtitle": "笔记本",
    "icon": "https://allengx.gitee.io/images/favicon.ico",
    "description": "整天摸鱼，却妄想拯救世界的技术宅？",
    "home_page_url": "https://allengx.gitee.io",
    "items": [
        {
            "id": "https://allengx.gitee.io/computer-science/study/micro-service/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%BF%B0%E5%92%8C%E8%AE%BE%E8%AE%A1/",
            "url": "https://allengx.gitee.io/computer-science/study/micro-service/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%BF%B0%E5%92%8C%E8%AE%BE%E8%AE%A1/",
            "title": "微服务概述和设计",
            "date_published": "2020-04-12T12:46:25.000Z",
            "content_html": "<div class=\"note info\">\n<p>以下为个人学习笔记整理</p>\n</div>\n<h1 id=\"微服务基本理论\"><a class=\"anchor\" href=\"#微服务基本理论\">#</a> 微服务基本理论</h1>\n<h2 id=\"cap定理\"><a class=\"anchor\" href=\"#cap定理\">#</a> CAP 定理</h2>\n<ul>\n<li>C（一致性）：所有分布式系统的数据在同一时间段内，保持一致且最新。</li>\n<li>A（可用性）：集群中部分节点出现故障后，集群依旧可以提供正常的服务。</li>\n<li>P（分区容错性）：在通信时限内，系统如果无法达成数据一致性，那么就必须在 C 和 A 之间做出选择。</li>\n</ul>\n<p>三者同时只能满足其二（CP 或 AP）。</p>\n<h2 id=\"base理论\"><a class=\"anchor\" href=\"#base理论\">#</a> Base 理论</h2>\n<ul>\n<li>BA（基本可用）：分布式系统出现故障时，允许损失部分可用性，保证核心功能可用。</li>\n<li>S（软状态）：允许系统存在中间状态，不会影响系统整体可用。</li>\n<li>E（最终一致性）：所有数据经过一段时间后可以最终达到一致</li>\n</ul>\n<h2 id=\"高并发\"><a class=\"anchor\" href=\"#高并发\">#</a> 高并发</h2>\n<p>同时并行处理多个请求，相应的考察指标有：</p>\n<ul>\n<li>响应时间：一次请求发起到得到响应所需时间。</li>\n<li>吞吐量：单位之间内处理的请求数量。</li>\n<li>每秒查询率：和吞吐量类似。</li>\n<li>并发用户数：同时能够承载的正常用户数量。</li>\n</ul>\n<p>针对提高高并发的处理办法：</p>\n<ul>\n<li>垂直扩展：提升单机的处理能力。升级机器配置或者提高单机架构性能。</li>\n<li>水平扩展：增加服务器数量。\n<ul>\n<li>数据库进行拆分：分表、分库、表分区</li>\n</ul>\n</li>\n<li>负载均衡</li>\n<li>集群</li>\n</ul>\n<h2 id=\"高性能\"><a class=\"anchor\" href=\"#高性能\">#</a> 高性能</h2>\n<ul>\n<li>RPC 通讯</li>\n<li>SQL 优化</li>\n<li>Redis 缓存</li>\n<li>GC 优化</li>\n<li>link-pool（链接池）</li>\n</ul>\n<h2 id=\"高可用\"><a class=\"anchor\" href=\"#高可用\">#</a> 高可用</h2>\n<p>高可用要求服务一纸可用，需要解决如下几个问题：</p>\n<ul>\n<li>单点故障</li>\n<li>流量过载</li>\n<li>服务器更新</li>\n</ul>\n<p>解决思路参考：<a href=\"###%E8%A7%A3%E5%86%B3%E9%AB%98%E5%8F%AF%E7%94%A8%E9%97%AE%E9%A2%98\">Kubernetes 简介</a></p>\n<h2 id=\"linux磁盘扩容\"><a class=\"anchor\" href=\"#linux磁盘扩容\">#</a> Linux 磁盘扩容</h2>\n<ul>\n<li>LVM：通过逻辑卷实现对硬盘的扩容。把多个物理卷通过逻辑上的集合而视为一个整体来使用，从而达到扩容的效果</li>\n</ul>\n<h1 id=\"微服务的概述\"><a class=\"anchor\" href=\"#微服务的概述\">#</a> 微服务的概述</h1>\n<p>把一个大型的但应用程序拆分为多个微服务，每个服务业务可以独立的进行开发、管理和迭代。核心目的是对系统进行解耦，提供更加灵活的服务支持，实现分布式的系统开发。</p>\n<h2 id=\"ddd领域驱动设计\"><a class=\"anchor\" href=\"#ddd领域驱动设计\">#</a> DDD 领域驱动设计</h2>\n<p>pass</p>\n<h2 id=\"定义\"><a class=\"anchor\" href=\"#定义\">#</a> 定义</h2>\n<ul>\n<li>一系列的独立的服务共同组成的系统</li>\n<li>单独部署，泡在自己的进程中</li>\n<li>每个服务为独立的业务开发</li>\n<li>分布式管理</li>\n<li>非常强调隔离性</li>\n</ul>\n<h2 id=\"标准\"><a class=\"anchor\" href=\"#标准\">#</a> 标准</h2>\n<ul>\n<li>分布式服务组成的系统</li>\n<li>按照业务，而不是技术来划分组织</li>\n<li>强服务个体和弱通信（Smart endpoints and dumb pipes）</li>\n<li>自动化运维（DevOps）</li>\n<li>高度容错性</li>\n<li>快速演化和迭代</li>\n</ul>\n<h2 id=\"分布式常见问题\"><a class=\"anchor\" href=\"#分布式常见问题\">#</a> 分布式常见问题</h2>\n<ul>\n<li>客户端如何和多个服务进行通讯？</li>\n<li>服务之间如何通讯？</li>\n<li>服务如何管理？</li>\n<li>服务挂了如何解决？</li>\n</ul>\n<h3 id=\"客户端如何和多个服务进行通讯\"><a class=\"anchor\" href=\"#客户端如何和多个服务进行通讯\">#</a> 客户端如何和多个服务进行通讯</h3>\n<p>通过 API 网关，进行统一的调度</p>\n<h3 id=\"服务之间如何通讯\"><a class=\"anchor\" href=\"#服务之间如何通讯\">#</a> 服务之间如何通讯</h3>\n<ul>\n<li>同步（对内 RPC、对外 RESTFUL）\n<ul>\n<li>HTTP：\n<ul>\n<li>json 数据</li>\n<li>跨防火墙（json 字符串）</li>\n</ul>\n</li>\n<li>RPC：\n<ul>\n<li>传输效率高</li>\n<li>二进制数据，减少传输大小</li>\n<li>序列化、反序列化次数少</li>\n<li>不支持跨防火墙（二进制不支持）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>异步\n<ul>\n<li>消息队列</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"服务如何管理服务注册与发现\"><a class=\"anchor\" href=\"#服务如何管理服务注册与发现\">#</a> 服务如何管理 —— 服务注册与发现</h3>\n<p>服务启动后会向一个中心服务（服务中心）去注册 IP，客户端统一像服务中心去申请访问其他服务的 IP 地址</p>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200824154427085.png\" alt=\"image-20200824154427085\" /></p>\n<h3 id=\"服务挂了如何解决\"><a class=\"anchor\" href=\"#服务挂了如何解决\">#</a> 服务挂了如何解决</h3>\n<h4 id=\"网络本身不可靠\"><a class=\"anchor\" href=\"#网络本身不可靠\">#</a> 网络本身不可靠</h4>\n<ul>\n<li>重试机制</li>\n</ul>\n<h4 id=\"流量过大扛不住\"><a class=\"anchor\" href=\"#流量过大扛不住\">#</a> 流量过大扛不住</h4>\n<ul>\n<li>限流</li>\n<li>熔断机制</li>\n<li>负载均衡</li>\n<li>服务降级（本地缓存）</li>\n</ul>\n<h2 id=\"微服务设计模式\"><a class=\"anchor\" href=\"#微服务设计模式\">#</a> 微服务设计模式</h2>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200824160214121.png\" alt=\"image-20200824160214121\" /></p>\n<h4 id=\"常见的设计模式\"><a class=\"anchor\" href=\"#常见的设计模式\">#</a> 常见的设计模式：</h4>\n<h5 id=\"聚合器模式\"><a class=\"anchor\" href=\"#聚合器模式\">#</a> 聚合器模式：</h5>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200824160250721.png\" alt=\"image-20200824160250721\" /></p>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200824160530908.png\" alt=\"image-20200824160530908\" /></p>\n<p><strong>简述：</strong> Aggregator 发送一条请求到对应的 Service，并且获得返回结果后返回给客户端</p>\n<h5 id=\"代理模式\"><a class=\"anchor\" href=\"#代理模式\">#</a> 代理模式：</h5>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200824160405940.png\" alt=\"image-20200824160405940\" /></p>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200824160601695.png\" alt=\"image-20200824160601695\" /></p>\n<p>** 简述：**Proxy 发送一条请求到对应的 Service，由对应的 Service 返回结果给客户端</p>\n<h5 id=\"链式模式\"><a class=\"anchor\" href=\"#链式模式\">#</a> 链式模式：</h5>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200824161110611.png\" alt=\"image-20200824161110611\" /></p>\n<p>** 简述：**ServiceA -&gt; ServiceB -&gt; ServiceC，最终由 ServiceA 返回对应的结果给客户端</p>\n<h5 id=\"分支模式\"><a class=\"anchor\" href=\"#分支模式\">#</a> 分支模式：</h5>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200824161342759.png\" alt=\"image-20200824161342759\" /></p>\n<p><strong>简述：</strong> 和链式有点类似只不过这里可能是横向的调用</p>\n<pre><code>ServiceA -&gt; ServiceB\nServiceA -&gt; ServiceC\n...\n</code></pre>\n<h5 id=\"数据共享模式\"><a class=\"anchor\" href=\"#数据共享模式\">#</a> 数据共享模式：</h5>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200824161818179.png\" alt=\"image-20200824161818179\" /></p>\n<p>** 简述：** 多个服务之间共享一个缓存和数据库</p>\n<h5 id=\"异步消息传递模式\"><a class=\"anchor\" href=\"#异步消息传递模式\">#</a> 异步消息传递模式：</h5>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200824162102751.png\" alt=\"image-20200824162102751\" /></p>\n<p>** 简述：** 异步消息强调消息的异步性，再通讯过程中加入消息对列的方式来完成</p>\n<h2 id=\"微服务架构设计模式\"><a class=\"anchor\" href=\"#微服务架构设计模式\">#</a> 微服务架构设计模式</h2>\n<ul>\n<li>伸缩能力</li>\n<li>可用性</li>\n<li>健壮性</li>\n<li>弹性</li>\n<li>独立的匿名服务</li>\n<li>去中心化</li>\n<li>故障隔离</li>\n<li>自动供给</li>\n<li>通过 DevOps 实现持续交付</li>\n</ul>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200827201913354.png\" alt=\"image-20200827201913354\" /></p>\n<h3 id=\"拆分模式\"><a class=\"anchor\" href=\"#拆分模式\">#</a> 拆分模式</h3>\n<h4 id=\"根据业务拆分\"><a class=\"anchor\" href=\"#根据业务拆分\">#</a> 根据业务拆分</h4>\n<p>...</p>\n<h4 id=\"利用子领域拆分\"><a class=\"anchor\" href=\"#利用子领域拆分\">#</a> 利用子领域拆分</h4>\n<p>...</p>\n<h4 id=\"根据事务拆分\"><a class=\"anchor\" href=\"#根据事务拆分\">#</a> 根据事务拆分</h4>\n<p>...</p>\n<h4 id=\"扼杀者模式\"><a class=\"anchor\" href=\"#扼杀者模式\">#</a> 扼杀者模式</h4>\n<p>...</p>\n<h4 id=\"舱壁模式\"><a class=\"anchor\" href=\"#舱壁模式\">#</a> 舱壁模式</h4>\n<p>...</p>\n<h4 id=\"sidecar模式\"><a class=\"anchor\" href=\"#sidecar模式\">#</a> Sidecar 模式</h4>\n<p>...</p>\n<h3 id=\"集成模式\"><a class=\"anchor\" href=\"#集成模式\">#</a> 集成模式</h3>\n<h4 id=\"api-网关模式\"><a class=\"anchor\" href=\"#api-网关模式\">#</a> API 网关模式</h4>\n<h4 id=\"聚合模式\"><a class=\"anchor\" href=\"#聚合模式\">#</a> 聚合模式</h4>\n<h4 id=\"代理模式-2\"><a class=\"anchor\" href=\"#代理模式-2\">#</a> 代理模式</h4>\n<h4 id=\"路由网关模式\"><a class=\"anchor\" href=\"#路由网关模式\">#</a> 路由网关模式</h4>\n<h4 id=\"链式微服务模式\"><a class=\"anchor\" href=\"#链式微服务模式\">#</a> 链式微服务模式</h4>\n<h4 id=\"分支模式-2\"><a class=\"anchor\" href=\"#分支模式-2\">#</a> 分支模式</h4>\n<h4 id=\"客户端分解模式\"><a class=\"anchor\" href=\"#客户端分解模式\">#</a> 客户端分解模式</h4>\n<h3 id=\"数据库模式\"><a class=\"anchor\" href=\"#数据库模式\">#</a> 数据库模式</h3>\n<h4 id=\"服务独占数据库\"><a class=\"anchor\" href=\"#服务独占数据库\">#</a> 服务独占数据库</h4>\n<p>...</p>\n<h4 id=\"服务共享数据库\"><a class=\"anchor\" href=\"#服务共享数据库\">#</a> 服务共享数据库</h4>\n<p>...</p>\n<h4 id=\"命令查询隔离\"><a class=\"anchor\" href=\"#命令查询隔离\">#</a> 命令查询隔离</h4>\n<p>...</p>\n<h4 id=\"事件源模式\"><a class=\"anchor\" href=\"#事件源模式\">#</a> 事件源模式</h4>\n<p>...</p>\n<h4 id=\"saga模式\"><a class=\"anchor\" href=\"#saga模式\">#</a> Saga 模式</h4>\n<p>...</p>\n<h3 id=\"观察者模式\"><a class=\"anchor\" href=\"#观察者模式\">#</a> 观察者模式</h3>\n<h4 id=\"日志聚合\"><a class=\"anchor\" href=\"#日志聚合\">#</a> 日志聚合</h4>\n<p>...</p>\n<h4 id=\"性能指标\"><a class=\"anchor\" href=\"#性能指标\">#</a> 性能指标</h4>\n<p>...</p>\n<h4 id=\"分布式追踪\"><a class=\"anchor\" href=\"#分布式追踪\">#</a> 分布式追踪</h4>\n<p>...</p>\n<h4 id=\"健康检查\"><a class=\"anchor\" href=\"#健康检查\">#</a> 健康检查</h4>\n<p>...</p>\n<h3 id=\"跨领域模式\"><a class=\"anchor\" href=\"#跨领域模式\">#</a> 跨领域模式</h3>\n<h4 id=\"外部化配置\"><a class=\"anchor\" href=\"#外部化配置\">#</a> 外部化配置</h4>\n<p>...</p>\n<h4 id=\"服务发现模式\"><a class=\"anchor\" href=\"#服务发现模式\">#</a> 服务发现模式</h4>\n<p>...</p>\n<h4 id=\"熔断模式\"><a class=\"anchor\" href=\"#熔断模式\">#</a> 熔断模式</h4>\n<p>...</p>\n<h4 id=\"蓝绿部署模式\"><a class=\"anchor\" href=\"#蓝绿部署模式\">#</a> 蓝绿部署模式</h4>\n<p>...</p>\n<h2 id=\"如何拆分微服务\"><a class=\"anchor\" href=\"#如何拆分微服务\">#</a> 如何拆分微服务</h2>\n<h3 id=\"拆分粒度\"><a class=\"anchor\" href=\"#拆分粒度\">#</a> 拆分粒度</h3>\n<p>...</p>\n",
            "tags": [
                "计算机科学",
                "学习笔记",
                "微服务",
                "微服务"
            ]
        },
        {
            "id": "https://allengx.gitee.io/computer-science/study/redis/%E4%B8%80%E3%80%81redis%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/",
            "url": "https://allengx.gitee.io/computer-science/study/redis/%E4%B8%80%E3%80%81redis%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/",
            "title": "一、redis新手入门",
            "date_published": "2020-04-12T12:46:25.000Z",
            "content_html": "<div class=\"note info\">\n<p>以下为个人学习笔记整理</p>\n</div>\n<h1 id=\"redis简介\"><a class=\"anchor\" href=\"#redis简介\">#</a> Redis 简介</h1>\n<h2 id=\"redis特点\"><a class=\"anchor\" href=\"#redis特点\">#</a> Redis 特点</h2>\n<ol>\n<li>非关系型数据库</li>\n<li>速度快</li>\n<li>key &amp; value（5 种类型） 形式\n<ol>\n<li>字符串</li>\n<li>列表</li>\n<li>集合</li>\n<li>散列表</li>\n<li>有序集合</li>\n</ol>\n</li>\n<li>使用<strong>复制特性</strong>扩展读性能</li>\n<li>使用<strong>客户端分片</strong>扩展写性能</li>\n</ol>\n<h3 id=\"分片\"><a class=\"anchor\" href=\"#分片\">#</a> 分片</h3>\n<p>通过将数据划分为多个部分进行分散处理（读写）以提高效率。</p>\n<h3 id=\"与memcached高性能键值缓存服务器相比\"><a class=\"anchor\" href=\"#与memcached高性能键值缓存服务器相比\">#</a> 与 memcached（高性能键值缓存服务器）相比</h3>\n<ol>\n<li>提供两种不同的写入方式。</li>\n<li>存储除字符串以外的其他数据结构。</li>\n</ol>\n<h2 id=\"redis安装-windows\"><a class=\"anchor\" href=\"#redis安装-windows\">#</a> Redis 安装 --windows</h2>\n<h3 id=\"下载即可使用\"><a class=\"anchor\" href=\"#下载即可使用\">#</a> 下载即可使用：</h3>\n<p>下载地址:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdGFyY2hpdmUvcmVkaXMvcmVsZWFzZXM=\">https://github.com/microsoftarchive/redis/releases</span></p>\n<h2 id=\"redis使用\"><a class=\"anchor\" href=\"#redis使用\">#</a> redis 使用：</h2>\n<p>python 下载 redis 三方库</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>pip install redis</pre></td></tr></table></figure><p>存取值</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> redis</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>conn <span class=\"token operator\">=</span> redis<span class=\"token punctuation\">.</span>Redis<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>conn<span class=\"token punctuation\">.</span><span class=\"token builtin\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"world\"</span><span class=\"token punctuation\">)</span>   <span class=\"token comment\"># key 为 hello value 为 world</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>conn<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span>   <span class=\"token comment\"># 获取 key 对应得 value</span></pre></td></tr></table></figure><p>注意</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>python代码中string 取值后是字节类型会带有 b'</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>需要在Redis声明中加入 decode_responses<span class=\"token operator\">=</span><span class=\"token boolean\">True</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>效果如下：</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>conn <span class=\"token operator\">=</span> redis<span class=\"token punctuation\">.</span>Redis<span class=\"token punctuation\">(</span>decode_responses<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h2 id=\"附加特性\"><a class=\"anchor\" href=\"#附加特性\">#</a> 附加特性</h2>\n<p>redis 服务关闭后的两种保存形式</p>\n<ol>\n<li>时间点转储：某段时间内，达到某个数量的数据被更新了，才进行一次转储操作</li>\n</ol>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>save <span class=\"token number\">900</span> <span class=\"token number\">1</span>    <span class=\"token comment\">#900 秒时间，至少有一条数据更新，则保存到数据文件中</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>save <span class=\"token number\">300</span> <span class=\"token number\">10</span>   <span class=\"token comment\">#300 秒时间，至少有 10 条数据更新，则保存到数据文件中</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>save <span class=\"token number\">60</span> <span class=\"token number\">10000</span>  <span class=\"token comment\">#60 秒时间，至少有 10000 条数据更新，则保存到数据文件中</span></pre></td></tr></table></figure><p>2.AOF (Append Only File): 把每个操作记录下来（不记录读操作），在 redis 下次启动时依次执行记录下来的操作复原数据。</p>\n<h2 id=\"redis-存储结构\"><a class=\"anchor\" href=\"#redis-存储结构\">#</a> redis 存储结构</h2>\n<table>\n<thead>\n<tr>\n<th>结构类型</th>\n<th>存储值</th>\n<th>结构的读写能力</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>string</td>\n<td>字符串、整数、浮点数</td>\n<td>能够作用字符串整体及部分、对整数和浮点数的自增、自减操作</td>\n</tr>\n<tr>\n<td>list</td>\n<td>链表，每个节点均为一个 string</td>\n<td>操作链表首尾，根据偏移量修改中间部分，读取单个或多个元素，根据值查找并操作对应节点</td>\n</tr>\n<tr>\n<td>set</td>\n<td>集合、元素不可重复</td>\n<td>交、并、差集，增删改查操作。</td>\n</tr>\n<tr>\n<td>hash</td>\n<td>键值对的无序字典</td>\n<td>增删改查操作。</td>\n</tr>\n<tr>\n<td>zset</td>\n<td>有序集合，字符串和浮点数分值的有序映射，排列顺序由分值决定</td>\n<td>增删改查，通过范围值（range）获取元素。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"redis-的-string\"><a class=\"anchor\" href=\"#redis-的-string\">#</a> redis 的 string：</h3>\n<p>字符串类型，整数和浮点数也会转为字符串。</p>\n<h4 id=\"操作get-set-delete\"><a class=\"anchor\" href=\"#操作get-set-delete\">#</a> 操作：get、set、delete</h4>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>conn<span class=\"token punctuation\">.</span><span class=\"token builtin\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"world\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>conn<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>conn<span class=\"token punctuation\">.</span>delete<span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h3 id=\"redis-的-list\"><a class=\"anchor\" href=\"#redis-的-list\">#</a> redis 的 list：</h3>\n<p>列表类型中全为 string，加入列表仅支持一个个加入，不支持 None 类型</p>\n<h4 id=\"操作-lpush-rpush-lrange-lindex-lpop-rpop\"><a class=\"anchor\" href=\"#操作-lpush-rpush-lrange-lindex-lpop-rpop\">#</a> 操作 lpush、rpush、lrange、lindex、lpop、rpop</h4>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"aaaaa\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    conn<span class=\"token punctuation\">.</span>lpush<span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 首插入</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    conn<span class=\"token punctuation\">.</span>rpush<span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 尾插入</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>conn<span class=\"token punctuation\">.</span>lrange<span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 范围取值 0 到 最后 即：全部元素</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>conn<span class=\"token punctuation\">.</span>lindex<span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 读取从左至右的第几个元素</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    conn<span class=\"token punctuation\">.</span>lpop<span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 左弹出</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    conn<span class=\"token punctuation\">.</span>rpop<span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 右弹出</span></pre></td></tr></table></figure><h3 id=\"redis-的-set\"><a class=\"anchor\" href=\"#redis-的-set\">#</a> redis 的 set:</h3>\n<p>集合中全为 string 且不可重复，集合是无序的</p>\n<h4 id=\"操作-sadd-smembers-sisemeber-srem\"><a class=\"anchor\" href=\"#操作-sadd-smembers-sisemeber-srem\">#</a> 操作 ： sadd、smembers、sisemeber、srem</h4>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>conn<span class=\"token punctuation\">.</span>sadd<span class=\"token punctuation\">(</span><span class=\"token string\">\"test\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"6\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 向集合中添加元素</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>smembers<span class=\"token punctuation\">(</span><span class=\"token string\">\"test\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 列出集合中全部元素</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>sismember<span class=\"token punctuation\">(</span><span class=\"token string\">\"test\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 判断集合中是否存在该元素</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>conn<span class=\"token punctuation\">.</span>srem<span class=\"token punctuation\">(</span><span class=\"token string\">\"test\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 删除集合中某个元素</span></pre></td></tr></table></figure><h3 id=\"redis-的-散列\"><a class=\"anchor\" href=\"#redis-的-散列\">#</a> redis 的 散列:</h3>\n<p>键值对的字典</p>\n<h4 id=\"操作-hset-hget-hgetall-hdel\"><a class=\"anchor\" href=\"#操作-hset-hget-hgetall-hdel\">#</a> 操作: hset、hget、hgetall、hdel</h4>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>conn<span class=\"token punctuation\">.</span>hset<span class=\"token punctuation\">(</span><span class=\"token string\">\"hash\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"key\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"value1\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 关联散列的键值对</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>hget<span class=\"token punctuation\">(</span><span class=\"token string\">\"hash\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"key\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 得到散列的值通过 key</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>hgetall<span class=\"token punctuation\">(</span><span class=\"token string\">\"hash\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 得到散列的所有键值对</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>conn<span class=\"token punctuation\">.</span>hdel<span class=\"token punctuation\">(</span><span class=\"token string\">\"hash\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"key\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 通过键去删除散列的键值对</span></pre></td></tr></table></figure><h3 id=\"redis-的-有序集合\"><a class=\"anchor\" href=\"#redis-的-有序集合\">#</a> redis 的 有序集合:</h3>\n<p>键值对存储的字典，且有序，且不可重复，值必须是浮点数，可以根据 key 访问元素，也可以根据 value 及 value 的排序访问元素</p>\n<h4 id=\"操作zadd-zrange-zrangebyscore-zrem\"><a class=\"anchor\" href=\"#操作zadd-zrange-zrangebyscore-zrem\">#</a> 操作：zadd、zrange、zrangebyscore、zrem</h4>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>conn<span class=\"token punctuation\">.</span>zadd<span class=\"token punctuation\">(</span><span class=\"token string\">\"zset\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"key1\"</span><span class=\"token punctuation\">:</span> <span class=\"token number\">999</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 有序集合添加键值对</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>conn<span class=\"token punctuation\">.</span>zadd<span class=\"token punctuation\">(</span><span class=\"token string\">\"zset\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"key2\"</span><span class=\"token punctuation\">:</span> <span class=\"token number\">888</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 有序集合添加键值对</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>conn<span class=\"token punctuation\">.</span>zadd<span class=\"token punctuation\">(</span><span class=\"token string\">\"zset\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"key3\"</span><span class=\"token punctuation\">:</span> <span class=\"token number\">777</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 有序集合添加键值对</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>zrange<span class=\"token punctuation\">(</span><span class=\"token string\">\"zset\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> withscores<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 根据位置获取集合中元素 [0,1],withscores=True 表示键值对均获得，不加则只获取 key</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>zrangebyscore<span class=\"token punctuation\">(</span><span class=\"token string\">\"zset\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">111</span><span class=\"token punctuation\">,</span> <span class=\"token number\">787</span><span class=\"token punctuation\">,</span> withscores<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 根据值的范围取到多个元素</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>conn<span class=\"token punctuation\">.</span>zrem<span class=\"token punctuation\">(</span><span class=\"token string\">\"zset\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"key3\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 根据 key 值来删除元素</span></pre></td></tr></table></figure>",
            "tags": [
                "计算机科学",
                "学习笔记",
                "Redis"
            ]
        },
        {
            "id": "https://allengx.gitee.io/computer-science/study/redis/%E4%B8%89%E3%80%81redis%E6%8C%87%E4%BB%A4/",
            "url": "https://allengx.gitee.io/computer-science/study/redis/%E4%B8%89%E3%80%81redis%E6%8C%87%E4%BB%A4/",
            "title": "三、redis指令",
            "date_published": "2020-04-12T12:46:25.000Z",
            "content_html": "<div class=\"note info\">\n<p>以下为个人学习笔记整理</p>\n</div>\n<h1 id=\"redis-命令\"><a class=\"anchor\" href=\"#redis-命令\">#</a> Redis 命令</h1>\n<ul>\n<li>字符串</li>\n<li>列表</li>\n<li>集合</li>\n<li>散列</li>\n<li>有序集合</li>\n<li>排序</li>\n<li>redis 基本事务</li>\n<li>过期键的处理</li>\n</ul>\n<h2 id=\"字符串命令\"><a class=\"anchor\" href=\"#字符串命令\">#</a> 字符串命令</h2>\n<h3 id=\"自增自减命令操作incr-decr-incrby-decrby-incrbyfloat\"><a class=\"anchor\" href=\"#自增自减命令操作incr-decr-incrby-decrby-incrbyfloat\">#</a> 自增自减命令操作：incr、decr、incrby、decrby、incrbyfloat</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>incr</td>\n<td>incr key-name—— 键对应的值 + 1</td>\n</tr>\n<tr>\n<td>decr</td>\n<td>decr key-name—— 键对应的值 - 1</td>\n</tr>\n<tr>\n<td>incrby</td>\n<td>incrby key-name amount—— 键对应的值 + amount</td>\n</tr>\n<tr>\n<td>decrby</td>\n<td>decrby key-name amount—— 键对应的值 - amount</td>\n</tr>\n<tr>\n<td>incrbyfloat</td>\n<td>incrbyfloat key-name amount—— 键对应的值 + 浮点数 amount</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> redis</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>conn <span class=\"token operator\">=</span> redis<span class=\"token punctuation\">.</span>Redis<span class=\"token punctuation\">(</span>decode_responses<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span><span class=\"token string\">\"key1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 得到 key 为 key1 的对象值，有返回值没有返回 None</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>incr<span class=\"token punctuation\">(</span><span class=\"token string\">\"key1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 对 key1 对应的值进行 + 1 操作，如果为 None 则变成 1</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>incr<span class=\"token punctuation\">(</span><span class=\"token string\">\"key1\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">15</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 对 key1 对应的值进行 + 15 操作</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>decr<span class=\"token punctuation\">(</span><span class=\"token string\">\"key1\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 对 key1 对应的值进行 - 5 操作</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span><span class=\"token string\">\"key1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span><span class=\"token builtin\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"key1\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">13</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 设置 key1 对应的值</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>incr<span class=\"token punctuation\">(</span><span class=\"token string\">\"key1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h3 id=\"字符串读取写入操作-append-getrange-setrange-getbit-setbit-bitcount-bitop\"><a class=\"anchor\" href=\"#字符串读取写入操作-append-getrange-setrange-getbit-setbit-bitcount-bitop\">#</a> 字符串读取写入操作: append、getrange、setrange、getbit、setbit、bitcount、bitop</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>append</td>\n<td>append key-name value—— 将 value 追加到 key-name 原来值得末尾</td>\n</tr>\n<tr>\n<td>getrange</td>\n<td>getrange key-name start end—— 获取从 start 到 end 偏移量的子串</td>\n</tr>\n<tr>\n<td>setrange</td>\n<td>setrange key-name offset value—— 把偏移量之后的字符设置为 value</td>\n</tr>\n<tr>\n<td>getbit</td>\n<td>getbit key-name offset—— 将字符串看成二级制，并返回偏移量的二进制值</td>\n</tr>\n<tr>\n<td>setbit</td>\n<td>setbit key-name offset value—— 将字符串看成二级制，并修改偏移量的二进制值为 value</td>\n</tr>\n</tbody>\n<tbody>\n<tr>\n<td>bitcount</td>\n<td>bitcount key-name [start end]—— 将字符串看成二级制，统计 start 到 end 内 1 的数量</td>\n</tr>\n<tr>\n<td>bitop</td>\n<td>bitop operation dest-key key-name [key-name...]—— 对多个二进制包进行（并 / 或 / 异或 / 非）等运算操作，并把结果保存着 dest-key 中</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token string\">\"new-string-key\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"hello \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>   <span class=\"token comment\"># 加入 'hello ' 字符串 到末尾</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token string\">\"new-string-key\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"world!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>substr<span class=\"token punctuation\">(</span><span class=\"token string\">\"new-string-key\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>        <span class=\"token comment\"># 读取 range [3:7] 左右都为闭区间</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>setrange<span class=\"token punctuation\">(</span><span class=\"token string\">\"new-string-key\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token string\">'H'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>    <span class=\"token comment\"># 第 0 个 字符设置为 H</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>setrange<span class=\"token punctuation\">(</span><span class=\"token string\">\"new-string-key\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token string\">'W'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>    <span class=\"token comment\"># 第 6 个 字符设置为 W</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span><span class=\"token string\">\"new-string-key\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>setrange<span class=\"token punctuation\">(</span><span class=\"token string\">\"new-string-key\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">11</span><span class=\"token punctuation\">,</span><span class=\"token string\">\", how are you?\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 从第 11 个开始插入 \", how are you?\"</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span><span class=\"token string\">\"new-string-key\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>setbit<span class=\"token punctuation\">(</span><span class=\"token string\">\"another-key\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>       <span class=\"token comment\"># 设置第 2 个二进制对象为 1</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>setbit<span class=\"token punctuation\">(</span><span class=\"token string\">\"another-key\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>       <span class=\"token comment\"># 设置第 7 个二进制对象为 1</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token comment\"># 0 1 2 3 4 5 6 7    # 0 1 2 3 4 5 6 7</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\"># 0 0 0 0 0 0 0 0  =>  0 0 1 0 0 0 0 1  => 33 => '!'</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span><span class=\"token string\">\"another-key\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h2 id=\"列表命令\"><a class=\"anchor\" href=\"#列表命令\">#</a> 列表命令</h2>\n<h3 id=\"列表常用操作rpush-lpush-rpop-lpop-lindex-lrange-ltrim\"><a class=\"anchor\" href=\"#列表常用操作rpush-lpush-rpop-lpop-lindex-lrange-ltrim\">#</a> 列表常用操作:rpush、lpush、rpop、lpop、lindex、lrange、ltrim</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>rpush</td>\n<td>rpush key-name value [value...]—— 将多个元素加入列表右端</td>\n</tr>\n<tr>\n<td>lpush</td>\n<td>lpush key-name value [value...]—— 将多个元素加入列表左端</td>\n</tr>\n<tr>\n<td>rpop</td>\n<td>rpop key-name—— 移除并返回右端元素</td>\n</tr>\n<tr>\n<td>lpop</td>\n<td>lpop key-name—— 移除并返回左端元素</td>\n</tr>\n<tr>\n<td>lindex</td>\n<td>lindex key-name offset—— 返回偏移量的元素</td>\n</tr>\n<tr>\n<td>lrange</td>\n<td>lrange key-name start end—— 返回 start 到 end 范围的元素，左右都是闭区间</td>\n</tr>\n<tr>\n<td>ltrim</td>\n<td>ltrim key-name start end—— 只保留 start 到 end 范围的元素，左右都是闭区间</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> redis</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>conn <span class=\"token operator\">=</span> redis<span class=\"token punctuation\">.</span>Redis<span class=\"token punctuation\">(</span>decode_responses<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>rpush<span class=\"token punctuation\">(</span><span class=\"token string\">\"list-key\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"last\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 向后插入</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>lpush<span class=\"token punctuation\">(</span><span class=\"token string\">\"list-key\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"first\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 向前插入</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>rpush<span class=\"token punctuation\">(</span><span class=\"token string\">\"list-key\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"new last\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>lrange<span class=\"token punctuation\">(</span><span class=\"token string\">\"list-key\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 从前往后依次输出</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>lpop<span class=\"token punctuation\">(</span><span class=\"token string\">\"list-key\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>    <span class=\"token comment\"># 从前弹出</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>lpop<span class=\"token punctuation\">(</span><span class=\"token string\">\"list-key\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>lrange<span class=\"token punctuation\">(</span><span class=\"token string\">\"list-key\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>rpush<span class=\"token punctuation\">(</span><span class=\"token string\">\"list-key\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"b\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"c\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"d\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"e\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 向后插入多个</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>lrange<span class=\"token punctuation\">(</span><span class=\"token string\">\"list-key\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>ltrim<span class=\"token punctuation\">(</span><span class=\"token string\">\"list-key\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>    <span class=\"token comment\"># 保留 [2:-1] 区间内的值</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>lrange<span class=\"token punctuation\">(</span><span class=\"token string\">\"list-key\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h3 id=\"阻塞式列表指令原子操作blpop-brpop-rpoplpush-brpoplpush\"><a class=\"anchor\" href=\"#阻塞式列表指令原子操作blpop-brpop-rpoplpush-brpoplpush\">#</a> 阻塞式列表指令（原子操作）:blpop、brpop、rpoplpush、brpoplpush</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>blpop</td>\n<td>blpop key-name [key-name...] timeout—— 从第一个非空列表弹出最左元素，或者 timeout 时间后自动结束等待</td>\n</tr>\n<tr>\n<td>brpop</td>\n<td>brpop key-name [key-name...] timeout—— 从第一个非空列表弹出最右元素，或者 timeout 时间后自动结束等待</td>\n</tr>\n<tr>\n<td>rpoplpush</td>\n<td>rpoplpush source-key dest-key—— 从 source-key 弹出最右元素加入 dest-key 最左端，并返回</td>\n</tr>\n<tr>\n<td>brpoplpush</td>\n<td>brpoplpush source-key dest-key timeout—— 从 source-key 弹出最右元素加入 dest-key 最左端，并返回，或者 timeout 时间后自动结束等待</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>brpoplpush<span class=\"token punctuation\">(</span><span class=\"token string\">\"list\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"list2\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>    <span class=\"token comment\"># 当 list 没有可弹出的元素时，程序会在一段时间内阻塞，来等待可弹出元素出现，否则一段时间后返回 None</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>rpush<span class=\"token punctuation\">(</span><span class=\"token string\">\"list\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"item1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>rpush<span class=\"token punctuation\">(</span><span class=\"token string\">\"list\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"item2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>rpush<span class=\"token punctuation\">(</span><span class=\"token string\">\"list2\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"item3\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>brpoplpush<span class=\"token punctuation\">(</span><span class=\"token string\">\"list\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"list2\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 将 list 最后边的元素放入 list2 的最前边</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>lrange<span class=\"token punctuation\">(</span><span class=\"token string\">\"list2\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>blpop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"list5\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"list4\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"list3\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"list2\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 从左到右检查列表内的 list，并对最先遇到的不为空的 list 执行左弹出操作</span></pre></td></tr></table></figure><h2 id=\"集合命令\"><a class=\"anchor\" href=\"#集合命令\">#</a> 集合命令</h2>\n<h3 id=\"集合常用操作指令sadd-srem-sismember-scard-smembers-srandmember-spop-smove\"><a class=\"anchor\" href=\"#集合常用操作指令sadd-srem-sismember-scard-smembers-srandmember-spop-smove\">#</a> 集合常用操作指令:sadd、srem、sismember、scard、smembers、srandmember、spop、smove</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>sadd</td>\n<td>sadd key-name item [item...]—— 将多个元素加入集合，返回成功加入的数量</td>\n</tr>\n<tr>\n<td>srem</td>\n<td>srem key-name item [item...]—— 从集合中删除多个元素，返回成功删除数量</td>\n</tr>\n<tr>\n<td>sismember</td>\n<td>sismember key-name item—— 判断 item 是否在集合内</td>\n</tr>\n<tr>\n<td>scard</td>\n<td>scard key-name—— 返回集合元素数量</td>\n</tr>\n<tr>\n<td>smembers</td>\n<td>smembers key-name —— 返回集合所有元素</td>\n</tr>\n<tr>\n<td>srandmember</td>\n<td>srandmember key-name [count]—— 随机返回 count 个元素 count 为负值时可能返回重复元素</td>\n</tr>\n<tr>\n<td>spop</td>\n<td>spop key-name—— 随机移除一个元素，并返回被移除元素</td>\n</tr>\n<tr>\n<td>smove</td>\n<td>smove source-key dest-key item—— 从 source-key 中移除 item 加入 dest-key 中移除失败返回 0 否则返回 1</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>sadd<span class=\"token punctuation\">(</span><span class=\"token string\">\"set-key\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"b\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"c\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 把元素加入集合，并返回加入的数量</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>srem<span class=\"token punctuation\">(</span><span class=\"token string\">\"set-key\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"c\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"d\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 移除集合中的某些元素 成功时 True 失败时 False</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>srem<span class=\"token punctuation\">(</span><span class=\"token string\">\"set-key\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"c\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"d\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>scard<span class=\"token punctuation\">(</span><span class=\"token string\">\"set-key\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 查看集合中元素数量</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>smembers<span class=\"token punctuation\">(</span><span class=\"token string\">\"set-key\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 输出集合中全部元素</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>smove<span class=\"token punctuation\">(</span><span class=\"token string\">\"set-key\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"set-key2\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 将 集合 set-key 中的 a 移至 se-key2 集合中 如果 a 不在 set-key 则返回 False</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>smove<span class=\"token punctuation\">(</span><span class=\"token string\">\"set-key\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"set-key2\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"c\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>smembers<span class=\"token punctuation\">(</span><span class=\"token string\">\"set-key2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h3 id=\"集合之间的常用操作指令sdiff-sdiffstore-sinter-sinterstore-sunion-sunionstore\"><a class=\"anchor\" href=\"#集合之间的常用操作指令sdiff-sdiffstore-sinter-sinterstore-sunion-sunionstore\">#</a> 集合之间的常用操作指令:sdiff、sdiffstore、sinter、sinterstore、sunion、sunionstore</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>sdiff</td>\n<td>sdiff key-name [key-name...]—— 返回在第一个集合不在其他的集合内的元素</td>\n</tr>\n<tr>\n<td>sdiffstore</td>\n<td>sdiffstore dest-key key-name [key-name...]—— 将在第一个集合不在其他的集合内的元素存储到 dest-key 里</td>\n</tr>\n<tr>\n<td>sinter</td>\n<td>sinter key-name [key-name...]—— 返回存在于所有集合的元素</td>\n</tr>\n<tr>\n<td>sinterstore</td>\n<td>sinterstore dest-key key-name [key-name...]—— 将存在于所有集合的元素存储在 dest-key 中</td>\n</tr>\n<tr>\n<td>sunion</td>\n<td>sunion key-name [key-name...]—— 返回至少存在于一个集合的所有元素</td>\n</tr>\n<tr>\n<td>sunionstore</td>\n<td>sunionstore dest-key key-name [key-name...]—— 返回存在于至少一个集合的所有元素到 dest-key 中</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>sadd<span class=\"token punctuation\">(</span><span class=\"token string\">\"skey1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"b\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"c\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"d\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>sadd<span class=\"token punctuation\">(</span><span class=\"token string\">\"skey2\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"c\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"d\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"e\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"f\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>sdiff<span class=\"token punctuation\">(</span><span class=\"token string\">\"skey1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"skey2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 两个集合做差运算</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>sinter<span class=\"token punctuation\">(</span><span class=\"token string\">\"skey1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"skey2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 两个集合做交运算</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>sunion<span class=\"token punctuation\">(</span><span class=\"token string\">\"skey1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"skey2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 两个集合做并运算</span></pre></td></tr></table></figure><h2 id=\"散列命令\"><a class=\"anchor\" href=\"#散列命令\">#</a> 散列命令</h2>\n<h3 id=\"散列常用操作指令-hmget-hmset-hdel-hlen\"><a class=\"anchor\" href=\"#散列常用操作指令-hmget-hmset-hdel-hlen\">#</a> 散列常用操作指令: hmget、hmset、hdel、hlen</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>hmget</td>\n<td>hmget key-name key [key...]—— 从散列里获取多个 key 的值</td>\n</tr>\n<tr>\n<td>hmset</td>\n<td>hmset key-name key value [key value...]—— 为散列设置多个 key value 值</td>\n</tr>\n<tr>\n<td>hdel</td>\n<td>hdel key-name key [key...]—— 删除散列多个 key 值并返回删除的数量</td>\n</tr>\n<tr>\n<td>hlen</td>\n<td>hlen key-name—— 散列键值对数量</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>hmset<span class=\"token punctuation\">(</span><span class=\"token string\">\"hash-key\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"k1\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"v1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"k2\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"v2\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"k3\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"v3\"</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 加入 散列的 key 和 value</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>hmget<span class=\"token punctuation\">(</span><span class=\"token string\">\"hash-key\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"k1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"k3\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 得到 key list 对应的 value list</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>hlen<span class=\"token punctuation\">(</span><span class=\"token string\">\"hash-key\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 得到 散列长度</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>hdel<span class=\"token punctuation\">(</span><span class=\"token string\">\"hash-key\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"k2\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"k3\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 删除某些 key 返回 删除的 key 数量</span></pre></td></tr></table></figure><h3 id=\"散列高级操作指令-hexists-hkeys-hvals-hgetall-hincrby-hincrbyfloat\"><a class=\"anchor\" href=\"#散列高级操作指令-hexists-hkeys-hvals-hgetall-hincrby-hincrbyfloat\">#</a> 散列高级操作指令: hexists、hkeys、hvals、hgetall、hincrby、hincrbyfloat</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>hexists</td>\n<td>hexists key-name key—— 检查某 key 是否存在于散列中</td>\n</tr>\n<tr>\n<td>hkeys</td>\n<td>hkeys key-name—— 获取散列的所有键</td>\n</tr>\n<tr>\n<td>hvals</td>\n<td>hvals key-name—— 获取散列的所有值</td>\n</tr>\n<tr>\n<td>hgetall</td>\n<td>hgetall key-name—— 获取散列的所有键和值</td>\n</tr>\n<tr>\n<td>hincrby</td>\n<td>hincrby key-name key increment—— 将键存储的值加上 increment</td>\n</tr>\n<tr>\n<td>hincrbyfloat</td>\n<td>hincrbyfloat key-name key increment—— 将键存储的值加上浮点数 increment</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>hmset<span class=\"token punctuation\">(</span><span class=\"token string\">\"hash-key2\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"short\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"long\"</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1000</span> <span class=\"token operator\">*</span> <span class=\"token string\">\"i\"</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>hkeys<span class=\"token punctuation\">(</span><span class=\"token string\">\"hash-key2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 得到所有的 key</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>hexists<span class=\"token punctuation\">(</span><span class=\"token string\">\"hash-key2\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"num\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 判断某些 key 是否存在</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>hexists<span class=\"token punctuation\">(</span><span class=\"token string\">\"hash-key2\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"long\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>hincrby<span class=\"token punctuation\">(</span><span class=\"token string\">\"hash-key2\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"num\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 对某些 key 的值进行自增操作，如果没有对应的值则默认对 0 进行自增</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>hmget<span class=\"token punctuation\">(</span><span class=\"token string\">\"hash-key2\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"num\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h2 id=\"有序集合\"><a class=\"anchor\" href=\"#有序集合\">#</a> 有序集合</h2>\n<h3 id=\"有序集合的常用操作zadd-zcard-zincrby-zscore-zrange-zcount-zrem-zrank\"><a class=\"anchor\" href=\"#有序集合的常用操作zadd-zcard-zincrby-zscore-zrange-zcount-zrem-zrank\">#</a> 有序集合的常用操作：zadd、zcard、zincrby、zscore、zrange、zcount、zrem、zrank</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>zadd</td>\n<td>zadd key-name map {key：value,...}—— 将带有分值的成员加入集合</td>\n</tr>\n<tr>\n<td>zcard</td>\n<td>zcard key-name—— 返回有序列表的成员数量</td>\n</tr>\n<tr>\n<td>zincrby</td>\n<td>key-name increment member—— 将 member 元素加上 increment</td>\n</tr>\n<tr>\n<td>zscore</td>\n<td>zscore key-name member—— 返回 member 元素的分值</td>\n</tr>\n<tr>\n<td>zrange</td>\n<td>zrange key-name start stop [withscores]—— 返回有序集合排名介于 start 和 stop 之间的成员，withscores 开启后分值也会一并返回</td>\n</tr>\n<tr>\n<td>zcount</td>\n<td>zcount key-name min max—— 返回介于 min 和 max 之间的成员数量</td>\n</tr>\n<tr>\n<td>zrem</td>\n<td>zrem key-name value [value...]—— 移除元素并返回移除数量</td>\n</tr>\n<tr>\n<td>zrank</td>\n<td>zrank key-name member—— 返回成员在有序集合中的排名</td>\n</tr>\n</tbody>\n</table>\n<pre><code>import redis\n\nconn = redis.Redis(decode_responses=True)\n\nprint(conn.zadd(&quot;zset-key&quot;, &#123;&quot;A&quot;: 3, &quot;B&quot;: 2&#125;))  # 向有序集合中加入元素\nprint(conn.zcard(&quot;zset-key&quot;))  # 有序集合的元素数量\nprint(conn.zincrby(&quot;zset-key&quot;, 2, &quot;A&quot;))  # A 元素的分值加2\nprint(conn.zscore(&quot;zset-key&quot;, &quot;A&quot;))  # 查看A元素的分值\nprint(conn.zrank(&quot;zset-key&quot;, &quot;B&quot;))  # 查看B 元素的排序（根据分值）排序从 0 开始\nprint(conn.zcount(&quot;zset-key&quot;, 0, 5))  # 分值为 0 - 5 的元素有多少个 左右都时是闭\nprint(conn.zrem(&quot;zset-key&quot;, 'B'))  # 移除 B 元素\nprint(conn.zrange(&quot;zset-key&quot;, 0, -1, withscores=True))  # 输出全部有序集合的 元素及其分值\n</code></pre>\n<h3 id=\"有序集合的高级操作zrevrnk-zrevrange-zrangebyscore-zrevrangebyscore-zremrangebyrank-zremrangebyscore-zinterstore-zunionstore\"><a class=\"anchor\" href=\"#有序集合的高级操作zrevrnk-zrevrange-zrangebyscore-zrevrangebyscore-zremrangebyrank-zremrangebyscore-zinterstore-zunionstore\">#</a> 有序集合的高级操作：zrevrnk、zrevrange、zrangebyscore、zrevrangebyscore、zremrangebyrank、zremrangebyscore、zinterstore、zunionstore</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>zrevrank</td>\n<td>zrevrank key-name value—— 返回元素的排名</td>\n</tr>\n<tr>\n<td>zrevrange</td>\n<td>zrevrange key-name start stop—— 返回排名范围内的元素</td>\n</tr>\n<tr>\n<td>zrangebyscore</td>\n<td>zrangebyscore key-name min max [withscores] [limit offset count]—— 返回有序列表中 min 到 max 的成员</td>\n</tr>\n<tr>\n<td>zrevrangebyscore</td>\n<td>zrevrangebyscore key-name min max [withscores] [limit offset count]—— 返回有序列表中 min 到 max 的成员，按照从大到小的顺序</td>\n</tr>\n<tr>\n<td>zremrangebyrank</td>\n<td>zremrangebyrank key-name start stop—— 移除介于 start 和 stop 之间的所有元素</td>\n</tr>\n<tr>\n<td>zremrangebyscore</td>\n<td>zremrangebyscore key-name min max—— 移除介于 min 和 max 之间的所有元素</td>\n</tr>\n<tr>\n<td>zinterstore</td>\n<td>zinterstore dest-key key-count key/[key...][None/weight/[weight...]][aggregate sum</td>\n<td>min</td>\n<td>max]—— 对集合进行交集运算</td>\n</tr>\n<tr>\n<td>zunionstore</td>\n<td>zunionstore dest-key key-count key/[key...][None/weight/[weight...]][aggregate sum</td>\n<td>min</td>\n<td>max]—— 对集合进行并集运算</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>zadd<span class=\"token punctuation\">(</span><span class=\"token string\">\"zset-1\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"A\"</span><span class=\"token punctuation\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"B\"</span><span class=\"token punctuation\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"C\"</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 向有序集合中加入元素</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>zadd<span class=\"token punctuation\">(</span><span class=\"token string\">\"zset-2\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"B\"</span><span class=\"token punctuation\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"C\"</span><span class=\"token punctuation\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"D\"</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 向有序集合中加入元素</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>zinterstore<span class=\"token punctuation\">(</span><span class=\"token string\">\"zset-i\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"zset-1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"zset-2\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 集合合并，保留相同元素，且分值叠加</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>zrange<span class=\"token punctuation\">(</span><span class=\"token string\">\"zset-i\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> withscores<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>zunionstore<span class=\"token punctuation\">(</span><span class=\"token string\">\"zset-j\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"zset-1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"zset-2\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> aggregate<span class=\"token operator\">=</span><span class=\"token string\">'min'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># aggregate = min/max/sum 集合合并，并对相同元素 取小 / 取大 / 取和</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>zrange<span class=\"token punctuation\">(</span><span class=\"token string\">\"zset-j\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> withscores<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>sadd<span class=\"token punctuation\">(</span><span class=\"token string\">\"set-1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"A\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"B\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 创建 集合（非有序集合）</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>zunionstore<span class=\"token punctuation\">(</span><span class=\"token string\">\"zset-h\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"zset-1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"zset-2\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"set-1\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 默认  aggregate = sum，集合也可以作为有序集合的合并对象</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>zrange<span class=\"token punctuation\">(</span><span class=\"token string\">\"zset-h\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> withscores<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h2 id=\"sort排序相关操作\"><a class=\"anchor\" href=\"#sort排序相关操作\">#</a> sort 排序相关操作</h2>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>sort</td>\n<td>sort key-name [by pattern][limit offset count][get pattern [get pattern...]][asc|desc][alpha][store desc-key]—— 根据给定的选项，对输入列表、集合或者有序集合进行排序，然后返回或者存储排序结果</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> redis</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>conn <span class=\"token operator\">=</span> redis<span class=\"token punctuation\">.</span>Redis<span class=\"token punctuation\">(</span>decode_responses<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>conn<span class=\"token punctuation\">.</span>rpush<span class=\"token punctuation\">(</span><span class=\"token string\">\"sort1\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">11</span><span class=\"token punctuation\">,</span> <span class=\"token number\">90</span><span class=\"token punctuation\">,</span> <span class=\"token number\">77</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span><span class=\"token string\">\"sort1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 根据大小</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span><span class=\"token string\">\"sort1\"</span><span class=\"token punctuation\">,</span> alpha<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 根据字母顺序</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">########## 权重 ##########</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>conn<span class=\"token punctuation\">.</span>hset<span class=\"token punctuation\">(</span><span class=\"token string\">\"a-1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"weight\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>conn<span class=\"token punctuation\">.</span>hset<span class=\"token punctuation\">(</span><span class=\"token string\">\"a-3\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"weight\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>conn<span class=\"token punctuation\">.</span>hset<span class=\"token punctuation\">(</span><span class=\"token string\">\"a-5\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"weight\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>conn<span class=\"token punctuation\">.</span>hset<span class=\"token punctuation\">(</span><span class=\"token string\">\"a-11\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"weight\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">44</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>conn<span class=\"token punctuation\">.</span>hset<span class=\"token punctuation\">(</span><span class=\"token string\">\"a-90\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"weight\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>conn<span class=\"token punctuation\">.</span>hset<span class=\"token punctuation\">(</span><span class=\"token string\">\"a-77\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"weight\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">66</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token comment\">########## 权重 ##########</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span><span class=\"token string\">\"sort1\"</span><span class=\"token punctuation\">,</span> by<span class=\"token operator\">=</span><span class=\"token string\">\"a-*->weight\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 根据上面的权重排序  </span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span><span class=\"token string\">\"sort1\"</span><span class=\"token punctuation\">,</span> by<span class=\"token operator\">=</span><span class=\"token string\">\"a-*->weight\"</span><span class=\"token punctuation\">,</span> get<span class=\"token operator\">=</span><span class=\"token string\">\"a-*->weight\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 把权重作为返回值</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token string\">'1'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'3'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'5'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'11'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'77'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'90'</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token string\">'1'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'11'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'3'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'5'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'77'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'90'</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token string\">'1'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'3'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'5'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'90'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'11'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'77'</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token string\">'1'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'2'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'3'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'5'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'44'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'66'</span><span class=\"token punctuation\">]</span></pre></td></tr></table></figure><h2 id=\"redis基本事务\"><a class=\"anchor\" href=\"#redis基本事务\">#</a> redis 基本事务</h2>\n<h3 id=\"基本事务指令watch-multi-exec-unwatch-discard\"><a class=\"anchor\" href=\"#基本事务指令watch-multi-exec-unwatch-discard\">#</a> 基本事务指令：watch、multi、exec、unwatch、discard</h3>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 非原子操作导致读写混乱</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> time</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">import</span> threading</pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>conn <span class=\"token operator\">=</span> redis<span class=\"token punctuation\">.</span>Redis<span class=\"token punctuation\">(</span>decode_responses<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>incr<span class=\"token punctuation\">(</span><span class=\"token string\">\"test--1:\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    time<span class=\"token punctuation\">.</span>sleep<span class=\"token punctuation\">(</span><span class=\"token number\">.1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>incr<span class=\"token punctuation\">(</span><span class=\"token string\">\"test--1:\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token keyword\">if</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        threading<span class=\"token punctuation\">.</span>Thread<span class=\"token punctuation\">(</span>target<span class=\"token operator\">=</span>test<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>start<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    time<span class=\"token punctuation\">.</span>sleep<span class=\"token punctuation\">(</span><span class=\"token number\">.5</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token comment\"># 通过事务的消息队列实现原子操作</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    pipline <span class=\"token operator\">=</span> conn<span class=\"token punctuation\">.</span>pipeline<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    pipline<span class=\"token punctuation\">.</span>incr<span class=\"token punctuation\">(</span><span class=\"token string\">\"test--1:\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    time<span class=\"token punctuation\">.</span>sleep<span class=\"token punctuation\">(</span><span class=\"token number\">.1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    pipline<span class=\"token punctuation\">.</span>incr<span class=\"token punctuation\">(</span><span class=\"token string\">\"test--1:\"</span><span class=\"token punctuation\">,</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    result <span class=\"token operator\">=</span> pipline<span class=\"token punctuation\">.</span>execute<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre></pre></td></tr><tr><td data-num=\"37\"></td><td><pre><span class=\"token keyword\">if</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>        threading<span class=\"token punctuation\">.</span>Thread<span class=\"token punctuation\">(</span>target<span class=\"token operator\">=</span>test<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>start<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>    time<span class=\"token punctuation\">.</span>sleep<span class=\"token punctuation\">(</span><span class=\"token number\">.5</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"42\"></td><td><pre><span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre><span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre><span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre><span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre><span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre><span class=\"token number\">0</span></pre></td></tr></table></figure><h2 id=\"过期键的处理\"><a class=\"anchor\" href=\"#过期键的处理\">#</a> 过期键的处理</h2>\n<h3 id=\"常用命令persist-ttl-expire-expireat-pttl-pexpire-pexpireat\"><a class=\"anchor\" href=\"#常用命令persist-ttl-expire-expireat-pttl-pexpire-pexpireat\">#</a> 常用命令:persist、ttl、expire、expireat、pttl、pexpire、pexpireat</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>persist</td>\n<td>persist key-name—— 移除键的过期时间</td>\n</tr>\n<tr>\n<td>ttl</td>\n<td>ttl key-name—— 查看键的过期时间</td>\n</tr>\n<tr>\n<td>expire</td>\n<td>expire key-name time—— 设置键的过期时间</td>\n</tr>\n<tr>\n<td>expireat</td>\n<td>expireat key-name timesetamp—— 将给定的过期时间修改为 unix 时间戳</td>\n</tr>\n<tr>\n<td>pttl</td>\n<td>pttl key-name—— 查看距离过期还有多久</td>\n</tr>\n<tr>\n<td>pexpire</td>\n<td>pexpire key-name time 让键在给定的多少<strong>毫秒</strong>后过期</td>\n</tr>\n<tr>\n<td>pexpireat</td>\n<td>pexpireat key-name time—— 将一个毫秒级的 unix 时间戳设置为键的过期时间</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> redis</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> time</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>conn <span class=\"token operator\">=</span> redis<span class=\"token punctuation\">.</span>Redis<span class=\"token punctuation\">(</span>decode_responses<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span><span class=\"token builtin\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"keys\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"value\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span><span class=\"token string\">\"keys\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>expire<span class=\"token punctuation\">(</span><span class=\"token string\">\"keys\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 设置该键的时间限制 2 秒后过期</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>time<span class=\"token punctuation\">.</span>sleep<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span><span class=\"token string\">\"keys\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span><span class=\"token builtin\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"keys\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"value2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>expire<span class=\"token punctuation\">(</span><span class=\"token string\">\"keys\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>ttl<span class=\"token punctuation\">(</span><span class=\"token string\">\"keys\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 查看还要多少秒过期</span></pre></td></tr></table></figure>",
            "tags": [
                "计算机科学",
                "学习笔记",
                "Redis"
            ]
        },
        {
            "id": "https://allengx.gitee.io/computer-science/study/redis/%E4%BA%8C%E3%80%81redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/",
            "url": "https://allengx.gitee.io/computer-science/study/redis/%E4%BA%8C%E3%80%81redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/",
            "title": "二、redis发布订阅",
            "date_published": "2020-04-12T12:46:25.000Z",
            "content_html": "<div class=\"note info\">\n<p>以下为个人学习笔记整理</p>\n</div>\n<h1 id=\"redis-发布订阅\"><a class=\"anchor\" href=\"#redis-发布订阅\">#</a> redis 发布订阅</h1>\n<h2 id=\"发布订阅相关命令\"><a class=\"anchor\" href=\"#发布订阅相关命令\">#</a> 发布订阅相关命令</h2>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>subscribe</td>\n<td>subscribe channel/[channel1 ....]—— 订阅一个或多个频道</td>\n</tr>\n<tr>\n<td>unsubscribe</td>\n<td>unsubscribe None/channel/[channel1 ...]—— 退订一个或多个频道</td>\n</tr>\n<tr>\n<td>publish</td>\n<td>publish channel message—— 向给定频道发送消息</td>\n</tr>\n<tr>\n<td>psubscribe</td>\n<td>psubscribe pattern/[pattern1...]—— 订阅与给定的模式相匹配的所有频道</td>\n</tr>\n<tr>\n<td>punsubscribe</td>\n<td>punsubscribe None/pattern/[pattern1...]—— 退订与给定的模式相匹配的所有频道</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> time</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> redis</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> threading</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>conn <span class=\"token operator\">=</span> redis<span class=\"token punctuation\">.</span>Redis<span class=\"token punctuation\">(</span>decode_responses<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">puber</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    time<span class=\"token punctuation\">.</span>sleep<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        conn<span class=\"token punctuation\">.</span>publish<span class=\"token punctuation\">(</span><span class=\"token string\">\"mychannel\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        time<span class=\"token punctuation\">.</span>sleep<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">runsub</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    threading<span class=\"token punctuation\">.</span>Thread<span class=\"token punctuation\">(</span>target<span class=\"token operator\">=</span>puber<span class=\"token punctuation\">,</span> args<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>start<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    sb <span class=\"token operator\">=</span> conn<span class=\"token punctuation\">.</span>pubsub<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    sb<span class=\"token punctuation\">.</span>subscribe<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"mychannel\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    count <span class=\"token operator\">=</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> sb<span class=\"token punctuation\">.</span>listen<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        count <span class=\"token operator\">+=</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>count<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token keyword\">if</span> count <span class=\"token operator\">==</span> <span class=\"token number\">10</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>            sb<span class=\"token punctuation\">.</span>unsubscribe<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token keyword\">if</span> count <span class=\"token operator\">==</span> <span class=\"token number\">11</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>            <span class=\"token keyword\">break</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>runsub<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre></pre></td></tr><tr><td data-num=\"26\"></td><td><pre></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token punctuation\">&#123;</span><span class=\"token string\">'type'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'subscribe'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'pattern'</span><span class=\"token punctuation\">:</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'channel'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'mychannel'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'data'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">&#125;</span>   <span class=\"token comment\">#打印的第一条信息，在客户端订阅了服务端的时候，会收到，data 表示订阅人数</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token punctuation\">&#123;</span><span class=\"token string\">'type'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'message'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'pattern'</span><span class=\"token punctuation\">:</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'channel'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'mychannel'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'data'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'0'</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token punctuation\">&#123;</span><span class=\"token string\">'type'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'message'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'pattern'</span><span class=\"token punctuation\">:</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'channel'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'mychannel'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'data'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'1'</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre><span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token punctuation\">&#123;</span><span class=\"token string\">'type'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'message'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'pattern'</span><span class=\"token punctuation\">:</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'channel'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'mychannel'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'data'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'2'</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre><span class=\"token number\">4</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre><span class=\"token punctuation\">&#123;</span><span class=\"token string\">'type'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'message'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'pattern'</span><span class=\"token punctuation\">:</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'channel'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'mychannel'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'data'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'3'</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre><span class=\"token number\">5</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre><span class=\"token punctuation\">&#123;</span><span class=\"token string\">'type'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'message'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'pattern'</span><span class=\"token punctuation\">:</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'channel'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'mychannel'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'data'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'4'</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre><span class=\"token number\">6</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre><span class=\"token punctuation\">&#123;</span><span class=\"token string\">'type'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'message'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'pattern'</span><span class=\"token punctuation\">:</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'channel'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'mychannel'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'data'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'5'</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre><span class=\"token number\">7</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre><span class=\"token punctuation\">&#123;</span><span class=\"token string\">'type'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'message'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'pattern'</span><span class=\"token punctuation\">:</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'channel'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'mychannel'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'data'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'6'</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre><span class=\"token number\">8</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre><span class=\"token punctuation\">&#123;</span><span class=\"token string\">'type'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'message'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'pattern'</span><span class=\"token punctuation\">:</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'channel'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'mychannel'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'data'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'7'</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre><span class=\"token number\">9</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre><span class=\"token punctuation\">&#123;</span><span class=\"token string\">'type'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'message'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'pattern'</span><span class=\"token punctuation\">:</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'channel'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'mychannel'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'data'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'8'</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre><span class=\"token number\">10</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre><span class=\"token punctuation\">&#123;</span><span class=\"token string\">'type'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'unsubscribe'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'pattern'</span><span class=\"token punctuation\">:</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'channel'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'mychannel'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'data'</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">&#125;</span> <span class=\"token comment\">#打印的最后一条消息，表示客户端在取消订阅后收到的最后一条消息，data 表示订阅人数</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre><span class=\"token number\">11</span></pre></td></tr></table></figure><h2 id=\"redis自带的发布订阅的弊端\"><a class=\"anchor\" href=\"#redis自带的发布订阅的弊端\">#</a> redis 自带的发布订阅的弊端：</h2>\n<p>1、消息传输过快会导致接收方的缓存挤压以至于卡死。<br />\n2、接收方断线后将失去之前的全部消息队列内未处理完的消息。</p>\n",
            "tags": [
                "计算机科学",
                "学习笔记",
                "Redis"
            ]
        },
        {
            "id": "https://allengx.gitee.io/computer-science/study/redis/%E4%BA%94%E3%80%81%E4%BD%BF%E7%94%A8redis%E6%9E%84%E5%BB%BA%E6%94%AF%E6%8C%81%E7%A8%8B%E5%BA%8F/",
            "url": "https://allengx.gitee.io/computer-science/study/redis/%E4%BA%94%E3%80%81%E4%BD%BF%E7%94%A8redis%E6%9E%84%E5%BB%BA%E6%94%AF%E6%8C%81%E7%A8%8B%E5%BA%8F/",
            "title": "五、使用redis构建支持程序",
            "date_published": "2020-04-12T12:46:25.000Z",
            "content_html": "<div class=\"note info\">\n<p>以下为个人学习笔记整理</p>\n</div>\n<h1 id=\"使用redis构建支持程序\"><a class=\"anchor\" href=\"#使用redis构建支持程序\">#</a> 使用 redis 构建支持程序</h1>\n<h2 id=\"使用redis记录日志\"><a class=\"anchor\" href=\"#使用redis记录日志\">#</a> 使用 redis 记录日志</h2>\n<h3 id=\"记录最新日志到redis\"><a class=\"anchor\" href=\"#记录最新日志到redis\">#</a> 记录最新日志到 redis</h3>\n<blockquote>\n<p>分级日志</p>\n</blockquote>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> logging</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> time</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>SEVERITY <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    logging<span class=\"token punctuation\">.</span>DEBUG<span class=\"token punctuation\">:</span> <span class=\"token string\">\"debug\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    logging<span class=\"token punctuation\">.</span>INFO<span class=\"token punctuation\">:</span> <span class=\"token string\">\"info\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    logging<span class=\"token punctuation\">.</span>WARNING<span class=\"token punctuation\">:</span> <span class=\"token string\">\"warning\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    logging<span class=\"token punctuation\">.</span>ERROR<span class=\"token punctuation\">:</span> <span class=\"token string\">\"error\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    logging<span class=\"token punctuation\">.</span>CRITICAL<span class=\"token punctuation\">:</span> <span class=\"token string\">\"critical\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">log_recent</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">,</span> message<span class=\"token punctuation\">,</span> severity<span class=\"token operator\">=</span>logging<span class=\"token punctuation\">.</span>INFO<span class=\"token punctuation\">,</span> pipe<span class=\"token operator\">=</span><span class=\"token boolean\">None</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    severity <span class=\"token operator\">=</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">(</span>SEVERITY<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span>severity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>lower<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    destination <span class=\"token operator\">=</span> <span class=\"token string\">\"recent:%s:%s\"</span> <span class=\"token operator\">%</span> <span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> severity<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    message <span class=\"token operator\">=</span> time<span class=\"token punctuation\">.</span>asctime<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">' '</span> <span class=\"token operator\">+</span> message</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    pipe <span class=\"token operator\">=</span> pipe <span class=\"token keyword\">or</span> conn<span class=\"token punctuation\">.</span>pipeline<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    pipe<span class=\"token punctuation\">.</span>lpush<span class=\"token punctuation\">(</span>destination<span class=\"token punctuation\">,</span> message<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    pipe<span class=\"token punctuation\">.</span>ltrim<span class=\"token punctuation\">(</span>destination<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">99</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    pipe<span class=\"token punctuation\">.</span>excute<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h3 id=\"记录常规日志redis\"><a class=\"anchor\" href=\"#记录常规日志redis\">#</a> 记录常规日志 redis</h3>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> redis</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">from</span> datetime <span class=\"token keyword\">import</span> datetime</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">log_common</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">,</span> message<span class=\"token punctuation\">,</span> severity<span class=\"token operator\">=</span>logging<span class=\"token punctuation\">.</span>INFO<span class=\"token punctuation\">,</span> timeout<span class=\"token operator\">=</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    severity <span class=\"token operator\">=</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">(</span>SEVERITY<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span>severity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>lower<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># info</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    destination <span class=\"token operator\">=</span> <span class=\"token string\">\"common: %s : %s\"</span> <span class=\"token operator\">%</span> <span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> severity<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># common : allen : info</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    start_key <span class=\"token operator\">=</span> destination <span class=\"token operator\">+</span> <span class=\"token string\">\":start\"</span>  <span class=\"token comment\"># common : allen : info : start</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    pipe <span class=\"token operator\">=</span> conn<span class=\"token punctuation\">.</span>pipeline<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    end <span class=\"token operator\">=</span> time<span class=\"token punctuation\">.</span>time<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> timeout</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">while</span> time<span class=\"token punctuation\">.</span>time<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> end<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            pipe<span class=\"token punctuation\">.</span>watch<span class=\"token punctuation\">(</span>start_key<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>            now <span class=\"token operator\">=</span> datetime<span class=\"token punctuation\">.</span>utcnow<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>timetuple<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>            hour_start <span class=\"token operator\">=</span> datetime<span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>now<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>isoformat<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 2019-11-07T09:00:00</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>            existing <span class=\"token operator\">=</span> pipe<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span>start_key<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 2019-11-07T08:00:00</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>            pipe<span class=\"token punctuation\">.</span>multi<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>            <span class=\"token keyword\">if</span> existing <span class=\"token keyword\">and</span> existing <span class=\"token operator\">&lt;</span> hour_start<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>                pipe<span class=\"token punctuation\">.</span>rename<span class=\"token punctuation\">(</span>destination<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>                            destination <span class=\"token operator\">+</span> <span class=\"token string\">\": last\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># common : allen : info - > common : allen : info : last</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>                pipe<span class=\"token punctuation\">.</span>rename<span class=\"token punctuation\">(</span>start_key<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>                            destination <span class=\"token operator\">+</span> <span class=\"token string\">\": pstart\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># common : allen : info : start -> common : allen : info : pstart</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>                pipe<span class=\"token punctuation\">.</span><span class=\"token builtin\">set</span><span class=\"token punctuation\">(</span>start_key<span class=\"token punctuation\">,</span> hour_start<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 2019-11-07T08:00:00 ->2019-11-07T09:00:00</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>            <span class=\"token keyword\">elif</span> <span class=\"token keyword\">not</span> existing<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>                pipe<span class=\"token punctuation\">.</span><span class=\"token builtin\">set</span><span class=\"token punctuation\">(</span>start_key<span class=\"token punctuation\">,</span> hour_start<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>            <span class=\"token comment\">#               name    amount  value</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>            pipe<span class=\"token punctuation\">.</span>zincrby<span class=\"token punctuation\">(</span>destination<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> message<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># [('message', x.0),...] -> [('message', x.0+1.0),...]</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>            log_recent<span class=\"token punctuation\">(</span>pipe<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">,</span> message<span class=\"token punctuation\">,</span> severity<span class=\"token punctuation\">,</span> pipe<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 见上节代码</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>            <span class=\"token keyword\">return</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>        <span class=\"token keyword\">except</span> redis<span class=\"token punctuation\">.</span>exceptions<span class=\"token punctuation\">.</span>WatchError<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>            <span class=\"token keyword\">continue</span></pre></td></tr></table></figure><h3 id=\"计数器和技术统计\"><a class=\"anchor\" href=\"#计数器和技术统计\">#</a> 计数器和技术统计</h3>\n<h4 id=\"存储计数器到redis\"><a class=\"anchor\" href=\"#存储计数器到redis\">#</a> 存储计数器到 redis</h4>\n<p>通过计数器记录网站点击量、销量或者数据库查询次数。从而对网站性能进行分析。例如 1s、5s、1 分钟执行了多少次。</p>\n<p>使用有序集合进行记录，集合的键值可以用时间戳表示，value 可以用点击次数表示。并且不会出现重复键值的情况</p>\n<pre><code>记录 2019 年 11 月 8 日 9 点 02 分的数据\nkey                     value\n201911010902$01:hit     100\n201911010902$05:hit     349\n201911010902$60:hit     5970\n</code></pre>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">#存数据</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> time</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> redis</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>PRECISION <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">60</span><span class=\"token punctuation\">,</span> <span class=\"token number\">300</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3600</span><span class=\"token punctuation\">,</span> <span class=\"token number\">18000</span><span class=\"token punctuation\">,</span> <span class=\"token number\">86400</span><span class=\"token punctuation\">]</span>  <span class=\"token comment\"># 1 秒、5 秒、1 分钟、5 分钟、1 小时、5 小时、1 天</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">update_counter</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">,</span> count<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> now<span class=\"token operator\">=</span><span class=\"token boolean\">None</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    now <span class=\"token operator\">=</span> now <span class=\"token keyword\">or</span> time<span class=\"token punctuation\">.</span>time<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    pipe <span class=\"token operator\">=</span> conn<span class=\"token punctuation\">.</span>pipeline<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">for</span> prec <span class=\"token keyword\">in</span> PRECISION<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        pnow <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span>now <span class=\"token operator\">/</span> prec<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> prec  <span class=\"token comment\"># 1573176436(1) 1573176435(5) 1573176420(60)...</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        hashstr <span class=\"token operator\">=</span> <span class=\"token string\">\"%s:%s\"</span> <span class=\"token operator\">%</span> <span class=\"token punctuation\">(</span>prec<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 1 : name</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        pipe<span class=\"token punctuation\">.</span>zadd<span class=\"token punctuation\">(</span><span class=\"token string\">\"know:\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span>hashstr<span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        pipe<span class=\"token punctuation\">.</span>hincrby<span class=\"token punctuation\">(</span><span class=\"token string\">\"count:\"</span> <span class=\"token operator\">+</span> hashstr<span class=\"token punctuation\">,</span> pnow<span class=\"token punctuation\">,</span> count<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># count:1 : name : &#123;1573176436:count,1573176437:count&#125; </span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>                                                       <span class=\"token comment\"># count:5 : name : &#123;1573176435:count,1573176440:count&#125;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    pipe<span class=\"token punctuation\">.</span>execute<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">#取数据</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> redis</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">get_counter</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">,</span> precision<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    hashstr <span class=\"token operator\">=</span> <span class=\"token string\">\"%s:%s\"</span> <span class=\"token operator\">%</span> <span class=\"token punctuation\">(</span>precision<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 1 : name</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    data <span class=\"token operator\">=</span> conn<span class=\"token punctuation\">.</span>hgetall<span class=\"token punctuation\">(</span><span class=\"token string\">\"count:\"</span> <span class=\"token operator\">+</span> hashstr<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># count:1 : name</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    to_return <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">for</span> key<span class=\"token punctuation\">,</span> value <span class=\"token keyword\">in</span> data<span class=\"token punctuation\">.</span>iteritems<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>  <span class=\"token comment\"># &#123;1573176436:1,1573176438:3,1573176437:2&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        to_return<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    to_return<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">return</span> to_return  <span class=\"token comment\"># [(\"1573176436\", 1), (\"1573176437\", 2), (\"1573176438\", 3)]</span></pre></td></tr></table></figure><h4 id=\"清理旧计数器\"><a class=\"anchor\" href=\"#清理旧计数器\">#</a> 清理旧计数器</h4>\n<p>上面对计数器的记录是通过时间间隔划分的，这周记录会让日志变得越来越庞大，为防止其无线膨胀，我们需要对其进行清理，当然，我们也可以在键中加入日期来进行分日记录，然后用 expire 对某个键进行删除。</p>\n<p>如果使用上面的记录方式（通过时间间隔划分）。在清理旧数据是，则需要考虑以下几点。</p>\n<ol>\n<li>任何时间都会有新数据加入。</li>\n<li>同一时间多个清理操作会一起执行。</li>\n<li>对于每天可能只更新一次的计数器来说，清理的频率不能设置的太低，不然会白白消耗性能。</li>\n<li>如果计数器不存在数据，则不需用对其进行清理。</li>\n</ol>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> time</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> bisect</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> redis</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>SAMPLE_COUNT <span class=\"token operator\">=</span> <span class=\"token number\">1000</span>  <span class=\"token comment\"># 保留 1000 条记录</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">clean_counters</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    pipe <span class=\"token operator\">=</span> conn<span class=\"token punctuation\">.</span>pipeline<span class=\"token punctuation\">(</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    passes <span class=\"token operator\">=</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">while</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        start <span class=\"token operator\">=</span> time<span class=\"token punctuation\">.</span>time<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        index <span class=\"token operator\">=</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token keyword\">while</span> index <span class=\"token operator\">&lt;</span> conn<span class=\"token punctuation\">.</span>zcard<span class=\"token punctuation\">(</span><span class=\"token string\">\"know:\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>  <span class=\"token comment\"># 计数器数量 > index</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            <span class=\"token builtin\">hash</span> <span class=\"token operator\">=</span> conn<span class=\"token punctuation\">.</span>zrange<span class=\"token punctuation\">(</span><span class=\"token string\">\"know:\"</span><span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 取到第 index 个计数器</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>            index <span class=\"token operator\">+=</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> <span class=\"token builtin\">hash</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>                <span class=\"token keyword\">break</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>            <span class=\"token builtin\">hash</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">hash</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>  <span class=\"token comment\"># 得到对应的值</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>            prec <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">hash</span><span class=\"token punctuation\">.</span>partition<span class=\"token punctuation\">(</span><span class=\"token string\">\":\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 1 : name 取到 1 的值（1 表示日志的记录间隔，通过写入时进行规定）</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>            bprec <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span>prec <span class=\"token operator\">//</span> <span class=\"token number\">60</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">or</span> <span class=\"token number\">1</span>  <span class=\"token comment\"># 小于 60 秒记录一次的每次都要清理，大于 60 秒的记录被跳过次数，根据跳过次数判断是否清理</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>            <span class=\"token keyword\">if</span> passes <span class=\"token operator\">%</span> bprec<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>                <span class=\"token keyword\">continue</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>            hkey <span class=\"token operator\">=</span> <span class=\"token string\">\"count:\"</span> <span class=\"token operator\">+</span> <span class=\"token builtin\">hash</span>  <span class=\"token comment\"># count:1 : name</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>            cutoff <span class=\"token operator\">=</span> time<span class=\"token punctuation\">.</span>time<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> SAMPLE_COUNT <span class=\"token operator\">*</span> prec  <span class=\"token comment\"># 判断需要从哪个时间开始截取数据</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>            samples <span class=\"token operator\">=</span> <span class=\"token builtin\">list</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> conn<span class=\"token punctuation\">.</span>hkeys<span class=\"token punctuation\">(</span>hkey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># ['1573176435','1573176440'] -> [1573176435,1573176440]</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>            samples<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>            remove <span class=\"token operator\">=</span> bisect<span class=\"token punctuation\">.</span>bisect_right<span class=\"token punctuation\">(</span>samples<span class=\"token punctuation\">,</span> cutoff<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 返回 cutoff 的插入位置，此处意为判断是否有比 cutoff 打的数据</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>            <span class=\"token keyword\">if</span> remove<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>                conn<span class=\"token punctuation\">.</span>hdel<span class=\"token punctuation\">(</span>hkey<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>samples<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span>remove<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 把小于 cutoff 的数据全部剔除</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>                <span class=\"token keyword\">if</span> remove <span class=\"token operator\">==</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>samples<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>  <span class=\"token comment\"># 剔除成功</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>                    <span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>                        pipe<span class=\"token punctuation\">.</span>watch<span class=\"token punctuation\">(</span>hkey<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>                        <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> pipe<span class=\"token punctuation\">.</span>hlen<span class=\"token punctuation\">(</span>hkey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>  <span class=\"token comment\"># 判断 1 : name 中是否还有记录  ，没有的话就把该 key 给回收</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>                            pipe<span class=\"token punctuation\">.</span>muti<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>                            pipe<span class=\"token punctuation\">.</span>zrem<span class=\"token punctuation\">(</span><span class=\"token string\">\"know:\"</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">hash</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>                            pipe<span class=\"token punctuation\">.</span>execute<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>                            index <span class=\"token operator\">-=</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>                        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>                            pipe<span class=\"token punctuation\">.</span>unwatch<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>                    <span class=\"token keyword\">except</span> redis<span class=\"token punctuation\">.</span>exceptions<span class=\"token punctuation\">.</span>WatchError<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>                        <span class=\"token keyword\">pass</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>        passes <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>  <span class=\"token comment\"># 步数 + 1</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>        duration <span class=\"token operator\">=</span> <span class=\"token builtin\">min</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">.</span>time<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> start<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">60</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 一个 while 执行时间  duration</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>        time<span class=\"token punctuation\">.</span>sleep<span class=\"token punctuation\">(</span><span class=\"token builtin\">max</span><span class=\"token punctuation\">(</span><span class=\"token number\">60</span> <span class=\"token operator\">-</span> duration<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 休眠 60-duration 的时间，保证 60 秒执行一次</span></pre></td></tr></table></figure><h3 id=\"使用redis统计数据\"><a class=\"anchor\" href=\"#使用redis统计数据\">#</a> 使用 redis 统计数据</h3>\n<p>统计最大最小数、总数和、总数量、总数平方和，通过对每次加入有序集合的 value 进行并集取最小、并集取最大操作以及自增来进行统计</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> time</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> redis</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">from</span> datetime <span class=\"token keyword\">import</span> datetime</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">import</span> uuid</pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">update_state</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">,</span> <span class=\"token builtin\">type</span><span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> timeout<span class=\"token operator\">=</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    destination <span class=\"token operator\">=</span> <span class=\"token string\">\"states:%s:%s\"</span> <span class=\"token operator\">%</span> <span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> <span class=\"token builtin\">type</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># states:context:type</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    start_key <span class=\"token operator\">=</span> destination <span class=\"token operator\">+</span> <span class=\"token string\">\":start\"</span>  <span class=\"token comment\"># states:context:type:start</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    pipe <span class=\"token operator\">=</span> conn<span class=\"token punctuation\">.</span>pipeline<span class=\"token punctuation\">(</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    end <span class=\"token operator\">=</span> time<span class=\"token punctuation\">.</span>time<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> timeout</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">while</span> time<span class=\"token punctuation\">.</span>time<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> end<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>            pipe<span class=\"token punctuation\">.</span>watch<span class=\"token punctuation\">(</span>start_key<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>            now <span class=\"token operator\">=</span> datetime<span class=\"token punctuation\">.</span>utcnow<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>timetuple<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># utcnow : time.struct_time(tm_year=2019, tm_mon=11, tm_mday=13, tm_hour=12, tm_min=1, tm_sec=36, tm_wday=2, tm_yday=317, tm_isdst=-1)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>            hour_start <span class=\"token operator\">=</span> datetime<span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>now<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>isoformat<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 2019-11-13T12:00:00</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>            existing <span class=\"token operator\">=</span> pipe<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span>start_key<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>            pipe<span class=\"token punctuation\">.</span>muti<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>            <span class=\"token keyword\">if</span> existing <span class=\"token keyword\">and</span> existing <span class=\"token operator\">&lt;</span> hour_start<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>                pipe<span class=\"token punctuation\">.</span>rename<span class=\"token punctuation\">(</span>destination<span class=\"token punctuation\">,</span> destination <span class=\"token operator\">+</span> <span class=\"token string\">\":last\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># states:context:type -> states:context:type:last</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>                pipe<span class=\"token punctuation\">.</span>rename<span class=\"token punctuation\">(</span>start_key<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>                            destination <span class=\"token operator\">+</span> <span class=\"token string\">\":pstart\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># states:context:type:start -> states:context:type:pstart</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>                pipe<span class=\"token punctuation\">.</span><span class=\"token builtin\">set</span><span class=\"token punctuation\">(</span>start_key<span class=\"token punctuation\">,</span> hour_start<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>            tkey1 <span class=\"token operator\">=</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">(</span>uuid<span class=\"token punctuation\">.</span>uuid4<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 用来存最小 key，value</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>            tkey2 <span class=\"token operator\">=</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">(</span>uuid<span class=\"token punctuation\">.</span>uuid4<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 用来存最大 key，value</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>            pipe<span class=\"token punctuation\">.</span>zadd<span class=\"token punctuation\">(</span>tkey1<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"min\"</span><span class=\"token punctuation\">:</span> value<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>            pipe<span class=\"token punctuation\">.</span>zadd<span class=\"token punctuation\">(</span>tkey2<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"max\"</span><span class=\"token punctuation\">:</span> value<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>            pipe<span class=\"token punctuation\">.</span>zunionstore<span class=\"token punctuation\">(</span>destination<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>destination<span class=\"token punctuation\">,</span> tkey1<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> aggregate<span class=\"token operator\">=</span><span class=\"token string\">\"min\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 两个集合合并，取分值小的 —— 意在每次保留最小的 value 到 destination 集合中</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>            pipe<span class=\"token punctuation\">.</span>zunionstore<span class=\"token punctuation\">(</span>destination<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>destination<span class=\"token punctuation\">,</span> tkey2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> aggregate<span class=\"token operator\">=</span><span class=\"token string\">\"max\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 两个集合合并，取分值大的 —— 意在每次保留最大的 value 到 destination 集合中</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>            pipe<span class=\"token punctuation\">.</span>delete<span class=\"token punctuation\">(</span>tkey1<span class=\"token punctuation\">,</span> tkey2<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>            pipe<span class=\"token punctuation\">.</span>zincrby<span class=\"token punctuation\">(</span>destination<span class=\"token punctuation\">,</span> <span class=\"token string\">\"count\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># count + 1</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>            pipe<span class=\"token punctuation\">.</span>zincrby<span class=\"token punctuation\">(</span>destination<span class=\"token punctuation\">,</span> <span class=\"token string\">\"sum\"</span><span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># sum + value</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>            pipe<span class=\"token punctuation\">.</span>zincrby<span class=\"token punctuation\">(</span>destination<span class=\"token punctuation\">,</span> <span class=\"token string\">\"sumsq\"</span><span class=\"token punctuation\">,</span> value <span class=\"token operator\">*</span> value<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># sumsq +value * value</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>            <span class=\"token keyword\">return</span> pipe<span class=\"token punctuation\">.</span>execute<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">3</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span>  <span class=\"token comment\"># 返回后三个数值 count , sum , sumsq</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>        <span class=\"token keyword\">except</span> redis<span class=\"token punctuation\">.</span>exceptions<span class=\"token punctuation\">.</span>WatchError<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>            <span class=\"token keyword\">continue</span></pre></td></tr></table></figure><figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">get_state</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">,</span> <span class=\"token builtin\">type</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    key <span class=\"token operator\">=</span> <span class=\"token string\">\"stats:%s:%s\"</span> <span class=\"token operator\">%</span> <span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> <span class=\"token builtin\">type</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    data <span class=\"token operator\">=</span> <span class=\"token builtin\">dict</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">.</span>zrange<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> withscores<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    data<span class=\"token punctuation\">[</span><span class=\"token string\">\"average\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> data<span class=\"token punctuation\">[</span><span class=\"token string\">\"sum\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">/</span> data<span class=\"token punctuation\">[</span><span class=\"token string\">\"count\"</span><span class=\"token punctuation\">]</span>  <span class=\"token comment\"># 平均数</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    numerator <span class=\"token operator\">=</span> data<span class=\"token punctuation\">[</span><span class=\"token string\">\"sumsq\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> data<span class=\"token punctuation\">[</span><span class=\"token string\">\"sum\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">**</span> <span class=\"token number\">2</span> <span class=\"token operator\">/</span> data<span class=\"token punctuation\">[</span><span class=\"token string\">\"count\"</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    data<span class=\"token punctuation\">[</span><span class=\"token string\">\"stddev\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>numerator <span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">[</span><span class=\"token string\">\"count\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token keyword\">or</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">**</span> <span class=\"token number\">0.5</span>  <span class=\"token comment\"># 标准差</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">return</span> data</pre></td></tr></table></figure><h3 id=\"简化统计数据记录与发现记录统计数据并进行分析\"><a class=\"anchor\" href=\"#简化统计数据记录与发现记录统计数据并进行分析\">#</a> 简化统计数据记录与发现（记录统计数据并进行分析）</h3>\n<p>构造一个记录运行性能的装饰器</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> contextlib</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># contextlib.contextmanager 该装饰器会先执行 yield 上面的语句 当 with access_time（）内的内容被执行后，会执行 yield 下面的语句</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 执行顺序如下</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token decorator annotation punctuation\">@contextlib<span class=\"token punctuation\">.</span>contextmanager</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">access_time</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    start <span class=\"token operator\">=</span> time<span class=\"token punctuation\">.</span>time<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 2</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">yield</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    delta <span class=\"token operator\">=</span> time<span class=\"token punctuation\">.</span>time<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> start  <span class=\"token comment\"># 4</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    stats <span class=\"token operator\">=</span> update_state<span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">,</span> <span class=\"token string\">\"AccessTime\"</span><span class=\"token punctuation\">,</span> delta<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    average <span class=\"token operator\">=</span> stats<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">/</span> stats<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    pipe <span class=\"token operator\">=</span> conn<span class=\"token punctuation\">.</span>pipeline<span class=\"token punctuation\">(</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    pipe<span class=\"token punctuation\">.</span>zadd<span class=\"token punctuation\">(</span><span class=\"token string\">\"slowest:AccessTime\"</span><span class=\"token punctuation\">,</span> context<span class=\"token punctuation\">,</span> average<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    pipe<span class=\"token punctuation\">.</span>zremrangebyrand<span class=\"token punctuation\">(</span><span class=\"token string\">\"slowest:AccessTime\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">101</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    pipe<span class=\"token punctuation\">.</span>execute<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">process_view</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">,</span> detectedfunc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    funcname <span class=\"token operator\">=</span> <span class=\"token builtin\">getattr</span><span class=\"token punctuation\">(</span>detectedfunc<span class=\"token punctuation\">,</span> <span class=\"token string\">\"__name__\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 1</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token keyword\">with</span> access_time<span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">,</span> funcname<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        <span class=\"token keyword\">return</span> detectedfunc<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 3</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        </pre></td></tr><tr><td data-num=\"26\"></td><td><pre>process_view<span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">,</span> func<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h2 id=\"查找ip所属城市及国家\"><a class=\"anchor\" href=\"#查找ip所属城市及国家\">#</a> 查找 ip 所属城市及国家</h2>\n<p>首先需要把 ip 对应的城市及国家表格载入 redis</p>\n<h3 id=\"载入位置表格\"><a class=\"anchor\" href=\"#载入位置表格\">#</a> 载入位置表格</h3>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0FsbGVuR1gvc3R1ZHlfcmVkaXMvYmxvYi9tYXN0ZXIvaXAvR2VvTGl0ZTItQ2l0eS1DU1ZfMjAxOTExMTIuemlw\">GeoLite2-City-Blocks-IPv4.csv 下载</span></p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> redis</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> csv</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 将 ip 地址转为 10 进制整数</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\"># 127.0.0.1 -> 2130706433</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">ip_to_score</span><span class=\"token punctuation\">(</span>ip_address<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    score <span class=\"token operator\">=</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">for</span> v <span class=\"token keyword\">in</span> ip_address<span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token string\">\".\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        score <span class=\"token operator\">=</span> score <span class=\"token operator\">*</span> <span class=\"token number\">256</span> <span class=\"token operator\">+</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">return</span> score</pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\"># 文件通过 http://dev.maxmind.com/geoip/geolite 的 GeoLite2-City-Blocks-IPv4.csv</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token comment\"># 构建唯一地址 ip-> 城市 id</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">import_ips_to_redis</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">,</span> filename<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">with</span> <span class=\"token builtin\">open</span><span class=\"token punctuation\">(</span>filename<span class=\"token punctuation\">,</span> <span class=\"token string\">\"rt\"</span><span class=\"token punctuation\">,</span> encoding<span class=\"token operator\">=</span><span class=\"token string\">\"utf-8\"</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> csv_file<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        csv_file <span class=\"token operator\">=</span> csv<span class=\"token punctuation\">.</span>reader<span class=\"token punctuation\">(</span>csv_file<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token keyword\">for</span> count<span class=\"token punctuation\">,</span> row <span class=\"token keyword\">in</span> <span class=\"token builtin\">enumerate</span><span class=\"token punctuation\">(</span>csv_file<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>            start_ip <span class=\"token operator\">=</span> row<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">if</span> row <span class=\"token keyword\">else</span> <span class=\"token string\">''</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token string\">\"i\"</span> <span class=\"token keyword\">in</span> start_ip<span class=\"token punctuation\">.</span>lower<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>                <span class=\"token keyword\">continue</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token string\">\".\"</span> <span class=\"token keyword\">in</span> start_ip<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>                start_ip <span class=\"token operator\">=</span> start_ip<span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token string\">\"/\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>   <span class=\"token comment\">#2.25.32.0/24</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>                start_ip <span class=\"token operator\">=</span> ip_to_score<span class=\"token punctuation\">(</span>start_ip<span class=\"token punctuation\">)</span>    <span class=\"token comment\"># 35201024</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>            <span class=\"token keyword\">elif</span> start_ip<span class=\"token punctuation\">.</span>isdigit<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>                start_ip <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span>start_ip<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>                <span class=\"token keyword\">continue</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>            city_id <span class=\"token operator\">=</span> row<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"_\"</span> <span class=\"token operator\">+</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">(</span>count<span class=\"token punctuation\">)</span> <span class=\"token comment\"># row ['2.25.32.0/24', '2645161', '2635167', '', '0', '0', 'SG3', '51.8513', '-0.1596', '100']</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>            conn<span class=\"token punctuation\">.</span>zadd<span class=\"token punctuation\">(</span><span class=\"token string\">\"ip2cityid:\"</span><span class=\"token punctuation\">,</span> city_id<span class=\"token punctuation\">,</span> start_ip<span class=\"token punctuation\">)</span>    <span class=\"token comment\"># ip2cityid: 2635167_14003 35201024</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre></pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token comment\"># 文件通过 http://dev.maxmind.com/geoip/geolite 的 GeoLite2-City-Locations-zh-CN.csv</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre><span class=\"token comment\"># 生成地址映射 城市 id-> 城市信息</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">import_cities_to_redis</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">,</span> filename<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>    <span class=\"token keyword\">with</span> <span class=\"token builtin\">open</span><span class=\"token punctuation\">(</span>filename<span class=\"token punctuation\">,</span> <span class=\"token string\">\"rt\"</span><span class=\"token punctuation\">,</span> encoding<span class=\"token operator\">=</span><span class=\"token string\">\"utf-8\"</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> csv_file<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>        csv_file <span class=\"token operator\">=</span> csv<span class=\"token punctuation\">.</span>reader<span class=\"token punctuation\">(</span>csv_file<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>        <span class=\"token keyword\">for</span> count<span class=\"token punctuation\">,</span> row <span class=\"token keyword\">in</span> <span class=\"token builtin\">enumerate</span><span class=\"token punctuation\">(</span>csv_file<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>row<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">4</span> <span class=\"token keyword\">or</span> <span class=\"token keyword\">not</span> row<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>isdigit<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>                <span class=\"token keyword\">continue</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>            <span class=\"token comment\"># row ['2827433', 'zh-CN', 'EU', ' 欧洲 ', 'DE', ' 德国 ', 'SL', '', '', '', '', '', 'Europe/Berlin', '1']</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>            row <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">.</span>encode<span class=\"token punctuation\">(</span><span class=\"token string\">'utf-8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>decode<span class=\"token punctuation\">(</span><span class=\"token string\">\"latin-1\"</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> row<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>            city_id <span class=\"token operator\">=</span> row<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>    <span class=\"token comment\"># 2827433</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>            country <span class=\"token operator\">=</span> row<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>    <span class=\"token comment\"># zh-CN</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>            region <span class=\"token operator\">=</span> row<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>     <span class=\"token comment\"># EU</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>            city <span class=\"token operator\">=</span> row<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span>       <span class=\"token comment\"># 欧洲 ->\"\\u00e6\\u00ac\\u00a7\\u00e6\\u00b4\\u00b2\"</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>            <span class=\"token comment\"># cityid2city: 2827433 [\"\\u00e6\\u00ac\\u00a7\\u00e6\\u00b4\\u00b2\", \"EU\", \"zh-CN\"]</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>            conn<span class=\"token punctuation\">.</span>hset<span class=\"token punctuation\">(</span><span class=\"token string\">\"cityid2city:\"</span><span class=\"token punctuation\">,</span> city_id<span class=\"token punctuation\">,</span> json<span class=\"token punctuation\">.</span>dumps<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>city<span class=\"token punctuation\">,</span> region<span class=\"token punctuation\">,</span> country<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre></pre></td></tr><tr><td data-num=\"48\"></td><td><pre></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>import_cities_to_redis<span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">,</span> <span class=\"token string\">\"C:/Users/duoyi/Desktop/GeoLite2-City-CSV_20191112/GeoLite2-City-Locations-zh-CN.csv\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>import_ips_to_redis<span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">,</span><span class=\"token string\">\"C:/Users/duoyi/Desktop/GeoLite2-City-CSV_20191112/GeoLite2-City-Blocks-IPv4.csv\"</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure>",
            "tags": [
                "计算机科学",
                "学习笔记",
                "Redis"
            ]
        },
        {
            "id": "https://allengx.gitee.io/computer-science/study/redis/%E5%9B%9B%E3%80%81redis%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BF%9D%E9%9A%9C/",
            "url": "https://allengx.gitee.io/computer-science/study/redis/%E5%9B%9B%E3%80%81redis%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BF%9D%E9%9A%9C/",
            "title": "四、redis数据安全及性能保障",
            "date_published": "2020-04-12T12:46:25.000Z",
            "content_html": "<div class=\"note info\">\n<p>以下为个人学习笔记整理</p>\n</div>\n<h1 id=\"redis数据安全及性能保障\"><a class=\"anchor\" href=\"#redis数据安全及性能保障\">#</a> redis 数据安全及性能保障</h1>\n<h2 id=\"持久化\"><a class=\"anchor\" href=\"#持久化\">#</a> 持久化</h2>\n<ul>\n<li>快照：在某个时刻将数据写入硬盘。</li>\n<li>追加文件：保存写操作的执行语句到硬盘。</li>\n</ul>\n<h2 id=\"如何创建快照\"><a class=\"anchor\" href=\"#如何创建快照\">#</a> 如何创建快照</h2>\n<ul>\n<li>客户端向 redis 发送 bgsave 命令：通过 fork 创建子进程去完成，不影响正常工作。</li>\n<li>客户端向 redis 发送 save 命令：不再响应任何操作，只进行快照创建。</li>\n<li>设置 save 选项：比如 save 60 100，如果 60 秒之内有 100 条数据被写入则自动执行 bgsave。</li>\n<li>收到关闭指令 shutdown：收到标准 team 信号后会执行 save 命令，阻塞所有客户端，并在 save 之后关闭服务</li>\n<li>redis 之间的 sync 同步操作：主服务器不在执行 bgsave 或者短时间内没有执行 bgsave 则执行一次 bgsave 操作。</li>\n</ul>\n<h2 id=\"快照持久化应用场景\"><a class=\"anchor\" href=\"#快照持久化应用场景\">#</a> 快照持久化应用场景</h2>\n<h3 id=\"个人开发\"><a class=\"anchor\" href=\"#个人开发\">#</a> 个人开发</h3>\n<p>设置 save 的配置为 save 900 1 ；15 分钟内只要有一条写入数据就进行快照生成，这样能够减少消耗的同时，保障每 15 分值就通过 bgsave 存储一次快照。</p>\n<p>注：时间可以根据自己的项目环境进行适当的整体。</p>\n<h3 id=\"对日志进行聚合计算\"><a class=\"anchor\" href=\"#对日志进行聚合计算\">#</a> 对日志进行聚合计算</h3>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> os</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">process_logs</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">,</span> path<span class=\"token punctuation\">,</span> callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    current_file<span class=\"token punctuation\">,</span> offset <span class=\"token operator\">=</span> conn<span class=\"token punctuation\">.</span>mget<span class=\"token punctuation\">(</span><span class=\"token string\">\"progress:file\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"progress:position\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 得到执行到的文件名和偏移量</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    pipe <span class=\"token operator\">=</span> conn<span class=\"token punctuation\">.</span>pipline<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 创建执行流水线</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token comment\"># 在流水线里加入更新行号操作，并执行流水线全部内容</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">def</span> <span class=\"token function\">update_progress</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        pipe<span class=\"token punctuation\">.</span>mset<span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>            <span class=\"token string\">\"progress:file\"</span><span class=\"token punctuation\">:</span> fname<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>            <span class=\"token string\">\"progress:position\"</span><span class=\"token punctuation\">:</span> offset</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        pipe<span class=\"token punctuation\">.</span>excute<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token comment\"># 遍历所有文件（文件名是时间）</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token keyword\">for</span> fname <span class=\"token keyword\">in</span> <span class=\"token builtin\">sorted</span><span class=\"token punctuation\">(</span>os<span class=\"token punctuation\">.</span>listdir<span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token keyword\">if</span> fname <span class=\"token operator\">&lt;</span> current_file<span class=\"token punctuation\">:</span>  <span class=\"token comment\"># 文件已经执行过了之间跳过</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>            <span class=\"token keyword\">continue</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        inp <span class=\"token operator\">=</span> <span class=\"token builtin\">open</span><span class=\"token punctuation\">(</span>os<span class=\"token punctuation\">.</span>path<span class=\"token punctuation\">.</span>join<span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">,</span> fname<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'rb'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token keyword\">if</span> fname <span class=\"token operator\">==</span> current_file<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>            inp<span class=\"token punctuation\">.</span>seek<span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span>offset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 定位到对应的执行点</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>            offset <span class=\"token operator\">=</span> <span class=\"token number\">0</span>  <span class=\"token comment\"># 从头开始</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        current_file <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token comment\"># 执行文件的每一行</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        <span class=\"token keyword\">for</span> lno<span class=\"token punctuation\">,</span> line <span class=\"token keyword\">in</span> <span class=\"token builtin\">enumerate</span><span class=\"token punctuation\">(</span>inp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>            callback<span class=\"token punctuation\">(</span>pipe<span class=\"token punctuation\">,</span> line<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 向队列中加入记录文件名字和偏移量的操作</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>            offset <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span>offset<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>line<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 计算执行后的偏移量</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> <span class=\"token punctuation\">(</span>lno <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>                update_progress<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>        <span class=\"token comment\"># 加入执行行数超过 1000 或者全部加入完毕后，开始执行流水线，并更新行号</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>        update_progress<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>        inp<span class=\"token punctuation\">.</span>close<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><blockquote>\n<p>注：以上方式都是存在丢失数据的可能性。</p>\n</blockquote>\n<h2 id=\"aof持久化\"><a class=\"anchor\" href=\"#aof持久化\">#</a> AOF 持久化</h2>\n<p>把每次执行的命令写入 AOF 文件的末尾，以此来记录数据的变化。通过设置 appendonly yes 配置选项来执行写入频率。</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>频率</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>alaways</td>\n<td>每个写命令都写入</td>\n</tr>\n<tr>\n<td>everysec</td>\n<td>每秒同步一次</td>\n</tr>\n<tr>\n<td>no</td>\n<td>让操作系统自己决定何时同步</td>\n</tr>\n</tbody>\n</table>\n<p>文件同步：</p>\n<ol>\n<li>file.write 写入缓冲区</li>\n<li>file.flush 请求操作系统将缓冲区的数据写入硬盘（不一定立刻写入）</li>\n<li>sync 请求操作系统将文件据同步到硬盘（一直阻塞到指定文件内容被写入为止）</li>\n</ol>\n<blockquote>\n<p>注：AOF alaways 可以避免数据丢失，但性能太低，且折损硬盘寿命，所以更推荐使用 everysec。</p>\n</blockquote>\n<h3 id=\"重写压缩-aof文件\"><a class=\"anchor\" href=\"#重写压缩-aof文件\">#</a> 重写 / 压缩 AOF 文件</h3>\n<ul>\n<li>发送 bgrewriteaof : 重写 AOF 文件</li>\n<li>设置重写执行间隔和大小：\n<ul>\n<li>auto-aof-rewrite-percentage 100</li>\n<li>auto-aof-rewrite-min-size 64mb</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"复制\"><a class=\"anchor\" href=\"#复制\">#</a> 复制</h2>\n<blockquote>\n<p>关系型数据库通常采用一个主服务器（master）向多个从服务器 (slave) 发送更新，通过从服务器来处理读请求，redis 也采用同样方法。</p>\n</blockquote>\n<p>性能考量：redis 在对集合和有序集合的操作上需要花费较多时间，<strong>sunionstore</strong> 对两个包含 10000 个元素的集合进行合并需要七 - 八毫秒。</p>\n<h3 id=\"复制启动过程\"><a class=\"anchor\" href=\"#复制启动过程\">#</a> 复制启动过程</h3>\n<table>\n<thead>\n<tr>\n<th>步骤</th>\n<th>主服务器操作</th>\n<th>从服务器操作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>等待指令</td>\n<td>连接主服务器，发送 sync 命令</td>\n</tr>\n<tr>\n<td>2</td>\n<td>执行 bgsave，并用缓冲区记录 bgsave 之后的所有写命令</td>\n<td>根据配置决定是继续用现有数据返回结果还是直接返回错误</td>\n</tr>\n<tr>\n<td>3</td>\n<td>bgsave 执行完毕，发送快照给从服务器，发送期间继续用缓冲区记录写命令</td>\n<td>丢弃全部旧数据，更新并载入主服务器快照数据文件</td>\n</tr>\n<tr>\n<td>4</td>\n<td>快照发送完毕，向从服务器发送存储在缓存中的写命令</td>\n<td>完成对快照文件载入，接受主服务器命令</td>\n</tr>\n<tr>\n<td>5</td>\n<td>缓冲区写入数据发送完毕，从现在开始没执行写指令便发送给从服务器</td>\n<td>执行主服务器发来的全部写命令后，接受主服务器发来的每一个写命令</td>\n</tr>\n</tbody>\n</table>\n<p><img data-src=\"https://github.com/AllenGX/study_redis/blob/master/pic/sync.png?raw=true\" alt=\"流程图\" /></p>\n<blockquote>\n<p>建议：redis 主服务器的内存使用最好在 50% ~ 65% 以内，预留 30%~45% 的内存用于执行 bgsave 和创建记录写命令的缓存会比较合理。</p>\n</blockquote>\n<blockquote>\n<p>注意：从服务器同步主服务器的所有数据时，会<strong>失去</strong>已有的<strong>全部数据</strong>，并替换为主服务器的数据。</p>\n</blockquote>\n<blockquote>\n<p>警告：redis 不支持<strong>主服务器</strong>同步到其他<strong>主服务器</strong>。</p>\n</blockquote>\n<h2 id=\"主从链\"><a class=\"anchor\" href=\"#主从链\">#</a> 主从链</h2>\n<p>主服务器有从服务器，从服务器还有从服务器的情况下，称为主从链。主从链过长的情况下同步消耗大量时间。当从服务器去同步主服务器数据并准备载入主服务器快照的时候，会断开该从服务器和其自身从服务器的链接，在载入完成后，其从服务器需要重新建立链接并执行同步的全部操作。当读操作过多且同步时间较长时会出现问题。这里可以通过主从节点中间层来解决。</p>\n<p>节点中间层：对一个主服务器设置若干个从服务器，由从服务器去管理其他的从服务器进行同步数据的操作，而主服务器只需要管理该若干个从服务器的数据同步。</p>\n<h2 id=\"磁盘写入检查\"><a class=\"anchor\" href=\"#磁盘写入检查\">#</a> 磁盘写入检查</h2>\n<p>1、确认主从服连接正常<br />\n 2、检查虚构值（令牌）是否标记给从服务器<br />\n 3、检查写入缓冲区状态<br />\n 4、1 秒内等待从服务器把缓冲区数据写入磁盘<br />\n 5、清理虚构值（令牌）</p>\n<h2 id=\"系统故障\"><a class=\"anchor\" href=\"#系统故障\">#</a> 系统故障</h2>\n<h3 id=\"验证快照和aof文件\"><a class=\"anchor\" href=\"#验证快照和aof文件\">#</a> 验证快照和 AOF 文件</h3>\n<p>1、扫描 AOF 文件，找出出错命令，清楚出错命令和之后的全部命令。（目前还没办法支持修复出错命令）</p>\n<h3 id=\"更换故障主服务器\"><a class=\"anchor\" href=\"#更换故障主服务器\">#</a> 更换故障主服务器</h3>\n<p>例如 A 为主服务器（出现了故障需要更换），B 为从服务（正常）</p>\n<p>1、向 B 服务器执行 Save 命令得到数据的快照，把快照发送给 C 服务器，启动其 redis 并创建快照。并告知 B 服务器，C 为其新的主服务器</p>\n<p>2、把 B 服务器升级为主服务器（turn），然后设置新的从服务器。</p>\n<h2 id=\"事务\"><a class=\"anchor\" href=\"#事务\">#</a> 事务</h2>\n<blockquote>\n<p>保障在多个客户端同时对相同数据进行写入，且不写脏数据</p>\n</blockquote>\n<pre><code>一个事务从MULTI开始，EXEC结束，中间的操作依次执行，遇到错误后回滚全部操作\n\nMULTI\n    操作1\n    操作2\n    操作3\n    ...\nEXEC\n</code></pre>\n<blockquote>\n<p>延迟执行事务有助于提升性能。把 MULTI，一系列操作和 EXEC 一起打包发送给 redis，以流水线的形式去执行能够提高效率。</p>\n</blockquote>\n<blockquote>\n<p>redis 的事务采用的是乐观锁。通过 watch 监听被修改对象，如果对象在自己修改之前被其他对象修改，则会抛出异常，自己的此次修改视为无效并重新尝试修改。<br />\n相比于 mysql 的悲观锁而言，可以减少客户端的等待时间，失败了就再来一次。</p>\n</blockquote>\n<h2 id=\"非事务型流水线\"><a class=\"anchor\" href=\"#非事务型流水线\">#</a> 非事务型流水线</h2>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># True 会让流水线变成一个事务，会存在额外开销，在不需要使用事务的情况下可以传入 False</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>pipe<span class=\"token operator\">=</span>conn<span class=\"token punctuation\">.</span>pipeline<span class=\"token punctuation\">(</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>操作<span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>操作<span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>操作<span class=\"token number\">3</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>pipe<span class=\"token punctuation\">.</span>execute<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h2 id=\"关于性能方面的注意事项\"><a class=\"anchor\" href=\"#关于性能方面的注意事项\">#</a> 关于性能方面的注意事项</h2>\n<blockquote>\n<p>redis-benchmark -c 1 -q</p>\n</blockquote>\n<p>&quot;-c 1&quot; 只使用一个客户端测试</p>\n<p>&quot;-q&quot; 简化输出</p>\n<pre><code>测试redis性能：\nC:\\Users\\guoxin&gt;redis-benchmark -c l -q\n\nresult（一秒内各个操作的执行次数）:\nPING_INLINE: 27495.19 requests per second\nPING_BULK: 28793.55 requests per second\nSET: 26903.42 requests per second\nGET: 28401.02 requests per second\nINCR: 28137.31 requests per second\nLPUSH: 27247.96 requests per second\nRPUSH: 27056.28 requests per second\nLPOP: 27181.30 requests per second\nRPOP: 27419.80 requests per second\nSADD: 28105.68 requests per second\nSPOP: 28137.31 requests per second\nLPUSH (needed to benchmark LRANGE): 27041.64 requests per second\nLRANGE_100 (first 100 elements): 16017.94 requests per second\nLRANGE_300 (first 300 elements): 8993.61 requests per second\nLRANGE_500 (first 450 elements): 6709.16 requests per second\nLRANGE_600 (first 600 elements): 5420.05 requests per second\nMSET (10 keys): 24709.66 requests per second\n\n# 该测试并非实际结果，该测试不会对命令进行回复。实际过程中性能只能达到测试的50%~60%\n\n注意：如果性能只能达到25%~30%或者客户端返回 “Cannot assign requested address”则说明在发送指令过程中可能再次创建了新连接\n\n</code></pre>\n",
            "tags": [
                "计算机科学",
                "学习笔记",
                "Redis"
            ]
        },
        {
            "id": "https://allengx.gitee.io/computer-science/study/python/python2%E5%92%8Cpython3%E5%B7%AE%E5%BC%82/",
            "url": "https://allengx.gitee.io/computer-science/study/python/python2%E5%92%8Cpython3%E5%B7%AE%E5%BC%82/",
            "title": "python2和python3差异",
            "date_published": "2020-04-12T12:46:25.000Z",
            "content_html": "<div class=\"note info\">\n<p>以下为个人学习笔记整理</p>\n</div>\n<h1 id=\"python2对比python3差异\"><a class=\"anchor\" href=\"#python2对比python3差异\">#</a> python2 对比 python3 差异</h1>\n<ul>\n<li><a href=\"#print is a Function\">print 函数调整</a></li>\n<li><a href=\"#Views And Iterators Instead Of Lists\">更多的地方返回值改为 「View」「Iteators」而不再是「List」</a></li>\n<li><a href=\"#Ordering\">比较功能的修改</a></li>\n<li><a href=\"#Integers\">整数部分的修改</a></li>\n<li><a href=\"#新语法\">新语法</a></li>\n<li><a href=\"#修改的语法\">修改的语法</a></li>\n<li><a href=\"#移除的语法\">移除的语法</a></li>\n</ul>\n<h2 id=\"print-is-a-function\"><a class=\"anchor\" href=\"#print-is-a-function\">#</a> print is a Function</h2>\n<p>​\t\tprint 不再是一个关键字，而是作为一个函数被使用。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Old<span class=\"token punctuation\">:</span> <span class=\"token keyword\">print</span> <span class=\"token string\">\"The answer is\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token operator\">*</span><span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>New<span class=\"token punctuation\">:</span> <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"The answer is\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h2 id=\"views-and-iterators-instead-of-lists\"><a class=\"anchor\" href=\"#views-and-iterators-instead-of-lists\">#</a> Views And Iterators Instead Of Lists</h2>\n<p>​\t\t部分函数的返回不再是 「list」 而是 「view」 或者 「iterators」</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Old<span class=\"token punctuation\">:</span> <span class=\"token builtin\">list</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">dict</span><span class=\"token punctuation\">.</span>keys<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> </pre></td></tr><tr><td data-num=\"2\"></td><td><pre>New<span class=\"token punctuation\">:</span> iterator <span class=\"token operator\">=</span> <span class=\"token builtin\">dict</span><span class=\"token punctuation\">.</span>keys<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>​\t\t不再支持部分接口</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">.</span>iterkeys<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">.</span>iteritems<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">.</span>itervalues<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>​\t\t部分函数的返回值修改为 iterator</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin\">zip</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token builtin\">filter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>​\t\trange 功能和 xrange 保持一致，xrange 不再被使用。</p>\n<p>##Ordering Comparisons</p>\n<p>​\t\t不同类型的对象之间进行比较会抛出 TypeError 异常</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Old<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;</span> <span class=\"token string\">\"\"</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token boolean\">True</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>New<span class=\"token punctuation\">:</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;</span> <span class=\"token string\">\"\"</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>TypeError<span class=\"token punctuation\">:</span> <span class=\"token string\">'&lt;'</span> <span class=\"token keyword\">not</span> supported between instances of <span class=\"token string\">'int'</span> <span class=\"token keyword\">and</span> <span class=\"token string\">'str'</span></pre></td></tr></table></figure><p>​\t\t部分函数被废弃</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin\">cmp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>__cmp__<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>​\t\t <code>builtin.sorted()</code>  and  <code>list.sort()</code>  不再支持 cmp 参数</p>\n<h2 id=\"integers\"><a class=\"anchor\" href=\"#integers\">#</a> Integers</h2>\n<p>​\t\tlong 类型更名为 int。int 类型将具备 long 类型的特性。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Old<span class=\"token punctuation\">:</span> <span class=\"token builtin\">long</span><span class=\"token punctuation\">(</span><span class=\"token number\">123</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>123L</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>New<span class=\"token punctuation\">:</span> <span class=\"token builtin\">long</span><span class=\"token punctuation\">(</span><span class=\"token number\">123</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>NameError<span class=\"token punctuation\">:</span> name <span class=\"token string\">'long'</span> <span class=\"token keyword\">is</span> <span class=\"token keyword\">not</span> defined</pre></td></tr></table></figure><p>​\t\t八进制函数表示差异</p>\n<pre><code>Old: 0666\nNew: 0o666\n</code></pre>\n<p>​\t\t删除了 sys.maxint 常量，int 类型大小和平台挂钩，不再依赖类型本身</p>\n<h2 id=\"text-vs-data-instead-of-unicode-vs-8-bit\"><a class=\"anchor\" href=\"#text-vs-data-instead-of-unicode-vs-8-bit\">#</a> Text Vs. Data Instead Of Unicode Vs. 8-bit</h2>\n<ul>\n<li>\n<p>废除了 8 位字符串和 Unicode 取而代之使用文本和数据加以区分。</p>\n</li>\n<li>\n<p>Unicode 文本不在需要用  <code>u</code>  来进行修饰，但二进制需要  <code>b</code>  进行修饰。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Old<span class=\"token punctuation\">:</span> <span class=\"token string\">u\"123\"</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token string\">u'123'</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>New<span class=\"token punctuation\">:</span> <span class=\"token string\">u\"123\"</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token string\">'123'</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>Old<span class=\"token punctuation\">:</span> <span class=\"token string\">b\"123\"</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token string\">'123'</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>New<span class=\"token punctuation\">:</span> <span class=\"token string\">b\"123\"</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token string\">b'123'</span></pre></td></tr></table></figure></li>\n<li>\n<p>StringIO 和 cStringIO 放入 io 模块了。</p>\n</li>\n<li>\n<p><code>basestring</code>  抽象类已被删除，使用 <code>str</code>  代替</p>\n</li>\n<li>\n<p><code>io.TextIOBase</code>  只支持读取 Unicode Text，读取字节流请使用 <code>io.TestIOBase.buffer</code></p>\n</li>\n</ul>\n<h2 id=\"新语法\"><a class=\"anchor\" href=\"#新语法\">#</a> 新语法</h2>\n<ul>\n<li>\n<p>支持通过  <code>__annotations__</code> 获取函数参数和返回值（<a href=\"https://www.python.org/dev/peps/pep-3107\"><strong>PEP 3107</strong></a>）</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>In<span class=\"token punctuation\">:</span> <span class=\"token keyword\">def</span> <span class=\"token function\">foobar</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">:</span> <span class=\"token string\">\"it's b\"</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span> <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">tuple</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">return</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>foobar<span class=\"token punctuation\">.</span>__annotations__</pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>Out<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">&#123;</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"it's b\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'c'</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'return'</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">tuple</span><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure></li>\n<li>\n<p>支持再可变参数后追加常规参数（<a href=\"https://www.python.org/dev/peps/pep-3102\"><strong>PEP 3102</strong></a>）</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>arg<span class=\"token punctuation\">,</span> defalut<span class=\"token operator\">=</span>false<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">pass</span></pre></td></tr></table></figure></li>\n<li>\n<p>加入 <code>nonlocal</code>  关键字用于显示的绑定非局部变量，避免在一些不必要的情况下自动从局部变量开始进行绑定。（<a href=\"https://www.python.org/dev/peps/pep-3104\"><strong>PEP 3104</strong></a>）</p>\n</li>\n<li>\n<p>扩展的可迭代拆包（<a href=\"https://www.python.org/dev/peps/pep-3132\"><strong>PEP 3132</strong></a>）</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Old<span class=\"token punctuation\">:</span> a<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>rest<span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>SyntaxError<span class=\"token punctuation\">:</span> invalid syntax</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>New<span class=\"token punctuation\">:</span> a<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>rest<span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>In<span class=\"token punctuation\">:</span> rest</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>Out<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"修改的语法\"><a class=\"anchor\" href=\"#修改的语法\">#</a> 修改的语法</h2>\n<ul>\n<li>\n<p>新的 <code>raise</code>  语句语法（<a href=\"https://www.python.org/dev/peps/pep-3109\"><strong>PEP 3109</strong></a> 和 <a href=\"https://www.python.org/dev/peps/pep-3134\"><strong>PEP 3134</strong></a>）</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>In<span class=\"token punctuation\">:</span> <span class=\"token keyword\">raise</span> ZeroDivisionError<span class=\"token punctuation\">,</span><span class=\"token string\">\"test error\"</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>Out<span class=\"token punctuation\">:</span> SyntaxError<span class=\"token punctuation\">:</span> invalid syntax</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>In<span class=\"token punctuation\">:</span> <span class=\"token keyword\">raise</span> ZeroDivisionError<span class=\"token punctuation\">(</span><span class=\"token string\">\"test error\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>Out<span class=\"token punctuation\">:</span> ZeroDivisionError<span class=\"token punctuation\">:</span> test error</pre></td></tr></table></figure></li>\n<li>\n<p>新的元类语法（<a href=\"https://www.python.org/dev/peps/pep-3115\"><strong>PEP 3115</strong></a>）</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Old<span class=\"token punctuation\">:</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">C</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    \t__metaclass__ <span class=\"token operator\">=</span> M</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>New<span class=\"token punctuation\">:</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">C</span><span class=\"token punctuation\">(</span>metaclass<span class=\"token operator\">=</span>M<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr></table></figure></li>\n<li>\n<p>加入 <code>...</code>  代表 <code>Ellipsis</code></p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Old<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>SyntaxError<span class=\"token punctuation\">:</span> invalid syntax</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>New<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>Ellipsis</pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"移除的语法\"><a class=\"anchor\" href=\"#移除的语法\">#</a> 移除的语法</h2>\n<ul>\n<li>\n<p>删除了元组参数拆包（<a href=\"https://www.python.org/dev/peps/pep-3113\"><strong>PEP 3113</strong></a>）</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Old<span class=\"token punctuation\">:</span> <span class=\"token keyword\">def</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">pass</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>SyntaxError<span class=\"token punctuation\">:</span> invalid syntax</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>New<span class=\"token punctuation\">:</span> <span class=\"token keyword\">def</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> combine<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    b<span class=\"token punctuation\">,</span> c <span class=\"token operator\">=</span> combine</pre></td></tr></table></figure></li>\n<li>\n<p>反引号 「` 」不能再代码中使用，取而代之用 repr</p>\n</li>\n<li>\n<p>删除  <code>&lt;&gt;</code>  用法，改为  <code>!=</code></p>\n</li>\n<li>\n<p>整数不再支持后缀 <code>L</code>  或 <code>l</code></p>\n</li>\n<li>\n<p>字符串不再支持前缀 <code>U</code>  或 <code>u</code></p>\n</li>\n<li>\n<p><code>from xxx import *</code>  不再支持用于函数内</p>\n</li>\n<li>\n<p>不以 <code>.</code>  作为开头的导入都被视为绝对导入（<a href=\"https://www.python.org/dev/peps/pep-0328\"><strong>PEP 328</strong></a>）</p>\n<pre><code>form .[module] import name(相对导入)\n</code></pre>\n</li>\n</ul>\n",
            "tags": [
                "计算机科学",
                "学习笔记",
                "Python",
                "Python"
            ]
        },
        {
            "id": "https://allengx.gitee.io/computer-science/study/python/python2%E8%A7%A3%E5%86%B3%E5%BC%82%E6%AD%A5%E5%8D%8F%E7%A8%8B%E9%97%AE%E9%A2%98/",
            "url": "https://allengx.gitee.io/computer-science/study/python/python2%E8%A7%A3%E5%86%B3%E5%BC%82%E6%AD%A5%E5%8D%8F%E7%A8%8B%E9%97%AE%E9%A2%98/",
            "title": "python2解决异步协程问题",
            "date_published": "2020-04-12T12:46:25.000Z",
            "content_html": "<div class=\"note info\">\n<p>以下为个人学习笔记整理</p>\n</div>\n<h1 id=\"yield的简单使用\"><a class=\"anchor\" href=\"#yield的简单使用\">#</a> yield 的简单使用</h1>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">Fuck</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">for</span> k<span class=\"token punctuation\">,</span> v <span class=\"token keyword\">in</span> <span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"1\"</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"2\"</span><span class=\"token punctuation\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"3\"</span><span class=\"token punctuation\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"4\"</span><span class=\"token punctuation\">:</span> <span class=\"token number\">4</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token keyword\">yield</span> k<span class=\"token punctuation\">,</span>v</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">for</span> k<span class=\"token punctuation\">,</span>v <span class=\"token keyword\">in</span> Fuck<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>k <span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h2 id=\"简单异步协程同步情况下会报错\"><a class=\"anchor\" href=\"#简单异步协程同步情况下会报错\">#</a> 简单异步协程（同步情况下会报错）</h2>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># -*- coding:utf-8 -*-</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> time</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> threading</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>g_func <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">asyncfunc</span><span class=\"token punctuation\">(</span>multiparams<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">def</span> <span class=\"token function\">decorator</span><span class=\"token punctuation\">(</span>func<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token keyword\">def</span> <span class=\"token function\">wrappedfunc</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kwargs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>            generator <span class=\"token operator\">=</span> func<span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kwargs<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> multiparams<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>                <span class=\"token keyword\">def</span> <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>                    <span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>                        generator<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>                    <span class=\"token keyword\">except</span> StopIteration<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>                        <span class=\"token keyword\">pass</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>                <span class=\"token keyword\">def</span> <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kwargs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>                    <span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>                        generator<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kwargs<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>                    <span class=\"token keyword\">except</span> StopIteration<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>                        <span class=\"token keyword\">pass</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>            generator<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span><span class=\"token boolean\">None</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>            <span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>                generator<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>            <span class=\"token keyword\">except</span> StopIteration<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>                <span class=\"token keyword\">pass</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>        <span class=\"token keyword\">return</span> wrappedfunc</pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token keyword\">return</span> decorator</pre></td></tr><tr><td data-num=\"31\"></td><td><pre></pre></td></tr><tr><td data-num=\"32\"></td><td><pre><span class=\"token decorator annotation punctuation\">@asyncfunc</span><span class=\"token punctuation\">(</span>multiparams<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">example</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>    obj <span class=\"token operator\">=</span> Obj<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>    cb <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>    obj <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> obj<span class=\"token punctuation\">.</span>Create<span class=\"token punctuation\">(</span>cb<span class=\"token punctuation\">)</span>    <span class=\"token comment\"># 异步创建</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>    obj <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> obj<span class=\"token punctuation\">.</span>Load<span class=\"token punctuation\">(</span>cb<span class=\"token punctuation\">)</span>      <span class=\"token comment\"># 异步加载</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"obj.m_Load :%s , obj.m_Create: %s\"</span><span class=\"token operator\">%</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">.</span>m_Load<span class=\"token punctuation\">,</span>obj<span class=\"token punctuation\">.</span>m_Create<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre></pre></td></tr><tr><td data-num=\"40\"></td><td><pre></pre></td></tr><tr><td data-num=\"41\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Obj</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>    <span class=\"token keyword\">def</span> <span class=\"token function\">Load</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> cb<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Load\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>        self<span class=\"token punctuation\">.</span>m_Load <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>        <span class=\"token keyword\">global</span> g_func</pre></td></tr><tr><td data-num=\"46\"></td><td><pre>        g_func<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">.</span>time<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> cb<span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>    <span class=\"token keyword\">def</span> <span class=\"token function\">Create</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> cb<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Create\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>        self<span class=\"token punctuation\">.</span>m_Create <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>        <span class=\"token keyword\">global</span> g_func</pre></td></tr><tr><td data-num=\"52\"></td><td><pre>        g_func<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">.</span>time<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> cb<span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre></pre></td></tr><tr><td data-num=\"54\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">Timer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>    <span class=\"token keyword\">global</span> g_func</pre></td></tr><tr><td data-num=\"56\"></td><td><pre>    <span class=\"token keyword\">while</span> <span class=\"token boolean\">True</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>        <span class=\"token keyword\">for</span> func <span class=\"token keyword\">in</span> g_func<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre>            <span class=\"token keyword\">if</span> time<span class=\"token punctuation\">.</span>time<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">></span>func<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"59\"></td><td><pre>                func<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>func<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>                g_func<span class=\"token punctuation\">.</span>remove<span class=\"token punctuation\">(</span>func<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre>        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Timer\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"62\"></td><td><pre>        time<span class=\"token punctuation\">.</span>sleep<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre></pre></td></tr><tr><td data-num=\"64\"></td><td><pre>example<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre>t1 <span class=\"token operator\">=</span> threading<span class=\"token punctuation\">.</span>Thread<span class=\"token punctuation\">(</span>target<span class=\"token operator\">=</span>Timer<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"66\"></td><td><pre>t1<span class=\"token punctuation\">.</span>start<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"67\"></td><td><pre></pre></td></tr><tr><td data-num=\"68\"></td><td><pre>result<span class=\"token punctuation\">:</span><span class=\"token operator\">-</span><span class=\"token operator\">-</span><span class=\"token operator\">-</span><span class=\"token operator\">-</span><span class=\"token operator\">-</span><span class=\"token operator\">-</span><span class=\"token operator\">-</span><span class=\"token operator\">-</span><span class=\"token operator\">-</span><span class=\"token operator\">-</span><span class=\"token operator\">-</span><span class=\"token operator\">-</span><span class=\"token operator\">-</span><span class=\"token operator\">-</span><span class=\"token operator\">-</span><span class=\"token operator\">-</span><span class=\"token operator\">-</span><span class=\"token operator\">-</span><span class=\"token operator\">-</span><span class=\"token operator\">-</span><span class=\"token operator\">-</span><span class=\"token operator\">-</span><span class=\"token operator\">-</span><span class=\"token operator\">-</span><span class=\"token operator\">-</span><span class=\"token operator\">-</span></pre></td></tr><tr><td data-num=\"69\"></td><td><pre>Create</pre></td></tr><tr><td data-num=\"70\"></td><td><pre>Timer</pre></td></tr><tr><td data-num=\"71\"></td><td><pre>Load</pre></td></tr><tr><td data-num=\"72\"></td><td><pre>Timer</pre></td></tr><tr><td data-num=\"73\"></td><td><pre>obj<span class=\"token punctuation\">.</span>m_Load <span class=\"token punctuation\">:</span><span class=\"token boolean\">True</span> <span class=\"token punctuation\">,</span> obj<span class=\"token punctuation\">.</span>m_Create<span class=\"token punctuation\">:</span> <span class=\"token boolean\">True</span></pre></td></tr><tr><td data-num=\"74\"></td><td><pre>Timer</pre></td></tr><tr><td data-num=\"75\"></td><td><pre>Timer</pre></td></tr></table></figure><h2 id=\"tornado协程coroutine原理\"><a class=\"anchor\" href=\"#tornado协程coroutine原理\">#</a> tornado 协程 (coroutine) 原理</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d5eDgxOS9hcnRpY2xlL2RldGFpbHMvNDU0MjAwMTc=\">https://blog.csdn.net/wyx819/article/details/45420017</span></p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># -*- coding:utf-8 -*-</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">import</span> logging</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> functools</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">import</span> sys</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">import</span> types</pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Return</span><span class=\"token punctuation\">(</span>Exception<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token triple-quoted-string string\">\"\"\"</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    用于存储返回结果的自定义异常</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    \"\"\"</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> value<span class=\"token operator\">=</span><span class=\"token boolean\">None</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token builtin\">super</span><span class=\"token punctuation\">(</span>Return<span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>__init__<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        self<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> value</pre></td></tr></table></figure><figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Future</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">object</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token triple-quoted-string string\">\"\"\"</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    用于保存异步调用后的结果及回调函数对象</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    \"\"\"</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token builtin\">super</span><span class=\"token punctuation\">(</span>Future<span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>__init__<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        self<span class=\"token punctuation\">.</span>_callbacks <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        self<span class=\"token punctuation\">.</span>_done <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        self<span class=\"token punctuation\">.</span>_result <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        self<span class=\"token punctuation\">.</span>_exec_info <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">def</span> <span class=\"token function\">done</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token keyword\">return</span> self<span class=\"token punctuation\">.</span>_done</pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token keyword\">def</span> <span class=\"token function\">result</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> timeout<span class=\"token operator\">=</span><span class=\"token boolean\">None</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token keyword\">if</span> self<span class=\"token punctuation\">.</span>_result <span class=\"token keyword\">is</span> <span class=\"token keyword\">not</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>            <span class=\"token keyword\">return</span> self<span class=\"token punctuation\">.</span>_result</pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token keyword\">assert</span> self<span class=\"token punctuation\">.</span>_done</pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token keyword\">return</span> self<span class=\"token punctuation\">.</span>_result</pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token keyword\">def</span> <span class=\"token function\">add_done_callback</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> fn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token keyword\">if</span> self<span class=\"token punctuation\">.</span>_done<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>            fn<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>            self<span class=\"token punctuation\">.</span>_callbacks<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token keyword\">def</span> <span class=\"token function\">_set_done</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>        self<span class=\"token punctuation\">.</span>_done <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>        <span class=\"token keyword\">for</span> cd <span class=\"token keyword\">in</span> self<span class=\"token punctuation\">.</span>_callbacks<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>            <span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>                cd<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>            <span class=\"token keyword\">except</span> Exception <span class=\"token keyword\">as</span> e<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>                logging<span class=\"token punctuation\">.</span>exception<span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>        self<span class=\"token punctuation\">.</span>_callbacks <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>    <span class=\"token keyword\">def</span> <span class=\"token function\">set_result</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>        self<span class=\"token punctuation\">.</span>_result <span class=\"token operator\">=</span> result</pre></td></tr><tr><td data-num=\"39\"></td><td><pre>        self<span class=\"token punctuation\">.</span>_set_done<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>    <span class=\"token keyword\">def</span> <span class=\"token function\">set_exec_info</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> exec_info<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>        self<span class=\"token punctuation\">.</span>_set_done<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>        self<span class=\"token punctuation\">.</span>_exec_info <span class=\"token operator\">=</span> exec_info</pre></td></tr><tr><td data-num=\"44\"></td><td><pre></pre></td></tr><tr><td data-num=\"45\"></td><td><pre></pre></td></tr><tr><td data-num=\"46\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">is_future</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token builtin\">isinstance</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">,</span> Future<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">IOLoop</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">object</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kwargs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token builtin\">super</span><span class=\"token punctuation\">(</span>IOLoop<span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>__init__<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        self<span class=\"token punctuation\">.</span>running <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token decorator annotation punctuation\">@classmethod</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">def</span> <span class=\"token function\">current</span><span class=\"token punctuation\">(</span>cls<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token keyword\">return</span> g_IOLoop</pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">def</span> <span class=\"token function\">add_future</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> future<span class=\"token punctuation\">,</span> callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token triple-quoted-string string\">\"\"\"</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        把回调函数加入future对象内</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        :param future:</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        :param callback:</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        :return:</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        \"\"\"</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token keyword\">assert</span> <span class=\"token builtin\">isinstance</span><span class=\"token punctuation\">(</span>future<span class=\"token punctuation\">,</span> Future<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        future<span class=\"token punctuation\">.</span>add_done_callback<span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>            <span class=\"token keyword\">lambda</span> future<span class=\"token punctuation\">:</span> self<span class=\"token punctuation\">.</span>add_callback<span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">,</span> future<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token keyword\">def</span> <span class=\"token function\">add_callback</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> callback<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kwargs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        func <span class=\"token operator\">=</span> functools<span class=\"token punctuation\">.</span>partial<span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kwargs<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        self<span class=\"token punctuation\">.</span>_run_callback<span class=\"token punctuation\">(</span>func<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token keyword\">def</span> <span class=\"token function\">_run_callback</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        ret <span class=\"token operator\">=</span> callback<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>        <span class=\"token keyword\">if</span> ret <span class=\"token keyword\">is</span> <span class=\"token keyword\">not</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>            <span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>                ret <span class=\"token operator\">=</span> convert_yielded<span class=\"token punctuation\">(</span>ret<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>            <span class=\"token keyword\">except</span> BadYieldError<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>                <span class=\"token keyword\">pass</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>                self<span class=\"token punctuation\">.</span>add_future<span class=\"token punctuation\">(</span>ret<span class=\"token punctuation\">,</span> <span class=\"token keyword\">lambda</span> fn<span class=\"token punctuation\">:</span> fn<span class=\"token punctuation\">.</span>result<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre></pre></td></tr><tr><td data-num=\"36\"></td><td><pre></pre></td></tr><tr><td data-num=\"37\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">coroutine</span><span class=\"token punctuation\">(</span>func<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>    <span class=\"token triple-quoted-string string\">\"\"\"</pre></td></tr><tr><td data-num=\"39\"></td><td><pre>    functools.wraps用来保留原函数信息，避免被迭代器取代</pre></td></tr><tr><td data-num=\"40\"></td><td><pre>    :param func:</pre></td></tr><tr><td data-num=\"41\"></td><td><pre>    :return:</pre></td></tr><tr><td data-num=\"42\"></td><td><pre>    \"\"\"</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>    <span class=\"token decorator annotation punctuation\">@functools<span class=\"token punctuation\">.</span>wraps</span><span class=\"token punctuation\">(</span>func<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>    <span class=\"token keyword\">def</span> <span class=\"token function\">wrapper</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kwargs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>        future <span class=\"token operator\">=</span> Future<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>        <span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>            result <span class=\"token operator\">=</span> func<span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kwargs<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>        <span class=\"token keyword\">except</span> <span class=\"token punctuation\">(</span>StopIteration<span class=\"token punctuation\">,</span> Return<span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> e<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>            result <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>value</pre></td></tr><tr><td data-num=\"51\"></td><td><pre>        <span class=\"token keyword\">except</span> Exception <span class=\"token keyword\">as</span> e<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>            logging<span class=\"token punctuation\">.</span>exception<span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>            future<span class=\"token punctuation\">.</span>set_exec_info<span class=\"token punctuation\">(</span>sys<span class=\"token punctuation\">.</span>exc_info<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>            <span class=\"token keyword\">return</span> future</pre></td></tr><tr><td data-num=\"55\"></td><td><pre>        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token builtin\">isinstance</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span> types<span class=\"token punctuation\">.</span>GeneratorType<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>                <span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre>                    generator <span class=\"token operator\">=</span> result</pre></td></tr><tr><td data-num=\"59\"></td><td><pre>                    yielded <span class=\"token operator\">=</span> <span class=\"token builtin\">next</span><span class=\"token punctuation\">(</span>generator<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>                <span class=\"token keyword\">except</span> <span class=\"token punctuation\">(</span>StopIteration<span class=\"token punctuation\">,</span> Return<span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> e<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre>                    future<span class=\"token punctuation\">.</span>set_result<span class=\"token punctuation\">(</span><span class=\"token builtin\">getattr</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">,</span> <span class=\"token string\">\"value\"</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"62\"></td><td><pre>                <span class=\"token keyword\">except</span> Exception <span class=\"token keyword\">as</span> e<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre>                    logging<span class=\"token punctuation\">.</span>exception<span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"64\"></td><td><pre>                    future<span class=\"token punctuation\">.</span>set_exec_info<span class=\"token punctuation\">(</span>sys<span class=\"token punctuation\">.</span>exc_info<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre>                <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"66\"></td><td><pre>                    Runner<span class=\"token punctuation\">(</span>generator<span class=\"token punctuation\">,</span> future<span class=\"token punctuation\">,</span> yielded<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"67\"></td><td><pre>                <span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"68\"></td><td><pre>                    <span class=\"token keyword\">return</span> future</pre></td></tr><tr><td data-num=\"69\"></td><td><pre>                <span class=\"token keyword\">finally</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"70\"></td><td><pre>                    <span class=\"token triple-quoted-string string\">\"\"\"</pre></td></tr><tr><td data-num=\"71\"></td><td><pre>                    此处为了解除环引用问题</pre></td></tr><tr><td data-num=\"72\"></td><td><pre>                    Exception 中会存在 future 引用</pre></td></tr><tr><td data-num=\"73\"></td><td><pre>                    future._exec_info 也会有 Exception 的引用</pre></td></tr><tr><td data-num=\"74\"></td><td><pre>                    \"\"\"</span></pre></td></tr><tr><td data-num=\"75\"></td><td><pre>                    future <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span></pre></td></tr><tr><td data-num=\"76\"></td><td><pre>        future<span class=\"token punctuation\">.</span>set_result<span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"77\"></td><td><pre>        <span class=\"token keyword\">return</span> future</pre></td></tr><tr><td data-num=\"78\"></td><td><pre></pre></td></tr><tr><td data-num=\"79\"></td><td><pre>    <span class=\"token keyword\">return</span> wrapper</pre></td></tr></table></figure><figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Runner</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">object</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token triple-quoted-string string\">\"\"\"</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    执行send函数来对生成器进行迭代</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    \"\"\"</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> generator<span class=\"token punctuation\">,</span> result_future<span class=\"token punctuation\">,</span> first_yielded<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token triple-quoted-string string\">\"\"\"</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        创建保存生成器现状的对象</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        :param generator: 生成器本身</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        :param result_future: 含有执行结果的 future</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        :param first_yielded: 生成器的第一个 yield 后的值</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        \"\"\"</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        self<span class=\"token punctuation\">.</span>generator <span class=\"token operator\">=</span> generator</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        self<span class=\"token punctuation\">.</span>result_future <span class=\"token operator\">=</span> result_future</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        self<span class=\"token punctuation\">.</span>future <span class=\"token operator\">=</span> g_null_future</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        self<span class=\"token punctuation\">.</span>running <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        self<span class=\"token punctuation\">.</span>finish <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        self<span class=\"token punctuation\">.</span>had_exception <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        self<span class=\"token punctuation\">.</span>io_loop <span class=\"token operator\">=</span> IOLoop<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token keyword\">if</span> self<span class=\"token punctuation\">.</span>handle_yielded<span class=\"token punctuation\">(</span>first_yielded<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>            self<span class=\"token punctuation\">.</span>run<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token keyword\">def</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        <span class=\"token keyword\">if</span> self<span class=\"token punctuation\">.</span>running <span class=\"token keyword\">or</span> self<span class=\"token punctuation\">.</span>finish<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>            <span class=\"token keyword\">return</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>            self<span class=\"token punctuation\">.</span>running <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>            <span class=\"token keyword\">while</span> <span class=\"token boolean\">True</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>                future <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>future</pre></td></tr><tr><td data-num=\"30\"></td><td><pre>                <span class=\"token triple-quoted-string string\">\"\"\"</pre></td></tr><tr><td data-num=\"31\"></td><td><pre>                如果 future 里面的回调还没执行，先不send 避免出现 yield 还没阻塞就 send 引发的异常</pre></td></tr><tr><td data-num=\"32\"></td><td><pre>                如果 future 已经执行了回调，里面必然有 result</pre></td></tr><tr><td data-num=\"33\"></td><td><pre>                如果 future 本身不是Future类型，抛出错误</pre></td></tr><tr><td data-num=\"34\"></td><td><pre>                \"\"\"</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>                <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> future<span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>                    <span class=\"token keyword\">return</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>                self<span class=\"token punctuation\">.</span>future <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>                <span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>                    <span class=\"token triple-quoted-string string\">\"\"\"</pre></td></tr><tr><td data-num=\"40\"></td><td><pre>                    1、正常执行：代表生成器还没有迭代完毕，进入下一轮迭代 得到 下一个 yield 右边值 正常情况下是 Future对象</pre></td></tr><tr><td data-num=\"41\"></td><td><pre>                    2、StopIteration or Return 异常：迭代结束 得到return 结果 或者得到 raise Retuen 对象里的 value</pre></td></tr><tr><td data-num=\"42\"></td><td><pre>                    3、Exception 函数本身执行错误，直接抛出异常</pre></td></tr><tr><td data-num=\"43\"></td><td><pre>                    \"\"\"</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>                    <span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>                        value <span class=\"token operator\">=</span> future<span class=\"token punctuation\">.</span>result<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>                    <span class=\"token keyword\">except</span> Exception <span class=\"token keyword\">as</span> e<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>                        logging<span class=\"token punctuation\">.</span>exception<span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>                        self<span class=\"token punctuation\">.</span>had_exception <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>                        yielded <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>generator<span class=\"token punctuation\">.</span>throw<span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>sys<span class=\"token punctuation\">.</span>exc_info<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>                    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>                        yielded <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>generator<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>                <span class=\"token keyword\">except</span> <span class=\"token punctuation\">(</span>StopIteration<span class=\"token punctuation\">,</span> Return<span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> e<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>                    <span class=\"token triple-quoted-string string\">\"\"\"</pre></td></tr><tr><td data-num=\"54\"></td><td><pre>                    生成器执行结束</pre></td></tr><tr><td data-num=\"55\"></td><td><pre>                        1、迭代终止抛出 StopIteration 异常，返回值return 会被保存在 StopIteration 的 value 属性里</pre></td></tr><tr><td data-num=\"56\"></td><td><pre>                        2、主动 raise Return 异常，raise Return(value)</pre></td></tr><tr><td data-num=\"57\"></td><td><pre>                    把异常中的结果返回给 result_future</pre></td></tr><tr><td data-num=\"58\"></td><td><pre>                    \"\"\"</span></pre></td></tr><tr><td data-num=\"59\"></td><td><pre>                    self<span class=\"token punctuation\">.</span>finish <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>                    self<span class=\"token punctuation\">.</span>future <span class=\"token operator\">=</span> g_null_future</pre></td></tr><tr><td data-num=\"61\"></td><td><pre>                    self<span class=\"token punctuation\">.</span>result_future<span class=\"token punctuation\">.</span>set_result<span class=\"token punctuation\">(</span><span class=\"token builtin\">getattr</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">,</span> <span class=\"token string\">\"value\"</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"62\"></td><td><pre>                    self<span class=\"token punctuation\">.</span>result_future <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span>  <span class=\"token comment\"># 断开引用</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre>                    <span class=\"token keyword\">return</span></pre></td></tr><tr><td data-num=\"64\"></td><td><pre>                <span class=\"token keyword\">except</span> Exception<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre>                    self<span class=\"token punctuation\">.</span>finish <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span></pre></td></tr><tr><td data-num=\"66\"></td><td><pre>                    self<span class=\"token punctuation\">.</span>future <span class=\"token operator\">=</span> g_null_future</pre></td></tr><tr><td data-num=\"67\"></td><td><pre>                    self<span class=\"token punctuation\">.</span>result_future<span class=\"token punctuation\">.</span>set_result<span class=\"token punctuation\">(</span>sys<span class=\"token punctuation\">.</span>exc_info<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"68\"></td><td><pre>                    self<span class=\"token punctuation\">.</span>result_future <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span>  <span class=\"token comment\"># 断开引用</span></pre></td></tr><tr><td data-num=\"69\"></td><td><pre>                    <span class=\"token keyword\">raise</span> Exception</pre></td></tr><tr><td data-num=\"70\"></td><td><pre>                <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> self<span class=\"token punctuation\">.</span>handle_yielded<span class=\"token punctuation\">(</span>yielded<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"71\"></td><td><pre>                    <span class=\"token keyword\">return</span></pre></td></tr><tr><td data-num=\"72\"></td><td><pre>        <span class=\"token keyword\">finally</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"73\"></td><td><pre>            self<span class=\"token punctuation\">.</span>running <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span></pre></td></tr><tr><td data-num=\"74\"></td><td><pre></pre></td></tr><tr><td data-num=\"75\"></td><td><pre>    <span class=\"token keyword\">def</span> <span class=\"token function\">handle_yielded</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> yielded<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"76\"></td><td><pre>        <span class=\"token triple-quoted-string string\">\"\"\"</pre></td></tr><tr><td data-num=\"77\"></td><td><pre>        如果生成器存在多个 yield 则每次 send 后 得到下一个 yielded 用来执行下一次 send 或者 raise Return 去返回结果</pre></td></tr><tr><td data-num=\"78\"></td><td><pre>        :param yielded:  下一个yield 的 右侧结果</pre></td></tr><tr><td data-num=\"79\"></td><td><pre>        :return:</pre></td></tr><tr><td data-num=\"80\"></td><td><pre>        \"\"\"</span></pre></td></tr><tr><td data-num=\"81\"></td><td><pre>        <span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"82\"></td><td><pre>            self<span class=\"token punctuation\">.</span>future <span class=\"token operator\">=</span> convert_yielded<span class=\"token punctuation\">(</span>yielded<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"83\"></td><td><pre>        <span class=\"token keyword\">except</span> BadYieldError<span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"84\"></td><td><pre>            self<span class=\"token punctuation\">.</span>future <span class=\"token operator\">=</span> Future<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"85\"></td><td><pre>            self<span class=\"token punctuation\">.</span>future<span class=\"token punctuation\">.</span>set_result<span class=\"token punctuation\">(</span>sys<span class=\"token punctuation\">.</span>exc_info<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"86\"></td><td><pre></pre></td></tr><tr><td data-num=\"87\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> self<span class=\"token punctuation\">.</span>future<span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"88\"></td><td><pre>            self<span class=\"token punctuation\">.</span>io_loop<span class=\"token punctuation\">.</span>add_future<span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"89\"></td><td><pre>                self<span class=\"token punctuation\">.</span>future<span class=\"token punctuation\">,</span> <span class=\"token keyword\">lambda</span> fn<span class=\"token punctuation\">:</span> self<span class=\"token punctuation\">.</span>run<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"90\"></td><td><pre>            <span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"91\"></td><td><pre>            <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span></pre></td></tr><tr><td data-num=\"92\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span></pre></td></tr><tr><td data-num=\"93\"></td><td><pre></pre></td></tr><tr><td data-num=\"94\"></td><td><pre></pre></td></tr><tr><td data-num=\"95\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">convert_yielded</span><span class=\"token punctuation\">(</span>yielded<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"96\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token builtin\">isinstance</span><span class=\"token punctuation\">(</span>yielded<span class=\"token punctuation\">,</span> Future<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"97\"></td><td><pre>        <span class=\"token keyword\">return</span> yielded</pre></td></tr><tr><td data-num=\"98\"></td><td><pre>    <span class=\"token keyword\">raise</span> BadYieldError<span class=\"token punctuation\">(</span><span class=\"token string\">\"yielded type error %r\"</span> <span class=\"token operator\">%</span> <span class=\"token punctuation\">(</span>yielded<span class=\"token punctuation\">,</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"99\"></td><td><pre></pre></td></tr><tr><td data-num=\"100\"></td><td><pre></pre></td></tr><tr><td data-num=\"101\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">BadYieldError</span><span class=\"token punctuation\">(</span>Exception<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"102\"></td><td><pre>    <span class=\"token keyword\">pass</span></pre></td></tr><tr><td data-num=\"103\"></td><td><pre></pre></td></tr><tr><td data-num=\"104\"></td><td><pre></pre></td></tr><tr><td data-num=\"105\"></td><td><pre><span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> <span class=\"token string\">\"g_IOLoop\"</span> <span class=\"token keyword\">in</span> <span class=\"token builtin\">globals</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"106\"></td><td><pre>    g_IOLoop <span class=\"token operator\">=</span> IOLoop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"107\"></td><td><pre></pre></td></tr><tr><td data-num=\"108\"></td><td><pre><span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> <span class=\"token string\">\"g_null_future\"</span> <span class=\"token keyword\">in</span> <span class=\"token builtin\">globals</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"109\"></td><td><pre>    <span class=\"token triple-quoted-string string\">\"\"\"</pre></td></tr><tr><td data-num=\"110\"></td><td><pre>    用来在特殊情况下推出函数的Future</pre></td></tr><tr><td data-num=\"111\"></td><td><pre>    \"\"\"</span></pre></td></tr><tr><td data-num=\"112\"></td><td><pre>    g_null_future <span class=\"token operator\">=</span> Future<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"113\"></td><td><pre>    g_null_future<span class=\"token punctuation\">.</span>set_result<span class=\"token punctuation\">(</span><span class=\"token boolean\">None</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">################### test</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>async_future2 <span class=\"token operator\">=</span> Future<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>async_future4 <span class=\"token operator\">=</span> Future<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token decorator annotation punctuation\">@coroutine</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">Test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token triple-quoted-string string\">\"\"\"</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    支持多函数嵌套调用</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    异步消息回调顺序可以不同</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    :return:</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    \"\"\"</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    ret2 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> Test2<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    ret4 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> Test4<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"异步/同步调用返回结果 %r，%r\"</span> <span class=\"token operator\">%</span> <span class=\"token punctuation\">(</span>ret2<span class=\"token punctuation\">,</span>ret4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token decorator annotation punctuation\">@coroutine</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">Test2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token triple-quoted-string string\">\"\"\"</pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    py3 return ret 和 raise Return(ret) 都可，py2 只能 raise Return(ret)</pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    :return:</pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    \"\"\"</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    ret <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> Test3<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">#future</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token comment\"># raise Return(ret)</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token keyword\">return</span> ret</pre></td></tr><tr><td data-num=\"28\"></td><td><pre></pre></td></tr><tr><td data-num=\"29\"></td><td><pre></pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">Test3</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    <span class=\"token triple-quoted-string string\">\"\"\"</pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    如果没有 yield 返回值必须是 Future 类型</pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    :return:</pre></td></tr><tr><td data-num=\"34\"></td><td><pre>    \"\"\"</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>    future <span class=\"token operator\">=</span> async_future2</pre></td></tr><tr><td data-num=\"36\"></td><td><pre>    <span class=\"token keyword\">return</span> future</pre></td></tr><tr><td data-num=\"37\"></td><td><pre></pre></td></tr><tr><td data-num=\"38\"></td><td><pre><span class=\"token decorator annotation punctuation\">@coroutine</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">Test4</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>    ret <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> Test5<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># future(4)</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>    <span class=\"token keyword\">return</span> ret</pre></td></tr><tr><td data-num=\"42\"></td><td><pre></pre></td></tr><tr><td data-num=\"43\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">Test5</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>    future <span class=\"token operator\">=</span> async_future4</pre></td></tr><tr><td data-num=\"45\"></td><td><pre>    <span class=\"token keyword\">return</span> future</pre></td></tr><tr><td data-num=\"46\"></td><td><pre></pre></td></tr><tr><td data-num=\"47\"></td><td><pre></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>Test<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre></pre></td></tr><tr><td data-num=\"50\"></td><td><pre><span class=\"token comment\"># 该函数可以在本地同帧下调用也可在远程调用后回调</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>async_future4<span class=\"token punctuation\">.</span>set_result<span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>async_future2<span class=\"token punctuation\">.</span>set_result<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure>",
            "tags": [
                "计算机科学",
                "学习笔记",
                "Python",
                "Python"
            ]
        },
        {
            "id": "https://allengx.gitee.io/computer-science/study/micro-service/istio/Istio%E7%AE%80%E4%BB%8B&&%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/",
            "url": "https://allengx.gitee.io/computer-science/study/micro-service/istio/Istio%E7%AE%80%E4%BB%8B&&%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/",
            "title": "Istio简介&&服务网格",
            "date_published": "2020-04-12T12:46:25.000Z",
            "content_html": "<div class=\"note info\">\n<p>以下为个人学习笔记整理</p>\n</div>\n<h2 id=\"istio-服务网格\"><a class=\"anchor\" href=\"#istio-服务网格\">#</a> Istio 服务网格</h2>\n<p>Istio 是运行于分布式应用程序之上的<strong>非侵入式（无代码入侵）服务网格系统</strong>，为了更好更轻松的解决服务指令问题。</p>\n<h3 id=\"服务网格是什么\"><a class=\"anchor\" href=\"#服务网格是什么\">#</a> 服务网格是什么</h3>\n<p><strong>服务网格</strong>用来描述组成这些应用程序的微服务网络以及它们之间的交互。随着服务网格的规模和复杂性不断的增长，它将会变得越来越难以理解和管理。它的需求包括：</p>\n<ul>\n<li>服务发现</li>\n<li>负载均衡</li>\n<li>故障恢复</li>\n<li>度量和监控</li>\n<li>A/B 测试</li>\n<li>金丝雀发布</li>\n<li>流量限制</li>\n<li>访问控制</li>\n<li>端到端认证</li>\n</ul>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200827203851769.png\" alt=\"image-20200827203851769\" /></p>\n<h3 id=\"什么是-istio\"><a class=\"anchor\" href=\"#什么是-istio\">#</a> 什么是 Istio</h3>\n<p>一个为微服务提供网络通信的代理。为每个微服务部署一个 Sidecar。然后通过使用其控制平面功能配置和管理 Istio，可以为服务添加 Istio 支持，包括：</p>\n<ul>\n<li>HTTP，gRPC，WebSocket 和 TCP 通信的自动负载平衡。</li>\n<li>通过丰富的路由规则，重试，故障转移和故障注入对流量行为进行精细控制。</li>\n<li>可插拔的策略层和配置 API，支持访问控制，速率限制和配额。</li>\n<li>群集内所有流量的自动指标，日志和跟踪，包括群集的入口和出口。</li>\n<li>通过强大的基于身份的身份验证和授权，确保群集中服务之间的通信安全。</li>\n</ul>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200827204217917.png\" alt=\"image-20200827204217917\" /></p>\n<p>总体上看，Istio 的服务网格由数据平面和控制平面两部分组成：</p>\n<ul>\n<li>\n<p><strong>数据平面</strong>：由一系列作为 Sidecar 部署的智能代理（Envoy）构成。这些代理联合 Mixer，中继，控制所有微服务之间的网络通信。需要注意，还有一些 Envoy 的 hi 独立部署（而非 Sidecar）的，用来实现 Kubernetes Ingress 控制器，Istio 的 Ingress/Egress 网关</p>\n</li>\n<li>\n<p><strong>控制平面</strong>：负责管理、配置智能代理，实现流量路由；配置 Citadel 实现 TLS 证书管理；配置 Mixers 来应用策略、收集指标帧。</p>\n</li>\n</ul>\n<h3 id=\"istio组件\"><a class=\"anchor\" href=\"#istio组件\">#</a> Istio 组件</h3>\n<ul>\n<li>\n<p><strong>Envoy：</strong> 高性能的代理，具备以下特性</p>\n<ul>\n<li>动态服务发现</li>\n<li>负责均衡</li>\n<li>TLS termination（可将 HTTP 请求伪装成 HTTPS）</li>\n<li>HTTP/2 和 gRPC 代理</li>\n<li>断路器</li>\n<li>健康检查</li>\n<li>分阶段（基于流百分比）发布</li>\n<li>故障注入</li>\n<li>丰富的监控指标</li>\n</ul>\n</li>\n<li>\n<p><strong>Pilot：</strong> 监控器，监测配置、规则、策略的变化并同步给 Envoy</p>\n<ul>\n<li>为 Envoy 提供服务发现</li>\n<li>为智能路由（AB 测试、金丝雀部署）</li>\n<li>提供弹性（超时、重试、断路器）</li>\n<li>分发身份验证策略给 Envoy</li>\n</ul>\n</li>\n<li>\n<p><strong>Mixer：</strong> 无关平台的组件</p>\n<ul>\n<li>为服务网格提供访问控制策略</li>\n<li>收集服务中的各项指标</li>\n<li>对收集的信息进行分析</li>\n</ul>\n</li>\n<li>\n<p><strong>Citadel：</strong> 提供服务与服务之间、或者针对终端用户的身份验证功能，可以加密网络中的流量</p>\n</li>\n<li>\n<p><strong>Kiali：</strong> 提供统一的可视化界面</p>\n</li>\n</ul>\n",
            "tags": [
                "计算机科学",
                "学习笔记",
                "微服务",
                "Istio"
            ]
        },
        {
            "id": "https://allengx.gitee.io/computer-science/study/micro-service/helm/Helm%E7%AE%80%E4%BB%8B&&%E5%8C%85%E7%AE%A1%E7%90%86/",
            "url": "https://allengx.gitee.io/computer-science/study/micro-service/helm/Helm%E7%AE%80%E4%BB%8B&&%E5%8C%85%E7%AE%A1%E7%90%86/",
            "title": "Helm简介&&包管理",
            "date_published": "2020-04-12T12:46:25.000Z",
            "content_html": "<div class=\"note info\">\n<p>以下为个人学习笔记整理</p>\n</div>\n<h2 id=\"helm\"><a class=\"anchor\" href=\"#helm\">#</a> Helm</h2>\n<p>Helm 是一个 Kubernetes 应用的包管理工具</p>\n<ul>\n<li>Helm：客户端工具，用于为 Kubernetes 应用程序提供 Chart 的创建、打包、发布，并管理本地和远程 Chart 仓库</li>\n<li>Tiller：服务端，需要部署在 Kubernetes 集群中，接受 Helm 请求，并根据 Chart 生成 Kubernetes 的部署文件（Release），然后交给 Kubernetes 创建应用。并且提供了 Release 的升级、删除、回滚等功能。</li>\n<li>Chart：Helm 的软件包，Tar 格式。其定义了一组 Kubernetes 资源配置相关的 Yaml 文件。常见的 Chart 大概一下几种：\n<ul>\n<li>service 配置文件（.yaml）</li>\n<li>deployment 配置文件</li>\n<li>pv 配置文件</li>\n<li>pvc 配置文件</li>\n<li>config-map 配置文件</li>\n</ul>\n</li>\n<li>Repoistory：Helm 的软件仓库，本质是个 Web 服务器，用于存放 Chart 供用户下载，Helm 可以管理多个 Repository。</li>\n<li>Release：用 helm install 命令在 Kubernetes 集群中部署的 Chart 称为 Release</li>\n</ul>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200827192009589.png\" alt=\"image-20200827192009589\" /></p>\n",
            "tags": [
                "计算机科学",
                "学习笔记",
                "微服务",
                "Helm"
            ]
        },
        {
            "id": "https://allengx.gitee.io/computer-science/study/micro-service/kubernetes/Kubernetes%E6%9E%84%E5%BB%BA%E7%8E%AF%E5%A2%83/",
            "url": "https://allengx.gitee.io/computer-science/study/micro-service/kubernetes/Kubernetes%E6%9E%84%E5%BB%BA%E7%8E%AF%E5%A2%83/",
            "title": "Kubernetes构建环境",
            "date_published": "2020-04-12T12:46:25.000Z",
            "content_html": "<div class=\"note info\">\n<p>以下为个人学习笔记整理</p>\n</div>\n<h2 id=\"kubernetes环境构建\"><a class=\"anchor\" href=\"#kubernetes环境构建\">#</a> Kubernetes 环境构建</h2>\n<h3 id=\"前提环境\"><a class=\"anchor\" href=\"#前提环境\">#</a> 前提环境：</h3>\n<ul>\n<li>ubuntu 18.04/ubuntu 16.04</li>\n<li>2GB 内存</li>\n<li>20G 硬盘</li>\n<li>CPU 一定要 2 核以上（否则会装不了 kubernetes）</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 查看逻辑 CPU 的个数</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">cat</span> /proc/cpuinfo<span class=\"token operator\">|</span> <span class=\"token function\">grep</span> <span class=\"token string\">\"processor\"</span><span class=\"token operator\">|</span> <span class=\"token function\">wc</span> -l</pre></td></tr></table></figure><h3 id=\"节点配置\"><a class=\"anchor\" href=\"#节点配置\">#</a> 节点配置</h3>\n<table>\n<thead>\n<tr>\n<th>主机名</th>\n<th>IP</th>\n<th>角色</th>\n<th>系统</th>\n<th>CPU / 内存</th>\n<th>磁盘</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>kubernetes-master</td>\n<td>10.0.2.110</td>\n<td>Master</td>\n<td>ubuntu 16.04</td>\n<td>2 核 2G</td>\n<td>20G</td>\n</tr>\n<tr>\n<td>kubernetes-node-01</td>\n<td>10.0.2.120</td>\n<td>Node</td>\n<td>ubuntu 16.04</td>\n<td>2 核 2G</td>\n<td>20G</td>\n</tr>\n<tr>\n<td>kubernetes-node-02</td>\n<td>10.0.2.121</td>\n<td>Node</td>\n<td>ubuntu 16.04</td>\n<td>2 核 2G</td>\n<td>20G</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"部署步骤\"><a class=\"anchor\" href=\"#部署步骤\">#</a> 部署步骤</h3>\n<h4 id=\"环境部署\"><a class=\"anchor\" href=\"#环境部署\">#</a> 环境部署</h4>\n<h5 id=\"通用部署流程\"><a class=\"anchor\" href=\"#通用部署流程\">#</a> 通用部署流程</h5>\n<ul>\n<li>关闭交换空间</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>swapoff -a</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">free</span> -h <span class=\"token comment\">#查看交换空间大小</span></pre></td></tr></table></figure><ul>\n<li>关闭交换空间自启动</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">vi</span> /etc/fstab</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># 注释掉含有 swap 开头的代码行</span></pre></td></tr></table></figure><ul>\n<li>关闭防火墙</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>ufw disable</pre></td></tr></table></figure><ul>\n<li>配置 DNS</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 取消 DNS 注释，并增加 DNS 配置如：114.114.114.114. 修改后重启计算机</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">vi</span> /etc/systemd/resolved.conf</pre></td></tr></table></figure><ul>\n<li>安装 Docker</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 更新软件源</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> update</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># 安装所需依赖</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> -y <span class=\"token function\">install</span> apt-transport-https ca-certificates <span class=\"token function\">curl</span> software-properties-common</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\"># 安装 GPG 证书</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">curl</span> -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg <span class=\"token operator\">|</span> <span class=\"token function\">sudo</span> apt-key <span class=\"token function\">add</span> -</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\"># 新增软件源信息</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">sudo</span> add-apt-repository <span class=\"token string\">\"deb  [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class=\"token variable\"><span class=\"token variable\">$(</span>lsb_release -cs<span class=\"token variable\">)</span></span> stable\"</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\"># 查看软件源信息</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token function\">cat</span> /etc/apt/sources.list</pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token comment\"># 再次更新软件源</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> -y update</pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token comment\"># 安装 docker</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> -y <span class=\"token function\">install</span> docker-ce</pre></td></tr></table></figure><ul>\n<li>配置 docker 加速器</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">vi</span> /etc/docker/daemon.json</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># 粘贴如下内容</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token string\">\"registry-mirrors\"</span>:<span class=\"token punctuation\">[</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token string\">\"https://k7da99jp.mirror.aliyuncs.com/\"</span>,</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token string\">\"http://hub-mirror.c.163.com\"</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><ul>\n<li>重启 docker</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>systemctl restart docker</pre></td></tr></table></figure><ul>\n<li>查看 docker 信息</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>docker info</pre></td></tr></table></figure><ul>\n<li>安装 Kubernetes 必备工具\n<ul>\n<li>kubeadm</li>\n<li>kubelet</li>\n<li>kubectl</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 安装系统工具</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">apt-get</span> update <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> -y apt-transport-https</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 安装 GPG 证书</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">curl</span> https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg <span class=\"token operator\">|</span> apt-key <span class=\"token function\">add</span> -</pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\"># 写入软件源</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">cat</span> <span class=\"token operator\">&lt;&lt;</span> EOF <span class=\"token operator\">></span> /etc/apt/sources.list.d/kubernetes.list </pre></td></tr><tr><td data-num=\"9\"></td><td><pre>deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>EOF</pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\"># 安装 Kubernetes 必备工具</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token function\">apt-get</span> update <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> -y kubelet kubeadm kubectl</pre></td></tr></table></figure><ul>\n<li>同步时区</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>dpkg-reconfigure tzdata</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># 时区选择 Asia -> shanghai</span></pre></td></tr></table></figure><ul>\n<li>安装 ntp（时间同步）</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 安装 uptdate</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> ntpdate</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 设置系统时间与网络时间同步（cn.pool.ntp.org 位于中国的公共 NTP 服务器）</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>ntpdate cn.poo.ntp.org</pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\"># 将系统时间写入硬件时间</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>hwclock --systohc</pre></td></tr></table></figure><ul>\n<li>确认时间</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">date</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># 输出结果</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>Web Aug <span class=\"token number\">26</span> <span class=\"token number\">10</span>:10:45 CST <span class=\"token number\">2020</span></pre></td></tr></table></figure><ul>\n<li>修改 cloud.cfg</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 防止重启后主机名还原</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">vi</span> /etc/cloud/cloud.cfg</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 该配置默认为 false，修改为 true 即可</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>preserve_hostname: <span class=\"token boolean\">true</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\"># 重启电脑，让配置生效</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">reboot</span></pre></td></tr></table></figure><h5 id=\"单独部署流程\"><a class=\"anchor\" href=\"#单独部署流程\">#</a> 单独部署流程</h5>\n<ul>\n<li>配置 IP</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">vi</span> /etc/network/interfaces</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># 修改成如下内容</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">#NAT interface</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>auto enp0s3</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>iface enp0s3 inet static</pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>address <span class=\"token number\">10.0</span>.2.110</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>netmask <span class=\"token number\">255.255</span>.255.0</pre></td></tr></table></figure><ul>\n<li>让配置生效</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>netplan apply</pre></td></tr></table></figure><ul>\n<li>配置主机名</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 修改主机名</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>hostnamectl set-hostname kubernetes-master</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 配置 hosts</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">cat</span> <span class=\"token operator\">>></span> /etc/hosts <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">EOF</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>10.0.2.110 kubernetes-master</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>EOF</span></pre></td></tr></table></figure><h4 id=\"集群部署\"><a class=\"anchor\" href=\"#集群部署\">#</a> 集群部署</h4>\n<ul>\n<li>创建并修改集群配置</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>kubeadm config print init-defaults --kubeconfig ClusterConfiguration <span class=\"token operator\">></span> kubeadm.yml</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">vi</span> kubeadm.yml</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 根据需要修改配置</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>advertiseAddress: <span class=\"token number\">10.0</span>.2.110</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>imageRepository: registry.aliyuncs.com/google_containers</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>kubernetesVersion: v1.18.0</pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\"># kubernetesVersion 版本查看</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>kubeadm version</pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token comment\"># 在 dnsDomain 下面配置一下 node 节点</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    dnsDomain: cluster.local</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    podSubnet: <span class=\"token string\">\"192.168.0.0/16\"</span> <span class=\"token comment\">#解决容器间通讯问题</span></pre></td></tr></table></figure><p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200826150028246.png\" alt=\"image-20200826150028246\" /></p>\n<ul>\n<li>查看所需镜像</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>kubeadm config images list --config kubeadm.yml</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># 输出如下：</span></pre></td></tr></table></figure><p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200826150945021.png\" alt=\"image-20200826150945021\" /></p>\n<ul>\n<li>拉取所需镜像</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>kubeadm config images pull --config kubeadm.yml</pre></td></tr></table></figure><ul>\n<li>安装主节点</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># --upload-certs 表示后续加入集群节点会自动分发证书文件</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># tee kubeadm-init.log 用来输出日志</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>kubeadm init --config<span class=\"token operator\">=</span>kubeadm.yml --upload-certs <span class=\"token operator\">|</span> <span class=\"token function\">tee</span> kubeadm-init.log</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\"># 如果出现 timed out waiting for the condition</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\"># 如果失败了执行重置后再确认配置是否正确后再重新初始化</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>kubeadm reset</pre></td></tr></table></figure><p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200826161759585.png\" alt=\"image-20200826161759585\" /></p>\n<ul>\n<li>查看集群是否安装成功</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>kubectl get node</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">#输出结果：</span></pre></td></tr></table></figure><p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200826163302130.png\" alt=\"image-20200826163302130\" /></p>\n<ul>\n<li>设置常规用户</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">mkdir</span> -p <span class=\"token environment constant\">$HOME</span>/.kube</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">cp</span> -i /etc/kubernetes/admin.conf <span class=\"token environment constant\">$HOME</span>/.kube/config</pre></td></tr></table></figure><ul>\n<li>添加从节点</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 就是上面输出结果的最后一句</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>kubeadm <span class=\"token function\">join</span> <span class=\"token number\">10.0</span>.2.110:6443 --token abcdef.0123456789adcdef --discovery-token-ca-cert-hash sha256:919818c94c0c157d554b9cdeccabfaca0cfc86ac22171a306e37133210256c7f</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 重新创建令牌</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>kubeadm token create</pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\"># 查看 token</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>kubeadm token list</pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\"># 获取 cert-hash</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt <span class=\"token operator\">|</span> openssl rsa -pubin -outform der <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span>/dev/null <span class=\"token operator\">|</span> openssl dgst -sha256 -hex <span class=\"token operator\">|</span> <span class=\"token function\">sed</span> <span class=\"token string\">'s/^.* //'</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token comment\"># 注意：如果 Master 的一个 token 被其他节点使用并加入集群后，之后其他节点加入时也需要使用之前的 token，而不能使用 kubeadm token create 新创建出来的 token</span></pre></td></tr></table></figure><p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200826172657121.png\" alt=\"image-20200826172657121\" /></p>\n<h4 id=\"配置集群网络\"><a class=\"anchor\" href=\"#配置集群网络\">#</a> 配置集群网络</h4>\n<ul>\n<li>以阿里的 Calico 为例</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>kubectl create -f https://docs.projectcalico.org/manifests/tigera-operator.yaml</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>kubectl create -f https://docs.projectcalico.org/manifests/custom-resources.yaml</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 查看 pod 运行状态 </span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>kubectl get pods --all-namespace</pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\"># 回撤操作 </span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>kubectl delete -f filename/url</pre></td></tr></table></figure><p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200827100046490.png\" alt=\"image-20200827100046490\" /></p>\n<h4 id=\"部署服务\"><a class=\"anchor\" href=\"#部署服务\">#</a> 部署服务</h4>\n<ul>\n<li>创建 deployment 配置文件</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 内容如下 nginx-deployment.yaml</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>apiVersion: apps/v1</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>kind: Deployment</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>metadata:</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  name: nginx-deployment</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  labels:</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    app: nginx</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>spec:</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token comment\"># 创建 2 个 nginx 容器</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  replicas: <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>  selector:</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    matchLabels:</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>      app: nginx</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>  template:</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    metadata:</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>      labels:</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        app: nginx</pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    spec:</pre></td></tr><tr><td data-num=\"19\"></td><td><pre>      containers:</pre></td></tr><tr><td data-num=\"20\"></td><td><pre>      - name: nginx</pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        image: nginx:1.14.2</pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        ports:</pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        - containerPort: <span class=\"token number\">80</span></pre></td></tr></table></figure><ul>\n<li>通过 deployment 构建容器并启动服务</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 这里只是部署再 kubernetes 的内网，外部还是无法访问的</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>kubectl apply -f nginx-deployment.yaml</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 默认情况下不会再 master 上部署 pod</span></pre></td></tr></table></figure><ul>\n<li>查看 pods</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>kubectl get pods</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>kubectl get deployment</pre></td></tr></table></figure><ul>\n<li>暴露服务</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>kubectl expose deployment nginx-deployment --port<span class=\"token operator\">=</span><span class=\"token number\">80</span> --type<span class=\"token operator\">=</span>LoadBalancer</pre></td></tr></table></figure><ul>\n<li>查看服务</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>kubectl get <span class=\"token function\">service</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># 10.96.0.1 和 10.103.245.150 都是 Kubernetes 内部的虚拟 ip</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 443 和 80 对应着内部的 端口号 </span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\"># 32287 则是服务暴露给外界的端口号</span></pre></td></tr></table></figure><p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200827160615246.png\" alt=\"image-20200827160615246\" /></p>\n<p>​</p>\n<ul>\n<li>查看服务描述</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>kubectl describe <span class=\"token function\">service</span> nginx-deployment</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># Type: LoadBalancer 负载均衡</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># IP: 10.103.245.150 内网 ip</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\"># Port: 80 内部端口</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\"># NodePort: 32287 节点端口</span></pre></td></tr></table></figure><p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200827161150691.png\" alt=\"image-20200827161150691\" /></p>\n<ul>\n<li>操作 docker</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 在 node 下执行</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>docker <span class=\"token function\">ps</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>docker <span class=\"token builtin class-name\">exec</span> -it container_id /bin/bash</pre></td></tr></table></figure><h4 id=\"如何停止并退出\"><a class=\"anchor\" href=\"#如何停止并退出\">#</a> 如何停止并退出</h4>\n<ul>\n<li>删除已经部署的服务</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>kubectl delete deployment nginx-deployment</pre></td></tr></table></figure><ul>\n<li>删除已经发布的服务</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>kuberctl delete <span class=\"token function\">service</span> nginx-deployment</pre></td></tr></table></figure><ul>\n<li>删除集群节点</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>kubectl delete node kubernetes-node-01</pre></td></tr></table></figure><h4 id=\"查看集群状态\"><a class=\"anchor\" href=\"#查看集群状态\">#</a> 查看集群状态</h4>\n<ul>\n<li>查看 master 状态</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>kubectl cluster-info</pre></td></tr></table></figure><ul>\n<li>查看各个节点状态</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>kubectl get nodes</pre></td></tr></table></figure><ul>\n<li>查看所有 pod 状态</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>kubectl get pods --all-namespaces</pre></td></tr></table></figure><ul>\n<li>查看 pod 运行状态</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>kubectl describe pod yourPodName -n kube-system</pre></td></tr></table></figure><ul>\n<li>查看 Pod 的配置是否正确</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>kubectl get pod <span class=\"token operator\">&lt;</span>pod-name<span class=\"token operator\">></span> -o yaml</pre></td></tr></table></figure><ul>\n<li>查看 Pod 的事件</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>kubectl describe pod <span class=\"token operator\">&lt;</span>pod-name<span class=\"token operator\">></span></pre></td></tr></table></figure><ul>\n<li>查看容器日志</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>kubectl logs <span class=\"token operator\">&lt;</span>pod-name<span class=\"token operator\">></span> <span class=\"token punctuation\">[</span>-c <span class=\"token operator\">&lt;</span>container-name<span class=\"token operator\">></span><span class=\"token punctuation\">]</span></pre></td></tr></table></figure><h2 id=\"kubernetes部署心得\"><a class=\"anchor\" href=\"#kubernetes部署心得\">#</a> Kubernetes 部署心得</h2>\n<ul>\n<li>\n<p>Kubernetes 是用来管理 docker 容器的工具，可以简单的理解为 Docker（不只是 docker，其他容器管理器也都可以使用 Kubernetes）的一个高可用自动化插件。</p>\n<ul>\n<li>集群内的节点必须可以<strong>互相之间通信</strong></li>\n<li>集群内的节点需要能够<strong>访问外网</strong></li>\n<li>集群内的主节点或者其他需要向外提供服务的节点（如：gate），需要能够被<strong>外界访问</strong></li>\n</ul>\n</li>\n<li>\n<p>启动容器不需要选择其所在的节点（也不能），Kubernetes 会通过 scheduler 默认根据机器配置来帮您自动分配，所以可以在只操作 Master 的情况下，对全部机器进行部署，调控</p>\n</li>\n<li>\n<p><code>docker run</code>  运行镜像的方式现在被替换为  <code>kubectl apply -f xxx.yaml</code>  的形式，并在执行后创建一个  <code>deployment</code>  用于管理 yaml 文件中配置的 Pod，我们只需要配置 yaml 里面需要启动多少个 Pod，对应的  <code>labels</code> ，以及  <code>port</code> 。其他的事情都交给 Kubernetes。</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># deployment 的 yaml 格式简单介绍</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># 先申明版本、类型（deployment）、labels、name（用于 Service 的构建）</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># 再申明 Pod 数量</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># 最后申明单个 Pod 的配置</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token comment\"># 里面由几个 container</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t\t<span class=\"token comment\"># 每个 container 类型、端口、版本</span></pre></td></tr></table></figure><ul>\n<li>运行 Container。是通过 deployment（Pod 和 ReplicaSet 的管理者）来创建相应的 Pod 并运行 Container。一个 deployment 对应着一个或多个 <code>ReplicaSet</code>  实体（具体根据 yaml 配置决定），deployment 对象则是由 DeploymentController 来进行管理。</li>\n<li>ReplicaSet 用来创建和删除 Pod，被 deployment 用作间接管理 Pod 的工具</li>\n<li>Service 是一个单独的路由代理，在指定 deployment 某类  Pod  需要对外提供服务的时候，会创建一个 Service 用来进行 ip 和端口的映射关系，避免内部机器重启后 ip 变化导致无法访问。</li>\n</ul>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200827174209322.png\" alt=\"image-20200827174209322\" /></p>\n<ul>\n<li>在关闭某类 Pod（真正意义上关闭）时，其所对应的 Service 还会存在，但已经实去了作用，记得要一起删了。</li>\n<li>对 Pod 、Node、Service、Deployment 都可以且只能在 Master 机器上通过 kubectl 命令行进行操作</li>\n<li>所有提供服务的 Pod 创建默认情况下是会避开 Master 节点的。</li>\n<li>对于每个 Node 节点，则可以通过 docker 指令进行单独管理，包括进入容器的 bash 界面进行响应操作，但删除添加 Container 操作会受限于 Kubernetes 的管理。需要在 Master 上通过 kubectl 进行操作。</li>\n</ul>\n<h4 id=\"部署故障回顾\"><a class=\"anchor\" href=\"#部署故障回顾\">#</a> 部署故障回顾</h4>\n<p>还有很多内容需要慢慢完善，暂时先把整个学习路线都过一遍，以后慢慢看。<br />\n部署 kubernetes 的集群时也遇到了不少问题，这里简单总结一下，其中最耗时间的就是网络那一块：</p>\n<ul>\n<li>本地的虚拟机和其他本地虚拟机无法链接，导致 master 节点上面显示的 node 节点状态一直处于 loop 状态，在启动和失败两个状态反复横跳。</li>\n<li>虚拟机无法连接互联网问题，这个也浪费了比较长的时间，导致后续很多镜像拉不下来，pod 状态一直是 ContainerCreating，后面查 describe 才发现 kubelet 链接一直是 confuse，这才想到是网络的问题，因为之前拉东西靠的都是镜像仓库。</li>\n<li>之后就是部署好了机器的服务，暴露了端口给外网，但是发现自己的 master 主机和 window 主机的 ip 不是一个网段，无法访问。要么就得从头配置 NAT 虚拟机网络，想想还是算了。</li>\n<li>还遇到的比较麻烦的问题就是 ubuntu 16.04 版本和 ubuntu18.04 版本的安装差异。一些 kubernetes 的指令做了很大程度上的调整。包括 deployment 的部署不再支持命令行，只能用 yaml 文件。</li>\n<li>机器配置必须得 2 核以上，不然安装 kubernetes 到一半的时候会失败。</li>\n<li>虚拟机的 ip 绝对不能重复，之前用的 NAT 的 dhcp 自动分配，每台机器的 ip 都是 10.0.2.15，导致后面装 阿里的 CNI（calico），三台机器只能起一个 calico，另外两个都提示 ip 冲突，导致最后 coredns 也起不来。</li>\n</ul>\n<p>总结一下就是 ip 规划一定得提前，不然网络问题后续搭起来了再来解决，那绝对是要命的。kubernetes 高可用不是开玩笑的... 有时候想关掉集群，重新调整网络再来。发现不按照正常流程还关不掉。</p>\n<p>这里还得感谢一下官方的排错文档：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poL2RvY3MvdGFza3MvZGVidWctYXBwbGljYXRpb24tY2x1c3Rlci9kZWJ1Zy1hcHBsaWNhdGlvbi8=\">pod 故障排查</span></p>\n",
            "tags": [
                "计算机科学",
                "学习笔记",
                "微服务",
                "K8s"
            ]
        },
        {
            "id": "https://allengx.gitee.io/computer-science/study/micro-service/docker/Docker%E4%BB%8B%E7%BB%8D&&%E5%AE%B9%E5%99%A8/",
            "url": "https://allengx.gitee.io/computer-science/study/micro-service/docker/Docker%E4%BB%8B%E7%BB%8D&&%E5%AE%B9%E5%99%A8/",
            "title": "Docker介绍&&容器",
            "date_published": "2020-04-12T12:46:25.000Z",
            "content_html": "<div class=\"note info\">\n<p>以下为个人学习笔记整理</p>\n</div>\n<h1 id=\"docker\"><a class=\"anchor\" href=\"#docker\">#</a> Docker</h1>\n<h3 id=\"介绍\"><a class=\"anchor\" href=\"#介绍\">#</a> 介绍</h3>\n<ul>\n<li>\n<p>C/S 架构。通过远程 API 来创建 Docker 容器</p>\n</li>\n<li>\n<p>容器 &amp;&amp; 镜像</p>\n<table>\n<thead>\n<tr>\n<th>Docker</th>\n<th>面向对象</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>容器</td>\n<td>对象</td>\n</tr>\n<tr>\n<td>镜像</td>\n<td>类</td>\n</tr>\n</tbody>\n</table>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200822181252411.png\" alt=\"image-20200822181252411\" /></p>\n</li>\n</ul>\n<h3 id=\"相比于传统的虚拟机\"><a class=\"anchor\" href=\"#相比于传统的虚拟机\">#</a> 相比于传统的虚拟机</h3>\n<ul>\n<li>更快的启动速度：不需要再构建一个虚拟操作系统。</li>\n<li>一致的运行环境：测试、开发、生产环境高度统一。</li>\n<li>持续交付和部署（CI/CD—— 持续集成 &amp;&amp; 持续部署）。</li>\n<li>更轻松的迁移。</li>\n</ul>\n<h3 id=\"常用docker指令\"><a class=\"anchor\" href=\"#常用docker指令\">#</a> 常用 Docker 指令</h3>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>docker ps</td>\n<td>查看运行中的容器 eg：docker pseg：docker ps -a</td>\n</tr>\n<tr>\n<td>docker stats</td>\n<td>查看容器消耗资源情况</td>\n</tr>\n<tr>\n<td>docker build -t +「image_name」:「tag」 -f +「DockerFile_name」+「DockerFile_path」</td>\n<td>使用 dockerfile 构建镜像 eg：docker build -t my_image ./eg：docker build -t my_image -f my_dockerfile ./</td>\n</tr>\n<tr>\n<td>docker exec -it + 「container_id / container_name」 bash</td>\n<td>进入 docker 的 bash 操作界面 eg：docker exec -it 9ef bash</td>\n</tr>\n<tr>\n<td>docker commit + 「container_id / container_name」 + 「image_id / image_name」：「tag」</td>\n<td>将容器保存为镜像 eg：docker commit 9ef 85a:1.0</td>\n</tr>\n<tr>\n<td>docker pull + 「url」:「tag」</td>\n<td>拉取远端仓库的镜像到本地 eg：docker pull <span class=\"exturl\" data-url=\"aHR0cDovL25jci1kZXYubmllLm5ldGVhc2UuY29tL2cxMTUvZGV2ZWw6bGFzdGVzdA==\">ncr-dev.nie.netease.com/g115/devel:lastest</span></td>\n</tr>\n<tr>\n<td>docker push + 「url」:「tag」</td>\n<td>提交本地镜像到远端仓库 eg：docker push <span class=\"exturl\" data-url=\"aHR0cDovL25jci1kZXYubmllLm5ldGVhc2UuY29tL2cxMTUvZGV2ZWw6bGFzdGVzdA==\">ncr-dev.nie.netease.com/g115/devel:lastest</span></td>\n</tr>\n<tr>\n<td>docker 「login/logout」 + 「url」-u lsername」</td>\n<td>登入 / 登出 第三方仓库 eg：docker login <span class=\"exturl\" data-url=\"aHR0cDovL25jci1kZXYubmllLm5ldHJhc2UuY29t\">ncr-dev.nie.netrase.com</span> -u username</td>\n</tr>\n<tr>\n<td>docker images</td>\n<td>查看本地镜像 eg：docker images</td>\n</tr>\n<tr>\n<td>docker rmi + 「image_id / image_name」</td>\n<td>删除本地的镜像 eg：docker rmi 85a</td>\n</tr>\n<tr>\n<td>docker save + 「image_id / image_name」 &gt; 「file_path」</td>\n<td>本地镜像打包成压缩包 eg：docker save 85a &gt;~/home/username/docker.tar.gz</td>\n</tr>\n<tr>\n<td>docker load &lt; 「压缩文件名」</td>\n<td>导入镜像压缩包 eg：docker load &lt; ~/home/username/docker.tar.gz</td>\n</tr>\n<tr>\n<td>docker run + 「参数」+ 「container_id /container_name」+ 「命令」</td>\n<td>创建并启动容器 eg：docker run -d 85a</td>\n</tr>\n<tr>\n<td>docker stop + 「container_id / container_name」</td>\n<td>关闭容器 eg：docker stop 9ef</td>\n</tr>\n<tr>\n<td>docker 「kill / start / restart 」+ 「container_id / container_name」</td>\n<td>强杀 / 启动 / 重启 容器 eg：docker kill 9efdocker start 9efdocker restart 9ef</td>\n</tr>\n<tr>\n<td>docker rm + 「image_id / image_name」</td>\n<td>删除容器 eg：docker rm -f 9ef</td>\n</tr>\n<tr>\n<td>docker inspect + 「image_id / image_name」</td>\n<td>查看镜像详细信息</td>\n</tr>\n<tr>\n<td>docker inspect + 「container_id / container_name」</td>\n<td>查看容器信息</td>\n</tr>\n<tr>\n<td>docker top + 「container_id / container_name」</td>\n<td>查看正在运行的容器进程</td>\n</tr>\n<tr>\n<td>docker tag + 「image_id / image_name」+「image_id / image_name」:「tag」</td>\n<td>修改镜像 tageg：docker tag 85a 85a:1.0 删除新创建的 tag：eg：docker rmi 85a:1.0</td>\n</tr>\n<tr>\n<td>docker system df</td>\n<td>查看镜像、容器等体积</td>\n</tr>\n<tr>\n<td>docker container prune</td>\n<td>删除所有容器</td>\n</tr>\n<tr>\n<td>docker image prune</td>\n<td>清理所有的虚悬镜像（产生原因时旧版本被新版本替代后的残留）</td>\n</tr>\n<tr>\n<td>docker network [...]</td>\n<td>docker 网络相关指令</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"docker网络\"><a class=\"anchor\" href=\"#docker网络\">#</a> Docker 网络</h3>\n<p>一个 container 对应一个局域网络，一个 container 内可以直接通过名称来访问，docker 为容器提供了以下网络：</p>\n<ul>\n<li>none：将容器添加到一个容器专门的网络堆栈中，没有对外连接。</li>\n<li>host：将容器添加到主机的网络堆栈中，容器与 docker 主机之间没有网络隔离。</li>\n<li>default bridge：默认网络模式。每个容器可以通过 ip 地址互相连接。</li>\n<li>overlay：覆盖网络。将多个 docker 守护程序连接再一起，使得集群之间可以互相通讯。</li>\n<li>macvlan：提供将 Mac 地址分配给容器的功能，使其具有物理设备的特性，Docker 守护程序通过 Mac 地址进行路由。</li>\n<li>自定义网桥：用户定义的网桥，具有更多的灵活性、隔离性和其他遍历功能。</li>\n</ul>\n<h3 id=\"dockerfile常用指令\"><a class=\"anchor\" href=\"#dockerfile常用指令\">#</a> DockerFile 常用指令</h3>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>COPY &lt;源路径&gt; &lt; 目标路径 &gt;</td>\n<td>复制文件到目录</td>\n</tr>\n<tr>\n<td>RUN &lt;指令&gt;</td>\n<td>执行指令，例： RUN rm -rf /user/local/*</td>\n</tr>\n<tr>\n<td>FROM &lt;镜像名&gt;</td>\n<td>继承一个镜像</td>\n</tr>\n<tr>\n<td>ADD &lt;源路径&gt; &lt; 目标路径 &gt;</td>\n<td>复制文件到目录，如果文件时压缩包，还会自动解压</td>\n</tr>\n<tr>\n<td>CMD &lt;脚本&gt;</td>\n<td>执行脚本的指令（只允许使用一次该指令），以最后出现的为准</td>\n</tr>\n<tr>\n<td>ENTRYPOINT &lt;脚本&gt;</td>\n<td>和 CMD 类似（只允许使用一次该指令）</td>\n</tr>\n<tr>\n<td>EVN &lt;变量名&gt; &lt; 值 &gt;</td>\n<td>配置环境变量</td>\n</tr>\n<tr>\n<td>VOLUME &lt;路径&gt;</td>\n<td>创建挂载点（一个类似容器内和外部环境交互的虚拟内存)，类似 linux 系统下 mount 的机制</td>\n</tr>\n<tr>\n<td>EXPOSE [&lt;端口 1&gt; ...]</td>\n<td>申明容器暴露的端口</td>\n</tr>\n<tr>\n<td>WORKDIR &lt;目录&gt;</td>\n<td>有点类似 CD，指定容器的初始目录</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"docker-compose\"><a class=\"anchor\" href=\"#docker-compose\">#</a> Docker Compose</h3>\n<p>Compose 是用于定义和运行多容器 Docker 应用程序的工具，简化容器的启动和定义容器之间的关系。</p>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200824141537909.png\" alt=\"image-20200824141537909\" /></p>\n<p>这部分以后再看，相关链接 https://www.bilibili.com/video/av62628434?p=27</p>\n",
            "tags": [
                "计算机科学",
                "学习笔记",
                "微服务",
                "Docker",
                "Docker"
            ]
        },
        {
            "id": "https://allengx.gitee.io/computer-science/study/micro-service/kubernetes/Kubernetes%E7%AE%80%E4%BB%8B/",
            "url": "https://allengx.gitee.io/computer-science/study/micro-service/kubernetes/Kubernetes%E7%AE%80%E4%BB%8B/",
            "title": "Kubernetes简介",
            "date_published": "2020-04-12T12:46:25.000Z",
            "content_html": "<div class=\"note info\">\n<p>以下为个人学习笔记整理</p>\n</div>\n<h2 id=\"kubernetes简介\"><a class=\"anchor\" href=\"#kubernetes简介\">#</a> Kubernetes 简介</h2>\n<h3 id=\"什么是kubernetes\"><a class=\"anchor\" href=\"#什么是kubernetes\">#</a> 什么是 Kubernetes</h3>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200824200237815.png\" alt=\"image-20200824200237815\" /></p>\n<p>k8s 是建立在容器引擎之上的可移植可扩展的<strong>容器编排系统</strong>，用于解决微服务中的高可用问题。通过使用「labels」和「pods」的概念，将逻辑单元进行分组，方便管理和发现。</p>\n<ul>\n<li>**pods：** 一组紧密关联的容器集合，他们共享 IPC（进程间通信）、Network（网络）、UTS namespace，是 Kubernetes 调度的基本单位。\n<ul>\n<li>UTS namespace—— 是 Linux 命名空间的一个子系统，主要用来完成对容器 Hostname 和 Domain 的隔离，同时保存内核名称、版本、以及底层体系结构类型等信息。</li>\n</ul>\n</li>\n<li>**labels：** 键值对标签，可以被关联到如 Pod 这样的对象上。</li>\n<li>**Image Registry：** 镜像仓库。</li>\n<li>**Kubernetes Node：**Kubernetes 集群子节点，主要由 <code>kubelet</code> 、 <code>kube-proxy</code> 、 <code>runtime</code>  三个模块构成</li>\n<li>**Kubernetes Master：**Kubernetes 集群的主节点，主要由 <code>kube-apiserver</code> 、 <code>kube-scheduler</code> 、 <code>kube-controller-manager</code> 、 <code>etcd</code>  四个模块组成</li>\n</ul>\n<p>使用 Kubernetes 可以：</p>\n<ul>\n<li>快速部署应用</li>\n<li>快速扩展应用</li>\n<li>无缝对接新的应用功能</li>\n<li>节省资源，优化硬件资源的使用</li>\n</ul>\n<h4 id=\"kubernetes架构\"><a class=\"anchor\" href=\"#kubernetes架构\">#</a> <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qaW1teXNvbmcuaW8va3ViZXJuZXRlcy1oYW5kYm9vay9jb25jZXB0cy8=\">Kubernetes 架构</span></h4>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200824195734072.png\" alt=\"image-20200824195734072\" /></p>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200824200024485.png\" alt=\"image-20200824200024485\" /></p>\n<h5 id=\"kubernetes-node\"><a class=\"anchor\" href=\"#kubernetes-node\">#</a> Kubernetes Node</h5>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200824200353285.png\" alt=\"image-20200824200353285\" /></p>\n<h5 id=\"kubernetes-master\"><a class=\"anchor\" href=\"#kubernetes-master\">#</a> Kubernetes Master</h5>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200824200328253.png\" alt=\"image-20200824200328253\" /></p>\n<h4 id=\"kubernetes组件\"><a class=\"anchor\" href=\"#kubernetes组件\">#</a> Kubernetes 组件</h4>\n<ul>\n<li>\n<p>**etcd：** 保存了整个集群的状态，实现了服务注册与发现功能。</p>\n</li>\n<li>\n<p>**pod：** 运行一组容器，实现不同机器的容器间通讯。</p>\n</li>\n<li>\n<p>**apiserver：** 提供了资源操作唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制。</p>\n</li>\n<li>\n<p>**controller-manager：** 负责维护集群的状态，比如故障检测、自动扩展、滚动更新等。Container 运行在 Pod 上，Pod 运行在 Controller 上。</p>\n</li>\n<li>\n<p>**scheduler：** 负责资源的调度，按照预定的调度策略将 Pod 调度到相应的机器上。</p>\n</li>\n<li>\n<p>**proxy：** 负责为 Service 提供 cluster 内部的服务发现和负载均衡。</p>\n</li>\n<li>\n<p>**pause：** 控制容器的停止与启动。</p>\n</li>\n<li>\n<p>**coredns：** 域名解析服务器，提供跨网段的通讯。</p>\n</li>\n<li>\n<p>**runtime：** 负责镜像管理以及 Pod 和容器的真正运行（CRI，Container Runtime Interface），默认的容器运行时为 Docker。</p>\n</li>\n</ul>\n<h4 id=\"安装kubernetes的三个必备工具\"><a class=\"anchor\" href=\"#安装kubernetes的三个必备工具\">#</a> 安装 Kubernetes 的三个必备工具</h4>\n<ul>\n<li>**kubeadm：**Kubernetes 的集群安装工具。</li>\n<li>**kubelet：** 负责维护容器的生命周期，同时也负责 Vloume（CVI，Container Vloume Interface）和网络（CNI，Container Network Interface）的管理。</li>\n<li>**kubectl：** 用于管理 Kubernetes 集群的命令行工具。</li>\n</ul>\n<h3 id=\"kubernetes特点\"><a class=\"anchor\" href=\"#kubernetes特点\">#</a> Kubernetes 特点：</h3>\n<ul>\n<li>\n<p><strong>可移植性</strong>：支持公有云、私有云、混合云、多重云</p>\n</li>\n<li>\n<p>** 可扩展性：** 模块化、插件化、可挂载、可组合</p>\n</li>\n<li>\n<p>** 自动化：** 自动化部署、自动重启、自动复制、自动伸缩 / 扩展</p>\n</li>\n</ul>\n<h3 id=\"解决高可用问题\"><a class=\"anchor\" href=\"#解决高可用问题\">#</a> 解决高可用问题</h3>\n<ul>\n<li>单点故障问题：检测服务故障，重启并恢复。</li>\n<li>流量过载问题：支持自动扩、缩容。</li>\n<li>服务器更新维护：滚动更新，金丝雀发布，回滚版本。</li>\n</ul>\n<h3 id=\"kubernetes提供的功能\"><a class=\"anchor\" href=\"#kubernetes提供的功能\">#</a> Kubernetes 提供的功能</h3>\n<ul>\n<li>多个进程协调工作</li>\n<li>存储系统挂载</li>\n<li>应用健康检查</li>\n<li>应用实例复制自动伸缩 / 扩展</li>\n<li>注册与发现</li>\n<li>负载均衡</li>\n<li>滚动更新</li>\n<li>资源监控</li>\n<li>日志访问</li>\n<li>调试应用程序</li>\n<li>提供认证和授权</li>\n</ul>\n<h3 id=\"kubernetes网络\"><a class=\"anchor\" href=\"#kubernetes网络\">#</a> Kubernetes 网络</h3>\n<h4 id=\"kubernetes中常见的容器网络解决方案cni\"><a class=\"anchor\" href=\"#kubernetes中常见的容器网络解决方案cni\">#</a> Kubernetes 中常见的容器网络解决方案 CNI</h4>\n<p>CNI 提供 Pod 与 Pod 间的通讯的标准，常见的 CNI 插件如下：</p>\n<ul>\n<li>Flannel</li>\n<li>Calico</li>\n<li>Canal</li>\n<li>Weave</li>\n</ul>\n<h5 id=\"flannel\"><a class=\"anchor\" href=\"#flannel\">#</a> Flannel</h5>\n<h6 id=\"flannel网络架构\"><a class=\"anchor\" href=\"#flannel网络架构\">#</a> Flannel 网络架构</h6>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200824175207079.png\" alt=\"image-20200824175207079\" /></p>\n<h3 id=\"kubernetes常见指令\"><a class=\"anchor\" href=\"#kubernetes常见指令\">#</a> <span class=\"exturl\" data-url=\"aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvcmVmZXJlbmNlL2dlbmVyYXRlZC9rdWJlY3RsL2t1YmVjdGwtY29tbWFuZHM=\">Kubernetes 常见指令：</span></h3>\n<h3 id=\"kubernetes-ingressapi网关简介\"><a class=\"anchor\" href=\"#kubernetes-ingressapi网关简介\">#</a> Kubernetes Ingress（API 网关）简介</h3>\n<p>Ingress 是对集群中服务的外部访问进行管理的 API 对象，典型的访问方式是 HTTP。</p>\n<p>Ingress 可以提供负载均衡、SSL 终结和基于名称的虚拟托管。</p>\n<h4 id=\"ingress是什么\"><a class=\"anchor\" href=\"#ingress是什么\">#</a> Ingress 是什么</h4>\n<p>Ingress 公开了从集群外部到集群内服务的 HTTP 和 HTTPS 路由。 流量路由由 Ingress 资源上定义的规则控制。</p>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200825100908440.png\" alt=\"image-20200825100908440\" /></p>\n<h4 id=\"术语\"><a class=\"anchor\" href=\"#术语\">#</a> 术语</h4>\n<ul>\n<li><strong>节点：</strong> Kubernetes 集群中的服务器</li>\n<li><strong>集群：</strong> Kubernetes 管理的一组服务器集合</li>\n<li><strong>边界路由器：</strong> 为局域网和 Internet 路由数据包的路由器，执行防火墙保护局域网络</li>\n<li><strong>集群网络：</strong> 遵循 Kubernetes 网络模型实现集群内的通信的具体实现，如：Flannel</li>\n<li><strong>服务：</strong> Kubernetes 的服务（Service）是使用标签选择器标识的一组 Pod Service（Depolyment）。<strong>除非另有说明，否则服务的虚拟 IP 仅可在集群内部访问</strong></li>\n</ul>\n<p>待学习...</p>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200825102307848.png\" alt=\"image-20200825102307848\" /></p>\n<h3 id=\"kubernetes-volume\"><a class=\"anchor\" href=\"#kubernetes-volume\">#</a> Kubernetes Volume</h3>\n<p>在 Kubernetes 集群中，虽然无状态的服务非常常见，但是在实际的生产中仍然会需要在集群中部署一些有状态的节点，比如一些存储中间件、消息队列等等。</p>\n<p>作为 Kubernetes 集群中除了 Pod 和 Service 之外最常见的基本对象，Volume 不仅能够解决 Container 中文件的临时性问题，也能够让同一个 Pod 中的多个 Container 共享文件。</p>\n<p>集群中的每一个卷在被 Pod 使用时都会经历四个操作:</p>\n<ul>\n<li>附着（Attach）</li>\n<li>挂载（Mount）</li>\n<li>卸载（Unmount）</li>\n<li>分离（Detach）</li>\n</ul>\n<h4 id=\"volume-是什么\"><a class=\"anchor\" href=\"#volume-是什么\">#</a> Volume 是什么</h4>\n<h5 id=\"volume临时卷\"><a class=\"anchor\" href=\"#volume临时卷\">#</a> Volume（临时卷）</h5>\n<p>在这一节中提到的卷（Volume）其实是一个比较特定的概念，它并不是一个持久化存储，可能会随着 Pod 的删除而删除，常见的卷就包括 <strong>EmptyDir</strong>、<strong>HostPath</strong>、<strong>ConfigMap</strong> 和 <strong>Secret</strong>，这些卷与所属的 Pod 具有相同的生命周期。</p>\n<h5 id=\"persistentvolume持久卷\"><a class=\"anchor\" href=\"#persistentvolume持久卷\">#</a> PersistentVolume（持久卷）</h5>\n<p>临时的卷没有办法解决数据持久存储的问题，想要让数据能够持久化，首先就需要将 Pod 和卷的声明周期分离，这也就是引入持久卷  <code>PersistentVolume(PV)</code>  的原因。我们可以将  <code>PersistentVolume</code>  理解为集群中资源的一种，它与集群中的节点 Node 有些相似，PV 为 Kubernete 集群提供了一个如何提供并且使用存储的抽象，与它一起被引入的另一个对象就是  <code>PersistentVolumeClaim(PVC)</code> —— 持久卷消费者，这两个对象之间的关系与节点和 Pod 之间的关系差不多：</p>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200825104127977.png\" alt=\"image-20200825104127977\" /></p>\n<p><code>PersistentVolume</code>  是集群中的一种被管理员分配的存储资源，而  <code>PersistentVolumeClaim</code>  表示用户对存储资源的申请，它与 Pod 非常相似，PVC 消耗了持久卷资源，而 Pod 消耗了节点上的 CPU 和内存等物理资源。</p>\n<p>因为 PVC 允许用户消耗抽象的存储资源，所以用户需要不同类型、属性和性能的 PV 就是一个比较常见的需求了，在这时我们可以通过  <code>StorageClass</code>  来提供不同种类的 PV 资源，上层用户就可以直接使用系统管理员提供好的存储类型。</p>\n<h5 id=\"pvpvc生命周期\"><a class=\"anchor\" href=\"#pvpvc生命周期\">#</a> PV/PVC 生命周期</h5>\n<p>PV 是群集中的资源。PVC 是对这些资源的请求，并且还充当对资源的检查。PV 和 PVC 之间的相互作用遵循以下生命周期：</p>\n<blockquote>\n<p>Provisioning -&gt; Binding -&gt; Using -&gt; Releasing -&gt; Recycling</p>\n</blockquote>\n<ul>\n<li><strong>供应准备（Provisioning）</strong>—— 通过集群外的存储系统或者云平台来提供存储持久化支持。\n<ul>\n<li>静态提供 Static：集群管理员创建多个 PV。 它们携带可供集群用户使用的真实存储的详细信息。 它们存在于 Kubernetes API 中，可用于消费</li>\n<li>动态提供 Dynamic：当管理员创建的静态 PV 都不匹配用户的 PersistentVolumeClaim 时，集群可能会尝试为 PVC 动态配置卷。 此配置基于 StorageClasses：PVC 必须请求一个类，并且管理员必须已创建并配置该类才能进行动态配置。 要求该类的声明有效地为自己禁用动态配置。</li>\n</ul>\n</li>\n<li><strong>绑定（Binding）</strong>--- 用户创建 pvc 并指定需要的资源和访问模式。在找到可用 pv 之前，pvc 会保持未绑定状态。</li>\n<li><strong>使用（Using）</strong>--- 用户可在 pod 中像 volume 一样使用 pvc。</li>\n<li><strong>释放（Releasing）</strong>--- 用户删除 pvc 来回收存储资源，pv 将变成 “released” 状态。由于还保留着之前的数据，这些数据需要根据不同的策略来处理，否则这些存储资源无法被其他 pvc 使用。</li>\n<li><strong>回收（Recycling）</strong>——pv 可以设置三种回收策略：保留（Retain），回收（Recycle）和删除（Delete）。\n<ul>\n<li>\n<p>Retain（保留）：允许人工处理保留的数据。</p>\n</li>\n<li>\n<p>Delete（删除）：将删除 pv 和外部关联的存储资源，需要插件支持。</p>\n</li>\n<li>\n<p>Recycle（回收）：将执行清除操作，之后可以被新的 pvc 使用，需要插件支持（ <code>rm -rf</code> ）</p>\n<pre><code>第一种回收策略就是保留（Retain）PV 中的数据，如果希望 PV 能够被重新使用，系统管理员需要删除被使用的`PersistentVolume` 对象并手动清除存储和相关存储上的数据。\n\n另一种常见的回收策略就是删除（Delete），当 PVC 被使用者删除之后，如果当前卷支持删除的回收策略，那么 PV 和相关的存储会被自动删除，如果当前 PV 上的数据确实不再需要，那么将回收策略设置成 Delete 能够节省手动处理的时间并快速释放无用的资源。\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"访问模式\"><a class=\"anchor\" href=\"#访问模式\">#</a> 访问模式</h5>\n<p>Kubernetes 中的 PV 提供三种不同的访问模式，分别是  <code>ReadWriteOnce</code> 、 <code>ReadOnlyMany</code>  和  <code>ReadWriteMany</code> ，这三种模式的含义和用法我们可以通过它们的名字推测出来：</p>\n<ul>\n<li><code>ReadWriteOnce</code>  表示当前卷可以被一个节点使用读写模式挂载；</li>\n<li><code>ReadOnlyMany</code>  表示当前卷可以被多个节点使用只读模式挂载；</li>\n<li><code>ReadWriteMany</code>  表示当前卷可以被多个节点使用读写模式挂载；</li>\n</ul>\n<blockquote>\n<p>通常采用的持久化方案：<strong>NFS + PV/PVC</strong> 的网络存储方案来进行数据持久化。</p>\n</blockquote>\n<h4 id=\"nfs是什么\"><a class=\"anchor\" href=\"#nfs是什么\">#</a> NFS 是什么</h4>\n<p>NFS 是网络文件系统 Network File System 的缩写，NFS 服务器可以让 PC 将网络中的 NFS 服务器共享的目录挂载到本地的文件系统中，而在本地的系统中来看，那个远程主机的目录就好像是自己的一个磁盘分区一样。</p>\n<h5 id=\"nfs原理\"><a class=\"anchor\" href=\"#nfs原理\">#</a> NFS 原理</h5>\n<p>NFS 使用 RPC (Remote Procedure Call) 的机制进行实现，RPC 使得客户端可以调用服务端的函数。同时，由于有 VFS 的存在，客户端可以像使用其它普通文件系统一样使用 NFS 文件系统。经由操作系统的内核，将 NFS 文件系统的调用请求通过 TCP/IP 发送至服务端的 NFS 服务。NFS 服务器执行相关的操作，并将操作结果返回给客户端。</p>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200825110217189.png\" alt=\"image-20200825110217189\" /></p>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200825120655819.png\" alt=\"image-20200825120655819\" /></p>\n<h3 id=\"kubernetes-configmap\"><a class=\"anchor\" href=\"#kubernetes-configmap\">#</a> Kubernetes ConfigMap</h3>\n<p>pass</p>\n<h3 id=\"kubernetes-dashboard\"><a class=\"anchor\" href=\"#kubernetes-dashboard\">#</a> Kubernetes Dashboard</h3>\n<p>pass</p>\n<h3 id=\"kubernetes-security\"><a class=\"anchor\" href=\"#kubernetes-security\">#</a> Kubernetes Security</h3>\n<p>pass</p>\n<h4 id=\"rbac用户角色授权\"><a class=\"anchor\" href=\"#rbac用户角色授权\">#</a> RBAC 用户角色授权</h4>\n<p>pass</p>\n<h4 id=\"serviceaccount\"><a class=\"anchor\" href=\"#serviceaccount\">#</a> ServiceAccount</h4>\n<p>pass</p>\n",
            "tags": [
                "计算机科学",
                "学习笔记",
                "微服务",
                "K8s"
            ]
        },
        {
            "id": "https://allengx.gitee.io/computer-science/study/python/python2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/",
            "url": "https://allengx.gitee.io/computer-science/study/python/python2%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/",
            "title": "python2源码剖析",
            "date_published": "2020-04-12T12:46:25.000Z",
            "content_html": "<div class=\"note info\">\n<p>以下为个人学习笔记整理</p>\n</div>\n<h1 id=\"python源码阅读\"><a class=\"anchor\" href=\"#python源码阅读\">#</a> python 源码阅读</h1>\n<h2 id=\"数据类型分析\"><a class=\"anchor\" href=\"#数据类型分析\">#</a> 数据类型分析</h2>\n<h3 id=\"pyintobjectpython中的int类型\"><a class=\"anchor\" href=\"#pyintobjectpython中的int类型\">#</a> PyIntObject——python 中的 int 类型</h3>\n<ul>\n<li>python 计算两个整数 ()\n<ul>\n<li>出现溢出后会转换成 long 类型（无限大整数）。</li>\n</ul>\n</li>\n<li>python 整数缓存\n<ul>\n<li><code>[-5~256]</code>  的整数。</li>\n<li>提供多个缓存块，每个能够存放 <code>(100/8)</code>  数量的 int 类型。</li>\n<li>控制这些块的结构是一个单向链表（指向每个块中第一个违背使用的内存块）。</li>\n<li>申请新的缓存块采用头插法。</li>\n<li>空闲地址指针 (free_list) 会串起所有缓存块的地址空间 (单链表)。</li>\n<li>对象释放后会以头插的形式再次加入到 (free_list)。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>隐患：py2.5 之前的版本（之后的不清楚），malloc 出来的缓存块没有一个回收机制，即：创建足够多的对象（malloc 足够多的缓存块）会导致另一种意义上的内存被榨干。</p>\n</blockquote>\n<h3 id=\"pystringobjectpython中的string类型\"><a class=\"anchor\" href=\"#pystringobjectpython中的string类型\">#</a> PyStringObject——python 中的 string 类型</h3>\n<ul>\n<li>字符串的 hash\n<ul>\n<li>初始为 -1。</li>\n<li>字符串 hash 采用的算法不够理想，性能消耗较大，会对每个字符进行  <code>乘</code>  操作。</li>\n</ul>\n</li>\n<li>字符串的特性\n<ul>\n<li>长度不能超过  <code>(2**32)/2</code> ，大概是 21 亿多位，2GB 左右大小。超过则不会创建。</li>\n</ul>\n</li>\n<li>intern 内存共享\n<ul>\n<li>针对相同字符串，<s>不重复创建</s>（其实还是会创建，再销毁），它们共享同一块数据。</li>\n<li>只会生效在  <code>PyStringObject</code>  对象，其子类不会生效。</li>\n<li>创建新对象时会判断是否已经存在，如果已经存在了，会删除原来创建的对象，然后修改其指针指向。</li>\n</ul>\n</li>\n<li>字符缓冲区\n<ul>\n<li>针对单个字符进行缓存，功能类似整数缓存，长度为 (2**8)——256 个字符。</li>\n<li>初始阶段为空，每次创键新的字符，且不再缓存区内时，进行 intern 操作后，加入进去。</li>\n<li><code>+</code>  操作在 string 中执行效率非常低下（string 对象本身是不可变长类型），推荐使用 <code>join</code>  来一次处理多个。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"pylistobjectpython中的list类型\"><a class=\"anchor\" href=\"#pylistobjectpython中的list类型\">#</a> PyListObject——python 中的 list 类型</h3>\n<ul>\n<li>形如 c++ 的 vector，本质还是一个数组，分配空间时，多分配一部分，用于动态扩充。</li>\n<li>管理 list 的指针同样也有一块缓存区，可存储数量是 80 个。如果已经全部占用，则会通过 <code>GC_NEW</code>  的方式创建新的。</li>\n<li>容量调整。在容量不在限制范围内（1/2 容量～容量上限之间）。会进行（扩容 / 缩容）操作，调整方法为： <code>newsize/8 + (newsize &lt;9 ? 3:6) + newsize</code></li>\n<li>负值索引的秘诀就在，获取下标的时候针对负数执行  <code>+size</code>  操作</li>\n<li>insert 对于 list 来说性能消耗要比 append 高，因为需要后移 insert 之后的元素。</li>\n<li>对象销毁后会尝试加入缓存区，如果缓冲区满了则释放掉。但是对象管理的内存会被归还。</li>\n<li>销毁后放回缓冲区的对象会替换原来正在被使用的缓存对象，但是这并不影响。因为被剔除的对象正在被其他对象使用，所以不会被释放。只是不被缓存区管理了。</li>\n</ul>\n<h3 id=\"pydictobjectpython中的dict类型\"><a class=\"anchor\" href=\"#pydictobjectpython中的dict类型\">#</a> PyDictObject——python 中的 dict 类型</h3>\n<ul>\n<li>数据结构是 hashtable，采用开放定址法进行冲突解决（二次探测）。</li>\n<li>伪删除，字典 key 和 value 被删除时，会暂时保留 key，并且赋值为 dummy，保证能够继续通过探测链找到后续节点。但是也可以对处于 dummy 的 key 进行赋值。相当于占着坑位。</li>\n<li>dict 的 entry 的三种状态\n<ul>\n<li>active（key，val 都不为 null）</li>\n<li>dummy（key 为 dummy，val 为 null）</li>\n<li>unused（key，val 都是 null）</li>\n</ul>\n</li>\n<li>hashtable 的最初大小为 <code>8</code> ，dict 对象的创建同样使用了缓冲池，方式等同于 List。缓存 80 个。</li>\n<li>hashtable 的映射函数是直接用某个对象的 hash 值和 dict 的大小做 <code>与</code> 操作保证结果小于等于 dict 大小。</li>\n<li>判断 key 是否存在需要判断 key 的地址是否相同，不相同再去判断 值的 hash 是否相同，相同再去进行对应的比较。</li>\n<li>hash 匹配失败后的再次 hash 策略：\n<ul>\n<li>上一个 entry 的 hash 与上容器大小为  <code>i</code></li>\n<li>第一个 entry 的 hash 为  <code>k</code></li>\n<li>冲突次数  <code>s</code></li>\n<li>dict 容器大小为  <code>m</code></li>\n<li>下一个地址公式： <code>（i * 4 + i + k / （4 * s * 常量） + 1） &amp; m</code></li>\n</ul>\n</li>\n<li>变更容量操作：\n<ul>\n<li>装载率： <code>active和dummy的数量 / 总容量</code></li>\n<li>当执行插入操作时，有 Unused 或者 Dummy 对象被填充，并且插入后装载率≥2/3 会进行扩容。</li>\n<li>变容方式 当前  <code>active的节点数*(active的节点数 &gt; 50000 ? 2 : 4)</code> ，如果大于 50000 变容为原来 active 节点的 2 倍。否则变容为 4 倍。</li>\n<li>上面的规则只是期望的变容值，实际结果还需要再次计算，计算方式为 8 的指数增长≥期望变容值。例如期望变容 20，那么最终扩容值会是  <code>8*2*2 = 32</code></li>\n<li>判断变容后和之前容量是否为 8，是则不需要变容。否则，分配新内存，把原来的 active 数据插入到新的内存中。释放原有内存。</li>\n<li>触发缩容的情况：在 active 节点较少，dummy 节点较多，进行插入操作，使得变容条件成立时，触发缩容。python2.7 可能不生效，3.7 可以。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"python的编译细节\"><a class=\"anchor\" href=\"#python的编译细节\">#</a> python 的编译细节</h2>\n<h3 id=\"pyc文件\"><a class=\"anchor\" href=\"#pyc文件\">#</a> pyc 文件</h3>\n<ul>\n<li>运行时的 python 中，字节码会被存储在 PyCodeObject 中。如果一个代码块被其他模块引用（import），python 会首先去寻找对应的 pyc 文件或者 dll 文件，如果没有则会把字节码内容编译到 pyc 内，再 import，pyc 文件。本质上 pyc 文件是 python 运行时对 PyCodeObject 的一个承载。</li>\n<li>pyc 文件保存的内容都是以二进制的形式。记录内容：\n<ul>\n<li>magic number 用于版本控制</li>\n<li>time 时间戳</li>\n<li>PyCodeObject 对象</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"pyframeobject对象\"><a class=\"anchor\" href=\"#pyframeobject对象\">#</a> PyFrameObject 对象</h3>\n<ul>\n<li>运行时的 python 内部对象。可以理解为 python 中一段 code block 所生成的对象。</li>\n<li>维护了当前 code block 的全部内容：\n<ul>\n<li>loacl: 本地变量。</li>\n<li>global: 全局变量。</li>\n<li>builtin: 内建变量。</li>\n<li>f_back: 用于返回上一层的指针。</li>\n</ul>\n</li>\n<li>维护 PyFrameObject 的「栈」空间:\n<ul>\n<li>f_valuestack: 指向栈的顶部。</li>\n<li>f_stacktop: 指向当前栈顶。</li>\n<li>f_localsplus: 栈起始空间（栈顶等于栈起始空间 + extras）</li>\n<li>extras: 一些指针等额外的空间。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"python控制流\"><a class=\"anchor\" href=\"#python控制流\">#</a> python 控制流</h2>\n<ul>\n<li>\n<p><code>if</code>  控制流 ——compare 操作</p>\n<ul>\n<li>if 控制流的跳转操作只能向前。</li>\n<li>原理：通过  <code>JUMP_IF_FALSE</code>  和  <code>JUMP_IF_TRUE</code>  和  <code>JUMP_FORWARD</code>  在不同代码片段实现跳转。</li>\n<li>if 控制流通常涉及到比较操作。python 的比较分为  <code>quick_compare</code>  和  <code>slow_compare</code> ，两者速度相差甚远\n<ul>\n<li>快比较适用于两个都是整数类型</li>\n<li>其他情况下会执行慢比较</li>\n</ul>\n</li>\n<li>常见的比较类型：\n<ul>\n<li>&lt;</li>\n<li>\n<blockquote></blockquote>\n</li>\n<li>==(  <code>is</code> )</li>\n<li>!=</li>\n<li>\n<blockquote>\n<p>=</p>\n</blockquote>\n</li>\n<li>&lt;=</li>\n<li>in</li>\n</ul>\n</li>\n<li>慢比较时，如果两个对象类型相同，且不是自定义对象，那么 python 会使用  <code>tp_richcompare</code>  比较器进行比较，如果没有定义  <code>tp_richcompare</code>  或者不满足前面的条件，则会使用用户自定义的  <code>tp_compare</code>  进行比较。如果上述两个比较器均未实现，python 还会尝试调用  <code>do_richcmp</code>  进行最后的垂死挣扎，这也是慢比较低下的原因。</li>\n<li>goto 指令：\n<ul>\n<li>JUMP_FORWARD：跳转到  <code>if else</code>  语句的最终结尾</li>\n<li>JUMP_IF_FALSE：跳转到对应 false 的逻辑处</li>\n<li>JUMP_IF_TRUE：跳转到对应 true 的逻辑处</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>for</code>  控制流</p>\n<ul>\n<li>for 控制流的跳转操作可以向前也可以回退。</li>\n<li>原理：for 语句会把全部对象顺序压入栈中，并把对象的迭代器设置为栈顶，然后通过 SET_TOP 跳转到栈顶，根据迭代器的 tp_iternext 找到对应的元素，进行迭代。</li>\n<li>goto 指令：\n<ul>\n<li>JUMP_ABSOLUTE：回到 FOR_ITER 指令位置，重新开始迭代下一个对象</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>switch case</code>  控制流</p>\n<ul>\n<li>没有了</li>\n</ul>\n</li>\n<li>\n<p><code>while</code>  控制流</p>\n<ul>\n<li>while 和 for 控制流类似。</li>\n</ul>\n</li>\n<li>\n<p><code>exception</code>  控制流</p>\n<ul>\n<li>异常控制流主要是处理 python 程序在执行过程中如何抛出和捕获异常的控制流。</li>\n<li>原理：程序执行过程中会构建一个调用栈，当执行到某个函数触发了异常，程序将通过  <code>PyEval_ExalFrameEx</code>  函数进行处理，如果没有检测到 except 时， 函数的状态会从  <code>WHY_NOT</code>  转变为  <code>WHY_EXCEPTION</code> ，并返回 NULL，同时调整栈指针指向上一层。</li>\n<li>异常控制流程图：</li>\n</ul>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200927160601568.png\" alt=\"image-20200927160601568\" /></p>\n<ul>\n<li><code>PyEval_ExalFrameEx</code>  函数伪代码：</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>PyObject<span class=\"token operator\">*</span> <span class=\"token function\">PyEval_EvalFrameEx</span><span class=\"token punctuation\">(</span>PyFrameObject <span class=\"token operator\">*</span>f<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token comment\">// 非正常执行</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>why <span class=\"token operator\">!=</span> WHY_NOT <span class=\"token operator\">&amp;&amp;</span> f<span class=\"token operator\">-></span>f_iblock <span class=\"token operator\">></span><span class=\"token number\">0</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>            PyTryBlock <span class=\"token operator\">*</span>b <span class=\"token operator\">=</span> <span class=\"token function\">PyFrame_BlockPop</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>            <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>            <span class=\"token comment\">// 有 finally 或者 except 语句</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>b<span class=\"token operator\">-></span>b_type <span class=\"token operator\">==</span> SETUP_FINALLY <span class=\"token operator\">||</span> b<span class=\"token operator\">-></span>b_type <span class=\"token operator\">==</span> SETUP_EXCEPT <span class=\"token operator\">&amp;&amp;</span> why <span class=\"token operator\">==</span> WHY_EXCEPTION<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>                 <span class=\"token comment\">// 出现异常，先把异常信息取出来，如果后续没有 except，需要保留现场信息并返回给上一级。</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>why <span class=\"token operator\">==</span> WHY_EXCEPTION<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>                    PyObject <span class=\"token operator\">*</span>exc<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>val<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>tb<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>                    <span class=\"token function\">PyErr_Fetch</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>exc<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>val<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>tb<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>                    <span class=\"token function\">PUSH</span><span class=\"token punctuation\">(</span>tb<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>                    <span class=\"token function\">PUSH</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>                    <span class=\"token function\">PUSH</span><span class=\"token punctuation\">(</span>exc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>                <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>                    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>                <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>                <span class=\"token comment\">// 设置为正常运转，并调用 except 或 finally</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>                <span class=\"token comment\">//except 执行后会继续在当前栈帧运行（异常被解决）</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>                <span class=\"token comment\">// 无 except 的情况下，finally 执行后会展开到上一层（异常未被解决）</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>                why <span class=\"token operator\">=</span> WHY_NOT<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>                <span class=\"token function\">JUMPTO</span><span class=\"token punctuation\">(</span>b<span class=\"token operator\">-></span>b_handler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>        </pre></td></tr><tr><td data-num=\"32\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>why <span class=\"token operator\">!=</span> WHY_NOT<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 不存在异常处理，展开堆栈，抛给上一层</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>why <span class=\"token operator\">!=</span> WHY_RETURN<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>        retval <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 通知前一栈帧有异常</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>    </pre></td></tr><tr><td data-num=\"39\"></td><td><pre>   <span class=\"token comment\">// 设置活动栈帧为当前栈帧的上一个，完成栈帧回退</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>   tstate<span class=\"token operator\">-></span>frame <span class=\"token operator\">=</span> f<span class=\"token operator\">-></span>f_back<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>   <span class=\"token keyword\">return</span> retval</pre></td></tr><tr><td data-num=\"42\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 示例 h () -> g () ->f () -> 1/0</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">h</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    g<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">g</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    f<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token operator\">/</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"11\"></td><td><pre>h<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200927145147290.png\" alt=\"image-20200927145147290\" /></p>\n<ul>\n<li><code>try catch</code>  控制流</li>\n</ul>\n<h2 id=\"python函数机制\"><a class=\"anchor\" href=\"#python函数机制\">#</a> python 函数机制</h2>\n<p>todo...</p>\n<h2 id=\"python类机制\"><a class=\"anchor\" href=\"#python类机制\">#</a> python 类机制</h2>\n<p>todo...</p>\n<h2 id=\"python运行环境初始化\"><a class=\"anchor\" href=\"#python运行环境初始化\">#</a> python 运行环境初始化</h2>\n<p>todo...</p>\n<h2 id=\"python模块动态加载机制\"><a class=\"anchor\" href=\"#python模块动态加载机制\">#</a> python 模块动态加载机制</h2>\n<p>todo...</p>\n<h2 id=\"python多线程机制\"><a class=\"anchor\" href=\"#python多线程机制\">#</a> python 多线程机制</h2>\n<p>todo...</p>\n<h2 id=\"python的垃圾回收gc\"><a class=\"anchor\" href=\"#python的垃圾回收gc\">#</a> python 的垃圾回收 GC</h2>\n<h3 id=\"block\"><a class=\"anchor\" href=\"#block\">#</a> block</h3>\n<ul>\n<li>用于存放对象的最小单位。</li>\n<li>针对不同 size 的数据进行分类存储的块。数据大小为 8 的整数倍，最大为 256 字节。</li>\n<li>如果内存大小≤256，则 python 会通过 PyObject_Malloc 去分配。如果 &gt; 256 字节，则会使用 malloc 来分配内存。</li>\n<li>size 有 32 种（0~31）之后的版本扩充到了 63（512 字节）。</li>\n<li>给对象分配的空间一般会超过原本大小，向上取 8 的整数倍。</li>\n</ul>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/Image(68).png\" alt=\"c87bfa632b2c7e3254911863fbe36e55.png\" /></p>\n<h3 id=\"pool\"><a class=\"anchor\" href=\"#pool\">#</a> pool</h3>\n<ul>\n<li>\n<p>同一个 pool 中的 block 大小必须统一。<br />\n<img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/Image(69).png\" alt=\"7b94ea10747352b5100ca504cdf76571.png\" /></p>\n</li>\n<li>\n<p>pool 的大小一般为 4kb。</p>\n</li>\n<li>\n<p>管理 block 的指针分为四种：</p>\n<ul>\n<li>bp 指针：指向当前使用 block。</li>\n<li>free 指针：指向下一个可用 block，free 是一个链表，每个节点内的值为 Null 或者是下一个空闲的 block 地址。</li>\n<li>next 指针：指向 free 的下一个空闲 block，一般是在当 free 内的值为 Null 的情况下，系统申请新空闲 block 后，给 free 作定位用的。</li>\n<li>maxnext 指针：指向 block 的最后一个 block 的首地址。用于判断 block 是否已经全部分配完毕。<br />\n<img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/Image(70).png\" alt=\"ba149b720cee23ad2d08f6d95bb29524.png\" /></li>\n</ul>\n</li>\n<li>\n<p>pool 的结构是由一个 pool_header 和一堆 block 组成的数组。它们是一个整体。</p>\n</li>\n<li>\n<p>pool 的状态：</p>\n<ul>\n<li>used 状态。pool 中即存在被使用的 block，也存在未被使用的 block。</li>\n<li>full 状态。pool 中所有 block 都在被使用。</li>\n<li>empty 状态。pool 中所有 block 都未被使用。</li>\n</ul>\n</li>\n<li>\n<p>usedpools。所有正在被使用的 pool 的双向链表头。本身是一个 pool_header * 组成的数组，通过一点取巧的方式把每个指针和其前面 2 个位置的指针一起视为一个 pool_header 对象从而构成一个空的双向链表。</p>\n</li>\n</ul>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200919154449909.png\" alt=\"image-20200919154449909\" /></p>\n<h3 id=\"arena\"><a class=\"anchor\" href=\"#arena\">#</a> arena</h3>\n<ul>\n<li>\n<p>多个 pool 的管理者，每个 arena 的 pool 可以存在多个不同的 <code>size class index</code> 。<br />\n<img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200919154538226.png\" alt=\"image-20200919154538226\" /></p>\n</li>\n<li>\n<p>一个 arena 的大小为 256k，可容纳 64 个 pool。<br />\n<img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200919154553555.png\" alt=\"image-20200919154553555\" /></p>\n</li>\n<li>\n<p>arena 的结构是由一个 arena_object 指针和一堆 pool 组成的数组构成。不像 pool 一样，arena 的指针和内存是分离的。</p>\n</li>\n<li>\n<p>arena 有两种状态</p>\n<ul>\n<li>未使用状态：arena_object 指针没有指向对应的 pool 组成的数组块。</li>\n<li>使用状态：arena_object 指针已经指向对应的 pool 组成的数组块。</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200919154614444.png\" alt=\"image-20200919154614444\" /><br />\n<img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200919154634438.png\" alt=\"image-20200919154634438\" /></p>\n<h3 id=\"arenas\"><a class=\"anchor\" href=\"#arenas\">#</a> arenas</h3>\n<ul>\n<li>管理多个 arena 的对象指针的数组。</li>\n<li>把 arena 分为两种状态：\n<ul>\n<li>未使用状态：通过 arenas 的 unused_arena_objects 指针作为表头的单向链表所连接</li>\n<li>使用状态：通过 arenas 的 used_arena_objects 指针作为表头的双向链表所连接</li>\n</ul>\n</li>\n<li>多个 arenas 通过名为 nextarena 和 prevatrena 的指针所联系在一起。</li>\n<li>初始化时创建的 arena 的数量为 16 个。之后如果未使用的 arena 不足时，会进行二倍的扩容。</li>\n<li>扩容操作只会创建 arena 的指针，只有在 arena 将要被使用时，才会去分配一个 256k 的大小。</li>\n<li>当前管理的 arena 的总数是由一个 int 类型的变量控制。每次扩容左移一位。当发生溢出（超过 2**32 或者分配的空间不足一个 arenas 的大小）时停止扩容操作。<br />\n<img data-src=\"https://gitee.com/allengx/pic_bed/raw/master/img/image-20200919154653554.png\" alt=\"image-20200919154653554\" /></li>\n</ul>\n<p>参考：<span class=\"exturl\" data-url=\"aHR0cDovL3drbGtlbi5tZS9wb3N0cy8yMDE1LzA4LzI5L3B5dGhvbi1zb3VyY2UtbWVtb3J5LTEuaHRtbA==\">http://wklken.me/posts/2015/08/29/python-source-memory-1.html</span></p>\n<p>参考：<span class=\"exturl\" data-url=\"aHR0cDovL3drbGtlbi5tZS9wb3N0cy8yMDE1LzA4LzI5L3B5dGhvbi1zb3VyY2UtbWVtb3J5LTIuaHRtbA==\">http://wklken.me/posts/2015/08/29/python-source-memory-2.html</span></p>\n<h3 id=\"垃圾回收gc\"><a class=\"anchor\" href=\"#垃圾回收gc\">#</a> 垃圾回收（GC）</h3>\n<h4 id=\"1-标记清除marksweep\"><a class=\"anchor\" href=\"#1-标记清除marksweep\">#</a> 1、标记清除（Mark——Sweep）</h4>\n<ul>\n<li>寻找根对象集合\n<ul>\n<li>采用双向链表存储所有 container 对象</li>\n<li>为此每个 container 对象头部都存在一个 PyGC_Head 的数据块（在 PyObject_Head 之前）</li>\n</ul>\n</li>\n<li>寻找可达对象和不可达对象</li>\n<li>广度探测</li>\n<li>对于非 container 对象不进行检查\n<ul>\n<li>一个对象如果不能存储其他对象的引用则被视为非 container 对象</li>\n</ul>\n</li>\n<li>对于可达对象进行保留，不可达对象进行回收。</li>\n</ul>\n<h4 id=\"2-分代的垃圾收集python的解决办法\"><a class=\"anchor\" href=\"#2-分代的垃圾收集python的解决办法\">#</a> 2、分代的垃圾收集 ——python 的解决办法</h4>\n<ul>\n<li>\n<p>核心思想：</p>\n<ul>\n<li>根据内存的创建时间划分为不同的「代」</li>\n<li>时间越「长」的对象其被回收的概率就「小」。</li>\n<li>经过多次垃圾回收「存活」下来的对象则会被分配到回收周期更「长」的代中。</li>\n<li>每个「代」在 python 中对应的是一个「链表」，python 总共把代分为三个。</li>\n<li>第「0」个代的链表长度超过 700 时会触发垃圾回收（第一、二代都是 10）。python 还会借此机会清理其他的代。</li>\n<li>python 对代的清理是通过把第 2 代到第 0 代的三个链表（也可能不足三个）进行 merge。最终链接到第 2 代的链表后，一口气执行垃圾回收，打上回收标记。</li>\n<li>打上不可回收标记。通过有效引用计数，把计数不为「0」的对象打上不可回收标记。</li>\n<li>把不可回收对象单独存放在一个集合内。并把这些对象中所引用的对象（并且这些引用对象打上了可回收标记），也加入这个集合（双向链表）。</li>\n<li>对于定义了「 <code>__del__</code> 」的对象（finalizer 对象）需要单独用一个 PyListObject 来存放，在删除 finalizer 对象的时候先扣除该对象所引用的对象的引用计数，并清理引用列表，待到引用计数为 0 时再进行垃圾回收，保证回收对象已经不被任何对象引用。</li>\n<li>三种存储回收对象的链表：\n<ul>\n<li>reachable：保存每次需要回收的所有对象。</li>\n<li>unreachable：保存双向引用的回收对象。</li>\n<li>uncollectable：保存带有「 <code>__del__</code> 」函数的双向引用对象。</li>\n</ul>\n</li>\n<li>正常情况下的对象会在计数为 0 的时候就被销毁，所以存在于 <code>root object</code>  的对象都是双向引用或者被系统引用的对象。后者一般不会被回收。</li>\n</ul>\n</li>\n<li>\n<p>有效引用计数（解决垃圾回收时环引用）：</p>\n<ul>\n<li>遍历所有需要回收的对象（在 root object 集合中）。根据对象类型，判断每个对象内的引用 是否也是需要回收的对象，如果是，则对他的引用计数「副本」进行「 <code>--</code> 」操作，最终引用计数副本为「0」的对象将被视为可能需要回收。</li>\n</ul>\n</li>\n<li>\n<p>注意事项：</p>\n<ul>\n<li>python 在回收垃圾的时候没办法保证顺序，尽量避免在「 <code>__del__</code> 」中引用其他对象。</li>\n<li>python2.7 和 python3.+ 对于执行垃圾回收时，在「 <code>__del__</code> 」中引用其他对象这一操作所给出的解决方案有所不同。</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "计算机科学",
                "学习笔记",
                "Python",
                "Python, 源码"
            ]
        },
        {
            "id": "https://allengx.gitee.io/computer-science/study/opengl/%E4%B8%89%E3%80%81OpenGL%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD/",
            "url": "https://allengx.gitee.io/computer-science/study/opengl/%E4%B8%89%E3%80%81OpenGL%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD/",
            "title": "三、OpenGL模型加载",
            "date_published": "2020-04-12T12:46:25.000Z",
            "content_html": "<div class=\"note info\">\n<p>以下为个人学习笔记整理</p>\n</div>\n<h1 id=\"模型加载\"><a class=\"anchor\" href=\"#模型加载\">#</a> 模型加载</h1>\n<h2 id=\"assimp\"><a class=\"anchor\" href=\"#assimp\">#</a> Assimp</h2>\n<p>到目前为止的所有场景中，我们一直都在滥用我们的箱子朋友，但时间久了甚至是我们最好的朋友也会感到无聊。在日常的图形程序中，通常都会使用非常复杂且好玩的模型，它们比静态的箱子要好看多了。然而，和箱子对象不同，我们不太能够对像是房子、汽车或者人形角色这样的复杂形状手工定义所有的顶点、法线和纹理坐标。我们想要的是将这些模型 (Model) 导入 (Import) 到程序当中。模型通常都由 3D 艺术家在<mark> Blender</mark>、<mark>3DS Max</mark> 或者<mark> Maya</mark> 这样的工具中精心制作。</p>\n<p>这些所谓的<mark> 3D 建模工具</mark> (3D Modeling Tool) 可以让艺术家创建复杂的形状，并使用一种叫做<mark> UV 映射</mark> (uv-mapping) 的手段来应用贴图。这些工具将会在导出到模型文件的时候<mark>自动生成所有的顶点坐标</mark>、<mark>顶点法线</mark>以及<mark>纹理坐标</mark>。这样子艺术家们即使不了解图形技术细节的情况下，也能拥有一套强大的工具来构建高品质的模型了。所有的技术细节都隐藏在了导出的模型文件中。但是，作为图形开发者，我们就必须要了解这些技术细节了。</p>\n<p>所以，我们的工作就是解析这些导出的模型文件以及提取所有有用的信息，将它们储存为 OpenGL 能够理解的格式。一个很常见的问题是，模型的文件格式有很多种，每一种都会以它们自己的方式来导出模型数据。像是 Wavefront 的.obj 这样的模型格式，只包含了<mark>模型数据</mark>以及<mark>材质信息</mark>，像是模型颜色和漫反射 / 镜面光贴图。而以 XML 为基础的 Collada 文件格式则非常的丰富，包含模型、光照、多种材质、动画数据、摄像机、完整的场景信息等等。Wavefront 的.obj 格式通常被认为是一个易于解析的模型格式。建议至少去 Wavefront 的 wiki 页面上看看文件格式的信息是如何封装的。这应该能让你认识到模型文件的基本结构。</p>\n<p>总而言之，不同种类的文件格式有很多，它们之间通常并没有一个通用的结构。所以如果我们想从这些文件格式中导入模型的话，我们必须要去自己对每一种需要导入的文件格式写一个导入器。很幸运的是，正好有一个库专门处理这个问题。</p>\n<h3 id=\"模型加载库\"><a class=\"anchor\" href=\"#模型加载库\">#</a> 模型加载库</h3>\n<p>一个非常流行的模型导入库是<mark> Assimp</mark>，它是 Open Asset Import Library（开放的资产导入库）的缩写。Assimp 能够导入很多种不同的模型文件格式（并也能够导出部分的格式），它会将所有的模型数据加载至 Assimp 的通用数据结构中。当 Assimp 加载完模型之后，我们就能够从 Assimp 的数据结构中提取我们所需的所有数据了。由于 Assimp 的数据结构保持不变，不论导入的是什么种类的文件格式，它都能够将我们从这些不同的文件格式中抽象出来，用同一种方式访问我们需要的数据。</p>\n<p>当使用 Assimp 导入一个模型的时候，它通常会将整个模型加载进一个<mark>场景</mark> (Scene) 对象，它会包含导入的模型 / 场景中的所有数据。Assimp 会将场景载入为一系列的节点 (Node)，每个节点包含了场景对象中所储存数据的索引，每个节点都可以有任意数量的子节点。Assimp 数据结构的（简化）模型如下：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/03/01/assimp_structure.png\" alt=\"image\" /></p>\n<ul>\n<li>和材质和<mark>网格</mark> (Mesh) 一样，所有的场景 / 模型数据都包含在 Scene 对象中。Scene 对象也包含了场景根节点的引用。</li>\n<li>场景的 Root node（根节点）可能包含子节点（和其它的节点一样），它会有一系列指向场景对象中 mMeshes 数组中储存的网格数据的索引。Scene 下的 mMeshes 数组储存了真正的 Mesh 对象，节点中的 mMeshes 数组保存的只是场景中网格数组的索引。</li>\n<li><mark>一个 Mesh 对象本身包含了渲染所需要的所有相关数据</mark>，像是顶点位置、法向量、纹理坐标、面 (Face) 和物体的材质。</li>\n<li>一个网格包含了多个面。<mark>Face 代表的是物体的渲染图元</mark> (Primitive)（三角形、方形、点）。一个面包含了组成图元的顶点的索引。由于顶点和索引是分开的，使用一个索引缓冲来渲染是非常简单的（见你好，三角形）。</li>\n<li>最后，一个网格也包含了一个<mark> Material</mark> 对象，它包含了一些函数能让我们获取物体的材质属性，比如说颜色和纹理贴图（比如漫反射和镜面光贴图）。</li>\n</ul>\n<p>所以，我们需要做的第一件事是将一个物体加载到 Scene 对象中，遍历节点，获取对应的 Mesh 对象（我们需要递归搜索每个节点的子节点），并处理每个 Mesh 对象来获取顶点数据、索引以及它的材质属性。最终的结果是一系列的网格数据，我们会将它们包含在一个 Model 对象中。</p>\n<blockquote>\n<p>网格<br />\n当使用建模工具对物体建模的时候，艺术家通常不会用单个形状创建出整个模型。通常每个模型都由几个子模型 / 形状组合而成。组合模型的每个单独的形状就叫做一个网格 (Mesh)。比如说有一个人形的角色：艺术家通常会将头部、四肢、衣服、武器建模为分开的组件，并将这些网格组合而成的结果表现为最终的模型。<mark>一个网格是我们在 OpenGL 中绘制物体所需的最小单位</mark>（顶点数据、索引和材质属性）。一个模型（通常）会包括多个网格。</p>\n</blockquote>\n<p>在下一节中，我们将创建我们自己的 Model 和 Mesh 类来加载并使用刚刚介绍的结构储存导入后的模型。如果我们想要绘制一个模型，我们不需要将<mark>整个</mark>模型渲染为一个整体，只需要渲染组成模型的每个独立的网格就可以了。然而，在我们开始导入模型之前，我们首先需要将 Assimp 包含到我们的工程当中。</p>\n<h3 id=\"构建assimp\"><a class=\"anchor\" href=\"#构建assimp\">#</a> 构建 Assimp</h3>\n<p>你可以在 Assimp 的<span class=\"exturl\" data-url=\"aHR0cDovL2Fzc2ltcC5zb3VyY2Vmb3JnZS5uZXQvbWFpbl9kb3dubG9hZHMuaHRtbA==\">下载页面</span>中选择相应的版本。在写作时使用的 Assimp 最高版本为 3.1.1。我们建议你自己编译 Assimp 库，因为它们的预编译库在大部分系统上都是不能运行的。如果你忘记如何使用 CMake 自己编译一个库的话，可以复习创建窗口小节。</p>\n<p>构建 Assimp 时可能会出现一些问题，所以我会将它们的解决方案列在这里，便于大家排除错误：</p>\n<ul>\n<li>CMake 在读取配置列表时，不断报出 DirectX 库丢失的错误。报错如下：</li>\n</ul>\n<blockquote>\n<p>Could not locate DirectX<br />\nCMake Error at cmake-modules/FindPkgMacros.cmake:110 (message):<br />\nRequired library DirectX not found! Install the library (including dev packages)<br />\nand try again. If the library is already installed, set the missing variables<br />\nmanually in cmake.</p>\n</blockquote>\n<p>这个问题的解决方案是安装 DirectX SDK，如果你之前没安装过的话。你可以从<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS9lbi11cy9kb3dubG9hZC9kZXRhaWxzLmFzcHg/aWQ9NjgxMg==\">这里下载 SDK</span>。</p>\n<ul>\n<li>安装 DirectX SDK 时，可能遇到一个错误码为 s1023 的错误。这种情况下，请在安装 SDK 之前根据这个先卸载 C++ Redistributable package (s)。</li>\n<li>一旦配置完成，你就可以生成解决方案文件了，打开解决方案文件并编译 Assimp 库（可以编译为 Debug 版本也可以编译为 Release 版本，只要能工作就行）。</li>\n<li>使用默认配置构建的 Assimp 是一个动态库 (Dynamic Library)，所以我们需要包含所生成的 assimp.dll 文件以及程序的二进制文件。你可以简单地将 DLL 复制到我们程序可执行文件的同一目录中。</li>\n<li>Assimp 编译之后，生成的库和 DLL 文件位于 code/Debug 或者 code/Release 文件夹中。</li>\n<li>接着把编译好的 LIB 文件和 DLL 文件拷贝到工程的相应目录下，并在解决方案中链接它们。并且记得把 Assimp 的头文件也复制到你的 include 目录中（头文件可以在从 Assimp 中下载的 include 目录里找到）。</li>\n</ul>\n<blockquote>\n<p>如果你想让 Assimp 使用多线程来获得更高的性能，你可以使用 Boost 库来编译 Assimp。你可以在它们的安装页面找到完整的安装介绍。</p>\n</blockquote>\n<h2 id=\"网格\"><a class=\"anchor\" href=\"#网格\">#</a> 网格</h2>\n<p>通过使用 Assimp，我们可以加载不同的模型到程序中，但是载入后它们都被储存为<mark> Assimp 的数据结构</mark>。我们最终仍要将这些数据转换为 OpenGL 能够理解的格式，这样才能渲染这个物体。我们从上一节中学到，网格 (Mesh) 代表的是单个的可绘制实体，我们现在先来定义一个我们自己的网格类。</p>\n<p>首先我们来回顾一下我们目前学到的知识，想想一个网格最少需要什么数据。一个网格应该至少需要一系列的顶点，每个顶点包含一个位置向量、一个法向量和一个纹理坐标向量。一个网格还应该包含用于索引绘制的索引以及纹理形式的材质数据（漫反射 / 镜面光贴图）。</p>\n<p>既然我们有了一个网格类的最低需求，我们可以在 OpenGL 中定义一个顶点了：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Vertex</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    glm<span class=\"token operator\">::</span>vec3 Position<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    glm<span class=\"token operator\">::</span>vec3 Normal<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    glm<span class=\"token operator\">::</span>vec2 TexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>我们将所有需要的向量储存到一个叫做 Vertex 的结构体中，我们可以用它来索引每个顶点属性。除了 Vertex 结构体之外，我们还需要将纹理数据整理到一个 Texture 结构体中。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Texture</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> id<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    string type<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>我们储存了纹理的 id 以及它的类型，比如是漫反射贴图或者是镜面光贴图。</p>\n<p>知道了顶点和纹理的实现，我们可以开始定义网格类的结构了：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Mesh</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token comment\">/*  网格数据  */</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        vector<span class=\"token operator\">&lt;</span>Vertex<span class=\"token operator\">></span> vertices<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span> indices<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        vector<span class=\"token operator\">&lt;</span>Texture<span class=\"token operator\">></span> textures<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token comment\">/*  函数  */</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token function\">Mesh</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span>Vertex<span class=\"token operator\">></span> vertices<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span> indices<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span>Texture<span class=\"token operator\">></span> textures<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token keyword\">void</span> <span class=\"token function\">Draw</span><span class=\"token punctuation\">(</span>Shader shader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">private</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token comment\">/*  渲染数据  */</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> VAO<span class=\"token punctuation\">,</span> VBO<span class=\"token punctuation\">,</span> EBO<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token comment\">/*  函数  */</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token keyword\">void</span> <span class=\"token function\">setupMesh</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>你可以看到这个类并不复杂。在构造器中，我们将所有必须的数据赋予了网格，我们在 setupMesh 函数中初始化缓冲，并最终使用 Draw 函数来绘制网格。注意我们将一个着色器传入了 Draw 函数中，将着色器传入网格类中可以让我们在绘制之前设置一些 uniform（像是链接采样器到纹理单元）。</p>\n<p>构造器的内容非常易于理解。我们只需要使用构造器的参数设置类的公有变量就可以了。我们在构造器中还调用了 setupMesh 函数：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">Mesh</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span>Vertex<span class=\"token operator\">></span> vertices<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span> indices<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span>Texture<span class=\"token operator\">></span> textures<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">this</span><span class=\"token operator\">-></span>vertices <span class=\"token operator\">=</span> vertices<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">this</span><span class=\"token operator\">-></span>indices <span class=\"token operator\">=</span> indices<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">this</span><span class=\"token operator\">-></span>textures <span class=\"token operator\">=</span> textures<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token function\">setupMesh</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这里没什么可说的。我们接下来讨论 setupMesh 函数。</p>\n<h3 id=\"初始化\"><a class=\"anchor\" href=\"#初始化\">#</a> 初始化</h3>\n<p>由于有了构造器，我们现在有一大列的网格数据用于渲染。在此之前我们还必须配置正确的缓冲，并通过顶点属性指针定义顶点着色器的布局。现在你应该对这些概念都很熟悉了，但我们这次会稍微有一点变动，使用结构体中的顶点数据：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">setupMesh</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token function\">glGenVertexArrays</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>VAO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token function\">glGenBuffers</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>VBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token function\">glGenBuffers</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>EBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token function\">glBindVertexArray</span><span class=\"token punctuation\">(</span>VAO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> VBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token function\">glBufferData</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> vertices<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>Vertex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>vertices<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> GL_STATIC_DRAW<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_ELEMENT_ARRAY_BUFFER<span class=\"token punctuation\">,</span> EBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token function\">glBufferData</span><span class=\"token punctuation\">(</span>GL_ELEMENT_ARRAY_BUFFER<span class=\"token punctuation\">,</span> indices<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> </pre></td></tr><tr><td data-num=\"14\"></td><td><pre>                 <span class=\"token operator\">&amp;</span>indices<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> GL_STATIC_DRAW<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token comment\">// 顶点位置</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token function\">glEnableVertexAttribArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   </pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token function\">glVertexAttribPointer</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>Vertex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token comment\">// 顶点法线</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token function\">glEnableVertexAttribArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   </pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token function\">glVertexAttribPointer</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>Vertex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">offsetof</span><span class=\"token punctuation\">(</span>Vertex<span class=\"token punctuation\">,</span> Normal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token comment\">// 顶点纹理坐标</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token function\">glEnableVertexAttribArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   </pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token function\">glVertexAttribPointer</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>Vertex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">offsetof</span><span class=\"token punctuation\">(</span>Vertex<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token function\">glBindVertexArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>代码应该和你所想得没什么不同，但有了 Vertex 结构体的帮助，我们使用了一些小技巧。</p>\n<p>C++ 结构体有一个很棒的特性，它们的内存布局是连续的 (Sequential)。也就是说，如果我们将结构体作为一个数据数组使用，那么它将会以顺序排列结构体的变量，这将会直接转换为我们在数组缓冲中所需要的 float（实际上是字节）数组。比如说，如果我们有一个填充后的 Vertex 结构体，那么它的内存布局将会等于：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Vertex vertex<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>vertex<span class=\"token punctuation\">.</span>Position  <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.2f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.4f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.6f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>vertex<span class=\"token punctuation\">.</span>Normal    <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>vertex<span class=\"token punctuation\">.</span>TexCoords <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec2</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// = [0.2f, 0.4f, 0.6f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f];</span></pre></td></tr></table></figure><p>由于有了这个有用的特性，我们能够直接传入一大列的 Vertex 结构体的指针作为缓冲的数据，它们将会完美地转换为 glBufferData 所能用的参数：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glBufferData</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> vertices<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>Vertex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>vertices<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> GL_STATIC_DRAW<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>自然 sizeof 运算也可以用在结构体上来计算它的字节大小。这个应该是 32 字节的（8 个 float * 每个 4 字节）。</p>\n<p>结构体的另外一个很好的用途是它的预处理指令 offsetof (s, m)，它的第一个参数是一个结构体，第二个参数是这个结构体中变量的名字。这个宏会返回那个变量距结构体头部的字节偏移量 (Byte Offset)。这正好可以用在定义 glVertexAttribPointer 函数中的偏移参数：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glVertexAttribPointer</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>Vertex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">offsetof</span><span class=\"token punctuation\">(</span>Vertex<span class=\"token punctuation\">,</span> Normal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>偏移量现在是使用<mark> offsetof</mark> 来定义了，在这里它会将法向量的字节偏移量设置为结构体中法向量的偏移量，也就是 3 个 float，即 12 字节。注意，我们同样将步长参数设置为了 Vertex 结构体的大小。</p>\n<p>使用这样的一个结构体不仅能够提供可读性更高的代码，也允许我们很容易地拓展这个结构。如果我们希望添加另一个顶点属性，我们只需要将它添加到结构体中就可以了。由于它的灵活性，渲染的代码不会被破坏。</p>\n<h3 id=\"渲染\"><a class=\"anchor\" href=\"#渲染\">#</a> 渲染</h3>\n<p>我们需要为 Mesh 类定义最后一个函数，它的 Draw 函数。在真正渲染这个网格之前，我们需要在调用 glDrawElements 函数之前先绑定相应的纹理。然而，这实际上有些困难，我们一开始并不知道这个网格（如果有的话）有多少纹理、纹理是什么类型的。所以我们该如何在着色器中设置纹理单元和采样器呢？</p>\n<p>为了解决这个问题，我们需要设定一个命名标准：每个漫反射纹理被命名为<mark> texture_diffuseN</mark>，每个镜面光纹理应该被命名为<mark> texture_specularN</mark>，其中 N 的范围是 1 到纹理采样器最大允许的数字。比如说我们对某一个网格有 3 个漫反射纹理，2 个镜面光纹理，它们的纹理采样器应该之后会被调用：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>uniform sampler2D texture_diffuse1<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>uniform sampler2D texture_diffuse2<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>uniform sampler2D texture_diffuse3<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>uniform sampler2D texture_specular1<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>uniform sampler2D texture_specular2<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>根据这个标准，我们可以在着色器中定义任意需要数量的纹理采样器，如果一个网格真的包含了（这么多）纹理，我们也能知道它们的名字是什么。根据这个标准，我们也能在一个网格中处理任意数量的纹理，开发者也可以自由选择需要使用的数量，他只需要定义正确的采样器就可以了（虽然定义少的话会有点浪费绑定和 uniform 调用）。</p>\n<blockquote>\n<p>像这样的问题有很多种不同的解决方案。如果你不喜欢这个解决方案，你可以自己想一个你自己的解决办法。</p>\n</blockquote>\n<p>最终的渲染代码是这样的：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">Draw</span><span class=\"token punctuation\">(</span>Shader shader<span class=\"token punctuation\">)</span> </pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> diffuseNr <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> specularNr <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> textures<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token function\">glActiveTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE0 <span class=\"token operator\">+</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 在绑定之前激活相应的纹理单元</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token comment\">// 获取纹理序号（diffuse_textureN 中的 N）</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        string number<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        string name <span class=\"token operator\">=</span> textures<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">==</span> <span class=\"token string\">\"texture_diffuse\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>            number <span class=\"token operator\">=</span> std<span class=\"token operator\">::</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span>diffuseNr<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">==</span> <span class=\"token string\">\"texture_specular\"</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>            number <span class=\"token operator\">=</span> std<span class=\"token operator\">::</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span>specularNr<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        shader<span class=\"token punctuation\">.</span><span class=\"token function\">setFloat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"material.\"</span> <span class=\"token operator\">+</span> name <span class=\"token operator\">+</span> number<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">c_str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> textures<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token function\">glActiveTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token comment\">// 绘制网格</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token function\">glBindVertexArray</span><span class=\"token punctuation\">(</span>VAO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token function\">glDrawElements</span><span class=\"token punctuation\">(</span>GL_TRIANGLES<span class=\"token punctuation\">,</span> indices<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> GL_UNSIGNED_INT<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token function\">glBindVertexArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们首先计算了每个纹理类型的 N - 分量，并将其拼接到纹理类型字符串上，来获取对应的 uniform 名称。接下来我们查找对应的采样器，将它的位置值设置为当前激活的纹理单元，并绑定纹理。这也是我们在 Draw 函数中需要着色器的原因。我们也将 &quot;material.&quot; 添加到了最终的 uniform 名称中，因为我们希望将纹理储存在一个材质结构体中（这在每个实现中可能都不同）。</p>\n<blockquote>\n<p>注意我们在将漫反射计数器和镜面光计数器插入 stringstream 时，对它们进行了递增。在 C<ins> 中，这个递增操作：variable</ins> 将会返回变量本身，之后再递增，而 ++variable 则是先递增，再返回值。在我们的例子中是首先将原本的计数器值插入 stringstream，之后再递增它，供下一次循环使用。</p>\n</blockquote>\n<h2 id=\"模型\"><a class=\"anchor\" href=\"#模型\">#</a> 模型</h2>\n<p>现在是时候接触 Assimp 并创建实际的加载和转换代码了。这个教程的目标是创建另一个类来完整地表示一个模型，或者说是包含多个网格，甚至是多个物体的模型。一个包含木制阳台、塔楼、甚至游泳池的房子可能仍会被加载为一个模型。我们会使用 Assimp 来加载模型，并将它转换 (Translate) 至多个在上一节中创建的 Mesh 对象。</p>\n<p>事不宜迟，我会先把 Model 类的结构给你：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Model</span> </pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token comment\">/*  函数   */</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token function\">Model</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>path<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>            <span class=\"token function\">loadModel</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token keyword\">void</span> <span class=\"token function\">Draw</span><span class=\"token punctuation\">(</span>Shader shader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   </pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">private</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token comment\">/*  模型数据  */</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        vector<span class=\"token operator\">&lt;</span>Mesh<span class=\"token operator\">></span> meshes<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        string directory<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token comment\">/*  函数   */</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token keyword\">void</span> <span class=\"token function\">loadModel</span><span class=\"token punctuation\">(</span>string path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        <span class=\"token keyword\">void</span> <span class=\"token function\">processNode</span><span class=\"token punctuation\">(</span>aiNode <span class=\"token operator\">*</span>node<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> aiScene <span class=\"token operator\">*</span>scene<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        Mesh <span class=\"token function\">processMesh</span><span class=\"token punctuation\">(</span>aiMesh <span class=\"token operator\">*</span>mesh<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> aiScene <span class=\"token operator\">*</span>scene<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        vector<span class=\"token operator\">&lt;</span>Texture<span class=\"token operator\">></span> <span class=\"token function\">loadMaterialTextures</span><span class=\"token punctuation\">(</span>aiMaterial <span class=\"token operator\">*</span>mat<span class=\"token punctuation\">,</span> aiTextureType type<span class=\"token punctuation\">,</span>string typeName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>Model 类包含了一个 Mesh 对象的 vector（译注：这里指的是 C++ 中的 vector 模板类，之后遇到均不译），构造器需要我们给它一个文件路径。在构造器中，它会直接通过 loadModel 来加载文件。私有函数将会处理 Assimp 导入过程中的一部分，我们很快就会介绍它们。我们还将储存文件路径的目录，在之后加载纹理的时候还会用到它。</p>\n<p>Draw 函数没有什么特别之处，基本上就是遍历了所有网格，并调用它们各自的 Draw 函数。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">Draw</span><span class=\"token punctuation\">(</span>Shader shader<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> meshes<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        meshes<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">Draw</span><span class=\"token punctuation\">(</span>shader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"导入3d模型到opengl\"><a class=\"anchor\" href=\"#导入3d模型到opengl\">#</a> 导入 3D 模型到 OpenGL</h3>\n<p>要想导入一个模型，并将它转换到我们自己的数据结构中的话，首先我们需要包含 Assimp 对应的头文件，这样编译器就不会抱怨我们了。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;assimp/Importer.hpp></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;assimp/scene.h></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;assimp/postprocess.h></span></span></pre></td></tr></table></figure><p>首先需要调用的函数是 loadModel，它会从构造器中直接调用。在 loadModel 中，我们使用 Assimp 来加载模型至 Assimp 的一个叫做 scene 的数据结构中。你可能还记得在模型加载章节的第一节教程中，这是 Assimp 数据接口的根对象。一旦我们有了这个场景对象，我们就能访问到加载后的模型中所有所需的数据了。</p>\n<p>Assimp 很棒的一点在于，它抽象掉了加载不同文件格式的所有技术细节，只需要一行代码就能完成所有的工作：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Assimp<span class=\"token operator\">::</span>Importer importer<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">const</span> aiScene <span class=\"token operator\">*</span>scene <span class=\"token operator\">=</span> importer<span class=\"token punctuation\">.</span><span class=\"token function\">ReadFile</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">,</span> aiProcess_Triangulate <span class=\"token operator\">|</span> aiProcess_FlipUVs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>我们首先声明了 Assimp 命名空间内的一个 Importer，之后调用了它的 ReadFile 函数。这个函数需要一个文件路径，它的第二个参数是一些后期处理 (Post-processing) 的选项。除了加载文件之外，Assimp 允许我们设定一些选项来强制它对导入的数据做一些额外的计算或操作。通过设定<mark> aiProcess_Triangulate</mark>，我们告诉 Assimp，如果模型不是（全部）由三角形组成，<mark>它需要将模型所有的图元形状变换为三角形</mark>。<mark>aiProcess_FlipUVs</mark> 将在处理的时候翻<mark>转 y 轴的纹理坐标</mark>（你可能还记得我们在纹理教程中说过，在 OpenGL 中大部分的图像的 y 轴都是反的，所以这个后期处理选项将会修复这个）。其它一些比较有用的选项有：</p>\n<ul>\n<li><mark>aiProcess_GenNormals</mark>：如果模型不包含法向量的话，就为每个顶点创建法线。</li>\n<li><mark>aiProcess_SplitLargeMeshes</mark>：将比较大的网格分割成更小的子网格，如果你的渲染有最大顶点数限制，只能渲染较小的网格，那么它会非常有用。</li>\n<li><mark>aiProcess_OptimizeMeshes</mark>：和上个选项相反，它会将多个小网格拼接为一个大的网格，减少绘制调用从而进行优化。</li>\n</ul>\n<p>Assimp 提供了很多有用的后期处理指令，你可以在这里找到全部的指令。实际上使用 Assimp 加载模型是非常容易的（你也可以看到）。困难的是之后使用返回的场景对象将加载的数据转换到一个 Mesh 对象的数组。</p>\n<p>完整的 loadModel 函数将会是这样的：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">loadModel</span><span class=\"token punctuation\">(</span>string path<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    Assimp<span class=\"token operator\">::</span>Importer import<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">const</span> aiScene <span class=\"token operator\">*</span>scene <span class=\"token operator\">=</span> import<span class=\"token punctuation\">.</span><span class=\"token function\">ReadFile</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">,</span> aiProcess_Triangulate <span class=\"token operator\">|</span> aiProcess_FlipUVs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    </pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>scene <span class=\"token operator\">||</span> scene<span class=\"token operator\">-></span>mFlags <span class=\"token operator\">&amp;</span> AI_SCENE_FLAGS_INCOMPLETE <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>scene<span class=\"token operator\">-></span>mRootNode<span class=\"token punctuation\">)</span> </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"ERROR::ASSIMP::\"</span> <span class=\"token operator\">&lt;&lt;</span> import<span class=\"token punctuation\">.</span><span class=\"token function\">GetErrorString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    directory <span class=\"token operator\">=</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">substr</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">find_last_of</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token function\">processNode</span><span class=\"token punctuation\">(</span>scene<span class=\"token operator\">-></span>mRootNode<span class=\"token punctuation\">,</span> scene<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在我们加载了模型之后，我们会检查场景和其根节点不为 null，并且检查了它的一个标记 (Flag)，来查看返回的数据是不是不完整的。如果遇到了任何错误，我们都会通过导入器的 GetErrorString 函数来报告错误并返回。我们也获取了文件路径的目录路径。</p>\n<p>如果什么错误都没有发生，我们希望处理场景中的所有节点，所以我们将第一个节点（根节点）传入了递归的 processNode 函数。因为每个节点（可能）包含有多个子节点，我们希望首先处理参数中的节点，再继续处理该节点所有的子节点，以此类推。这正符合一个递归结构，所以我们将定义一个递归函数。递归函数在做一些处理之后，使用不同的参数递归调用这个函数自身，直到某个条件被满足停止递归。在我们的例子中退出条件 (Exit Condition) 是所有的<mark>节点都被处理完毕</mark>。</p>\n<p>你可能还记得 Assimp 的结构中，每个节点包含了一系列的网格索引，每个索引指向场景对象中的那个特定网格。我们接下来就想去获取这些网格索引，获取每个网格，处理每个网格，接着对每个节点的子节点重复这一过程。processNode 函数的内容如下：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">processNode</span><span class=\"token punctuation\">(</span>aiNode <span class=\"token operator\">*</span>node<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> aiScene <span class=\"token operator\">*</span>scene<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\">// 处理节点所有的网格（如果有的话）</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> node<span class=\"token operator\">-></span>mNumMeshes<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        aiMesh <span class=\"token operator\">*</span>mesh <span class=\"token operator\">=</span> scene<span class=\"token operator\">-></span>mMeshes<span class=\"token punctuation\">[</span>node<span class=\"token operator\">-></span>mMeshes<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        meshes<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span><span class=\"token function\">processMesh</span><span class=\"token punctuation\">(</span>mesh<span class=\"token punctuation\">,</span> scene<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>         </pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token comment\">// 接下来对它的子节点重复这一过程</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> node<span class=\"token operator\">-></span>mNumChildren<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token function\">processNode</span><span class=\"token punctuation\">(</span>node<span class=\"token operator\">-></span>mChildren<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> scene<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们首先检查每个节点的网格索引，并索引场景的 mMeshes 数组来获取对应的网格。返回的网格将会传递到 processMesh 函数中，它会返回一个 Mesh 对象，我们可以将它存储在 meshes 列表 /vector。</p>\n<p>所有网格都被处理之后，我们会遍历节点的所有子节点，并对它们调用相同的 processMesh 函数。当一个节点不再有任何子节点之后，这个函数将会停止执行。</p>\n<blockquote>\n<p>认真的读者可能会发现，我们可以基本上忘掉处理任何的节点，只需要遍历场景对象的所有网格，就不需要为了索引做这一堆复杂的东西了。我们仍这么做的原因是，使用节点的最初想法是将网格之间定义一个父子关系。通过这样递归地遍历这层关系，我们就能将某个网格定义为另一个网格的父网格了。<br />\n这个系统的一个使用案例是，当你想位移一个汽车的网格时，你可以保证它的所有子网格（比如引擎网格、方向盘网格、轮胎网格）都会随着一起位移。这样的系统能够用父子关系很容易地创建出来。</p>\n</blockquote>\n<blockquote>\n<p>然而，现在我们并没有使用这样一种系统，但如果你想对你的网格数据有更多的控制，通常都是建议使用这一种方法的。这种类节点的关系毕竟是由创建了这个模型的艺术家所定义。</p>\n</blockquote>\n<p>下一步就是将 Assimp 的数据解析到上一节中创建的 Mesh 类中。</p>\n<h3 id=\"从assimp到网格\"><a class=\"anchor\" href=\"#从assimp到网格\">#</a> 从 Assimp 到网格</h3>\n<p>将一个 aiMesh 对象转化为我们自己的网格对象不是那么困难。我们要做的只是访问网格的相关属性并将它们储存到我们自己的对象中。processMesh 函数的大体结构如下：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Mesh <span class=\"token function\">processMesh</span><span class=\"token punctuation\">(</span>aiMesh <span class=\"token operator\">*</span>mesh<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> aiScene <span class=\"token operator\">*</span>scene<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    vector<span class=\"token operator\">&lt;</span>Vertex<span class=\"token operator\">></span> vertices<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span><span class=\"token operator\">></span> indices<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    vector<span class=\"token operator\">&lt;</span>Texture<span class=\"token operator\">></span> textures<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> mesh<span class=\"token operator\">-></span>mNumVertices<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        Vertex vertex<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token comment\">// 处理顶点位置、法线和纹理坐标</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        vertices<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>vertex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token comment\">// 处理索引</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token comment\">// 处理材质</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mesh<span class=\"token operator\">-></span>mMaterialIndex <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token function\">Mesh</span><span class=\"token punctuation\">(</span>vertices<span class=\"token punctuation\">,</span> indices<span class=\"token punctuation\">,</span> textures<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>处理网格的过程主要有三部分：获取所有的顶点数据，获取它们的网格索引，并获取相关的材质数据。处理后的数据将会储存在三个 vector 当中，我们会利用它们构建一个 Mesh 对象，并返回它到函数的调用者那里。</p>\n<p>获取顶点数据非常简单，我们定义了一个 Vertex 结构体，我们将在每个迭代之后将它加到<mark> vertices</mark> 数组中。我们会遍历网格中的所有顶点（使用 mesh-&gt;mNumVertices 来获取）。在每个迭代中，我们希望使用所有的相关数据填充这个结构体。顶点的位置是这样处理的：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 vector<span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"2\"></td><td><pre>vector<span class=\"token punctuation\">.</span>x <span class=\"token operator\">=</span> mesh<span class=\"token operator\">-></span>mVertices<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>vector<span class=\"token punctuation\">.</span>y <span class=\"token operator\">=</span> mesh<span class=\"token operator\">-></span>mVertices<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>vector<span class=\"token punctuation\">.</span>z <span class=\"token operator\">=</span> mesh<span class=\"token operator\">-></span>mVertices<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>z<span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>vertex<span class=\"token punctuation\">.</span>Position <span class=\"token operator\">=</span> vector<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>注意我们为了传输 Assimp 的数据，我们定义了一个 vec3 的临时变量。使用这样一个临时变量的原因是 Assimp 对向量、矩阵、字符串等都有自己的一套数据类型，它们并不能完美地转换到 GLM 的数据类型中。</p>\n<blockquote>\n<p>Assimp 将它的顶点位置数组叫做 mVertices，这其实并不是那么直观。</p>\n</blockquote>\n<p>处理法线的步骤也是差不多的：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vector<span class=\"token punctuation\">.</span>x <span class=\"token operator\">=</span> mesh<span class=\"token operator\">-></span>mNormals<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>vector<span class=\"token punctuation\">.</span>y <span class=\"token operator\">=</span> mesh<span class=\"token operator\">-></span>mNormals<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>vector<span class=\"token punctuation\">.</span>z <span class=\"token operator\">=</span> mesh<span class=\"token operator\">-></span>mNormals<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>z<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>vertex<span class=\"token punctuation\">.</span>Normal <span class=\"token operator\">=</span> vector<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>纹理坐标的处理也大体相似，但 Assimp 允许一个模型在一个顶点上有最多 8 个不同的纹理坐标，我们不会用到那么多，我们只关心第一组纹理坐标。我们同样也想检查网格是否真的包含了纹理坐标（可能并不会一直如此）</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mesh<span class=\"token operator\">-></span>mTextureCoords<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 网格是否有纹理坐标？</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    glm<span class=\"token operator\">::</span>vec2 vec<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    vec<span class=\"token punctuation\">.</span>x <span class=\"token operator\">=</span> mesh<span class=\"token operator\">-></span>mTextureCoords<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    vec<span class=\"token punctuation\">.</span>y <span class=\"token operator\">=</span> mesh<span class=\"token operator\">-></span>mTextureCoords<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    vertex<span class=\"token punctuation\">.</span>TexCoords <span class=\"token operator\">=</span> vec<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">else</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    vertex<span class=\"token punctuation\">.</span>TexCoords <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec2</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>vertex 结构体现在已经填充好了需要的顶点属性，我们会在迭代的最后将它压入 vertices 这个 vector 的尾部。这个过程会对每个网格的顶点都重复一遍 (<mark>vertices.push_back</mark>)。</p>\n<h3 id=\"索引\"><a class=\"anchor\" href=\"#索引\">#</a> 索引</h3>\n<p>Assimp 的接口定义了每个网格都有一个<mark>面 (Face) 数组</mark>，每个面代表了一个图元，在我们的例子中（由于使用了<mark> aiProcess_Triangulate</mark> 选项）<mark>它总是三角形</mark>。一个面包含了多个索引，它们定义了在每个图元中，我们应该绘制哪个顶点，并以什么顺序绘制，所以如果我们遍历了所有的面，并储存了面的索引到 indices 这个 vector 中就可以了。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> mesh<span class=\"token operator\">-></span>mNumFaces<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    aiFace face <span class=\"token operator\">=</span> mesh<span class=\"token operator\">-></span>mFaces<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> face<span class=\"token punctuation\">.</span>mNumIndices<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        indices<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>face<span class=\"token punctuation\">.</span>mIndices<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>所有的外部循环都结束了，我们现在有了一系列的顶点和索引数据，它们可以用来通过<mark> glDrawElements</mark> 函数来绘制网格。然而，为了结束这个话题，并且对网格提供一些细节，我们还需要处理网格的材质。</p>\n<h3 id=\"材质\"><a class=\"anchor\" href=\"#材质\">#</a> 材质</h3>\n<p>和节点一样，一个网格只包含了一个指向材质对象的索引。如果想要获取网格真正的材质，我们还需要索引场景的<mark> mMaterials</mark> 数组。网格材质索引位于它的 mMaterialIndex 属性中，我们同样可以用它来检测一个网格是否包含有材质：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mesh<span class=\"token operator\">-></span>mMaterialIndex <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    aiMaterial <span class=\"token operator\">*</span>material <span class=\"token operator\">=</span> scene<span class=\"token operator\">-></span>mMaterials<span class=\"token punctuation\">[</span>mesh<span class=\"token operator\">-></span>mMaterialIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    vector<span class=\"token operator\">&lt;</span>Texture<span class=\"token operator\">></span> diffuseMaps <span class=\"token operator\">=</span> <span class=\"token function\">loadMaterialTextures</span><span class=\"token punctuation\">(</span>material<span class=\"token punctuation\">,</span> </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>                                        aiTextureType_DIFFUSE<span class=\"token punctuation\">,</span> <span class=\"token string\">\"texture_diffuse\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    textures<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>textures<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> diffuseMaps<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> diffuseMaps<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    vector<span class=\"token operator\">&lt;</span>Texture<span class=\"token operator\">></span> specularMaps <span class=\"token operator\">=</span> <span class=\"token function\">loadMaterialTextures</span><span class=\"token punctuation\">(</span>material<span class=\"token punctuation\">,</span> </pre></td></tr><tr><td data-num=\"8\"></td><td><pre>                                        aiTextureType_SPECULAR<span class=\"token punctuation\">,</span> <span class=\"token string\">\"texture_specular\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    textures<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>textures<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> specularMaps<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> specularMaps<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们首先从场景的 mMaterials 数组中获取 aiMaterial 对象。接下来我们希望加载网格的漫反射和 / 或镜面光贴图。一个材质对象的内部对每种纹理类型都存储了一个纹理位置数组。不同的纹理类型都以 aiTextureType_为前缀。我们使用一个叫做<mark> loadMaterialTextures</mark> 的工具函数来从材质中获取纹理。这个函数将会返回一个<mark> Texture</mark> 结构体的 vector，我们将在模型的 textures vector 的尾部之后存储它。</p>\n<p>loadMaterialTextures 函数遍历了给定纹理类型的所有纹理位置，获取了纹理的文件位置，并加载并和生成了纹理，将信息储存在了一个 Vertex 结构体中。它看起来会像这样：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vector<span class=\"token operator\">&lt;</span>Texture<span class=\"token operator\">></span> <span class=\"token function\">loadMaterialTextures</span><span class=\"token punctuation\">(</span>aiMaterial <span class=\"token operator\">*</span>mat<span class=\"token punctuation\">,</span> aiTextureType type<span class=\"token punctuation\">,</span> string typeName<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    vector<span class=\"token operator\">&lt;</span>Texture<span class=\"token operator\">></span> textures<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> mat<span class=\"token operator\">-></span><span class=\"token function\">GetTextureCount</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        aiString str<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        mat<span class=\"token operator\">-></span><span class=\"token function\">GetTexture</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        Texture texture<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        texture<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> <span class=\"token function\">TextureFromFile</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">.</span><span class=\"token function\">C_Str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> directory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        texture<span class=\"token punctuation\">.</span>type <span class=\"token operator\">=</span> typeName<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        texture<span class=\"token punctuation\">.</span>path <span class=\"token operator\">=</span> str<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        textures<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>texture<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">return</span> textures<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们首先通过 GetTextureCount 函数检查储存在材质中纹理的数量，这个函数需要一个纹理类型。我们会使用 GetTexture 获取每个纹理的文件位置，它会将结果储存在一个 aiString 中。我们接下来使用另外一个叫做 TextureFromFile 的工具函数，它将会（用 stb_image.h）加载一个纹理并返回该纹理的 ID。如果你不确定这样的代码是如何写出来的话，可以查看最后的完整代码。</p>\n<blockquote>\n<p>注意，我们假设了模型文件中纹理文件的路径是相对于模型文件的本地 (Local) 路径，比如说与模型文件处于同一目录下。我们可以将纹理位置字符串拼接到之前（在 loadModel 中）获取的目录字符串上，来获取完整的纹理路径（这也是为什么 GetTexture 函数也需要一个目录字符串）。</p>\n</blockquote>\n<blockquote>\n<p>在网络上找到的某些模型会对纹理位置使用绝对 (Absolute) 路径，这就不能在每台机器上都工作了。在这种情况下，你可能会需要手动修改这个文件，来让它对纹理使用本地路径（如果可能的话）。</p>\n</blockquote>\n<h3 id=\"重大优化\"><a class=\"anchor\" href=\"#重大优化\">#</a> 重大优化</h3>\n<p>这还没有完全结束，因为我们还想做出一个重大的（但不是完全必须的）优化。大多数场景都会在多个网格中重用部分纹理。还是想想一个房子，它的墙壁有着花岗岩的纹理。这个纹理也可以被应用到地板、天花板、楼梯、桌子，甚至是附近的一口井上。加载纹理并不是一个开销不大的操作，在我们当前的实现中，即便同样的纹理已经被加载过很多遍了，对每个网格仍会加载并生成一个新的纹理。这很快就会变成模型加载实现的性能瓶颈。</p>\n<p>所以我们会对模型的代码进行调整，将所有加载过的纹理全局储存，每当我们想加载一个纹理的时候，首先去检查它有没有被加载过。如果有的话，我们会直接使用那个纹理，并跳过整个加载流程，来为我们省下很多处理能力。为了能够比较纹理，我们还需要储存它们的路径：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Texture</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> id<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    string type<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    aiString path<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 我们储存纹理的路径用于与其它纹理进行比较</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>接下来我们将所有加载过的纹理储存在另一个 vector 中，在模型类的顶部声明为一个私有变量：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vector<span class=\"token operator\">&lt;</span>Texture<span class=\"token operator\">></span> textures_loaded<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>之后，在 loadMaterialTextures 函数中，我们希望将纹理的路径与储存在 textures_loaded 这个 vector 中的所有纹理进行比较，看看当前纹理的路径是否与其中的一个相同。如果是的话，则跳过纹理加载 / 生成的部分，直接使用定位到的纹理结构体为网格的纹理。更新后的函数如下：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vector<span class=\"token operator\">&lt;</span>Texture<span class=\"token operator\">></span> <span class=\"token function\">loadMaterialTextures</span><span class=\"token punctuation\">(</span>aiMaterial <span class=\"token operator\">*</span>mat<span class=\"token punctuation\">,</span> aiTextureType type<span class=\"token punctuation\">,</span> string typeName<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    vector<span class=\"token operator\">&lt;</span>Texture<span class=\"token operator\">></span> textures<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> mat<span class=\"token operator\">-></span><span class=\"token function\">GetTextureCount</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        aiString str<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        mat<span class=\"token operator\">-></span><span class=\"token function\">GetTexture</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token keyword\">bool</span> skip <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> textures_loaded<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span><span class=\"token function\">strcmp</span><span class=\"token punctuation\">(</span>textures_loaded<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>path<span class=\"token punctuation\">.</span><span class=\"token function\">data</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">C_Str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>            <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>                textures<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>textures_loaded<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>                skip <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"15\"></td><td><pre>                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>            <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>skip<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span>   <span class=\"token comment\">// 如果纹理还没有被加载，则加载它</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>            Texture texture<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>            texture<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> <span class=\"token function\">TextureFromFile</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">.</span><span class=\"token function\">C_Str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> directory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>            texture<span class=\"token punctuation\">.</span>type <span class=\"token operator\">=</span> typeName<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>            texture<span class=\"token punctuation\">.</span>path <span class=\"token operator\">=</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">C_Str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>            textures<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>texture<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>            textures_loaded<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>texture<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 添加到已加载的纹理中</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token keyword\">return</span> textures<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>所以现在我们不仅有了个灵活的模型加载系统，我们也获得了一个加载对象很快的优化版本。</p>\n<h3 id=\"和箱子模型告别\"><a class=\"anchor\" href=\"#和箱子模型告别\">#</a> 和箱子模型告别</h3>\n<p>所以，让我们导入一个由真正的艺术家所创造的模型，替代我这个天才的作品（你要承认，这些箱子可能是你看过的最漂亮的立方体了），测试一下我们的实现吧。由于我不想让我占太多的功劳，我会偶尔让别的艺术家也加入我们，这次我们将会加载 Crytek 的游戏孤岛危机 (Crysis) 中的原版纳米装 (Nanosuit)。这个模型被输出为一个.obj 文件以及一个.mtl 文件，.mtl 文件包含了模型的漫反射、镜面光和法线贴图（这个会在后面学习到），你可以在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWFybm9wZW5nbC1jbi5naXRodWIuaW8vZGF0YS9uYW5vc3VpdC5yYXI=\">这里下载到</span>（稍微修改之后的）模型，注意所有的纹理和模型文件应该位于同一个目录下，以供加载纹理。</p>\n<blockquote>\n<p>你从本网站中下载到的版本是修改过的版本，每个纹理的路径都被修改为了一个本地的相对路径，而不是原资源的绝对路径。</p>\n</blockquote>\n<p>现在在代码中，声明一个 Model 对象，将模型的文件位置传入。接下来模型应该会自动加载并（如果没有错误的话）在渲染循环中使用它的 Draw 函数来绘制物体，这样就可以了。不再需要缓冲分配、属性指针和渲染指令，只需要一行代码就可以了。接下来如果你创建一系列着色器，其中片段着色器仅仅输出物体的漫反射纹理颜色，最终的结果看上去会是这样的：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/03/03/model_diffuse.png\" alt=\"image\" /></p>\n<p>我们可以变得更有创造力一点，根据我们之前在光照教程中学过的知识，引入两个点光源到渲染方程中，结合镜面光贴图，我们能得到很惊人的效果。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/03/03/model_lighting.png\" alt=\"image\" /></p>\n<p>甚至我都必须要承认这个可能是比一直使用的箱子要好看多了。使用 Assimp，你能够加载互联网上的无数模型。有很多资源网站都提供了多种格式的免费 3D 模型供你下载。但还是要注意，有些模型会不能正常地载入，<mark>纹理的路径会出现问题</mark>，或者 Assimp 并<mark>不支持它的格式</mark>。</p>\n",
            "tags": [
                "计算机科学",
                "学习笔记",
                "OpenGL"
            ]
        },
        {
            "id": "https://allengx.gitee.io/computer-science/study/opengl/%E4%BA%8C%E3%80%81OpenGL%E5%85%89%E7%85%A7/",
            "url": "https://allengx.gitee.io/computer-science/study/opengl/%E4%BA%8C%E3%80%81OpenGL%E5%85%89%E7%85%A7/",
            "title": "二、OpenGL光照",
            "date_published": "2020-04-12T12:46:25.000Z",
            "content_html": "<div class=\"note info\">\n<p>以下为个人学习笔记整理</p>\n</div>\n<h1 id=\"光照\"><a class=\"anchor\" href=\"#光照\">#</a> 光照</h1>\n<h2 id=\"颜色\"><a class=\"anchor\" href=\"#颜色\">#</a> 颜色</h2>\n<p>现实世界中有无数种颜色，每一个物体都有它们自己的颜色。我们需要使用（有限的）数值来模拟真实世界中（无限）的颜色，所以并不是所有现实世界中的颜色都可以用数值来表示的。然而我们仍能通过数值来表现出非常多的颜色，甚至你可能都不会注意到与现实的颜色有任何的差异。颜色可以数字化的由红色 (Red)、绿色 (Green) 和蓝色 (Blue) 三个分量组成，它们通常被缩写为 RGB。仅仅用这三个值就可以组合出任意一种颜色。例如，要获取一个珊瑚红 (Coral) 色的话，我们可以定义这样的一个颜色向量：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 <span class=\"token function\">coral</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.31f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>我们在现实生活中看到某一物体的颜色并不是这个物体真正拥有的颜色，而是它所反射的 (Reflected) 颜色。换句话说，那些不能被物体所吸收 (Absorb) 的颜色（被拒绝的颜色）就是我们能够感知到的物体的颜色。例如，太阳光能被看见的白光其实是由许多不同的颜色组合而成的（如下图所示）。如果我们将白光照在一个蓝色的玩具上，这个蓝色的玩具会吸收白光中除了蓝色以外的所有子颜色，不被吸收的蓝色光被反射到我们的眼中，让这个玩具看起来是蓝色的。下图显示的是一个珊瑚红的玩具，它以不同强度反射了多个颜色。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/02/01/light_reflection.png\" alt=\"image\" /></p>\n<p>你可以看到，白色的阳光实际上是所有可见颜色的集合，物体吸收了其中的大部分颜色。它仅反射了代表物体颜色的部分，被反射颜色的组合就是我们所感知到的颜色（此例中为珊瑚红）。</p>\n<p>这些颜色反射的定律被直接地运用在图形领域。当我们在 OpenGL 中创建一个光源时，我们希望给光源一个颜色。在上一段中我们有一个白色的太阳，所以我们也将光源设置为白色。<mark>当我们把光源的颜色与物体的颜色值相乘，所得到的就是这个物体所反射的颜色</mark>（也就是我们所感知到的颜色）。让我们再次审视我们的玩具（这一次它还是珊瑚红），看看如何在图形学中计算出它的反射颜色。我们将这两个颜色向量作分量相乘，结果就是最终的颜色向量了：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 <span class=\"token function\">lightColor</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 <span class=\"token function\">toyColor</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.31f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 result <span class=\"token operator\">=</span> lightColor <span class=\"token operator\">*</span> toyColor<span class=\"token punctuation\">;</span> <span class=\"token comment\">// = (1.0f, 0.5f, 0.31f);</span></pre></td></tr></table></figure><p>我们可以看到玩具的颜色吸收了白色光源中很大一部分的颜色，但它根据自身的颜色值对红、绿、蓝三个分量都做出了一定的反射。这也表现了现实中颜色的工作原理。由此，我们可以定义物体的颜色为物体从一个光源反射各个颜色分量的大小。现在，如果我们使用<mark>绿色的光源</mark>又会发生什么呢？</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 <span class=\"token function\">lightColor</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 <span class=\"token function\">toyColor</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.31f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 result <span class=\"token operator\">=</span> lightColor <span class=\"token operator\">*</span> toyColor<span class=\"token punctuation\">;</span> <span class=\"token comment\">// = (0.0f, 0.5f, 0.0f);</span></pre></td></tr></table></figure><p>可以看到，并没有红色和蓝色的光让我们的玩具来吸收或反射。这个玩具吸收了光线中一半的绿色值，但仍然也反射了一半的绿色值。玩具现在看上去是深绿色 (Dark-greenish) 的。我们可以看到，如果我们用绿色光源来照射玩具，那么只有绿色分量能被反射和感知到，红色和蓝色都不能被我们所感知到。这样做的结果是，一个珊瑚红的玩具突然变成了深绿色物体。现在我们来看另一个例子，使用<mark>深橄榄绿色 (Dark olive-green) 的光源</mark>：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 <span class=\"token function\">lightColor</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.33f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.42f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.18f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 <span class=\"token function\">toyColor</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.31f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 result <span class=\"token operator\">=</span> lightColor <span class=\"token operator\">*</span> toyColor<span class=\"token punctuation\">;</span> <span class=\"token comment\">// = (0.33f, 0.21f, 0.06f);</span></pre></td></tr></table></figure><h3 id=\"创建一个光照场景\"><a class=\"anchor\" href=\"#创建一个光照场景\">#</a> 创建一个光照场景</h3>\n<p>在接下来的教程中，我们将会广泛地使用颜色来模拟现实世界中的光照效果，创造出一些有趣的视觉效果。由于我们现在将会使用光源了，我们希望将它们显示为可见的物体，并在场景中至少加入一个物体来测试模拟光照的效果。</p>\n<p>首先我们需要一个物体来作为被投光 (Cast the light) 的对象，我们将使用前面教程中的那个著名的立方体箱子。我们还需要一个物体来代表光源在 3D 场景中的位置。简单起见，我们依然使用一个立方体来代表光源（我们已拥有立方体的顶点数据是吧？）。</p>\n<p>填一个顶点缓冲对象 (VBO)，设定一下顶点属性指针和其它一些乱七八糟的东西现在对你来说应该很容易了，所以我们就不再赘述那些步骤了。如果你仍然觉得这很困难，我建议你复习之前的教程，并且在继续学习之前先把练习过一遍。</p>\n<p>我们首先需要一个顶点着色器来绘制箱子。与之前的顶点着色器相比，容器的顶点位置是保持不变的（虽然这一次我们不需要纹理坐标了），因此顶点着色器中没有新的代码。我们将会使用之前教程顶点着色器的精简版：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> in vec3 aPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>uniform mat4 model<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>uniform mat4 view<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>uniform mat4 projection<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> projection <span class=\"token operator\">*</span> view <span class=\"token operator\">*</span> model <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>aPos<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>记得更新你的顶点数据和属性指针使其与新的顶点着色器保持一致（当然你可以继续留着纹理数据和属性指针。在这一节中我们将不会用到它们，但有一个全新的开始也不是什么坏主意）。</p>\n<p>因为我们还要创建一个表示灯（光源）的立方体，所以我们还要为这个灯创建一个专门的 VAO。当然我们也可以让这个灯和其它物体使用同一个 VAO，简单地对它的 model（模型）矩阵做一些变换就好了，然而接下来的教程中我们会频繁地对顶点数据和属性指针做出修改，我们并不想让这些修改影响到灯（我们只关心灯的顶点位置），因此我们有必要为灯创建一个新的 VAO。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> lightVAO<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glGenVertexArrays</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>lightVAO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glBindVertexArray</span><span class=\"token punctuation\">(</span>lightVAO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// 只需要绑定 VBO 不用再次设置 VBO 的数据，因为箱子的 VBO 数据中已经包含了正确的立方体顶点数据</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> VBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">// 设置灯立方体的顶点属性（对我们的灯来说仅仅只有位置数据）</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">glVertexAttribPointer</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span> <span class=\"token number\">3</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">glEnableVertexAttribArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这段代码对你来说应该非常直观。现在我们已经创建了表示灯和被照物体箱子，我们只需要再定义一个片段着色器就行了：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>out vec4 FragColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>uniform vec3 objectColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>uniform vec3 lightColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>lightColor <span class=\"token operator\">*</span> objectColor<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这个片段着色器从 uniform 变量中接受物体的颜色和光源的颜色。正如本节一开始所讨论的那样，我们将光源的颜色和物体（反射的）颜色相乘。这个着色器理解起来应该很容易。我们把物体的颜色设置为之前提到的珊瑚红色，并把光源设置为白色。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 在此之前不要忘记首先 use 对应的着色器程序（来设定 uniform）</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>lightingShader<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>lightingShader<span class=\"token punctuation\">.</span><span class=\"token function\">setVec3</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"objectColor\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.31f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>lightingShader<span class=\"token punctuation\">.</span><span class=\"token function\">setVec3</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"lightColor\"</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>要注意的是，当我们修改顶点或者片段着色器后，灯的位置或颜色也会随之改变，这并不是我们想要的效果。我们不希望灯的颜色在接下来的教程中因光照计算的结果而受到影响，而是希望它能够与其它的计算分离。我们希望灯一直保持明亮，不受其它颜色变化的影响（这样它才更像是一个真实的光源）。</p>\n<p>为了实现这个目标，我们需要为灯的绘制创建另外的一套着色器，从而能保证它能够在其它光照着色器发生改变的时候不受影响。顶点着色器与我们当前的顶点着色器是一样的，所以你可以直接把现在的顶点着色器用在灯上。灯的片段着色器给灯定义了一个不变的常量白色，保证了灯的颜色一直是亮的：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>out vec4 FragColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 将向量的四个分量全部设置为 1.0</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>当我们想要绘制我们的物体的时候，我们需要使用刚刚定义的光照着色器来绘制箱子（或者可能是其它的物体）。当我们想要绘制灯的时候，我们会使用灯的着色器。在之后的教程里我们会逐步更新这个光照着色器，从而能够慢慢地实现更真实的效果。</p>\n<p>使用这个灯立方体的主要目的是为了让我们知道光源在场景中的具体位置。我们通常在场景中定义一个光源的位置，但这只是一个位置，它并没有视觉意义。为了显示真正的灯，我们将表示光源的立方体绘制在与光源相同的位置。我们将使用我们为它新建的片段着色器来绘制它，让它一直处于白色的状态，不受场景中的光照影响。</p>\n<p>我们声明一个全局 vec3 变量来表示光源在场景的世界空间坐标中的位置：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 <span class=\"token function\">lightPos</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.2f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>然后我们把灯位移到这里，然后将它缩小一点，让它不那么明显：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>model <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">mat4</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>model <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">translate</span><span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">,</span> lightPos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>model <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">scale</span><span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.2f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>请把上述的所有代码片段放在你程序中合适的位置，这样我们就能有一个干净的光照实验场地了。如果一切顺利，运行效果将会如下图所示：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/02/01/colors_scene.png\" alt=\"image\" /></p>\n<h2 id=\"基础光照\"><a class=\"anchor\" href=\"#基础光照\">#</a> 基础光照</h2>\n<p>现实世界的光照是极其复杂的，而且会受到诸多因素的影响，这是我们有限的计算能力所无法模拟的。因此 OpenGL 的光照使用的是简化的模型，对现实的情况进行近似，这样处理起来会更容易一些，而且看起来也差不多一样。这些光照模型都是基于我们对光的物理特性的理解。其中一个模型被称<mark>为冯氏光照模型</mark> (Phong Lighting Model)。冯氏光照模型的主要结构由 3 个分量组成：<mark>环境</mark> (Ambient)、<mark>漫反射</mark> (Diffuse) 和<mark>镜面</mark> (Specular) 光照。下面这张图展示了这些光照分量看起来的样子：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/02/02/basic_lighting_phong.png\" alt=\"image\" /></p>\n<ul>\n<li><mark>环境光照</mark> (Ambient Lighting)：即使在黑暗的情况下，世界上通常也仍然有一些光亮（月亮、远处的光），所以物体几乎永远不会是完全黑暗的。为了模拟这个，我们会使用一个环境光照常量，它永远会给物体一些颜色。</li>\n<li><mark>漫反射光照</mark> (Diffuse Lighting)：模拟光源对物体的方向性影响 (Directional Impact)。它是冯氏光照模型中视觉上最显著的分量。物体的某一部分越是正对着光源，它就会越亮。</li>\n<li><mark>镜面光照</mark> (Specular Lighting)：模拟有光泽物体上面出现的亮点。镜面光照的颜色相比于物体的颜色会更倾向于光的颜色。</li>\n</ul>\n<p>为了创建有趣的视觉场景，我们希望模拟至少这三种光照分量。我们将以最简单的一个开始：环境光照。</p>\n<h3 id=\"环境光照\"><a class=\"anchor\" href=\"#环境光照\">#</a> 环境光照</h3>\n<p>光通常都不是来自于同一个光源，而是来自于我们周围分散的很多光源，即使它们可能并不是那么显而易见。光的一个属性是，它可以向很多方向发散并反弹，从而能够到达不是非常直接临近的点。所以，光能够在其它的表面上反射，对一个物体产生间接的影响。考虑到这种情况的算法叫做<mark>全局照明</mark> (Global Illumination) 算法，但是这种算法既开销高昂又极其复杂。</p>\n<p>由于我们现在对那种又复杂又开销高昂的算法不是很感兴趣，所以我们将会先使用一个简化的全局照明模型，即<mark>环境光照</mark>。正如你在上一节所学到的，我们使用一个很小的常量（光照）颜色，添加到物体片段的最终颜色中，这样子的话即便场景中没有直接的光源也能看起来存在有一些发散的光。</p>\n<p>把环境光照添加到场景里非常简单。我们用光的颜色乘以一个很小的<mark>常量环境因子</mark>，再乘以物体的颜色，然后将最终结果作为片段的颜色：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">float</span> ambientStrength <span class=\"token operator\">=</span> <span class=\"token number\">0.1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    vec3 ambient <span class=\"token operator\">=</span> ambientStrength <span class=\"token operator\">*</span> lightColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    vec3 result <span class=\"token operator\">=</span> ambient <span class=\"token operator\">*</span> objectColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>如果你现在运行你的程序，你会注意到冯氏光照的第一个阶段已经应用到你的物体上了。这个物体非常暗，但由于应用了环境光照（注意光源立方体没受影响是因为我们对它使用了另一个着色器），也不是完全黑的。它看起来应该像这样：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/02/02/ambient_lighting.png\" alt=\"image\" /></p>\n<h3 id=\"漫反射光照\"><a class=\"anchor\" href=\"#漫反射光照\">#</a> 漫反射光照</h3>\n<p>环境光照本身不能提供最有趣的结果，但是漫反射光照就能开始对物体产生显著的视觉影响了。漫反射光照使物体上与光线方向越接近的片段能从光源处获得更多的亮度。为了能够更好的理解漫反射光照，请看下图：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/02/02/diffuse_light.png\" alt=\"image\" /></p>\n<p>图左上方有一个光源，它所发出的光线落在物体的一个片段上。我们需要测量这个光线是以什么角度接触到这个片段的。如果光线<mark>垂直于物体表面</mark>，这束光对物体的<mark>影响会最大化</mark>（译注：更亮）。为了测量光线和片段的角度，我们使用一个叫做<mark>法向量</mark> (Normal Vector) 的东西，它是垂直于片段表面的一个向量（这里以黄色箭头表示），我们在后面再讲这个东西。这两个向量之间的角度很容易就能够通过点乘计算出来。</p>\n<p>你可能记得在变换那一节教程里，我们知道两个单位向量的夹角越小，它们点乘的结果越倾向于 1。当两个<mark>向量的夹角为 90 度的时候，点乘会变为 0</mark>。这同样适用于 θ，θ 越大，光对片段颜色的影响就应该越小。</p>\n<blockquote>\n<p>注意，为了（只）得到两个向量夹角的余弦值，我们使用的是<strong>单位向量</strong>（长度为 1 的向量），所以我们需要确保所有的向量都是标准化的，否则点乘返回的就不仅仅是余弦值了（见变换）。</p>\n</blockquote>\n<p>点乘返回一个标量，我们可以用它计算光线对片段颜色的影响。不同片段朝向光源的方向的不同，这些片段被照亮的情况也不同。</p>\n<p>所以，计算漫反射光照需要什么？</p>\n<ul>\n<li>法向量：<mark>一个垂直于顶点表面的向量</mark>。</li>\n<li>定向的光线：作为光源的位置与片段的位置之间向量差的方向向量。为了计算这个光线，我们需要光的位置向量和片段的位置向量。</li>\n</ul>\n<h3 id=\"法向量\"><a class=\"anchor\" href=\"#法向量\">#</a> 法向量</h3>\n<p>法向量是<mark>一个垂直于顶点表面的</mark>（单位）向量。由于顶点本身并没有表面（它只是空间中一个独立的点），我们利用它周围的顶点来计算出这个顶点的表面。我们能够使用一个小技巧，使用叉乘对立方体所有的顶点计算法向量，但是由于 3D 立方体不是一个复杂的形状，所以我们可以简单地把法线数据手工添加到顶点数据中。更新后的顶点数据数组可以在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWFybm9wZW5nbC5jb20vY29kZV92aWV3ZXIucGhwP2NvZGU9bGlnaHRpbmcvYmFzaWNfbGlnaHRpbmdfdmVydGV4X2RhdGE=\">这里找到</span>。试着去想象一下，这些法向量真的是垂直于立方体各个平面的表面的（一个立方体由 6 个平面组成）。</p>\n<p>由于我们向顶点数组添加了额外的数据，所以我们应该更新光照的顶点着色器：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> in vec3 aPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> in vec3 aNormal<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr></table></figure><p>现在我们已经向每个顶点添加了一个法向量并更新了顶点着色器，我们还要更新顶点属性指针。注意，灯使用同样的顶点数组作为它的顶点数据，然而灯的着色器并没有使用新添加的法向量。我们不需要更新灯的着色器或者是属性的配置，但是我们必须至少修改一下顶点属性指针来适应新的顶点数组的大小：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glVertexAttribPointer</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span> <span class=\"token number\">6</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glEnableVertexAttribArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glVertexAttribPointer</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span> <span class=\"token number\">6</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glEnableVertexAttribArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>我们只想使用每个顶点的前三个 float，并且忽略后三个 float，所以我们只需要把步长参数改成 float 大小的 6 倍就行了。</p>\n<blockquote>\n<p>虽然对灯的着色器使用不能完全利用的顶点数据看起来不是那么高效，但这些顶点数据已经从箱子对象载入后开始就储存在 GPU 的内存里了，所以我们并不需要储存新数据到 GPU 内存中。这实际上比给灯专门分配一个新的 VBO 更高效了。</p>\n</blockquote>\n<p><mark>所有光照的计算都是在片段着色器里进行</mark>，所以我们需要将法向量由顶点着色器传递到片段着色器。我们这么做：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>out vec3 Normal<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> projection <span class=\"token operator\">*</span> view <span class=\"token operator\">*</span> model <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>aPos<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    Normal <span class=\"token operator\">=</span> aNormal<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"计算漫反射光照\"><a class=\"anchor\" href=\"#计算漫反射光照\">#</a> 计算漫反射光照</h3>\n<p>我们现在对每个顶点都有了法向量，但是我们仍然需要光源的位置向量和片段的位置向量。由于光源的位置是一个静态变量，我们可以简单地在片段着色器中把它声明为 uniform：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>uniform vec3 lightPos<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>然后在渲染循环中（渲染循环的外面也可以，因为它不会改变）更新 uniform。我们使用在前面声明的 lightPos 向量作为光源位置：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>lightingShader<span class=\"token punctuation\">.</span><span class=\"token function\">setVec3</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"lightPos\"</span><span class=\"token punctuation\">,</span> lightPos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>最后，我们还需要片段的位置。我们会在世界空间中进行所有的光照计算，因此我们需要一个在世界空间中的顶点位置。我们可以通过把顶点位置属性乘以模型矩阵（不是观察和投影矩阵）来把它变换到世界空间坐标。这个在顶点着色器中很容易完成，所以我们声明一个输出变量，并计算它的世界空间坐标：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>out vec3 FragPos<span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"2\"></td><td><pre>out vec3 Normal<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> projection <span class=\"token operator\">*</span> view <span class=\"token operator\">*</span> model <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>aPos<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    FragPos <span class=\"token operator\">=</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span>model <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>aPos<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    Normal <span class=\"token operator\">=</span> aNormal<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>最后，在片段着色器中添加相应的输入变量。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>in vec3 FragPos<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>现在，所有需要的变量都设置好了，我们可以在片段着色器中添加光照计算了。</p>\n<p>我们需要做的第一件事是计算光源和片段位置之间的方向向量。前面提到，光的方向向量是光源位置向量与片段位置向量之间的向量差。你可能记得在变换教程中，我们能够简单地通过让两个向量相减的方式计算向量差。我们同样希望确保所有相关向量最后都转换为单位向量，所以我们把法线和最终的方向向量都进行标准化：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vec3 norm <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>Normal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>vec3 lightDir <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>lightPos <span class=\"token operator\">-</span> FragPos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>下一步，我们对 norm 和 lightDir 向量进行点乘，计算光源对当前片段实际的漫发射影响。结果值再乘以光的颜色，得到漫反射分量。两个向量之间的角度越大，漫反射分量就会越小：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> diff <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token function\">dot</span><span class=\"token punctuation\">(</span>norm<span class=\"token punctuation\">,</span> lightDir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>vec3 diffuse <span class=\"token operator\">=</span> diff <span class=\"token operator\">*</span> lightColor<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>如果两个向量之间的角度大于 90 度，点乘的结果就会变成负数，这样会导致漫反射分量变为负数。为此，我们使用 max 函数返回两个参数之间较大的参数，从而保证漫反射分量不会变成负数。负数颜色的光照是没有定义的，所以最好避免它，除非你是那种古怪的艺术家。</p>\n<p>现在我们有了环境光分量和漫反射分量，我们把它们相加，然后把结果乘以物体的颜色，来获得片段最后的输出颜色。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vec3 result <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>ambient <span class=\"token operator\">+</span> diffuse<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> objectColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>FragColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><img data-src=\"https://learnopengl-cn.github.io/img/02/02/basic_lighting_diffuse.png\" alt=\"image\" /></p>\n<h3 id=\"最后一件事\"><a class=\"anchor\" href=\"#最后一件事\">#</a> 最后一件事</h3>\n<p>现在我们已经把法向量从顶点着色器传到了片段着色器。可是，目前片段着色器里的计算都是在世界空间坐标中进行的。所以，我们是不是应该把法向量也转换为世界空间坐标？基本正确，但是这不是简单地把它乘以一个模型矩阵就能搞定的。</p>\n<p>首先，法向量只是一个方向向量，不能表达空间中的特定位置。同时，法向量没有齐次坐标（顶点位置中的 w 分量）。这意味着，<mark>位移不应该影响到法向量</mark>。因此，如果我们打算把法向量乘以一个模型矩阵，我们就要从矩阵中移除位移部分，只选用模型矩阵左上角 3×3 的矩阵（注意，我们也可以把法向量的 w 分量设置为 0，再乘以 4×4 矩阵；这同样可以移除位移）。对于法向量，我们只希望对它实施缩放和旋转变换。</p>\n<p>其次，如果模型矩阵执行了<mark>不等比缩放</mark>，<mark>顶点的改变会导致法向量<strong>不再垂直</strong>于表面了</mark>。因此，我们不能用这样的模型矩阵来变换法向量。下面的图展示了应用了不等比缩放的模型矩阵对法向量的影响：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/02/02/basic_lighting_normal_transformation.png\" alt=\"image\" /></p>\n<p>每当我们应用一个不等比缩放时（注意：等比缩放不会破坏法线，因为法线的方向没被改变，仅仅改变了法线的长度，而这很容易通过标准化来修复），法向量就不会再垂直于对应的表面了，这样光照就会被破坏。</p>\n<p>修复这个行为的诀窍是使用一个为法向量专门定制的模型矩阵。这个矩阵称之为<mark>法线矩阵</mark> (Normal Matrix)，它使用了一些线性代数的操作来移除对法向量错误缩放的影响。如果你想知道这个矩阵是如何计算出来的，建议去阅读这个<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5saWdodGhvdXNlM2QuY29tL3R1dG9yaWFscy9nbHNsLXR1dG9yaWFsL3RoZS1ub3JtYWwtbWF0cml4Lw==\">文章</span>。</p>\n<p>法线矩阵被定义为「<mark>模型矩阵左上角的逆矩阵的转置矩阵</mark>」。真是拗口，如果你不明白这是什么意思，别担心，我们还没有讨论<mark>逆矩阵</mark> (Inverse Matrix) 和<mark>转置矩阵</mark> (Transpose Matrix)。注意，大部分的资源都会将法线矩阵定义为应用到模型 - 观察矩阵 (Model-view Matrix) 上的操作，但是由于我们只在世界空间中进行操作（不是在观察空间），我们只使用模型矩阵。</p>\n<p>在顶点着色器中，我们可以使用 inverse 和 transpose 函数自己生成这个法线矩阵，这两个函数对所有类型矩阵都有效。注意我们还要把被处理过的矩阵强制转换为 3×3 矩阵，来保证它失去了位移属性以及能够乘以 vec3 的法向量。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Normal <span class=\"token operator\">=</span> <span class=\"token function\">mat3</span><span class=\"token punctuation\">(</span><span class=\"token function\">transpose</span><span class=\"token punctuation\">(</span><span class=\"token function\">inverse</span><span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> aNormal<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在漫反射光照部分，光照表现并没有问题，这是因为我们没有对物体本身执行任何缩放操作，所以并不是必须要使用一个法线矩阵，仅仅让模型矩阵乘以法线也可以。可是，如果你进行了不等比缩放，使用法线矩阵去乘以法向量就是必不可少的了。</p>\n<blockquote>\n<p>即使是对于着色器来说，<mark>逆矩阵也是一个开销比较大的运算</mark>，因此，只要可能就应该避免在着色器中进行逆矩阵运算，它们必须为你场景中的每个顶点都进行这样的处理。用作学习目这样做是可以的，但是对于一个对效率有要求的应用来说，在绘制之前你最好用 CPU 计算出法线矩阵，然后通过 uniform 把值传递给着色器（像模型矩阵一样）。</p>\n</blockquote>\n<h3 id=\"镜面光照\"><a class=\"anchor\" href=\"#镜面光照\">#</a> 镜面光照</h3>\n<p>如果你还没被这些光照计算搞得精疲力尽，我们就再把镜面高光 (Specular Highlight) 加进来，这样冯氏光照才算完整。</p>\n<p>和漫反射光照一样，镜面光照也是依据光的方向向量和物体的法向量来决定的，但是它也依赖于观察方向，例如玩家是从什么方向看着这个片段的。镜面光照是基于光的反射特性。如果我们想象物体表面像一面镜子一样，那么，无论我们从哪里去看那个表面所反射的光，镜面光照都会达到最大化。你可以从下面的图片看到效果：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/02/02/basic_lighting_specular_theory.png\" alt=\"image\" /></p>\n<p>我们通过反射法向量周围光的方向来计算<mark>反射向量</mark>。然后我们计算<mark>反射向量和视线方向的角度差</mark>，如果<mark>夹角越小</mark>，那么<mark>镜面光的影响就会越大</mark>。它的作用效果就是，当我们去看光被物体所反射的那个方向的时候，我们会看到一个高光。</p>\n<p>观察向量是镜面光照附加的一个变量，我们可以使用观察者世界空间位置和片段的位置来计算它。之后，我们计算镜面光强度，用它乘以光源的颜色，再将它加上环境光和漫反射分量。</p>\n<blockquote>\n<p>我们选择在世界空间进行光照计算，但是大多数人趋向于在观察空间进行光照计算。在观察空间计算的好处是，观察者的位置总是 (0, 0, 0)，所以这样你直接就获得了观察者位置。可是我发现在学习的时候在世界空间中计算光照更符合直觉。如果你仍然希望在观察空间计算光照的话，你需要将所有相关的向量都用观察矩阵进行变换（记得也要改变法线矩阵）。</p>\n</blockquote>\n<p>为了得到观察者的世界空间坐标，我们简单地使用摄像机对象的位置坐标代替（它当然就是观察者）。所以我们把另一个 uniform 添加到片段着色器，把相应的摄像机位置坐标传给片段着色器：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>uniform vec3 viewPos<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>lightingShader<span class=\"token punctuation\">.</span><span class=\"token function\">setVec3</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"viewPos\"</span><span class=\"token punctuation\">,</span> camera<span class=\"token punctuation\">.</span>Position<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>现在我们已经获得所有需要的变量，可以计算高光强度了。首先，我们定义一个<mark>镜面强度</mark> (Specular Intensity) 变量，给镜面高光一个中等亮度颜色，让它不要产生过度的影响。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> specularStrength <span class=\"token operator\">=</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>如果我们把它设置为 1.0f，我们会得到一个非常亮的镜面光分量，这对于一个珊瑚色的立方体来说有点太多了。下一节教程中我们会讨论如何合理设置这些光照强度，以及它们是如何影响物体的。下一步，我们计算视线方向向量，和对应的沿着法线轴的反射向量：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vec3 viewDir <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>viewPos <span class=\"token operator\">-</span> FragPos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>vec3 reflectDir <span class=\"token operator\">=</span> <span class=\"token function\">reflect</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>lightDir<span class=\"token punctuation\">,</span> norm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>需要注意的是我们对 lightDir 向量进行了取反。<mark>reflect 函数要求第一个向量是<strong>从光源指向片段位置的向量</strong></mark>，但是 lightDir 当前正好相反，是从片段指向光源（由先前我们计算 lightDir 向量时，减法的顺序决定）。为了保证我们得到正确的 reflect 向量，我们通过对 lightDir 向量取反来获得相反的方向。第二个参数要求是一个法向量，所以我们提供的是已标准化的 norm 向量。</p>\n<p>剩下要做的是计算镜面分量。下面的代码完成了这件事：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> spec <span class=\"token operator\">=</span> <span class=\"token function\">pow</span><span class=\"token punctuation\">(</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token function\">dot</span><span class=\"token punctuation\">(</span>viewDir<span class=\"token punctuation\">,</span> reflectDir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">32</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>vec3 specular <span class=\"token operator\">=</span> specularStrength <span class=\"token operator\">*</span> spec <span class=\"token operator\">*</span> lightColor<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>我们先计算视线方向与反射方向的点乘（并确保它不是负值），然后取它的 32 次幂。这个<mark> 32 是高光的反光度</mark> (Shininess)。一个物体的反光度越高，反射光的能力越强，散射得越少，高光点就会越小。在下面的图片里，你会看到不同反光度的视觉效果影响：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/02/02/basic_lighting_specular_shininess.png\" alt=\"image\" /></p>\n<p>我们不希望镜面成分过于显眼，所以我们把指数保持为 32。剩下的最后一件事情是把它加到环境光分量和漫反射分量里，再用结果乘以物体的颜色：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vec3 result <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>ambient <span class=\"token operator\">+</span> diffuse <span class=\"token operator\">+</span> specular<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> objectColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>FragColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>我们现在为冯氏光照计算了全部的光照分量。根据你的视角，你可以看到类似下面的画面：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/02/02/basic_lighting_specular.png\" alt=\"image\" /></p>\n<blockquote>\n<p>在光照着色器的早期，开发者曾经在顶点着色器中实现冯氏光照模型。在顶点着色器中做光照的优势是，相比片段来说，顶点要少得多，因此会更高效，所以（开销大的）光照计算频率会更低。然而，顶点着色器中的最终颜色值是仅仅只是那个顶点的颜色值，片段的颜色值是由插值光照颜色所得来的。结果就是这种光照看起来不会非常真实，除非使用了大量顶点。</p>\n</blockquote>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/02/02/basic_lighting_gouruad.png\" alt=\"image\" /></p>\n<p>在顶点着色器中实现的冯氏光照模型叫做<mark> Gouraud</mark> 着色 (Gouraud Shading)，而不是冯氏着色 (<mark>Phong Shading</mark>)。记住，由于插值，这种光照看起来有点逊色。冯氏着色能产生更平滑的光照效果。</p>\n<h2 id=\"材质\"><a class=\"anchor\" href=\"#材质\">#</a> 材质</h2>\n<p>在现实世界里，每个物体会对光产生不同的反应。比如说，钢看起来通常会比陶瓷花瓶更闪闪发光，木头箱子也不会像钢制箱子那样对光产生很强的反射。每个物体对镜面高光也有不同的反应。有些物体反射光的时候不会有太多的散射 (Scatter)，因而产生一个较小的高光点，而有些物体则会散射很多，产生一个有着更大半径的高光点。如果我们想要在 OpenGL 中模拟多种类型的物体，我们必须为每个物体分别定义一个<mark>材质</mark> (Material) 属性。</p>\n<p>在上一节中，我们指定了一个物体和光的颜色，以及结合环境光和镜面强度分量，来定义物体的视觉输出。当描述一个物体的时候，我们可以用这三个分量来定义一个<mark>材质颜色</mark> (Material Color)：<mark>环境光照</mark> (Ambient Lighting)、<mark>漫反射光照</mark> (Diffuse Lighting) 和<mark>镜面光照</mark> (Specular Lighting)。通过为每个分量指定一个颜色，我们就能够对物体的颜色输出有着精细的控制了。现在，我们再添加<mark>反光度</mark> (Shininess) 这个分量到上述的三个颜色中，这就有我们需要的所有材质属性了：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Material</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    vec3 ambient<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    vec3 diffuse<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    vec3 specular<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">float</span> shininess<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>uniform Material material<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在片段着色器中，我们创建一个结构体 (Struct) 来储存物体的材质属性。我们也可以把它们储存为独立的 uniform 值，但是作为一个结构体来储存会更有条理一些。我们首先定义结构体的布局 (Layout)，然后使用刚创建的结构体为类型，简单地声明一个 uniform 变量。</p>\n<p>你可以看到，我们为每个冯氏光照模型的分量都定义一个颜色向量。ambient 材质向量定义了在环境光照下这个物体反射得是什么颜色，通常这是和物体颜色相同的颜色。diffuse 材质向量定义了在漫反射光照下物体的颜色。（和环境光照一样）漫反射颜色也要设置为我们需要的物体颜色。specular 材质向量设置的是镜面光照对物体的颜色影响（或者甚至可能反射一个物体特定的镜面高光颜色）。最后，shininess 影响镜面高光的散射 / 半径。</p>\n<ul>\n<li><strong>ambient</strong>: 环境光照下这个物体反射得是什么颜色。</li>\n<li><strong>diffuse</strong>: 在漫反射光照下物体的颜色。</li>\n<li><strong>specular</strong>: 镜面光照对物体的颜色影响。</li>\n<li><strong>shininess</strong>: 影响镜面高光的散射 / 半径。</li>\n</ul>\n<p>这四个元素定义了一个物体的材质，通过它们我们能够模拟很多现实世界中的材质。<span class=\"exturl\" data-url=\"aHR0cDovL2RldmVybmF5LmZyZWUuZnIvY291cnMvb3BlbmdsL21hdGVyaWFscy5odG1s\">devernay.free.fr</span> 上的一个表格展示了几种材质属性，它们模拟了现实世界中的真实材质。下面的图片展示了几种现实世界的材质对我们的立方体的影响：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/02/03/materials_real_world.png\" alt=\"image\" /></p>\n<p>可以看到，通过正确地指定一个物体的材质属性，我们对这个物体的感知也就不同了。效果非常明显，但是要想获得更真实的效果，我们最终需要更加复杂的形状，而不单单是一个立方体。在后面的教程中，我们会讨论更复杂的形状。</p>\n<p>为一个物体赋予一款合适的材质是非常困难的，这需要大量实验和丰富的经验，所以由于不合适的材质而毁了物体的视觉质量是件经常发生的事。</p>\n<p>让我们在着色器中实现这样的一个材质系统。</p>\n<h3 id=\"设置材质\"><a class=\"anchor\" href=\"#设置材质\">#</a> 设置材质</h3>\n<p>我们在片段着色器中创建了一个材质结构体的 uniform，所以下面我们希望修改一下光照的计算来顺应新的材质属性。由于所有材质变量都储存在结构体中，我们可以从 uniform 变量 material 中访问它们：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span>    </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\">// 环境光</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    vec3 ambient <span class=\"token operator\">=</span> lightColor <span class=\"token operator\">*</span> material<span class=\"token punctuation\">.</span>ambient<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">// 漫反射 </span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    vec3 norm <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>Normal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    vec3 lightDir <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>lightPos <span class=\"token operator\">-</span> FragPos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">float</span> diff <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token function\">dot</span><span class=\"token punctuation\">(</span>norm<span class=\"token punctuation\">,</span> lightDir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    vec3 diffuse <span class=\"token operator\">=</span> lightColor <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>diff <span class=\"token operator\">*</span> material<span class=\"token punctuation\">.</span>diffuse<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token comment\">// 镜面光</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    vec3 viewDir <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>viewPos <span class=\"token operator\">-</span> FragPos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    vec3 reflectDir <span class=\"token operator\">=</span> <span class=\"token function\">reflect</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>lightDir<span class=\"token punctuation\">,</span> norm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">float</span> spec <span class=\"token operator\">=</span> <span class=\"token function\">pow</span><span class=\"token punctuation\">(</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token function\">dot</span><span class=\"token punctuation\">(</span>viewDir<span class=\"token punctuation\">,</span> reflectDir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> material<span class=\"token punctuation\">.</span>shininess<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    vec3 specular <span class=\"token operator\">=</span> lightColor <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>spec <span class=\"token operator\">*</span> material<span class=\"token punctuation\">.</span>specular<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    vec3 result <span class=\"token operator\">=</span> ambient <span class=\"token operator\">+</span> diffuse <span class=\"token operator\">+</span> specular<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>可以看到，我们现在在需要的地方访问了材质结构体中的所有属性，并且这次是根据材质的颜色来计算最终的输出颜色的。物体的每个材质属性都乘上了它们对应的<mark>光照分量</mark> (lightColor)。</p>\n<p>我们现在可以在程序中设置适当的 uniform，对物体设置材质了。GLSL 中的结构体在设置 uniform 时并没有什么特别之处。结构体只是作为 uniform 变量的一个封装，所以如果想填充这个结构体的话，我们仍需要对每个单独的 uniform 进行设置，但这次要带上结构体名的前缀：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>lightingShader<span class=\"token punctuation\">.</span><span class=\"token function\">setVec3</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"material.ambient\"</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.31f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>lightingShader<span class=\"token punctuation\">.</span><span class=\"token function\">setVec3</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"material.diffuse\"</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.31f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>lightingShader<span class=\"token punctuation\">.</span><span class=\"token function\">setVec3</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"material.specular\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>lightingShader<span class=\"token punctuation\">.</span><span class=\"token function\">setFloat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"material.shininess\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">32.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>我们将环境光和漫反射分量设置成我们想要让物体所拥有的颜色，而将镜面分量设置为一个中等亮度的颜色，我们不希望镜面分量在这个物体上过于强烈。我们将反光度保持为 32。现在我们能够程序中非常容易地修改物体的材质了。</p>\n<p>运行程序，你应该会得到下面这样的结果：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/02/03/materials_with_material.png\" alt=\"image\" /></p>\n<h3 id=\"光的属性\"><a class=\"anchor\" href=\"#光的属性\">#</a> 光的属性</h3>\n<p>这个物体太亮了。物体过亮的原因是环境光、漫反射和镜面光这三个颜色对任何一个光源都会去全力反射。光源对环境光、漫反射和镜面光分量也具有着不同的强度。前面的教程，我们通过使用一个强度值改变环境光和镜面光强度的方式解决了这个问题。我们想做一个类似的系统，但是这次是要为每个光照分量都指定一个强度向量。如果我们假设 lightColor 是<mark> vec3 (1.0)</mark>，代码会看起来像这样：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vec3 ambient  <span class=\"token operator\">=</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> material<span class=\"token punctuation\">.</span>ambient<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>vec3 diffuse  <span class=\"token operator\">=</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>diff <span class=\"token operator\">*</span> material<span class=\"token punctuation\">.</span>diffuse<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>vec3 specular <span class=\"token operator\">=</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>spec <span class=\"token operator\">*</span> material<span class=\"token punctuation\">.</span>specular<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>所以物体的每个材质属性对每一个光照分量都返回了最大的强度。对单个光源来说，这些 vec3 (1.0) 值同样可以分别改变，而这通常就是我们想要的。现在，物体的环境光分量完全地影响了立方体的颜色，可是环境光分量实际上不应该对最终的颜色有这么大的影响，所以我们会将光源的环境光强度设置为一个小一点的值，从而限制环境光颜色：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vec3 ambient <span class=\"token operator\">=</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> material<span class=\"token punctuation\">.</span>ambient<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>我们可以用同样的方式修改光源的漫反射和镜面光强度。这和我们在上一节中所做的极为相似，你可以说我们已经创建了一些光照属性来影响每个单独的光照分量。我们希望为光照属性创建一个与材质结构体类似的结构体：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Light</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    vec3 position<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    vec3 ambient<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    vec3 diffuse<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    vec3 specular<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>uniform Light light<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>一个光源对它的<mark> ambient</mark>、<mark>diffuse</mark> 和<mark> specular</mark> 光照有着不同的强度。环境光照通常会设置为一个比较低的强度，因为我们不希望环境光颜色太过显眼。光源的漫反射分量通常设置为光所具有的颜色，通常是一个比较明亮的白色。镜面光分量通常会保持为 vec3 (1.0)，以最大强度发光。注意我们也将光源的位置添加到了结构体中。</p>\n<p>和材质 uniform 一样，我们需要更新片段着色器：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vec3 ambient  <span class=\"token operator\">=</span> light<span class=\"token punctuation\">.</span>ambient <span class=\"token operator\">*</span> material<span class=\"token punctuation\">.</span>ambient<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>vec3 diffuse  <span class=\"token operator\">=</span> light<span class=\"token punctuation\">.</span>diffuse <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>diff <span class=\"token operator\">*</span> material<span class=\"token punctuation\">.</span>diffuse<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>vec3 specular <span class=\"token operator\">=</span> light<span class=\"token punctuation\">.</span>specular <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>spec <span class=\"token operator\">*</span> material<span class=\"token punctuation\">.</span>specular<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>我们接下来在程序中设置光照强度：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>lightingShader<span class=\"token punctuation\">.</span><span class=\"token function\">setVec3</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"light.ambient\"</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.2f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.2f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.2f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>lightingShader<span class=\"token punctuation\">.</span><span class=\"token function\">setVec3</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"light.diffuse\"</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 将光照调暗了一些以搭配场景</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>lightingShader<span class=\"token punctuation\">.</span><span class=\"token function\">setVec3</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"light.specular\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><img data-src=\"https://learnopengl-cn.github.io/img/02/03/materials_light.png\" alt=\"image\" /></p>\n<h3 id=\"不同的光源颜色\"><a class=\"anchor\" href=\"#不同的光源颜色\">#</a> 不同的光源颜色</h3>\n<p>到目前为止，我们都只对光源设置了从白到灰到黑范围内的颜色，这样只会改变物体各个分量的强度，而不是它的真正颜色。由于现在能够非常容易地访问光照的属性了，我们可以随着时间改变它们的颜色，从而获得一些非常有意思的效果。由于所有的东西都在片段着色器中配置好了，修改光源的颜色非常简单，我们能够立刻创造一些很有趣的效果：</p>\n<p>我们可以利用 sin 和 glfwGetTime 函数改变光源的环境光和漫反射颜色，从而很容易地让光源的颜色随着时间变化：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 lightColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>lightColor<span class=\"token punctuation\">.</span>x <span class=\"token operator\">=</span> <span class=\"token function\">sin</span><span class=\"token punctuation\">(</span><span class=\"token function\">glfwGetTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">2.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>lightColor<span class=\"token punctuation\">.</span>y <span class=\"token operator\">=</span> <span class=\"token function\">sin</span><span class=\"token punctuation\">(</span><span class=\"token function\">glfwGetTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">0.7f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>lightColor<span class=\"token punctuation\">.</span>z <span class=\"token operator\">=</span> <span class=\"token function\">sin</span><span class=\"token punctuation\">(</span><span class=\"token function\">glfwGetTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">1.3f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 diffuseColor <span class=\"token operator\">=</span> lightColor   <span class=\"token operator\">*</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 降低影响</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 ambientColor <span class=\"token operator\">=</span> diffuseColor <span class=\"token operator\">*</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.2f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 很低的影响</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>lightingShader<span class=\"token punctuation\">.</span><span class=\"token function\">setVec3</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"light.ambient\"</span><span class=\"token punctuation\">,</span> ambientColor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>lightingShader<span class=\"token punctuation\">.</span><span class=\"token function\">setVec3</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"light.diffuse\"</span><span class=\"token punctuation\">,</span> diffuseColor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h2 id=\"光照贴图\"><a class=\"anchor\" href=\"#光照贴图\">#</a> 光照贴图</h2>\n<p>在上一节中，我们讨论了让每个物体都拥有自己独特的材质从而对光照做出不同的反应的方法。这样子能够很容易在一个光照的场景中给每个物体一个独特的外观，但是这仍不能对一个物体的视觉输出提供足够多的灵活性。</p>\n<p>在上一节中，我们将整个物体的材质定义为一个整体，但现实世界中的物体通常并不只包含有一种材质，而是由多种材质所组成。想想一辆汽车：它的外壳非常有光泽，车窗会部分反射周围的环境，轮胎不会那么有光泽，所以它没有镜面高光，轮毂非常闪亮（如果你洗车了的话）。汽车同样会有漫反射和环境光颜色，它们在整个物体上也不会是一样的，汽车有着许多种不同的环境光 / 漫反射颜色。总之，这样的物体在不同的部件上都有不同的材质属性。</p>\n<p>所以，上一节中的那个材质系统是肯定不够的，它只是一个最简单的模型，所以我们需要拓展之前的系统，引入<mark>漫反射</mark>和<mark>镜面光贴图</mark> (Map)。这允许我们对物体的漫反射分量（以及间接地对环境光分量，它们几乎总是一样的）和镜面光分量有着更精确的控制。</p>\n<h3 id=\"漫反射贴图\"><a class=\"anchor\" href=\"#漫反射贴图\">#</a> 漫反射贴图</h3>\n<p>我们希望通过某种方式对物体的每个片段单独设置漫反射颜色。有能够让我们根据片段在物体上的位置来获取颜色值得系统吗？</p>\n<p>这可能听起来很熟悉，而且事实上这个系统我们已经使用很长时间了。这听起来很像在之前教程中详细讨论过的纹理，而这基本就是这样：一个纹理。我们仅仅是对同样的原理使用了不同的名字：其实都是使用一张覆盖物体的图像，让我们能够逐片段索引其独立的颜色值。在光照场景中，它通常叫做一个漫反射贴图 (Diffuse Map)（3D 艺术家通常都这么叫它），它是一个表现了物体所有的漫反射颜色的纹理图像。</p>\n<p>为了演示漫反射贴图，我们将会使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWFybm9wZW5nbC1jbi5naXRodWIuaW8vaW1nLzAyLzA0L2NvbnRhaW5lcjIucG5n\">下面的图片</span>，它是一个有钢边框的木箱：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/02/04/container2.png\" alt=\"image\" /></p>\n<p>在着色器中使用漫反射贴图的方法和纹理教程中是完全一样的。但这次我们会将纹理储存为 Material 结构体中的一个<mark> sampler2D</mark>。我们将之前定义的<mark> vec3 漫反射颜色向量替换为漫反射贴图</mark>。</p>\n<blockquote>\n<p>注意 sampler2D 是所谓的<strong>不透明类型</strong> (Opaque Type)，也就是说我们<mark>不能将它实例化</mark>，只能通过 uniform 来定义它。如果我们使用除 uniform 以外的方法（比如函数的参数）实例化这个结构体，GLSL 会抛出一些奇怪的错误。这同样也适用于任何封装了不透明类型的结构体。</p>\n</blockquote>\n<p>我们也移除了环境光材质颜色向量，因为环境光颜色在几乎所有情况下都等于漫反射颜色，所以我们不需要将它们分开储存：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Material</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    sampler2D diffuse<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    vec3      specular<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">float</span>     shininess<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>in vec2 TexCoords<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>注意我们将在片段着色器中再次需要纹理坐标，所以我们声明一个额外的输入变量。接下来我们只需要从纹理中采样片段的漫反射颜色值即可：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vec3 diffuse <span class=\"token operator\">=</span> light<span class=\"token punctuation\">.</span>diffuse <span class=\"token operator\">*</span> diff <span class=\"token operator\">*</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>material<span class=\"token punctuation\">.</span>diffuse<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>不要忘记将环境光得材质颜色设置为漫反射材质颜色同样的值。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vec3 ambient <span class=\"token operator\">=</span> light<span class=\"token punctuation\">.</span>ambient <span class=\"token operator\">*</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>material<span class=\"token punctuation\">.</span>diffuse<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这就是使用漫反射贴图的全部步骤了。你可以看到，这并不是什么新的东西，但这能够极大地提高视觉品质。为了让它正常工作，我们还需要使用纹理坐标更新顶点数据，将它们作为顶点属性传递到片段着色器，加载材质并绑定材质到合适的纹理单元。</p>\n<p>更新后的顶点数据可以在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWFybm9wZW5nbC5jb20vY29kZV92aWV3ZXIucGhwP2NvZGU9bGlnaHRpbmcvdmVydGV4X2RhdGFfdGV4dHVyZXM=\">这里找到</span>。顶点数据现在包含了顶点位置、法向量和立方体顶点处的纹理坐标。让我们更新顶点着色器来以顶点属性的形式接受纹理坐标，并将它们传递到片段着色器中：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> in vec3 aPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> in vec3 aNormal<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> in vec2 aTexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>out vec2 TexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    TexCoords <span class=\"token operator\">=</span> aTexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>记得去更新两个 VAO 的顶点属性指针来匹配新的顶点数据，并加载箱子图像为一个纹理。在绘制箱子之前，我们希望将要用的纹理单元赋值到 material.diffuse 这个 uniform 采样器，并绑定箱子的纹理到这个纹理单元：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>lightingShader<span class=\"token punctuation\">.</span><span class=\"token function\">setInt</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"material.diffuse\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glActiveTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> diffuseMap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>使用了漫反射贴图之后，细节再一次得到惊人的提升，这次箱子有了光照开始闪闪发光（字面意思也是）了。你的箱子看起来可能像这样：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/02/04/materials_diffuse_map.png\" alt=\"image\" /></p>\n<h3 id=\"镜面光贴图\"><a class=\"anchor\" href=\"#镜面光贴图\">#</a> 镜面光贴图</h3>\n<p>你可能会注意到，镜面高光看起来有些奇怪，因为我们的物体大部分都是木头，我们知道木头不应该有这么强的镜面高光的。我们可以将物体的镜面光材质设置为 vec3 (0.0) 来解决这个问题，但这也意味着箱子钢制的边框将不再能够显示镜面高光了，我们知道钢铁应该是有一些镜面高光的。所以，我们想要让物体的某些部分以不同的强度显示镜面高光。这个问题看起来和漫反射贴图非常相似。是巧合吗？我想不是。</p>\n<p>我们同样可以使用一个专门用于镜面高光的纹理贴图。这也就意味着我们需要生成一个黑白的（如果你想得话也可以是彩色的）纹理，来定义物体每部分的镜面光强度。下面是一个<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWFybm9wZW5nbC1jbi5naXRodWIuaW8vaW1nLzAyLzA0L2NvbnRhaW5lcjJfc3BlY3VsYXIucG5n\">镜面光贴图</span> (Specular Map) 的例子：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/02/04/container2_specular.png\" alt=\"image\" /></p>\n<p>镜面高光的强度可以通过图像每个像素的亮度来获取。镜面光贴图上的每个像素都可以由一个颜色向量来表示，比如说黑色代表颜色向量 vec3 (0.0)，灰色代表颜色向量 vec3 (0.5)。在片段着色器中，我们接下来会取样对应的颜色值并将它乘以光源的镜面强度。一个像素越「白」，乘积就会越大，物体的镜面光分量就会越亮。</p>\n<p>由于箱子大部分都由木头所组成，而且木头材质应该没有镜面高光，所以漫反射纹理的整个木头部分全部都转换成了黑色。箱子钢制边框的镜面光强度是有细微变化的，钢铁本身会比较容易受到镜面高光的影响，而裂缝则不会。</p>\n<blockquote>\n<p>从实际角度来说，木头其实也有镜面高光，尽管它的反光度 (Shininess) 很小（更多的光被散射），影响也比较小，但是为了教学目的，我们可以假设木头不会对镜面光有任何反应。</p>\n</blockquote>\n<p>使用 Photoshop 或 Gimp 之类的工具，将漫反射纹理转换为镜面光纹理还是比较容易的，只需要剪切掉一些部分，将图像转换为黑白的，并增加亮度 / 对比度就好了。</p>\n<h3 id=\"采样镜面光贴图\"><a class=\"anchor\" href=\"#采样镜面光贴图\">#</a> 采样镜面光贴图</h3>\n<p>镜面光贴图和其它的纹理非常类似，所以代码也和漫反射贴图的代码很类似。记得要保证正确地加载图像并生成一个纹理对象。由于我们正在同一个片段着色器中使用另一个纹理采样器，我们必须要对镜面光贴图使用一个不同的纹理单元（见纹理），所以我们在渲染之前先把它绑定到合适的纹理单元上：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>lightingShader<span class=\"token punctuation\">.</span><span class=\"token function\">setInt</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"material.specular\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glActiveTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> specularMap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>接下来更新片段着色器的材质属性，让其接受一个 sampler2D 而不是 vec3 作为镜面光分量：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Material</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    sampler2D diffuse<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    sampler2D specular<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">float</span>     shininess<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>最后我们希望采样镜面光贴图，来获取片段所对应的镜面光强度：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vec3 ambient  <span class=\"token operator\">=</span> light<span class=\"token punctuation\">.</span>ambient  <span class=\"token operator\">*</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>material<span class=\"token punctuation\">.</span>diffuse<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>vec3 diffuse  <span class=\"token operator\">=</span> light<span class=\"token punctuation\">.</span>diffuse  <span class=\"token operator\">*</span> diff <span class=\"token operator\">*</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>material<span class=\"token punctuation\">.</span>diffuse<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>vec3 specular <span class=\"token operator\">=</span> light<span class=\"token punctuation\">.</span>specular <span class=\"token operator\">*</span> spec <span class=\"token operator\">*</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>material<span class=\"token punctuation\">.</span>specular<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>FragColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>ambient <span class=\"token operator\">+</span> diffuse <span class=\"token operator\">+</span> specular<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>通过使用镜面光贴图我们可以可以对物体设置大量的细节，比如物体的哪些部分需要有闪闪发光的属性，我们甚至可以设置它们对应的强度。镜面光贴图能够在漫反射贴图之上给予我们更高一层的控制。</p>\n<blockquote>\n<p>如果你想另辟蹊径，你也可以在镜面光贴图中使用真正的颜色，不仅设置每个片段的镜面光强度，还设置了镜面高光的颜色。从现实角度来说，镜面高光的颜色大部分（甚至全部）都是由光源本身所决定的，所以这样并不能生成非常真实的视觉效果（这也是为什么图像通常是黑白的，我们只关心强度）。</p>\n</blockquote>\n<p>如果你现在运行程序的话，你可以清楚地看到箱子的材质现在和真实的钢制边框箱子非常类似了：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/02/04/materials_specular_map.png\" alt=\"image\" /></p>\n<p>通过使用漫反射和镜面光贴图，我们可以给相对简单的物体添加大量的细节。我们甚至可以使用<mark>法线 / 凹凸贴图</mark> (Normal/Bump Map) 或者<mark>反射贴图</mark> (Reflection Map) 给物体添加更多的细节，但这些将会留到之后的教程中。把你的箱子给你的朋友或者家人看看，并且坚信我们的箱子有一天会比现在更加漂亮！</p>\n<h2 id=\"投光物\"><a class=\"anchor\" href=\"#投光物\">#</a> 投光物</h2>\n<p>我们目前使用的光照都来自于空间中的一个点。它能给我们不错的效果，但现实世界中，我们有很多种类的光照，每种的表现都不同。将光<mark>投射</mark> (Cast) 到物体的光源叫做投光物 (Light Caster)。在这一节中，我们将会讨论几种不同类型的投光物。学会模拟不同种类的光源是又一个能够进一步丰富场景的工具。</p>\n<p>我们首先将会讨论<mark>定向光</mark> (Directional Light)，接下来是<mark>点光源</mark> (Point Light)，它是我们之前学习的光源的拓展，最后我们将会讨论聚光 (Spotlight)。在下一节中我们将讨论如何将这些不同种类的光照类型整合到一个场景之中。</p>\n<h3 id=\"平行光\"><a class=\"anchor\" href=\"#平行光\">#</a> 平行光</h3>\n<p>当一个光源处于很远的地方时，来自光源的每条光线就会近似于互相平行。不论物体和 / 或者观察者的位置，看起来好像所有的<mark>光都来自于同一个方向</mark>。当我们使用一个假设光源处于无限远处的模型时，它就被称为定向光，因为它的所有光线都有着相同的方向，它与光源的位置是没有关系的。</p>\n<p>定向光非常好的一个例子就是太阳。太阳距离我们并不是无限远，但它已经远到在光照计算中可以把它视为无限远了。所以来自太阳的所有光线将被模拟为平行光线，我们可以在下图看到：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/02/05/light_casters_directional.png\" alt=\"image\" /></p>\n<p>因为所有的光线都是平行的，所以物体与光源的相对位置是不重要的，因为对场景中每一个物体光的方向都是一致的。由于光的位置向量保持一致，场景中每个物体的光照计算将会是类似的。</p>\n<p>我们可以定义一个光线方向向量而不是位置向量来模拟一个定向光。着色器的计算基本保持不变，但这次我们将直接使用光的<mark> direction</mark> 向量而不是通过<mark> direction</mark> 来计算<mark> lightDir</mark> 向量。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Light</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">//vec3 position; // 使用定向光就不再需要了</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    vec3 direction<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    vec3 ambient<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    vec3 diffuse<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    vec3 specular<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  vec3 lightDir <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>light<span class=\"token punctuation\">.</span>direction<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>注意我们首先对 light.direction 向量取反。我们目前使用的光照计算需求一个从<mark>片段至光源的光线方向</mark>，但人们更习惯定义定向光为一个从光源出发的全局方向。所以我们需要对全局光照方向向量取反来改变它的方向，它现在是一个指向光源的方向向量了。而且，记得对向量进行标准化，假设输入向量为一个单位向量是很不明智的。</p>\n<p>最终的 lightDir 向量将和以前一样用在<mark>漫反射</mark>和<mark>镜面光</mark>计算中。</p>\n<p>为了清楚地展示定向光对多个物体具有相同的影响，我们将会再次使用坐标系统章节最后的那个箱子派对的场景。如果你错过了派对，我们先定义了十个不同的箱子位置，并对每个箱子都生成了一个不同的模型矩阵，每个模型矩阵都包含了对应的局部 - 世界坐标变换：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    glm<span class=\"token operator\">::</span>mat4 model<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    model <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">translate</span><span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">,</span> cubePositions<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">float</span> angle <span class=\"token operator\">=</span> <span class=\"token number\">20.0f</span> <span class=\"token operator\">*</span> i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    model <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">rotate</span><span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">radians</span><span class=\"token punctuation\">(</span>angle<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.3f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    lightingShader<span class=\"token punctuation\">.</span><span class=\"token function\">setMat4</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"model\"</span><span class=\"token punctuation\">,</span> model<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token function\">glDrawArrays</span><span class=\"token punctuation\">(</span>GL_TRIANGLES<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">36</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>同时，不要忘记定义光源的方向（注意我们将方向定义为从光源出发的方向，你可以很容易看到光的方向朝下）。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>lightingShader<span class=\"token punctuation\">.</span><span class=\"token function\">setVec3</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"light.direction\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.2f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.3f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><blockquote>\n<p>我们一直将光的位置和位置向量定义为 vec3，但一些人会喜欢将所有的向量都定义为 vec4。当我们将位置向量定义为一个 vec4 时，很重要的一点是要将 w 分量设置为 1.0，这样变换和投影才能正确应用。然而，当我们定义一个方向向量为 vec4 的时候，我们不想让位移有任何的效果（因为它仅仅代表的是方向），所以我们将 w 分量设置为 0.0。</p>\n</blockquote>\n<blockquote>\n<p>方向向量就会像这样来表示：vec4 (0.2f, 1.0f, 0.3f, 0.0f)。这也可以作为一个快速检测光照类型的工具：你可以检测 w 分量是否等于 1.0，来检测它是否是光的位置向量；<mark>w 分量等于 0.0，则它是光的方向向量</mark>，这样就能根据这个来调整光照计算了：</p>\n</blockquote>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>lightVector<span class=\"token punctuation\">.</span>w <span class=\"token operator\">==</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 注意浮点数据类型的误差</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token comment\">// 执行定向光照计算</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>lightVector<span class=\"token punctuation\">.</span>w <span class=\"token operator\">==</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token comment\">// 根据光源的位置做光照计算（与上一节一样）</span></pre></td></tr></table></figure><blockquote>\n<p>你知道吗：这正是旧 OpenGL（固定函数式）决定光源是定向光还是位置光源 (Positional Light Source) 的方法，并根据它来调整光照。</p>\n</blockquote>\n<p>如果你现在编译程序，在场景中自由移动，你就可以看到好像有一个太阳一样的光源对所有的物体投光。你能注意到漫反射和镜面光分量的反应都好像在天空中有一个光源的感觉吗？它会看起来像这样：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/02/05/light_casters_directional_light.png\" alt=\"image\" /></p>\n<h3 id=\"点光源\"><a class=\"anchor\" href=\"#点光源\">#</a> 点光源</h3>\n<p>定向光对于照亮整个场景的全局光源是非常棒的，但除了定向光之外我们也需要一些分散在场景中的点光源 (Point Light)。点光源是处于世界中某一个位置的光源，它会朝着所有方向发光，但光线会随着距离逐渐衰减。想象作为投光物的灯泡和火把，它们都是点光源。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/02/05/light_casters_point.png\" alt=\"image\" /></p>\n<p>在之前的教程中，我们一直都在使用一个（简化的）点光源。我们在给定位置有一个光源，它会从它的光源位置开始朝着所有方向散射光线。然而，我们定义的光源模拟的是永远不会衰减的光线，这看起来像是光源亮度非常的强。在大部分的 3D 模拟中，我们都希望模拟的光源仅照亮光源附近的区域而不是整个场景。</p>\n<p>如果你将 10 个箱子加入到上一节光照场景中，你会注意到在最后面的箱子和在灯面前的箱子都以相同的强度被照亮，并没有定义一个公式来将光随距离衰减。我们希望在后排的箱子与前排的箱子相比仅仅是被轻微地照亮。</p>\n<h3 id=\"衰减\"><a class=\"anchor\" href=\"#衰减\">#</a> 衰减</h3>\n<p>随着光线传播距离的增长逐渐削减光的强度通常叫做<mark>衰减</mark> (Attenuation)。随距离减少光强度的一种方式是使用一个线性方程。这样的方程能够随着距离的增长线性地减少光的强度，从而让远处的物体更暗。然而，这样的线性方程通常会看起来比较假。在现实世界中，灯在近处通常会非常亮，但随着距离的增加光源的亮度一开始会下降非常快，但在远处时剩余的光强度就会下降的非常缓慢了。所以，我们需要一个不同的公式来减少光的强度。</p>\n<p>幸运的是一些聪明的人已经帮我们解决了这个问题。下面这个公式根据片段距光源的距离计算了衰减值，之后我们会将它乘以光的强度向量：</p>\n<pre><code class=\"language-math\">Fatt=\\frac &#123;1.0&#125;&#123;K_c+K_l∗d+K_q∗d^2&#125;\n</code></pre>\n<p>在这里 d 代表了片段距光源的<mark>距离</mark>。接下来为了计算衰减值，我们定义 3 个（可配置的）项：常数项 Kc、一次项 Kl 和二次项 Kq。</p>\n<ul>\n<li>常数项通常保持为 1.0，它的主要作用是保证<mark>分母永远不会比 1 小</mark>，否则的话在某些距离上它反而会增加强度，这肯定不是我们想要的效果。</li>\n<li>一次项会与距离值相乘，以线性的方式减少强度。</li>\n<li>二次项会与距离的平方相乘，让光源以二次递减的方式减少强度。二次项在距离比较小的时候影响会比一次项小很多，但当距离值比较大的时候它就会比一次项更大了。</li>\n</ul>\n<p>由于二次项的存在，光线会在大部分时候以线性的方式衰退，直到距离变得足够大，让二次项超过一次项，光的强度会以更快的速度下降。这样的结果就是，光在近距离时亮度很高，但随着距离变远亮度迅速降低，最后会以更慢的速度减少亮度。下面这张图显示了在 100 的距离内衰减的效果：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/02/05/attenuation.png\" alt=\"image\" /></p>\n<p>你可以看到光在近距离的时候有着最高的强度，但随着距离增长，它的强度明显减弱，并缓慢地在距离大约 100 的时候强度接近 0。这正是我们想要的。</p>\n<h3 id=\"选择正确的值\"><a class=\"anchor\" href=\"#选择正确的值\">#</a> 选择正确的值</h3>\n<p>但是，该对这三个项设置什么值呢？正确地设定它们的值取决于很多因素：环境、希望光覆盖的距离、光的类型等。在大多数情况下，这都是经验的问题，以及适量的调整。下面这个表格显示了模拟一个（大概）真实的，覆盖特定半径（距离）的光源时，这些项可能取的一些值。第一列指定的是在给定的三项时光所能覆盖的距离。这些值是大多数光源很好的起始点，它们由 Ogre3D 的 Wiki 所提供：</p>\n<table>\n<thead>\n<tr>\n<th>距离</th>\n<th>常数项</th>\n<th>一次项</th>\n<th>二次项</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>7</td>\n<td>1.0</td>\n<td>0.7</td>\n<td>1.8</td>\n</tr>\n<tr>\n<td>13</td>\n<td>1.0</td>\n<td>0.35</td>\n<td>0.44</td>\n</tr>\n<tr>\n<td>20</td>\n<td>1.0</td>\n<td>0.22</td>\n<td>0.20</td>\n</tr>\n<tr>\n<td>32</td>\n<td>1.0</td>\n<td>0.14</td>\n<td>0.07</td>\n</tr>\n<tr>\n<td>50</td>\n<td>1.0</td>\n<td>0.09</td>\n<td>0.032</td>\n</tr>\n<tr>\n<td>65</td>\n<td>1.0</td>\n<td>0.07</td>\n<td>0.017</td>\n</tr>\n<tr>\n<td>100</td>\n<td>1.0</td>\n<td>0.045</td>\n<td>0.0075</td>\n</tr>\n<tr>\n<td>160</td>\n<td>1.0</td>\n<td>0.027</td>\n<td>0.0028</td>\n</tr>\n<tr>\n<td>200</td>\n<td>1.0</td>\n<td>0.022</td>\n<td>0.0019</td>\n</tr>\n<tr>\n<td>325</td>\n<td>1.0</td>\n<td>0.014</td>\n<td>0.0007</td>\n</tr>\n<tr>\n<td>600</td>\n<td>1.0</td>\n<td>0.007</td>\n<td>0.0002</td>\n</tr>\n<tr>\n<td>3250</td>\n<td>1.0</td>\n<td>0.0014</td>\n<td>0.000007</td>\n</tr>\n</tbody>\n</table>\n<p>你可以看到，常数项 Kc 在所有的情况下都是 1.0。一次项 Kl 为了覆盖更远的距离通常都很小，二次项 Kq 甚至更小。尝试对这些值进行实验，看看它们在你的实现中有什么效果。在我们的环境中，32 到 100 的距离对大多数的光源都足够了。</p>\n<h3 id=\"实现衰减\"><a class=\"anchor\" href=\"#实现衰减\">#</a> 实现衰减</h3>\n<p>为了实现衰减，在片段着色器中我们还需要三个额外的值：也就是公式中的常数项、一次项和二次项。它们最好储存在之前定义的 Light 结构体中。注意我们使用上一节中计算 lightDir 的方法，而不是上面定向光部分的。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Light</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    vec3 position<span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    vec3 ambient<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    vec3 diffuse<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    vec3 specular<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">float</span> constant<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">float</span> linear<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">float</span> quadratic<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>然后我们将在 OpenGL 中设置这些项：我们希望光源能够覆盖 50 的距离，所以我们会使用表格中对应的常数项、一次项和二次项：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>lightingShader<span class=\"token punctuation\">.</span><span class=\"token function\">setFloat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"light.constant\"</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">1.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>lightingShader<span class=\"token punctuation\">.</span><span class=\"token function\">setFloat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"light.linear\"</span><span class=\"token punctuation\">,</span>    <span class=\"token number\">0.09f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>lightingShader<span class=\"token punctuation\">.</span><span class=\"token function\">setFloat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"light.quadratic\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.032f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在片段着色器中实现衰减还是比较直接的：我们根据公式计算衰减值，之后再分别乘以环境光、漫反射和镜面光分量。</p>\n<p>我们仍需要公式中距光源的距离，还记得我们是怎么计算一个向量的长度的吗？我们可以通过获取片段和光源之间的向量差，并获取结果向量的长度作为距离项。我们可以使用 GLSL 内建的 length 函数来完成这一点：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> distance    <span class=\"token operator\">=</span> <span class=\"token function\">length</span><span class=\"token punctuation\">(</span>light<span class=\"token punctuation\">.</span>position <span class=\"token operator\">-</span> FragPos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">float</span> attenuation <span class=\"token operator\">=</span> <span class=\"token number\">1.0</span> <span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span>light<span class=\"token punctuation\">.</span>constant <span class=\"token operator\">+</span> light<span class=\"token punctuation\">.</span>linear <span class=\"token operator\">*</span> distance <span class=\"token operator\">+</span> light<span class=\"token punctuation\">.</span>quadratic <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>distance <span class=\"token operator\">*</span> distance<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>接下来，我们将包含这个衰减值到光照计算中，将它分别乘以环境光、漫反射和镜面光颜色。</p>\n<blockquote>\n<p>我们可以将环境光分量保持不变，让环境光照不会随着距离减少，但是如果我们使用多于一个的光源，所有的环境光分量将会开始叠加，所以在这种情况下我们也希望衰减环境光照。简单实验一下，看看什么才能在你的环境中效果最好。</p>\n</blockquote>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>ambient  <span class=\"token operator\">*=</span> attenuation<span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"2\"></td><td><pre>diffuse  <span class=\"token operator\">*=</span> attenuation<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>specular <span class=\"token operator\">*=</span> attenuation<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><img data-src=\"https://learnopengl-cn.github.io/img/02/05/light_casters_point_light.png\" alt=\"image\" /></p>\n<p>你可以看到，只有前排的箱子被照亮的，距离最近的箱子是最亮的。后排的箱子一点都没有照亮，因为它们离光源实在是太远了。你可以在这里找到程序的代码。</p>\n<p>点光源就是一个能够配置位置和衰减的光源。它是我们光照工具箱中的又一个光照类型。</p>\n<h3 id=\"聚光\"><a class=\"anchor\" href=\"#聚光\">#</a> 聚光</h3>\n<p>我们要讨论的最后一种类型的光是<mark>聚光</mark> (Spotlight)。聚光是位于环境中某个位置的光源，它只朝一个特定方向而不是所有方向照射光线。这样的结果就是只有在聚光方向的特定半径内的物体才会被照亮，其它的物体都会保持黑暗。聚光很好的例子就是路灯或手电筒。</p>\n<p>OpenGL 中聚光是用一个世界空间位置、一个方向和一个切光角 (Cutoff Angle) 来表示的，切光角指定了聚光的半径（译注：是圆锥的半径不是距光源距离那个半径）。对于每个片段，我们会计算片段是否位于聚光的切光方向之间（也就是在锥形内），如果是的话，我们就会相应地照亮片段。下面这张图会让你明白聚光是如何工作的：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/02/05/light_casters_spotlight_angles.png\" alt=\"image\" /></p>\n<ul>\n<li><mark>LightDir</mark>：从片段指向光源的向量。</li>\n<li><mark>SpotDir</mark>：聚光所指向的方向。</li>\n<li><mark>Phiϕ</mark>：指定了聚光半径的切光角。落在这个角度之外的物体都不会被这个聚光所照亮。</li>\n<li><mark>Thetaθ</mark>：LightDir 向量和 SpotDir 向量之间的夹角。在聚光内部的话 θ 值应该比 ϕ 值小。</li>\n</ul>\n<p>所以我们要做的就是计算<mark> LightDir</mark> 向量和<mark> SpotDir</mark> 向量之间的点积（还记得它会返回两个单位向量夹角的余弦值吗？），并将它与切光角 ϕ 值对比。你现在应该了解聚光究竟是什么了，下面我们将以手电筒的形式创建一个聚光。</p>\n<h3 id=\"手电筒\"><a class=\"anchor\" href=\"#手电筒\">#</a> 手电筒</h3>\n<p><mark>手电筒</mark> (Flashlight) 是一个位于观察者位置的聚光，通常它都会瞄准玩家视角的正前方。基本上说，手电筒就是普通的聚光，但它的位置和方向会随着玩家的位置和朝向不断更新。</p>\n<p>所以，在片段着色器中我们需要的值有聚光的位置向量（来计算光的方向向量）、聚光的方向向量和一个切光角。我们可以将它们储存在 Light 结构体中：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">Light</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    vec3  position<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    vec3  direction<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">float</span> cutOff<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>接下来我们将合适的值传到着色器中：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>lightingShader<span class=\"token punctuation\">.</span><span class=\"token function\">setVec3</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"light.position\"</span><span class=\"token punctuation\">,</span>  camera<span class=\"token punctuation\">.</span>Position<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>lightingShader<span class=\"token punctuation\">.</span><span class=\"token function\">setVec3</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"light.direction\"</span><span class=\"token punctuation\">,</span> camera<span class=\"token punctuation\">.</span>Front<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>lightingShader<span class=\"token punctuation\">.</span><span class=\"token function\">setFloat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"light.cutOff\"</span><span class=\"token punctuation\">,</span>   glm<span class=\"token operator\">::</span><span class=\"token function\">cos</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">radians</span><span class=\"token punctuation\">(</span><span class=\"token number\">12.5f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>你可以看到，我们并没有给切光角设置一个角度值，反而是用角度值计算了一个余弦值，将余弦结果传递到片段着色器中。这样做的原因是在片段着色器中，我们会计算<mark> LightDir</mark> 和<mark> SpotDir</mark> 向量的<mark>点积</mark>，这个点积返回的将是一个余弦值而不是角度值，所以我们不能直接使用角度值和余弦值进行比较。为了获取角度值我们需要计算点积结果的反余弦，这是一个开销很大的计算。所以为了节约一点性能开销，我们将会计算切光角对应的余弦值，并将它的结果传入片段着色器中。由于这两个角度现在都由余弦角来表示了，我们可以直接对它们进行比较而不用进行任何开销高昂的计算。</p>\n<p>接下来就是计算 θ 值，并将它和切光角 ϕ 对比，来决定是否在聚光的内部：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> theta <span class=\"token operator\">=</span> <span class=\"token function\">dot</span><span class=\"token punctuation\">(</span>lightDir<span class=\"token punctuation\">,</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>light<span class=\"token punctuation\">.</span>direction<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>theta <span class=\"token operator\">></span> light<span class=\"token punctuation\">.</span>cutOff<span class=\"token punctuation\">)</span> </pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#123;</span>       </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token comment\">// 执行光照计算</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">else</span>  <span class=\"token comment\">// 否则，使用环境光，让场景在聚光之外时不至于完全黑暗</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  color <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>light<span class=\"token punctuation\">.</span>ambient <span class=\"token operator\">*</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>material<span class=\"token punctuation\">.</span>diffuse<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>我们首先计算了 lightDir 和取反的 direction 向量（取反的是因为我们想让向量指向光源而不是从光源出发）之间的点积。记住要对所有的相关向量标准化。</p>\n<blockquote>\n<p>你可能奇怪为什么在 if 条件中使用的是 &gt; 符号而不是 &lt; 符号。theta 不应该比光的切光角更小才是在聚光内部吗？这并没有错，但不要忘记角度值现在都由余弦值来表示的。一个 0 度的角度表示的是 1.0 的余弦值，而一个 90 度的角度表示的是 0.0 的余弦值，你可以在下图中看到：</p>\n</blockquote>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/02/05/light_casters_cos.png\" alt=\"image\" /></p>\n<blockquote>\n<p>你现在可以看到，余弦值越接近 1.0，它的角度就越小。这也就解释了为什么 theta 要比切光值更大了。切光值目前设置为 12.5 的余弦，约等于 0.9978，所以在 0.9979 到 1.0 内的 theta 值才能保证片段在聚光内，从而被照亮。</p>\n</blockquote>\n<h3 id=\"平滑软化边缘\"><a class=\"anchor\" href=\"#平滑软化边缘\">#</a> 平滑 / 软化边缘</h3>\n<p>为了创建一种看起来边缘平滑的聚光，我们需要模拟聚光有一个<mark>内圆锥</mark> (Inner Cone) 和一个<mark>外圆锥</mark> (Outer Cone)。我们可以将内圆锥设置为上一部分中的那个圆锥，但我们也需要一个外圆锥，来让光从内圆锥逐渐减暗，直到外圆锥的边界。</p>\n<p>为了创建一个外圆锥，我们只需要再定义一个余弦值来代表聚光方向向量和外圆锥向量（等于它的半径）的夹角。然后，如果一个片段处于内外圆锥之间，将会给它计算出一个 0.0 到 1.0 之间的强度值。如果片段在内圆锥之内，它的强度就是 1.0，如果在外圆锥之外强度值就是 0.0。</p>\n<p>我们可以用下面这个公式来计算这个值：</p>\n<pre><code class=\"language-math\">I=\\frac&#123;θ−γ&#125;ϵ\n</code></pre>\n<p>这里 ϵ(Epsilon) 是内（ϕ）和外圆锥（γ）之间的余弦值差（ϵ=ϕ−γ）。最终的 I 值就是在当前片段聚光的强度。</p>\n<p>很难去表现这个公式是怎么工作的，所以我们用一些实例值来看看：</p>\n<table>\n<thead>\n<tr>\n<th>θ</th>\n<th>θ（角度）</th>\n<th>ϕ（内光切）</th>\n<th>ϕ（角度）</th>\n<th>γ（外光切）</th>\n<th>γ（角度）</th>\n<th>ϵ</th>\n<th>I</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0.87</td>\n<td>30</td>\n<td>0.91</td>\n<td>25</td>\n<td>0.82</td>\n<td>35</td>\n<td>0.91 - 0.82 = 0.09</td>\n<td>0.87 - 0.82 / 0.09 = 0.56</td>\n</tr>\n<tr>\n<td>0.9</td>\n<td>26</td>\n<td>0.91</td>\n<td>25</td>\n<td>0.82</td>\n<td>35</td>\n<td>0.91 - 0.82 = 0.09</td>\n<td>0.9 - 0.82 / 0.09 = 0.89</td>\n</tr>\n<tr>\n<td>0.97</td>\n<td>14</td>\n<td>0.91</td>\n<td>25</td>\n<td>0.82</td>\n<td>35</td>\n<td>0.91 - 0.82 = 0.09</td>\n<td>0.97 - 0.82 / 0.09 = 1.67</td>\n</tr>\n<tr>\n<td>0.83</td>\n<td>34</td>\n<td>0.91</td>\n<td>25</td>\n<td>0.82</td>\n<td>35</td>\n<td>0.91 - 0.82 = 0.09</td>\n<td>0.83 - 0.82 / 0.09 = 0.11</td>\n</tr>\n<tr>\n<td>0.64</td>\n<td>50</td>\n<td>0.91</td>\n<td>25</td>\n<td>0.82</td>\n<td>35</td>\n<td>0.91 - 0.82 = 0.09</td>\n<td>0.64 - 0.82 / 0.09 = -2.0</td>\n</tr>\n<tr>\n<td>0.966</td>\n<td>15</td>\n<td>0.9978</td>\n<td>12.5</td>\n<td>0.953</td>\n<td>17.5</td>\n<td>0.966 - 0.953 = 0.0448</td>\n<td>0.966 - 0.953 / 0.0448 = 0.29</td>\n</tr>\n</tbody>\n</table>\n<p>你可以看到，我们基本是在内外余弦值之间根据 θ 插值。如果你仍不明白发生了什么，不必担心，只需要记住这个公式就好了，在你更聪明的时候再回来看看。</p>\n<p>我们现在有了一个在聚光外是负的，在内圆锥内大于 1.0 的，在边缘处于两者之间的强度值了。如果我们正确地约束 (Clamp) 这个值，在片段着色器中就不再需要 if-else 了，我们能够使用计算出来的强度值直接乘以光照分量：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> theta     <span class=\"token operator\">=</span> <span class=\"token function\">dot</span><span class=\"token punctuation\">(</span>lightDir<span class=\"token punctuation\">,</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>light<span class=\"token punctuation\">.</span>direction<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">float</span> epsilon   <span class=\"token operator\">=</span> light<span class=\"token punctuation\">.</span>cutOff <span class=\"token operator\">-</span> light<span class=\"token punctuation\">.</span>outerCutOff<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">float</span> intensity <span class=\"token operator\">=</span> <span class=\"token function\">clamp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>theta <span class=\"token operator\">-</span> light<span class=\"token punctuation\">.</span>outerCutOff<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> epsilon<span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    </pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// 将不对环境光做出影响，让它总是能有一点光</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>diffuse  <span class=\"token operator\">*=</span> intensity<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>specular <span class=\"token operator\">*=</span> intensity<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr></table></figure><p>注意我们使用了 clamp 函数，它把第一个参数约束 (Clamp) 在了 0.0 到 1.0 之间。这保证强度值不会在 [0, 1] 区间之外。</p>\n<p>确定你将 outerCutOff 值添加到了 Light 结构体之中，并在程序中设置它的 uniform 值。下面的图片中，我们使用的内切光角是 12.5，外切光角是 17.5：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/02/05/light_casters_spotlight.png\" alt=\"image\" /></p>\n<p>啊，这样看起来就好多了。稍微对内外切光角实验一下，尝试创建一个更能符合你需求的聚光。你可以在这里找到程序的源码。</p>\n<p>这样的手电筒 / 聚光类型的灯光非常适合恐怖游戏，结合定向光和点光源，环境就会开始被照亮了。在下一节的教程中，我们将会结合我们至今讨论的所有光照和技巧。</p>\n<h3 id=\"多光源\"><a class=\"anchor\" href=\"#多光源\">#</a> 多光源</h3>\n<p>我们在前面的教程中已经学习了许多关于 OpenGL 中光照的知识，其中包<mark>括冯氏着色</mark> (Phong Shading)、<mark>材质</mark> (Material)、<mark>光照贴图</mark> (Lighting Map) 以及不同种类的投光物 (Light Caster)。在这一节中，我们将结合之前学过的所有知识，创建一个包含六个光源的场景。我们将模拟一个类似太阳的<mark>定向光</mark> (Directional Light) 光源，四个分散在场景中的<mark>点光源</mark> (Point Light)，以及一个<mark>手电筒</mark> (Flashlight)。</p>\n<p>为了在场景中使用多个光源，我们希望将光照计算封装到 GLSL 函数中。这样做的原因是，每一种光源都需要一种不同的计算方法，而一旦我们想对多个光源进行光照计算时，代码很快就会变得非常复杂。如果我们只在 main 函数中进行所有的这些计算，代码很快就会变得难以理解。</p>\n<p>GLSL 中的函数和 C 函数很相似，它有一个函数名、一个返回值类型，如果函数不是在 main 函数之前声明的，我们还必须在代码文件顶部声明一个原型。我们对每个光照类型都创建一个不同的函数：定向光、点光源和聚光。</p>\n<p>当我们在场景中使用多个光源时，通常使用以下方法：我们需要有一个单独的颜色向量代表片段的输出颜色。对于每一个光源，它对片段的贡献颜色将会加到片段的输出颜色向量上。所以场景中的每个光源都会计算它们各自对片段的影响，并结合为一个最终的输出颜色。大体的结构会像是这样：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>out vec4 FragColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token comment\">// 定义一个输出颜色值</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  vec3 output<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token comment\">// 将定向光的贡献加到输出中</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  output <span class=\"token operator\">+=</span> <span class=\"token function\">someFunctionToCalculateDirectionalLight</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token comment\">// 对所有的点光源也做相同的事情</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nr_of_point_lights<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    output <span class=\"token operator\">+=</span> <span class=\"token function\">someFunctionToCalculatePointLight</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  <span class=\"token comment\">// 也加上其它的光源（比如聚光）</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  output <span class=\"token operator\">+=</span> <span class=\"token function\">someFunctionToCalculateSpotLight</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>  FragColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>output<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>实际的代码对每一种实现都可能不同，但大体的结构都是差不多的。我们定义了几个函数，用来计算每个光源的影响，并将最终的结果颜色加到输出颜色向量上。例如，如果两个光源都很靠近一个片段，那么它们所结合的贡献将会形成一个比单个光源照亮时更加明亮的片段。</p>\n<h3 id=\"定向光\"><a class=\"anchor\" href=\"#定向光\">#</a> 定向光</h3>\n<p>我么需要在片段着色器中定义一个函数来计算定向光对相应片段的贡献：它接受一些参数并计算一个定向光照颜色。</p>\n<p>首先，我们需要定义一个定向光源最少所需要的变量。我们可以将这些变量储存在一个叫做 DirLight 的结构体中，并将它定义为一个 uniform。需要的变量在上一节中都介绍过：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">DirLight</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    vec3 direction<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    vec3 ambient<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    vec3 diffuse<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    vec3 specular<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"8\"></td><td><pre>uniform DirLight dirLight<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>接下来我们可以将 dirLight 传入一个有着一下原型的函数。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vec3 <span class=\"token function\">CalcDirLight</span><span class=\"token punctuation\">(</span>DirLight light<span class=\"token punctuation\">,</span> vec3 normal<span class=\"token punctuation\">,</span> vec3 viewDir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>和 C/C++ 一样，如果我们想调用一个函数（这里是在 main 函数中调用），这个函数需要在调用者的行数之前被定义过。在这个例子中我们更喜欢在 main 函数以下定义函数，所以上面要求就不满足了。所以，我们需要在 main 函数之上定义函数的原型，这和 C 语言中是一样的。</p>\n<p>你可以看到，这个函数需要一个 DirLight 结构体和其它两个向量来进行计算。如果你认真完成了上一节的话，这个函数的内容应该理解起来很容易：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vec3 <span class=\"token function\">CalcDirLight</span><span class=\"token punctuation\">(</span>DirLight light<span class=\"token punctuation\">,</span> vec3 normal<span class=\"token punctuation\">,</span> vec3 viewDir<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    vec3 lightDir <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>light<span class=\"token punctuation\">.</span>direction<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token comment\">// 漫反射着色</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">float</span> diff <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token function\">dot</span><span class=\"token punctuation\">(</span>normal<span class=\"token punctuation\">,</span> lightDir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">// 镜面光着色</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    vec3 reflectDir <span class=\"token operator\">=</span> <span class=\"token function\">reflect</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>lightDir<span class=\"token punctuation\">,</span> normal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">float</span> spec <span class=\"token operator\">=</span> <span class=\"token function\">pow</span><span class=\"token punctuation\">(</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token function\">dot</span><span class=\"token punctuation\">(</span>viewDir<span class=\"token punctuation\">,</span> reflectDir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> material<span class=\"token punctuation\">.</span>shininess<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token comment\">// 合并结果</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    vec3 ambient  <span class=\"token operator\">=</span> light<span class=\"token punctuation\">.</span>ambient  <span class=\"token operator\">*</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>material<span class=\"token punctuation\">.</span>diffuse<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    vec3 diffuse  <span class=\"token operator\">=</span> light<span class=\"token punctuation\">.</span>diffuse  <span class=\"token operator\">*</span> diff <span class=\"token operator\">*</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>material<span class=\"token punctuation\">.</span>diffuse<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    vec3 specular <span class=\"token operator\">=</span> light<span class=\"token punctuation\">.</span>specular <span class=\"token operator\">*</span> spec <span class=\"token operator\">*</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>material<span class=\"token punctuation\">.</span>specular<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>ambient <span class=\"token operator\">+</span> diffuse <span class=\"token operator\">+</span> specular<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们基本上只是从上一节中复制了代码，并使用函数参数的两个向量来计算定向光的贡献向量。最终环境光、漫反射和镜面光的贡献将会合并为单个颜色向量返回。</p>\n<h3 id=\"点光源-2\"><a class=\"anchor\" href=\"#点光源-2\">#</a> 点光源</h3>\n<p>和定向光一样，我们也希望定义一个用于计算点光源对相应片段贡献，以及衰减，的函数。同样，我们定义一个包含了点光源所需所有变量的结构体：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">PointLight</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    vec3 position<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">float</span> constant<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">float</span> linear<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">float</span> quadratic<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    vec3 ambient<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    vec3 diffuse<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    vec3 specular<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token expression\">NR_POINT_LIGHTS <span class=\"token number\">4</span></span></span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>uniform PointLight pointLights<span class=\"token punctuation\">[</span>NR_POINT_LIGHTS<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>你可以看到，我们在 GLSL 中使用了预处理指令来定义了我们场景中点光源的数量。接着我们使用了这个<mark> NR_POINT_LIGHTS</mark> 常量来创建了一个<mark> PointLight</mark> 结构体的数组。GLSL 中的数组和 C 数组一样，可以使用一对方括号来创建。现在我们有四个待填充数据的 PointLight 结构体。</p>\n<blockquote>\n<p>我们也可以定义一个大的结构体（而不是为每种类型的光源定义不同的结构体），包含所有不同种光照类型所需的变量，并将这个结构体用到所有的函数中，只需要忽略用不到的变量就行了。然而，我个人觉得当前的方法会更直观一点，不仅能够节省一些代码，而且由于不是所有光照类型都需要所有的变量，这样也能节省一些内存。</p>\n</blockquote>\n<p>点光源函数的原型如下：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vec3 <span class=\"token function\">CalcPointLight</span><span class=\"token punctuation\">(</span>PointLight light<span class=\"token punctuation\">,</span> vec3 normal<span class=\"token punctuation\">,</span> vec3 fragPos<span class=\"token punctuation\">,</span> vec3 viewDir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这个函数从参数中获取所需的所有数据，并返回一个代表该点光源对片段的颜色贡献的 vec3。我们再一次聪明地从之前的教程中复制粘贴代码，完成了下面这样的函数：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vec3 <span class=\"token function\">CalcPointLight</span><span class=\"token punctuation\">(</span>PointLight light<span class=\"token punctuation\">,</span> vec3 normal<span class=\"token punctuation\">,</span> vec3 fragPos<span class=\"token punctuation\">,</span> vec3 viewDir<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    vec3 lightDir <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>light<span class=\"token punctuation\">.</span>position <span class=\"token operator\">-</span> fragPos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token comment\">// 漫反射着色</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">float</span> diff <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token function\">dot</span><span class=\"token punctuation\">(</span>normal<span class=\"token punctuation\">,</span> lightDir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">// 镜面光着色</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    vec3 reflectDir <span class=\"token operator\">=</span> <span class=\"token function\">reflect</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>lightDir<span class=\"token punctuation\">,</span> normal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">float</span> spec <span class=\"token operator\">=</span> <span class=\"token function\">pow</span><span class=\"token punctuation\">(</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token function\">dot</span><span class=\"token punctuation\">(</span>viewDir<span class=\"token punctuation\">,</span> reflectDir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> material<span class=\"token punctuation\">.</span>shininess<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token comment\">// 衰减</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">float</span> distance    <span class=\"token operator\">=</span> <span class=\"token function\">length</span><span class=\"token punctuation\">(</span>light<span class=\"token punctuation\">.</span>position <span class=\"token operator\">-</span> fragPos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">float</span> attenuation <span class=\"token operator\">=</span> <span class=\"token number\">1.0</span> <span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span>light<span class=\"token punctuation\">.</span>constant <span class=\"token operator\">+</span> light<span class=\"token punctuation\">.</span>linear <span class=\"token operator\">*</span> distance <span class=\"token operator\">+</span> </pre></td></tr><tr><td data-num=\"12\"></td><td><pre>                 light<span class=\"token punctuation\">.</span>quadratic <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>distance <span class=\"token operator\">*</span> distance<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    </pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token comment\">// 合并结果</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    vec3 ambient  <span class=\"token operator\">=</span> light<span class=\"token punctuation\">.</span>ambient  <span class=\"token operator\">*</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>material<span class=\"token punctuation\">.</span>diffuse<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    vec3 diffuse  <span class=\"token operator\">=</span> light<span class=\"token punctuation\">.</span>diffuse  <span class=\"token operator\">*</span> diff <span class=\"token operator\">*</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>material<span class=\"token punctuation\">.</span>diffuse<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    vec3 specular <span class=\"token operator\">=</span> light<span class=\"token punctuation\">.</span>specular <span class=\"token operator\">*</span> spec <span class=\"token operator\">*</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>material<span class=\"token punctuation\">.</span>specular<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    ambient  <span class=\"token operator\">*=</span> attenuation<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    diffuse  <span class=\"token operator\">*=</span> attenuation<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    specular <span class=\"token operator\">*=</span> attenuation<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>ambient <span class=\"token operator\">+</span> diffuse <span class=\"token operator\">+</span> specular<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>将这些功能抽象到这样一个函数中的优点是，我们能够不用重复的代码而很容易地计算多个点光源的光照了。在 main 函数中，我们只需要创建一个循环，遍历整个点光源数组，对每个点光源调用<mark> CalcPointLight</mark> 就可以了。</p>\n<h3 id=\"合并结果\"><a class=\"anchor\" href=\"#合并结果\">#</a> 合并结果</h3>\n<p>现在我们已经定义了一个计算定向光的函数和一个计算点光源的函数了，我们可以将它们合并放到 main 函数中。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\">// 属性</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    vec3 norm <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>Normal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    vec3 viewDir <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>viewPos <span class=\"token operator\">-</span> FragPos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token comment\">// 第一阶段：定向光照</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    vec3 result <span class=\"token operator\">=</span> <span class=\"token function\">CalcDirLight</span><span class=\"token punctuation\">(</span>dirLight<span class=\"token punctuation\">,</span> norm<span class=\"token punctuation\">,</span> viewDir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token comment\">// 第二阶段：点光源</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> NR_POINT_LIGHTS<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        result <span class=\"token operator\">+=</span> <span class=\"token function\">CalcPointLight</span><span class=\"token punctuation\">(</span>pointLights<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> norm<span class=\"token punctuation\">,</span> FragPos<span class=\"token punctuation\">,</span> viewDir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    </pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token comment\">// 第三阶段：聚光</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token comment\">//result += CalcSpotLight(spotLight, norm, FragPos, viewDir);    </span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>每个光源类型都将它们的贡献加到了最终的输出颜色上，直到所有的光源都处理完了。最终的颜色包含了场景中所有光源的颜色影响所合并的结果。如果你想的话，你也可以实现一个聚光，并将它的效果加到输出颜色中。我们会将 CalcSpotLight 函数留给读者作为练习。</p>\n<p>设置定向光结构体的 uniform 应该非常熟悉了，但是你可能会在想我们该如何设置点光源的 uniform 值，因为点光源的 uniform 现在是一个 PointLight 的数组了。这并不是我们以前讨论过的话题。</p>\n<p>很幸运的是，这并不是很复杂，设置一个结构体数组的 uniform 和设置一个结构体的 uniform 是很相似的，但是这一次在访问 uniform 位置的时候，我们需要定义对应的数组下标值：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>lightingShader<span class=\"token punctuation\">.</span><span class=\"token function\">setFloat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"pointLights[0].constant\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在这里我们索引了 pointLights 数组中的第一个 PointLight，并获取了 constant 变量的位置。但这也意味着不幸的是我们必须对这四个点光源手动设置 uniform 值，这让点光源本身就产生了 28 个 uniform 调用，非常冗长。你也可以尝试将这些抽象出去一点，定义一个点光源类，让它来为你设置 uniform 值，但最后你仍然要用这种方式设置所有光源的 uniform 值。</p>\n<p>别忘了，我们还需要为每个点光源定义一个位置向量，所以我们让它们在场景中分散一点。我们会定义另一个 glm::vec3 数组来包含点光源的位置：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 pointLightPositions<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span> <span class=\"token number\">0.7f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.2f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">2.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span> <span class=\"token number\">2.3f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">3.3f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">4.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">4.0f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">2.0f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">12.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">3.0f</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>接下来我们从 pointLights 数组中索引对应的 PointLight，将它的 position 值设置为刚刚定义的位置值数组中的其中一个。同时我们还要保证现在绘制的是四个灯立方体而不是仅仅一个。只要对每个灯物体创建一个不同的模型矩阵就可以了，和我们之前对箱子的处理类似。</p>\n<p>如果你还使用了手电筒的话，所有光源组合的效果将看起来和下图差不多：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/02/06/multiple_lights_combined.png\" alt=\"image\" /></p>\n<p>你可以看到，很显然天空中有一个全局照明（像一个太阳），我们有四个光源分散在场景中，以及玩家视角的手电筒。看起来是不是非常不错？</p>\n<p>上面图片中的所有光源都是使用上一节中所使用的默认属性，但如果你愿意实验这些数值的话，你能够得到很多有意思的结果。艺术家和关卡设计师通常都在编辑器中不断的调整这些光照参数，保证光照与环境相匹配。在我们刚刚创建的简单光照环境中，你可以简单地调整一下光源的属性，创建很多有意思的视觉效果：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/02/06/multiple_lights_atmospheres.png\" alt=\"image\" /></p>\n<p>上图四种效果<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWFybm9wZW5nbC5jb20vY29kZV92aWV3ZXIucGhwP2NvZGU9bGlnaHRpbmcvbXVsdGlwbGVfbGlnaHRzLWV4ZXJjaXNlMg==\">参数代码</span></p>\n<p>我们也改变了清屏的颜色来更好地反应光照。你可以看到，只需要简单地调整一些光照参数，你就能创建完全不同的氛围。</p>\n<p>相信你现在已经对 OpenGL 的光照有很好的理解了。有了目前所学的这些知识，我们已经可以创建出丰富有趣的环境和氛围了。尝试实验一下不同的值，创建出你自己的氛围吧。</p>\n<h2 id=\"复习\"><a class=\"anchor\" href=\"#复习\">#</a> 复习</h2>\n<p>恭喜您已经学习到了这个地方！辛苦啦！不知道你有没有注意到，总的来说我们在学习光照教程的时候关于 OpenGL 本身并没有什么新东西，除了想访问 uniform 数组这样细枝末节的知识。目前为止的所有教程都是关于使用一些技巧或者公式来操作着色器，达到真实的光照效果。这再一次想你展示了着色器的威力。着色器是非常灵活的，你也亲眼见证了我们仅仅使用一些 3D 向量和可配置的变量就能够创造出惊人的图像这一点。</p>\n<p>在前面的几个教程中，你学习了颜色、冯氏光照模型（包括环境光照、漫反射光照和镜面光照）、物体的材质、可配置的光照属性、漫反射和镜面光贴图、不同种类的光，并且学习了怎样将所有所学知识融会贯通，合并到一个程序当中。记得去实验一下不同的光照、材质颜色、光照属性，并且试着利用你无穷的创造力创建自己的环境。</p>\n<p>在下一节当中，我们在我们的场景当中加入更高级的形状，这些形状将会在我们之前讨论过的光照模型中非常好看。</p>\n<h3 id=\"词汇表\"><a class=\"anchor\" href=\"#词汇表\">#</a> 词汇表</h3>\n<ul>\n<li><mark>颜色向量 (Color Vector)</mark>：一个通过红绿蓝 (RGB) 分量的组合描绘大部分真实颜色的向量。一个物体的颜色实际上是该物体所不能吸收的反射颜色分量。</li>\n<li><mark>冯氏光照模型 (Phong Lighting Model)</mark>：一个通过计算环境光，漫反射，和镜面光分量的值来估计真实光照的模型。</li>\n<li><mark>环境光照 (Ambient Lighting)</mark>：通过给每个没有被光照的物体很小的亮度，使其不是完全黑暗的，从而对全局光照进行估计。</li>\n<li><mark>漫反射着色 (Diffuse Shading)</mark>：一个顶点 / 片段与光线方向越接近，光照会越强。使用了法向量来计算角度。</li>\n<li><mark>法向量 (Normal Vector)</mark>：一个垂直于平面的单位向量。</li>\n<li><mark>法线矩阵 (Normal Matrix)</mark>：一个 3x3 矩阵，或者说是没有平移的模型（或者模型 - 观察）矩阵。它也被以某种方式修改（逆转置），从而在应用非统一缩放时，保持法向量朝向正确的方向。否则法向量会在使用非统一缩放时被扭曲。</li>\n<li><mark>镜面光照 (Specular Lighting)</mark>：当观察者视线靠近光源在表面的反射线时会显示的镜面高光。镜面光照是由观察者的方向，光源的方向和设定高光分散量的反光度值三个量共同决定的。</li>\n<li><mark>冯氏着色 (Phong Shading)</mark>：冯氏光照模型应用在片段着色器。</li>\n<li><mark>Gouraud 着色 (Gouraud shading)</mark>：冯氏光照模型应用在顶点着色器上。在使用很少数量的顶点时会产生明显的瑕疵。会得到效率提升但是损失了视觉质量。</li>\n<li><mark>GLSL 结构体 (GLSL struct)</mark>：一个类似于 C 的结构体，用作着色器变量的容器。大部分时间用来管理输入 / 输出 /uniform。</li>\n<li><mark>材质 (Material)</mark>：一个物体反射的环境光，漫反射，镜面光颜色。这些东西设定了物体所拥有的颜色。</li>\n<li><mark>光照属性 (Light (properties))</mark>：一个光的环境光，漫反射，镜面光的强度。可以使用任何颜色值，对每一个冯氏分量 (Phong Component) 定义光源发出的颜色 / 强度。</li>\n<li><mark>漫反射贴图 (Diffuse Map)</mark>：一个设定了每个片段中漫反射颜色的纹理图片。</li>\n<li><mark>镜面光贴图 (Specular Map)</mark>：一个设定了每一个片段的镜面光强度 / 颜色的纹理贴图。仅在物体的特定区域显示镜面高光。</li>\n<li><mark>定向光 (Directional Light)</mark>：只有一个方向的光源。它被建模为不管距离有多长所有光束都是平行而且其方向向量在整个场景中保持不变。</li>\n<li><mark>点光源 (Point Light)</mark>：一个在场景中有位置的，光线逐渐衰减的光源。</li>\n<li><mark>衰减 (Attenuation)</mark>：光随着距离减少强度的过程，通常使用在点光源和聚光下。</li>\n<li><mark>聚光 (Spotlight)</mark>：一个被定义为在某一个方向上的锥形的光源。</li>\n<li><mark>手电筒 (Flashlight)</mark>：一个摆放在观察者视角的聚光。</li>\n<li><mark>GLSL uniform 数组 (GLSL Uniform Array)</mark>：一个 uniform 值数组。它的工作原理和 C 语言数组大致一样，只是不能动态分配内存。</li>\n</ul>\n",
            "tags": [
                "计算机科学",
                "学习笔记",
                "OpenGL"
            ]
        },
        {
            "id": "https://allengx.gitee.io/computer-science/study/opengl/%E4%B8%80%E3%80%81OpenGL%E5%85%A5%E9%97%A8/",
            "url": "https://allengx.gitee.io/computer-science/study/opengl/%E4%B8%80%E3%80%81OpenGL%E5%85%A5%E9%97%A8/",
            "title": "一、OpenGL入门",
            "date_published": "2020-04-12T12:46:25.000Z",
            "content_html": "<div class=\"note info\">\n<p>以下为个人学习笔记整理</p>\n</div>\n<h1 id=\"环境搭建\"><a class=\"anchor\" href=\"#环境搭建\">#</a> 环境搭建</h1>\n<h2 id=\"状态机\"><a class=\"anchor\" href=\"#状态机\">#</a> 状态机</h2>\n<p>OpenGL 自身是一个巨大的状态机 (State Machine)：<mark>一系列的变量描述 OpenGL 此刻应当如何运行</mark>。OpenGL 的状态通常被称为 OpenGL 上下文 (Context)。我们通常使用如下途径去更改 OpenGL 状态：设置选项，操作缓冲。最后，我们使用当前 OpenGL 上下文来渲染。</p>\n<p>假设当我们想告诉 OpenGL 去画线段而不是三角形的时候，我们通过改变一些上下文变量来改变 OpenGL 状态，从而告诉 OpenGL 如何去绘图。一旦我们改变了 OpenGL 的状态为绘制线段，下一个绘制命令就会画出线段而不是三角形。</p>\n<p>当使用 OpenGL 的时候，我们会遇到一些状态设置函数 (State-changing Function)，这类函数将会改变上下文。以及状态使用函数 (State-using Function)，这类函数会根据当前 OpenGL 的状态执行一些操作。只要你记住 OpenGL 本质上是个大状态机，就能更容易理解它的大部分特性。</p>\n<h2 id=\"简要工作流程\"><a class=\"anchor\" href=\"#简要工作流程\">#</a> 简要工作流程</h2>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 创建对象</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> objectId <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glGenObject</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>objectId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// 绑定对象至上下文</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">glBindObject</span><span class=\"token punctuation\">(</span>GL_WINDOW_TARGET<span class=\"token punctuation\">,</span> objectId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">// 设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">glSetObjectOption</span><span class=\"token punctuation\">(</span>GL_WINDOW_TARGET<span class=\"token punctuation\">,</span> GL_OPTION_WINDOW_WIDTH<span class=\"token punctuation\">,</span> <span class=\"token number\">800</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">glSetObjectOption</span><span class=\"token punctuation\">(</span>GL_WINDOW_TARGET<span class=\"token punctuation\">,</span> GL_OPTION_WINDOW_HEIGHT<span class=\"token punctuation\">,</span> <span class=\"token number\">600</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">// 将上下文对象设回默认</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token function\">glBindObject</span><span class=\"token punctuation\">(</span>GL_WINDOW_TARGET<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这一小段代码展现了你以后使用 OpenGL 时常见的工作流。我们首先创建一个对象，<mark>然后用一个 id 保存它的引用</mark>（实际数据被储存在后台）。然后我们将对象绑定至上下文的目标位置（例子中窗口对象目标的位置被定义成<mark> GL_WINDOW_TARGET</mark>）。接下来我们设置窗口的选项。<mark>最后我们将目标位置的对象 id 设回 0，解绑这个对象</mark>。设置的选项将被保存在 objectId 所引用的对象中，一旦我们重新绑定这个对象到<mark> GL_WINDOW_TARGET</mark> 位置，这些选项就会重新生效。</p>\n<h2 id=\"opengl和glfw\"><a class=\"anchor\" href=\"#opengl和glfw\">#</a> OpenGL 和 GLFW</h2>\n<p>在我们画出出色的效果之前，首先要做的就是创建一个 OpenGL 上下文 (Context) 和一个用于显示的窗口。然而，<mark>这些操作在每个系统上都是不一样的，OpenGL 有目的地从这些操作抽象 (Abstract) 出去</mark>。这意味着我们不得不自己处理创建窗口，定义 OpenGL 上下文以及处理用户输入。</p>\n<p>幸运的是，有一些库已经提供了我们所需的功能，其中一部分是特别针对 OpenGL 的。这些库节省了我们书写操作系统相关代码的时间，提供给我们一个窗口和上下文用来渲染。最流行的几个库有 GLUT，SDL，SFML 和 GLFW。在教程里我们将使用 GLFW。</p>\n<p><mark>GLFW 是一个专门针对 OpenGL 的 C 语言库</mark>，它提供了一些渲染物体所需的最低限度的接口。它允许用户创建 OpenGL 上下文，定义窗口参数以及处理用户输入。</p>\n<h2 id=\"glad\"><a class=\"anchor\" href=\"#glad\">#</a> GLAD</h2>\n<p>因为 OpenGL 只是一个标准 / 规范，具体的实现是由驱动开发商针对特定显卡实现的。由于 OpenGL 驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。所以任务就落在了开发者身上，开发者需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。取得地址的方法因平台而异，在 Windows 上会是类似这样：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 定义函数原型</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>GL_GENBUFFERS<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>GLsizei<span class=\"token punctuation\">,</span> GLuint<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// 找到正确的函数并赋值给函数指针</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>GL_GENBUFFERS glGenBuffers  <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>GL_GENBUFFERS<span class=\"token punctuation\">)</span><span class=\"token function\">wglGetProcAddress</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"glGenBuffers\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// 现在函数可以被正常调用了</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>GLuint buffer<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">glGenBuffers</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>你可以看到代码非常复杂，而且很繁琐，我们需要对每个可能使用的函数都要重复这个过程。<mark>幸运的是，有些库能简化此过程，其中 GLAD 是目前最新，也是最流行的库</mark>。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">gladLoadGLLoader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>GLADloadproc<span class=\"token punctuation\">)</span>glfwGetProcAddress<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Failed to initialize GLAD\"</span> <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们给 GLAD 传入了用来加载系统相关的 OpenGL 函数指针地址的函数。<mark>GLFW 给我们的是 glfwGetProcAddress，它根据我们编译的系统定义了正确的函数。</mark></p>\n<p>上述环境配置参考：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC82NGZlNGE0YzFlZDg=\">OpenGL 学习笔记（一）使用 VS2017 和 CMake 配置 GLFW 和 GLAD</span></p>\n<hr />\n<h1 id=\"introduction\"><a class=\"anchor\" href=\"#introduction\">#</a> introduction</h1>\n<h2 id=\"hello-window\"><a class=\"anchor\" href=\"#hello-window\">#</a> Hello Window</h2>\n<p>在我们开始渲染之前还有一件重要的事情要做，我们必须告诉 OpenGL 渲染窗口的尺寸大小，即视口 (Viewport)，这样 OpenGL 才只能知道怎样根据窗口大小显示数据和坐标。我们可以通过调用 glViewport 函数来设置窗口的维度 (Dimension)：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glViewport</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">800</span><span class=\"token punctuation\">,</span> <span class=\"token number\">600</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>OpenGL 幕后使用 glViewport 中定义的位置和宽高进行 2D 坐标的转换，将 OpenGL 中的位置坐标转换为你的屏幕坐标。例如，OpenGL 中的坐标 (-0.5, 0.5) 有可能（最终）被映射为屏幕中的坐标 (200,450)。注意，处理过的 OpenGL 坐标范围只为 - 1 到 1，<mark>因此我们事实上将 (-1 到 1) 范围内的坐标映射到 (0, 800) 和 (0, 600)</mark>。</p>\n<p>我们还需要注册这个函数，告诉 GLFW 我们希望每当窗口调整大小的时候调用这个函数：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glfwSetFramebufferSizeCallback</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">,</span> framebuffer_size_callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>我们还可以将我们的函数注册到其它很多的回调函数中。比如说，我们可以创建一个回调函数来处理手柄输入变化，处理错误消息等。<mark>我们会在创建窗口之后，渲染循环初始化之前注册这些回调函数</mark>。</p>\n<h3 id=\"渲染循环\"><a class=\"anchor\" href=\"#渲染循环\">#</a> 渲染循环</h3>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">glfwWindowShouldClose</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token function\">glfwSwapBuffers</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token function\">glfwPollEvents</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    </pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><ul>\n<li>glfwWindowShouldClose 函数在我们每次循环的开始前检查一次 GLFW 是否被要求退出，<mark>如果是的话该函数返回 true 然后渲染循环便结束了</mark>，之后为我们就可以关闭应用程序了。</li>\n<li><mark>glfwPollEvents 函数检查有没有触发什么事件</mark>（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数（可以通过回调方法手动设置）。</li>\n<li>glfwSwapBuffers 函数会交换颜色缓冲（它是一个储存着 GLFW 窗口每一个像素颜色值的大缓冲），<mark>它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上</mark>。</li>\n</ul>\n<h4 id=\"双缓冲double-buffer\"><a class=\"anchor\" href=\"#双缓冲double-buffer\">#</a> 双缓冲 (Double Buffer)</h4>\n<p>应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。前缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在后缓冲上绘制。<mark>当所有的渲染指令执行完毕后，我们交换 (Swap) 前缓冲和后缓冲</mark>，这样图像就立即呈显出来，之前提到的不真实感就消除了。</p>\n<h3 id=\"释放资源\"><a class=\"anchor\" href=\"#释放资源\">#</a> 释放资源</h3>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glfwTerminate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"输入\"><a class=\"anchor\" href=\"#输入\">#</a> 输入</h3>\n<p>我们同样也希望能够在 GLFW 中实现一些输入控制，这可以通过使用 GLFW 的几个输入函数来完成。我们将会使用 GLFW 的<mark> glfwGetKey</mark> 函数，它需要一个窗口以及一个按键作为输入。这个函数将会返回这个按键是否正在被按下。我们将创建一个 processInput 函数来让所有的输入代码保持整洁。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">processInput</span><span class=\"token punctuation\">(</span>GLFWwindow <span class=\"token operator\">*</span>window<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">glfwGetKey</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">,</span> GLFW_KEY_ESCAPE<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> GLFW_PRESS<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token function\">glfwSetWindowShouldClose</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们接下来在渲染循环的每一个迭代中调用 processInput：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">glfwWindowShouldClose</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token function\">processInput</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token function\">glfwSwapBuffers</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token function\">glfwPollEvents</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"渲染\"><a class=\"anchor\" href=\"#渲染\">#</a> 渲染</h3>\n<p>我们要把所有的渲染 (Rendering) 操作放到渲染循环中，因为我们想让这些渲染指令在每次渲染循环迭代的时候都能被执行。代码将会是这样的：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 渲染循环</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">glfwWindowShouldClose</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t<span class=\"token comment\">// input</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t<span class=\"token comment\">// -----</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t<span class=\"token function\">processInput</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t<span class=\"token comment\">// render</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t<span class=\"token comment\">// ------</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t<span class=\"token function\">glClearColor</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.2f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.3f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.3f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t<span class=\"token function\">glClear</span><span class=\"token punctuation\">(</span>GL_COLOR_BUFFER_BIT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t<span class=\"token comment\">// glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t<span class=\"token comment\">// -------------------------------------------------------------------------------</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t<span class=\"token function\">glfwSwapBuffers</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t<span class=\"token function\">glfwPollEvents</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们可以通过调用 glClear 函数来清空屏幕的颜色缓冲，它接受一个缓冲位 (Buffer Bit) 来指定要清空的缓冲，可能的缓冲位有<mark> GL_COLOR_BUFFER_BIT</mark>，<mark>GL_DEPTH_BUFFER_BIT</mark> 和<mark> GL_STENCIL_BUFFER_BIT</mark>。由于现在我们只关心颜色值，所以我们只清空颜色缓冲。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glClear</span><span class=\"token punctuation\">(</span>GL_COLOR_BUFFER_BIT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>注意，除了 glClear 之外，我们还调用了 glClearColor 来设置清空屏幕所用的颜色。<mark>当调用 glClear 函数，清除颜色缓冲之后，整个颜色缓冲都会被填充为 glClearColor 里所设置的颜色</mark>。在这里，我们将屏幕设置为了类似黑板的深蓝绿色。</p>\n<hr />\n<h2 id=\"hello-triangle\"><a class=\"anchor\" href=\"#hello-triangle\">#</a> Hello Triangle</h2>\n<p>在学习此节之前，建议将这三个单词先记下来：</p>\n<ul>\n<li>顶点数组对象：Vertex Array Object，VAO</li>\n<li>顶点缓冲对象：Vertex Buffer Object，VBO</li>\n<li>索引缓冲对象：Element Buffer Object，EBO 或 Index Buffer Object，IBO</li>\n</ul>\n<p>在 OpenGL 中，任何事物都在 3D 空间中，而屏幕和窗口却是 2D 像素数组，这导致 OpenGL 的大部分工作都是关于把 3D 坐标转变为适应你屏幕的 2D 像素。<mark>3D 坐标转为 2D 坐标的处理过程是由 OpenGL 的图形渲染管线（Graphics Pipeline，大多译为管线</mark>，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：<mark>第一部分把你的 3D 坐标转换为 2D 坐标，第二部分是把 2D 坐标转变为实际的有颜色的像素</mark>。这个教程里，我们会简单地讨论一下图形渲染管线，以及如何利用它创建一些漂亮的像素。</p>\n<p>2D 坐标和像素也是不同的，2D 坐标精确表示一个点在 2D 空间中的位置，而 2D 像素是这个点的近似值，<mark>2D 像素受到你的屏幕 / 窗口分辨率的限制</mark>。</p>\n<p>下面，你会看到一个图形渲染管线的每个阶段的抽象展示。要注意蓝色部分代表的是我们可以注入自定义的着色器的部分。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/04/pipeline.png\" alt=\"image\" /></p>\n<p>第一个部分是顶点着色器 (Vertex Shader)，它把一个单独的顶点作为输入。<mark>顶点着色器主要的目的是把 3D 坐标转为另一种 3D 坐标</mark>，同时顶点着色器允许我们对顶点属性进行一些基本处理。</p>\n<p>图元装配 (Primitive Assembly) 阶段将顶点着色器输出的所有顶点作为输入（如果是 GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状；本节例子中是一个三角形。</p>\n<p>图元装配阶段的输出会传递给几何着色器 (Geometry Shader)。几何着色器把图元形式的一系列顶点的集合作为输入，<mark>它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状</mark>。例子中，它生成了另一个三角形。</p>\n<p>几何着色器的输出会被传入<mark>光栅化阶段</mark> (Rasterization Stage)，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器 (Fragment Shader) 使用的片段 (Fragment)。在片段着色器运行之前会执行裁切 (Clipping)。<mark>裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率</mark>。</p>\n<blockquote>\n<h5 id=\"注opengl中的一个片段是opengl渲染一个像素所需的所有数据\"><a class=\"anchor\" href=\"#注opengl中的一个片段是opengl渲染一个像素所需的所有数据\">#</a> 注：OpenGL 中的一个片段是 OpenGL 渲染一个像素所需的所有数据。</h5>\n</blockquote>\n<p><mark>片段着色器</mark>的主要目的是<mark>计算一个像素的最终颜色</mark>，这也是所有 OpenGL 高级效果产生的地方。通常，片段着色器包含 3D 场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。</p>\n<p>在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做<mark> Alpha 测试和混合 (Blending) 阶段</mark>。这个阶段检测片段的对应的深度（和模板 (Stencil)）值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查 alpha 值（alpha 值定义了一个物体的透明度）并对物体进行混合 (Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。</p>\n<p>可以看到，图形渲染管线非常复杂，它包含很多可配置的部分。然而，对于大多数场合，<mark>我们只需要配置顶点和片段着色器就行了</mark>。几何着色器是可选的，通常使用它默认的着色器就行了。</p>\n<p>在现代 OpenGL 中，<mark>我们必须定义至少一个顶点着色器和一个片段着色器</mark>（因为 GPU 中没有默认的顶点 / 片段着色器）。出于这个原因，刚开始学习现代 OpenGL 的时候可能会非常困难，因为在你能够渲染自己的第一个三角形之前已经需要了解一大堆知识了。在本节结束你最终渲染出你的三角形的时候，你也会了解到非常多的图形编程知识。</p>\n<h3 id=\"顶点输入\"><a class=\"anchor\" href=\"#顶点输入\">#</a> 顶点输入</h3>\n<p>开始绘制图形之前，我们必须先给 OpenGL 输入一些顶点数据。OpenGL 是一个 3D 图形库，所以我们在 OpenGL 中指定的所有坐标都是 3D 坐标（x、y 和 z）。OpenGL 不是简单地把所有的 3D 坐标变换为屏幕上的 2D 像素；<mark>OpenGL 仅当 3D 坐标在 3 个轴（x、y 和 z）上都为 - 1.0 到 1.0 的范围内时才处理它</mark>。所有在所谓的标准化设备坐标 (Normalized Device Coordinates) 范围内的坐标才会最终呈现在屏幕上（在这个范围以外的坐标都不会显示）。</p>\n<p>顶点定义（三角形为例）：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> vertices<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token operator\">-</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>     <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>     <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>标准化设备坐标 (Normalized Device Coordinates, NDC)</p>\n<p>一旦你的顶点坐标已经在顶点着色器中处理过，它们就应该是标准化设备坐标了，标准化设备坐标是一个 x、y 和 z 值在 - 1.0 到 1.0 的一小段空间。任何落在范围外的坐标都会被丢弃 / 裁剪，不会显示在你的屏幕上。下面你会看到我们定义的在标准化设备坐标中的三角形 (忽略 z 轴)：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/04/ndc.png\" alt=\"image\" /></p>\n<p>与通常的屏幕坐标不同，y 轴正方向为向上，(0, 0) 坐标是这个图像的中心，而不是左上角。最终你希望所有 (变换过的) 坐标都在这个坐标空间中，否则它们就不可见了。</p>\n<p>你的标准化设备坐标接着会变换为<mark>屏幕空间坐标</mark> (Screen-space Coordinates)，这是使用你通过 glViewport 函数提供的数据，进行<mark>视口变换</mark> (Viewport Transform) 完成的。<mark>所得的屏幕空间坐标又会被变换为片段输入到片段着色器中</mark>。</p>\n<p>我们通过<mark>顶点缓冲对象</mark> (Vertex Buffer Objects, VBO) 管理这个内存，它会在 GPU 内存（通常被称为显存）中储存大量顶点。使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。从 CPU 把数据发送到显卡相对较慢，所以只要可能我们都要尝试尽量一次性发送尽可能多的数据。当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。</p>\n<p>顶点缓冲对象是我们在 OpenGL 教程中第一个出现的 OpenGL 对象。就像 OpenGL 中的其它对象一样，这个缓冲有一个独一无二的 ID，所以我们可以使用 glGenBuffers 函数和一个缓冲 ID 生成一个 VBO 对象：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> VBO<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glGenBuffers</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>VBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>OpenGL 有很多缓冲对象类型，顶点缓冲对象的缓冲类型是<mark> GL_ARRAY_BUFFER</mark>。OpenGL 允许我们同时绑定多个缓冲，只要它们是不同的缓冲类型。我们可以使用<mark> glBindBuffer</mark> 函数把新创建的缓冲绑定<mark>到 GL_ARRAY_BUFFER</mark> 目标上：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> VBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>从这一刻起，我们使用的任何（在<mark> GL_ARRAY_BUFFER</mark> 目标上的）缓冲调用都会用来配置当前绑定的缓冲 (VBO)。然后我们可以调用<mark> glBufferData</mark> 函数，它会把之前定义的顶点数据复制到缓冲的内存中：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glBufferData</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>vertices<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> vertices<span class=\"token punctuation\">,</span> GL_STATIC_DRAW<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>glBufferData 是一个专门用来把用户定义的数据复制到当前绑定缓冲的函数。它的第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到<mark> GL_ARRAY_BUFFER</mark> 目标上。第二个参数指定传输数据的大小 (以字节为单位)；用一个简单的 sizeof 计算出顶点数据大小就行。第三个参数是我们希望发送的实际数据。</p>\n<p>第四个参数指定了我们希望显卡如何管理给定的数据。它有三种形式：</p>\n<ul>\n<li>GL_STATIC_DRAW ：数据不会或几乎不会改变。</li>\n<li>GL_DYNAMIC_DRAW：数据会被改变很多。</li>\n<li>GL_STREAM_DRAW ：数据每次绘制时都会改变。</li>\n</ul>\n<p>如果三角形的位置数据不会改变，每次渲染调用时都保持原样，则它的使用类型最好是<mark> GL_STATIC_DRAW</mark>。如果，比如说一个缓冲中的数据将频繁被改变，那么使用的类型就是<mark> GL_DYNAMIC_DRAW</mark> 或<mark> GL_STREAM_DRAW</mark>，这样就能确保显卡把数据放在能够高速写入的内存部分。</p>\n<h3 id=\"顶点着色器\"><a class=\"anchor\" href=\"#顶点着色器\">#</a> 顶点着色器</h3>\n<p>我们需要做的第一件事是用着色器语言 GLSL (OpenGL Shading Language) 编写顶点着色器，然后编译这个着色器，这样我们就可以在程序中使用它了。下面你会看到一个非常基础的 GLSL 顶点着色器的源代码：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">460</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> in vec3 aPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>aPos<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">,</span> aPos<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">,</span> aPos<span class=\"token punctuation\">.</span>z<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>可以看到，GLSL 看起来很像 C 语言。每个着色器都起始于一个版本声明。OpenGL 3.3 以及和更高版本中，GLSL 版本号和 OpenGL 的版本是匹配的（<mark>比如说 GLSL 420 版本对应于 OpenGL 4.2</mark>）。我们同样明确表示我们会使用核心模式。</p>\n<p>下一步，<mark>使用 in 关键字，在顶点着色器中声明所有的输入顶点属性</mark> (Input Vertex Attribute)。现在我们只关心位置 (Position) 数据，所以我们只需要一个顶点属性。GLSL 有一个向量数据类型，它包含 1 到 4 个 float 分量，包含的数量可以从它的后缀数字看出来。由于每个顶点都有一个 3D 坐标，我们就创建一个 vec3 输入变量 aPos。我们同样也通过 layout (location = 0) 设定了输入变量的位置值 (Location) 你后面会看到为什么我们会需要这个位置值。</p>\n<h4 id=\"向量vector\"><a class=\"anchor\" href=\"#向量vector\">#</a> 向量 (Vector)</h4>\n<p>在图形编程中我们经常会使用向量这个数学概念，因为它简明地表达了任意空间中的位置和方向，并且它有非常有用的数学属性。在 GLSL 中一个向量有最多 4 个分量，每个分量值都代表空间中的一个坐标，它们可以通过 vec.x、vec.y、vec.z 和 vec.w 来获取。注意 vec.w 分量不是用作表达空间中的位置的（我们处理的是 3D 不是 4D），而是用在所谓<mark>透视除法</mark> (Perspective Division) 上。我们会在后面的教程中更详细地讨论向量。</p>\n<p>为了设置顶点着色器的输出，我们必须把位置数据赋值给预定义的 gl_Position 变量，它在幕后是 vec4 类型的。在 main 函数的最后，我们将 gl_Position 设置的值会成为该顶点着色器的输出。由于我们的输入是一个 3 分量的向量，我们必须把它转换为 4 分量的。我们可以把 vec3 的数据作为 vec4 构造器的参数，同时把 w 分量设置为 1.0f（我们会在后面解释为什么）来完成这一任务。</p>\n<p>当前这个顶点着色器可能是我们能想到的最简单的顶点着色器了，因为我们对输入数据什么都没有处理就把它传到着色器的输出了。在真实的程序里输入数据通常都不是标准化设备坐标，所以我们首先必须先把它们转换至 OpenGL 的可视区域内。</p>\n<h3 id=\"编译着色器\"><a class=\"anchor\" href=\"#编译着色器\">#</a> 编译着色器</h3>\n<p>我们已经写了一个顶点着色器源码（储存在一个 C 的字符串中），但是为了能够让 OpenGL 使用它，我们必须在运行时动态编译它的源码。</p>\n<p>我们首先要做的是创建一个着色器对象，注意还是用 ID 来引用的。所以我们储存这个顶点着色器为 unsigned int，然后用 glCreateShader 创建这个着色器：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> vertexShader<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>vertexShader <span class=\"token operator\">=</span> <span class=\"token function\">glCreateShader</span><span class=\"token punctuation\">(</span>GL_VERTEX_SHADER<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>我们把需要创建的着色器类型以参数形式提供给 glCreateShader。由于我们正在创建一个顶点着色器，传递的参数是<mark> GL_VERTEX_SHADER</mark>。</p>\n<p>下一步我们把这个着色器源码附加到着色器对象上，然后编译它：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glShaderSource</span><span class=\"token punctuation\">(</span>vertexShader<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>vertexShaderSource<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glCompileShader</span><span class=\"token punctuation\">(</span>vertexShader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>你可能会希望检测在调用 glCompileShader 后编译是否成功了，如果没成功的话，你还会希望知道错误是什么，这样你才能修复它们。检测编译时错误可以通过以下代码来实现：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span>  success<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">char</span> infoLog<span class=\"token punctuation\">[</span><span class=\"token number\">512</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glGetShaderiv</span><span class=\"token punctuation\">(</span>vertexShader<span class=\"token punctuation\">,</span> GL_COMPILE_STATUS<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>success<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>首先我们定义一个整型变量来表示是否成功编译，还定义了一个储存错误消息（如果有的话）的容器。然后我们用 glGetShaderiv 检查是否编译成功。如果编译失败，我们会用 glGetShaderInfoLog 获取错误消息，然后打印它。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>success<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token function\">glGetShaderInfoLog</span><span class=\"token punctuation\">(</span>vertexShader<span class=\"token punctuation\">,</span> <span class=\"token number\">512</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> infoLog<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n\"</span> <span class=\"token operator\">&lt;&lt;</span> infoLog <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"片段着色器\"><a class=\"anchor\" href=\"#片段着色器\">#</a> 片段着色器</h3>\n<p>片段着色器 (Fragment Shader) 是第二个也是最后一个我们打算创建的用于渲染三角形的着色器。片段着色器所做的是计算像素最后的颜色输出。为了让事情更简单，我们的片段着色器将会一直输出橘黄色。</p>\n<p>在计算机图形中颜色被表示为有 4 个元素的数组：红色、绿色、蓝色和 alpha (透明度) 分量，通常缩写为 RGBA。当在 OpenGL 或 GLSL 中定义一个颜色的时候，我们把颜色每个分量的强度设置在 0.0 到 1.0 之间。比如说我们设置红为 1.0f，绿为 1.0f，我们会得到两个颜色的混合色，即黄色。这三种颜色分量的不同调配可以生成超过 1600 万种不同的颜色！</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>out vec4 FragColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.2f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>片段着色器只需要一个输出变量，这个变量是一个 4 分量向量，它表示的是最终的输出颜色，我们应该自己将其计算出来。我们可以用 out 关键字声明输出变量，这里我们命名为 FragColor。下面，我们将一个 alpha 值为 1.0 (1.0 代表完全不透明) 的橘黄色的 vec4 赋值给颜色输出。</p>\n<p>编译片段着色器的过程与顶点着色器类似，只不过我们使用<mark> GL_FRAGMENT_SHADER</mark> 常量作为着色器类型：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> fragmentShader<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>fragmentShader <span class=\"token operator\">=</span> <span class=\"token function\">glCreateShader</span><span class=\"token punctuation\">(</span>GL_FRAGMENT_SHADER<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glShaderSource</span><span class=\"token punctuation\">(</span>fragmentShader<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>fragmentShaderSource<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glCompileShader</span><span class=\"token punctuation\">(</span>fragmentShader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"着色器程序\"><a class=\"anchor\" href=\"#着色器程序\">#</a> 着色器程序</h4>\n<p>着色器程序对象 (Shader Program Object) 是多个着色器合并之后并最终链接完成的版本。如果要使用刚才编译的着色器我们必须把它们链接 (Link) 为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。已激活着色器程序的着色器将在我们发送渲染调用的时候被使用。</p>\n<p>当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当输出和输入不匹配的时候，你会得到一个连接错误。</p>\n<p>创建一个程序对象很简单：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> shaderProgram<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>shaderProgram <span class=\"token operator\">=</span> <span class=\"token function\">glCreateProgram</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>glCreateProgram 函数创建一个程序，并返回新创建程序对象的 ID 引用。现在我们需要把之前编译的着色器附加到程序对象上，然后用 glLinkProgram 链接它们：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glAttachShader</span><span class=\"token punctuation\">(</span>shaderProgram<span class=\"token punctuation\">,</span> vertexShader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glAttachShader</span><span class=\"token punctuation\">(</span>shaderProgram<span class=\"token punctuation\">,</span> fragmentShader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glLinkProgram</span><span class=\"token punctuation\">(</span>shaderProgram<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>代码应该很清楚，我们把着色器附加到了程序上，然后用 glLinkProgram 链接。</p>\n<p>就像着色器的编译一样，我们也可以检测链接着色器程序是否失败，并获取相应的日志。与上面不同，我们不会调用 glGetShaderiv 和 glGetShaderInfoLog，现在我们使用：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glGetProgramiv</span><span class=\"token punctuation\">(</span>shaderProgram<span class=\"token punctuation\">,</span> GL_LINK_STATUS<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>success<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>success<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token function\">glGetProgramInfoLog</span><span class=\"token punctuation\">(</span>shaderProgram<span class=\"token punctuation\">,</span> <span class=\"token number\">512</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> infoLog<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>得到的结果就是一个程序对象，我们可以调用 glUseProgram 函数，用刚创建的程序对象作为它的参数，以激活这个程序对象：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glUseProgram</span><span class=\"token punctuation\">(</span>shaderProgram<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在 glUseProgram 函数调用之后，每个着色器调用和渲染调用都会使用这个程序对象（也就是之前写的着色器) 了。</p>\n<p>对了，在把着色器对象链接到程序对象以后，记得删除着色器对象，我们不再需要它们了：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glDeleteShader</span><span class=\"token punctuation\">(</span>vertexShader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glDeleteShader</span><span class=\"token punctuation\">(</span>fragmentShader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>现在，我们已经把输入顶点数据发送给了 GPU，并指示了 GPU 如何在顶点和片段着色器中处理它。就快要完成了，但还没结束，OpenGL 还不知道它该如何解释内存中的顶点数据，以及它该如何将顶点数据链接到顶点着色器的属性上。我们需要告诉 OpenGL 怎么做。</p>\n<h4 id=\"链接顶点属性\"><a class=\"anchor\" href=\"#链接顶点属性\">#</a> 链接顶点属性</h4>\n<p>顶点着色器允许我们指定任何以顶点属性为形式的输入。这使其具有很强的灵活性的同时，它还的确意味着我们必须<mark>手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性</mark>。所以，我们必须在渲染前指定 OpenGL 该如何解释顶点数据。</p>\n<p>我们的顶点缓冲数据会被解析为下面这样子 (三角形三个顶点)：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/04/vertex_attribute_pointer.png\" alt=\"image\" /></p>\n<ul>\n<li>位置数据被储存为 32 位（4 字节）浮点值。</li>\n<li>每个位置包含 3 个这样的值。</li>\n<li>在这 3 个值之间没有空隙（或其他值）。这几个值在数组中紧密排列 (Tightly Packed)。</li>\n<li>数据中第一个值在缓冲开始的位置。</li>\n</ul>\n<p>有了这些信息我们就可以使用<mark> glVertexAttribPointer</mark> 函数告诉 OpenGL 该如何解析顶点数据（应用到逐个顶点属性上）了：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glVertexAttribPointer</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span> <span class=\"token number\">3</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glEnableVertexAttribArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>glVertexAttribPointer 函数的参数非常多，所以我会逐一介绍它们：</p>\n<ul>\n<li>第一个参数指定我们要配置的顶点属性。还记得我们在顶点着色器中使用 layout (location = 0) 定义了 position 顶点属性的位置值 (Location) 吗？它可以把顶点属性的位置值设置为 0。因为我们希望把数据传递到这一个顶点属性中，所以这里我们传入 0。</li>\n<li>第二个参数指定顶点属性的大小。顶点属性是一个 vec3，它由 3 个值组成，所以大小是 3。</li>\n<li>第三个参数指定数据的类型，这里是 GL_FLOAT (GLSL 中 vec * 都是由浮点数值组成的)。</li>\n<li>下个参数定义我们是否希望数据被标准化 (Normalize)。如果我们设置为 GL_TRUE，所有数据都会被映射到 0（对于有符号型 signed 数据是 - 1）到 1 之间。我们把它设置为 GL_FALSE。</li>\n<li>第五个参数叫做步长 (Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在 3 个 float 之后，我们把步长设置为 3 * sizeof (float)。要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以设置为 0 来让 OpenGL 决定具体步长是多少（只有当数值是紧密排列时才可用）。一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔，我们在后面会看到更多的例子（译注：这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组 0 位置之间有多少字节）。</li>\n<li>最后一个参数的类型是 void*，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量 (Offset)。由于位置数据在数组的开头，所以这里是 0。我们会在后面详细解释这个参数。</li>\n</ul>\n<p>每个顶点属性从一个 VBO 管理的内存中获得它的数据，而具体是从哪个 VBO（程序中可以有多个 VBO）获取则是通过在调用 glVetexAttribPointer 时绑定到<mark> GL_ARRAY_BUFFER</mark> 的 VBO 决定的。由于在调用 glVetexAttribPointer 之前绑定的是先前定义的 VBO 对象，顶点属性 0 表示现在会链接到它的顶点数据。</p>\n<p>现在我们已经定义了 OpenGL 该如何解释顶点数据，我们现在应该使用 glEnableVertexAttribArray，以顶点属性位置值作为参数，启用顶点属性；顶点属性默认是禁用的。自此，所有东西都已经设置好了：我们使用一个顶点缓冲对象将顶点数据初始化至缓冲中，建立了一个顶点和一个片段着色器，并告诉了 OpenGL 如何把顶点数据链接到顶点着色器的顶点属性上。在 OpenGL 中绘制一个物体，代码会像是这样：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 0. 复制顶点数组到缓冲中供 OpenGL 使用</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> VBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glBufferData</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>vertices<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> vertices<span class=\"token punctuation\">,</span> GL_STATIC_DRAW<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// 1. 设置顶点属性指针</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">glVertexAttribPointer</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span> <span class=\"token number\">3</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">glEnableVertexAttribArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">// 2. 当我们渲染一个物体时要使用着色器程序</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">glUseProgram</span><span class=\"token punctuation\">(</span>shaderProgram<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">// 3. 绘制物体</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token function\">someOpenGLFunctionThatDrawsOurTriangle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>每当我们绘制一个物体的时候都必须重复这一过程。这看起来可能不多，但是如果有超过 5 个顶点属性，上百个不同物体呢（这其实并不罕见）。绑定正确的缓冲对象，为每个物体配置所有顶点属性很快就变成一件麻烦事。有没有一些方法可以使我们把所有这些状态配置储存在一个对象中，并且可以通过绑定这个对象来恢复状态呢？</p>\n<h4 id=\"顶点数组对象\"><a class=\"anchor\" href=\"#顶点数组对象\">#</a> 顶点数组对象</h4>\n<p>顶点数组对象 (Vertex Array Object, VAO) 可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个 VAO 中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的 VAO 就行了。这使在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的 VAO 就行了。刚刚设置的所有状态都将存储在 VAO 中</p>\n<p>一个顶点数组对象会储存以下这些内容：</p>\n<ul>\n<li>glEnableVertexAttribArray 和 glDisableVertexAttribArray 的调用。</li>\n<li>通过 glVertexAttribPointer 设置的顶点属性配置。</li>\n<li>通过 glVertexAttribPointer 调用与顶点属性关联的顶点缓冲对象。</li>\n</ul>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/04/vertex_array_objects.png\" alt=\"image\" /></p>\n<p>创建一个 VAO 和创建一个 VBO 很类似：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> VAO<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glGenVertexArrays</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>VAO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>要想使用 VAO，要做的只是使用 glBindVertexArray 绑定 VAO。从绑定之后起，我们应该绑定和配置对应的 VBO 和属性指针，之后解绑 VAO 供之后使用。当我们打算绘制一个物体的时候，我们只要在绘制物体前简单地把 VAO 绑定到希望使用的设定上就行了。这段代码应该看起来像这样：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">//..:: 初始化代码（只运行一次 (除非你的物体频繁改变)） :: ..</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// 1. 绑定 VAO</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glBindVertexArray</span><span class=\"token punctuation\">(</span>VAO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// 2. 把顶点数组复制到缓冲中供 OpenGL 使用</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> VBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">glBufferData</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>vertices<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> vertices<span class=\"token punctuation\">,</span> GL_STATIC_DRAW<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">// 3. 设置顶点属性指针</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">glVertexAttribPointer</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span> <span class=\"token number\">3</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token function\">glEnableVertexAttribArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token comment\">//..:: 绘制代码（渲染循环中） :: ..</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token comment\">// 4. 绘制物体</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token function\">glUseProgram</span><span class=\"token punctuation\">(</span>shaderProgram<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token function\">glBindVertexArray</span><span class=\"token punctuation\">(</span>VAO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token function\">someOpenGLFunctionThatDrawsOurTriangle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>就这么多了！前面做的一切都是等待这一刻，一个储存了我们顶点属性配置和应使用的 VBO 的顶点数组对象。一般当你打算绘制多个物体时，你首先要生成 / 配置所有的 VAO（和必须的 VBO 及属性指针)，然后储存它们供后面使用。<mark>当我们打算绘制物体的时候就拿出相应的 VAO，绑定它，绘制完物体后，再解绑 VAO</mark>。</p>\n<h3 id=\"我们一直期待的三角形\"><a class=\"anchor\" href=\"#我们一直期待的三角形\">#</a> 我们一直期待的三角形</h3>\n<p>要想绘制我们想要的物体，OpenGL 给我们提供了 glDrawArrays 函数，它使用当前激活的着色器，之前定义的顶点属性配置，和 VBO 的顶点数据（通过 VAO 间接绑定）来绘制图元。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glUseProgram</span><span class=\"token punctuation\">(</span>shaderProgram<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glBindVertexArray</span><span class=\"token punctuation\">(</span>VAO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glDrawArrays</span><span class=\"token punctuation\">(</span>GL_TRIANGLES<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>glDrawArrays 函数第一个参数是我们打算绘制的 OpenGL 图元的类型。由于我们在一开始时说过，我们希望绘制的是一个三角形，这里传递 GL_TRIANGLES 给它。第二个参数指定了顶点数组的起始索引，我们这里填 0。最后一个参数指定我们打算绘制多少个顶点，这里是 3（我们只从我们的数据中渲染一个三角形，它只有 3 个顶点长）。</p>\n<p>现在尝试编译代码，如果弹出了任何错误，回头检查你的代码。如果你编译通过了，你应该看到下面的结果：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/04/hellotriangle.png\" alt=\"image\" /></p>\n<h4 id=\"索引缓冲对象\"><a class=\"anchor\" href=\"#索引缓冲对象\">#</a> 索引缓冲对象</h4>\n<p>在渲染顶点这一话题上我们还有最后一个需要讨论的东西 —— 索引缓冲对象 (Element Buffer Object，EBO，也叫 Index Buffer Object，IBO)。要解释索引缓冲对象的工作方式最好还是举个例子：假设我们不再绘制一个三角形而是绘制一个矩形。我们可以绘制两个三角形来组成一个矩形（OpenGL 主要处理三角形）。这会生成下面的顶点的集合：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> vertices<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">// 第一个三角形</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>   <span class=\"token comment\">// 右上角</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>  <span class=\"token comment\">// 右下角</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token operator\">-</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>  <span class=\"token comment\">// 左上角</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">// 第二个三角形</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>  <span class=\"token comment\">// 右下角</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token operator\">-</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 左下角</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token operator\">-</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span>   <span class=\"token comment\">// 左上角</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>可以看到，有几个顶点叠加了。我们指定了右下角和左上角两次！一个矩形只有 4 个而不是 6 个顶点，这样就产生 50% 的额外开销。当我们有包括上千个三角形的模型之后这个问题会更糟糕，这会产生一大堆浪费。更好的解决方案是只储存不同的顶点，并设定绘制这些顶点的顺序。这样子我们只要储存 4 个顶点就能绘制矩形了，之后只要指定绘制的顺序就行了。如果 OpenGL 提供这个功能就好了，对吧？</p>\n<p>很幸运，索引缓冲对象的工作方式正是这样的。和顶点缓冲对象一样，EBO 也是一个缓冲，它专门储存索引，OpenGL 调用这些顶点的索引来决定该绘制哪个顶点。所谓的<mark>索引绘制</mark> (Indexed Drawing) 正是我们问题的解决方案。首先，我们先要定义（不重复的）顶点，和绘制出矩形所需的索引：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> vertices<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>   <span class=\"token comment\">// 右上角</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>  <span class=\"token comment\">// 右下角</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token operator\">-</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 左下角</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token operator\">-</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span>   <span class=\"token comment\">// 左上角</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> indices<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// 注意索引从 0 开始！</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 第一个三角形</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span>  <span class=\"token comment\">// 第二个三角形</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>你可以看到，当时用索引的时候，我们只定义了 4 个顶点，而不是 6 个。下一步我们需要创建索引缓冲对象：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> EBO<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glGenBuffers</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>EBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>与 VBO 类似，我们先绑定 EBO 然后用 glBufferData 把索引复制到缓冲里。同样，和 VBO 类似，我们会把这些函数调用放在绑定和解绑函数调用之间，只不过这次我们把缓冲的类型定义为<mark> GL_ELEMENT_ARRAY_BUFFER</mark>。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_ELEMENT_ARRAY_BUFFER<span class=\"token punctuation\">,</span> EBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glBufferData</span><span class=\"token punctuation\">(</span>GL_ELEMENT_ARRAY_BUFFER<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>indices<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> indices<span class=\"token punctuation\">,</span> GL_STATIC_DRAW<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>要注意的是，我们传递了 GL_ELEMENT_ARRAY_BUFFER 当作缓冲目标。最后一件要做的事是<mark>用 glDrawElements 来替换 glDrawArrays 函数</mark>，来指明我们从索引缓冲渲染。使用<strong> glDrawElements</strong> 时，我们会使用当前绑定的索引缓冲对象中的索引进行绘制：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_ELEMENT_ARRAY_BUFFER<span class=\"token punctuation\">,</span> EBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glDrawElements</span><span class=\"token punctuation\">(</span>GL_TRIANGLES<span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> GL_UNSIGNED_INT<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>第一个参数指定了我们绘制的模式，这个和 glDrawArrays 的一样。第二个参数是我们打算绘制顶点的个数，这里填 6，也就是说我们一共需要绘制 6 个顶点。第三个参数是索引的类型，这里是 GL_UNSIGNED_INT。最后一个参数里我们可以指定 EBO 中的偏移量（或者传递一个索引数组，但是这是当你不在使用索引缓冲对象的时候），但是我们会在这里填写 0。</p>\n<p>glDrawElements 函数从当前绑定到 GL_ELEMENT_ARRAY_BUFFER 目标的 EBO 中获取索引。这意味着我们必须在每次要用索引渲染一个物体时绑定相应的 EBO，这还是有点麻烦。不过顶点数组对象同样可以保存索引缓冲对象的绑定状态。VAO 绑定时正在绑定的索引缓冲对象会被保存为 VAO 的元素缓冲对象。绑定 VAO 的同时也会自动绑定 EBO。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/04/vertex_array_objects_ebo.png\" alt=\"image\" /></p>\n<p>最后的初始化和绘制代码现在看起来像这样：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">//..:: 初始化代码 :: ..</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// 1. 绑定顶点数组对象</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glBindVertexArray</span><span class=\"token punctuation\">(</span>VAO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// 2. 把我们的顶点数组复制到一个顶点缓冲中，供 OpenGL 使用</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> VBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">glBufferData</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>vertices<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> vertices<span class=\"token punctuation\">,</span> GL_STATIC_DRAW<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">// 3. 复制我们的索引数组到一个索引缓冲中，供 OpenGL 使用</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_ELEMENT_ARRAY_BUFFER<span class=\"token punctuation\">,</span> EBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token function\">glBufferData</span><span class=\"token punctuation\">(</span>GL_ELEMENT_ARRAY_BUFFER<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>indices<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> indices<span class=\"token punctuation\">,</span> GL_STATIC_DRAW<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">// 4. 设定顶点属性指针</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token function\">glVertexAttribPointer</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span> <span class=\"token number\">3</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token function\">glEnableVertexAttribArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token comment\">//..:: 绘制代码（渲染循环中） :: ..</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token function\">glUseProgram</span><span class=\"token punctuation\">(</span>shaderProgram<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token function\">glBindVertexArray</span><span class=\"token punctuation\">(</span>VAO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token function\">glDrawElements</span><span class=\"token punctuation\">(</span>GL_TRIANGLES<span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> GL_UNSIGNED_INT<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token function\">glBindVertexArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>运行程序会获得下面这样的图片的结果。左侧图片看应该起来很熟悉，而右侧的则是使用线框模式 (Wireframe Mode) 绘制的。线框矩形可以显示出矩形的确是由两个三角形组成的。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/04/hellotriangle2.png\" alt=\"image\" /></p>\n<p>线框模式 (Wireframe Mode)</p>\n<p>要想用线框模式绘制你的三角形，你可以通过 glPolygonMode (GL_FRONT_AND_BACK, GL_LINE) 函数配置 OpenGL 如何绘制图元。第一个参数表示我们打算将其应用到所有的三角形的正面和背面，第二个参数告诉我们用线来绘制。之后的绘制调用会一直以线框模式绘制三角形，直到我们用 glPolygonMode (GL_FRONT_AND_BACK, GL_FILL) 将其设置回默认模式。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glPolygonMode</span><span class=\"token punctuation\">(</span>GL_FRONT_AND_BACK<span class=\"token punctuation\">,</span> GL_LINE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 线框模式</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glPolygonMode</span><span class=\"token punctuation\">(</span>GL_FRONT_AND_BACK<span class=\"token punctuation\">,</span> GL_FILL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 默认模式</span></pre></td></tr></table></figure><hr />\n<h2 id=\"着色器\"><a class=\"anchor\" href=\"#着色器\">#</a> 着色器</h2>\n<p>着色器 (Shader) 是运行在<mark> GPU</mark> 上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。从基本意义上来说，着色器只是一种把输入转化为输出的程序。<mark>着色器也是一种非常独立的程序，因为它们之间不能相互通信</mark>；它们之间唯一的沟通只有通过输入和输出。</p>\n<h3 id=\"着色器语言glsl\"><a class=\"anchor\" href=\"#着色器语言glsl\">#</a> 着色器语言 GLSL</h3>\n<p>着色器是使用一种叫 GLSL 的类 C 语言写成的。GLSL 是为图形计算量身定制的，它包含一些针对向量和矩阵操作的有用特性。</p>\n<p>着色器的开头总是要声明版本，接着是输入和输出变量、uniform 和 main 函数。每个着色器的入口点都是 main 函数，在这个函数中我们处理所有的输入变量，并将结果输出到输出变量中。如果你不知道什么是 uniform 也不用担心，我们后面会进行讲解。</p>\n<p>一个典型的着色器有下面的结构：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\">version_number</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>in type in_variable_name<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>in type in_variable_name<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>out type out_variable_name<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>uniform type uniform_name<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>  <span class=\"token comment\">// 处理输入并进行一些图形操作</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  <span class=\"token comment\">// 输出处理过的结果到输出变量</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>  out_variable_name <span class=\"token operator\">=</span> weird_stuff_we_processed<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>当我们特别谈论到顶点着色器的时候，每个输入变量也叫<mark>顶点属性</mark> (Vertex Attribute)。我们能声明的顶点属性是有上限的，它一般由硬件来决定。OpenGL 确保至少有<mark> 16</mark> 个包含 4 分量的顶点属性可用，但是有些硬件或许允许更多的顶点属性，你可以查询 GL_MAX_VERTEX_ATTRIBS 来获取具体的上限：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> nrAttributes<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glGetIntegerv</span><span class=\"token punctuation\">(</span>GL_MAX_VERTEX_ATTRIBS<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>nrAttributes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Maximum nr of vertex attributes supported: \"</span> <span class=\"token operator\">&lt;&lt;</span> nrAttributes <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"数据类型\"><a class=\"anchor\" href=\"#数据类型\">#</a> 数据类型</h3>\n<p>和其他编程语言一样，GLSL 有数据类型可以来指定变量的种类。GLSL 中包含 C 等其它语言大部分的默认基础数据类型：<mark>int、float、double、uint 和 bool</mark>。GLSL 也有两种容器类型，它们会在这个教程中使用很多，分别是<mark>向量</mark> (Vector) 和<mark>矩阵</mark> (Matrix)，其中矩阵我们会在之后的教程里再讨论。</p>\n<h4 id=\"向量\"><a class=\"anchor\" href=\"#向量\">#</a> 向量</h4>\n<p>GLSL 中的向量是一个可以包含有<mark> 1、2、3 或者 4</mark> 个分量的容器，分量的类型可以是前面默认基础类型的任意一个。它们可以是下面的形式（n 代表分量的数量）：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>vecn</td>\n<td>包含 n 个 float 分量的默认向量</td>\n</tr>\n<tr>\n<td>bvecn</td>\n<td>包含 n 个 bool 分量的向量</td>\n</tr>\n<tr>\n<td>ivecn</td>\n<td>包含 n 个 int 分量的向量</td>\n</tr>\n<tr>\n<td>uvecn</td>\n<td>包含 n 个 unsigned int 分量的向量</td>\n</tr>\n<tr>\n<td>dvecn</td>\n<td>包含 n 个 double 分量的向量</td>\n</tr>\n</tbody>\n</table>\n<p>一个向量的分量可以通过 vec.x 这种方式获取，这里 x 是指这个向量的第一个分量。你可以分别使用.x、.y、.z 和.w 来获取它们的第 1、2、3、4 个分量。GLSL 也允许你对颜色使用<mark> rgba</mark>，或是对纹理坐标使用<mark> stpq</mark> 访问相同的分量。</p>\n<p>向量这一数据类型也允许一些有趣而灵活的分量选择方式，叫做<mark>重组</mark> (Swizzling)。重组允许这样的语法：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vec2 someVec<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>vec4 differentVec <span class=\"token operator\">=</span> someVec<span class=\"token punctuation\">.</span>xyxx<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>vec3 anotherVec <span class=\"token operator\">=</span> differentVec<span class=\"token punctuation\">.</span>zyw<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>vec4 otherVec <span class=\"token operator\">=</span> someVec<span class=\"token punctuation\">.</span>xxxx <span class=\"token operator\">+</span> anotherVec<span class=\"token punctuation\">.</span>yxzy<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>你可以使用上面<mark> 4 个字母任意组合</mark>来创建一个和原来向量一样长的（同类型）新向量，只要原来向量有那些分量即可；然而，你<mark>不允许在一个 vec2 向量中去获取.z 元素</mark>。我们也可以把一个向量作为一个参数传给不同的向量构造函数，以减少需求参数的数量。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vec2 vect <span class=\"token operator\">=</span> <span class=\"token function\">vec2</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>vec4 result <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>vect<span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>vec4 otherResult <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">.</span>xyz<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h4 id=\"输入与输出\"><a class=\"anchor\" href=\"#输入与输出\">#</a> 输入与输出</h4>\n<p>GLSL 定义了<mark> in</mark> 和<mark> out</mark> 关键字专门来实现数据交流与传递。每个着色器使用这两个关键字设定输入和输出，只要一个输出变量与下一个着色器阶段的输入匹配，它就会传递下去。但在顶点和片段着色器中会有点不同。</p>\n<p><mark>顶点着色器</mark>需要为它的输入提供一个额外的 layout 标识，这样我们才能把它链接到顶点数据。</p>\n<blockquote>\n<p>你也可以忽略 layout (location = 0) 标识符，通过在 OpenGL 代码中使用 glGetAttribLocation 查询属性位置值 (Location)，但是我更喜欢在着色器中设置它们，这样会更容易理解而且节省你（和 OpenGL）的工作量。</p>\n</blockquote>\n<p>另一个例外是<mark>片段着色器</mark>，它需要一个 vec4 颜色输出变量，因为片段着色器需要生成一个最终输出的颜色。如果你在片段着色器没有定义输出颜色，OpenGL 会把你的物体渲染为<mark>黑色（或白色</mark>）。</p>\n<p>所以，如果我们打算从一个着色器向另一个着色器发送数据，我们必须在发送方着色器中声明一个输出，在接收方着色器中声明一个类似的输入。<mark>当类型和名字都一样</mark>的时候，OpenGL 就会把两个变量链接到一起，它们之间就能发送数据了（这是在链接程序对象时完成的）。为了展示这是如何工作的，我们会稍微改动一下之前教程里的那个着色器，让顶点着色器为片段着色器决定颜色。</p>\n<h5 id=\"顶点着色器-2\"><a class=\"anchor\" href=\"#顶点着色器-2\">#</a> 顶点着色器</h5>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> in vec3 aPos<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 位置变量的属性位置值为 0</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>out vec4 vertexColor<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 为片段着色器指定一个颜色输出</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>aPos<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 注意我们如何把一个 vec3 作为 vec4 的构造器的参数</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    vertexColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 把输出变量设置为暗红色</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h5 id=\"片段着色器-2\"><a class=\"anchor\" href=\"#片段着色器-2\">#</a> 片段着色器</h5>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>out vec4 FragColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>in vec4 vertexColor<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 从顶点着色器传来的输入变量（名称相同、类型相同）</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> vertexColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>你可以看到我们在顶点着色器中声明了一个 vertexColor 变量作为 vec4 输出，并在片段着色器中声明了一个类似的 vertexColor。<mark>由于它们名字相同且类型相同，片段着色器中的 vertexColor 就和顶点着色器中的 vertexColor 链接了</mark>。由于我们在顶点着色器中将颜色设置为深红色，最终的片段也是深红色的。下面的图片展示了输出结果：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/05/shaders.png\" alt=\"image\" /></p>\n<h4 id=\"uniform\"><a class=\"anchor\" href=\"#uniform\">#</a> Uniform</h4>\n<p><mark>Uniform 是一种从 CPU 中的应用向 GPU 中的着色器发送数据的方式</mark>，但 uniform 和顶点属性有些不同。首先，<mark>uniform 是全局的 (Global)</mark>。全局意味着 uniform 变量必须在每个着色器程序对象都是<mark>独一无二</mark>的，而且它可以被着色器程序的<mark>任意着色器</mark>在<mark>任意阶段</mark>访问。第二，无论你把 uniform 值设置成什么，uniform 会<mark>一直保存它们的数据</mark>，直到它们被重置或更新。</p>\n<p>我们可以在一个着色器中添加 uniform 关键字至类型和变量名前来声明一个 GLSL 的 uniform。从此处开始我们就可以在着色器中使用新声明的 uniform 了。我们来看看这次是否能通过 uniform 设置三角形的颜色：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>out vec4 FragColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>uniform vec4 ourColor<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 在 OpenGL 程序代码中设定这个变量</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> ourColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们在片段着色器中声明了一个 uniform vec4 的 ourColor，并把片段着色器的输出颜色设置为 uniform 值的内容。因为 uniform 是全局变量，我们可以在任何着色器中定义它们，而无需通过顶点着色器作为中介。顶点着色器中不需要这个 uniform，所以我们不用在那里定义它。</p>\n<p><strong>如果你声明了一个 uniform 却在 GLSL 代码中没用过，编译器会<mark>静默移除这个变量</mark>，导致最后编译出的版本中并不会包含它，这可能导致几个非常麻烦的错误，记住这点！</strong></p>\n<p>这个 uniform 现在还是空的；我们还没有给它添加任何数据，所以下面我们就做这件事。我们首先需要找到着色器中 uniform 属性的索引 / 位置值。当我们得到 uniform 的索引 / 位置值后，我们就可以更新它的值了。这次我们不去给像素传递单独一个颜色，而是让它随着时间改变颜色：</p>\n<pre><code>float timeValue = glfwGetTime();\nfloat greenValue = (sin(timeValue) / 2.0f) + 0.5f;\nint vertexColorLocation = glGetUniformLocation(shaderProgram, &quot;ourColor&quot;);\nglUseProgram(shaderProgram);\nglUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);\n</code></pre>\n<p>首先我们通过 glfwGetTime () 获取运行的秒数。然后我们使用 sin 函数让颜色在 0.0 到 1.0 之间改变，最后将结果储存到 greenValue 里。</p>\n<p>接着，我们用<mark> glGetUniformLocation</mark> 查询 uniform ourColor 的位置值。我们为查询函数提供着色器程序和 uniform 的名字（这是我们希望获得的位置值的来源）。如果 glGetUniformLocation 返回 - 1 就代表没有找到这个位置值。最后，我们可以通过<mark> glUniform4f</mark> 函数设置 uniform 值。注意，<mark>查询</mark> uniform 地址不要求你之前使用过着色器程序，但是<mark>更新</mark>一个 uniform 之前你必须先使用程序（调用 glUseProgram)，因为它是在当前激活的着色器程序中设置 uniform 的。</p>\n<blockquote>\n<p>uniform 必须先激活后才能修改，查询不需要激活，但修改必须先激活。<mark>glUseProgram</mark> 方法激活</p>\n</blockquote>\n<p>因为 OpenGL 在其核心是一个 C 库，所以它不支持类型重载，在函数参数不同的时候就要为其定义新的函数；glUniform 是一个典型例子。这个函数有一个特定的后缀，标识设定的 uniform 的类型。可能的后缀有：</p>\n<table>\n<thead>\n<tr>\n<th>后缀</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>f</td>\n<td>函数需要一个 float 作为它的值</td>\n</tr>\n<tr>\n<td>i</td>\n<td>函数需要一个 int 作为它的值</td>\n</tr>\n<tr>\n<td>ui</td>\n<td>函数需要一个 unsigned int 作为它的值</td>\n</tr>\n<tr>\n<td>3f</td>\n<td>函数需要 3 个 float 作为它的值</td>\n</tr>\n<tr>\n<td>fv</td>\n<td>函数需要一个 float 向量 / 数组作为它的值</td>\n</tr>\n</tbody>\n</table>\n<p>每当你打算配置一个 OpenGL 的选项时就可以简单地根据这些规则选择适合你的数据类型的重载函数。在我们的例子里，我们希望分别设定 uniform 的 4 个 float 值，所以我们通过<mark> glUniform4f</mark> 传递我们的数据 (注意，我们也可以使用<mark> fv</mark> 版本)。</p>\n<p>现在你知道如何设置 uniform 变量的值了，我们可以使用它们来渲染了。如果我们打算让颜色慢慢变化，我们就要在游戏循环的每一次迭代中（所以他会逐帧改变）更新这个 uniform，否则三角形就不会改变颜色。下面我们就计算 greenValue 然后每个渲染迭代都更新这个 uniform：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">glfwWindowShouldClose</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\">// 输入</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token function\">processInput</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">// 渲染</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token comment\">// 清除颜色缓冲</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token function\">glClearColor</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.2f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.3f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.3f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token function\">glClear</span><span class=\"token punctuation\">(</span>GL_COLOR_BUFFER_BIT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token comment\">// 记得激活着色器</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token function\">glUseProgram</span><span class=\"token punctuation\">(</span>shaderProgram<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token comment\">// 更新 uniform 颜色</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">float</span> timeValue <span class=\"token operator\">=</span> <span class=\"token function\">glfwGetTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token keyword\">float</span> greenValue <span class=\"token operator\">=</span> <span class=\"token function\">sin</span><span class=\"token punctuation\">(</span>timeValue<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2.0f</span> <span class=\"token operator\">+</span> <span class=\"token number\">0.5f</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token keyword\">int</span> vertexColorLocation <span class=\"token operator\">=</span> <span class=\"token function\">glGetUniformLocation</span><span class=\"token punctuation\">(</span>shaderProgram<span class=\"token punctuation\">,</span> <span class=\"token string\">\"ourColor\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token function\">glUniform4f</span><span class=\"token punctuation\">(</span>vertexColorLocation<span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> greenValue<span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token comment\">// 绘制三角形</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token function\">glBindVertexArray</span><span class=\"token punctuation\">(</span>VAO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token function\">glDrawArrays</span><span class=\"token punctuation\">(</span>GL_TRIANGLES<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token comment\">// 交换缓冲并查询 IO 事件</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token function\">glfwSwapBuffers</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token function\">glfwPollEvents</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWFybm9wZW5nbC1jbi5naXRodWIuaW8vaW1nLzAxLzA1L3NoYWRlcnMubXA0\">效果视频</span></p>\n<h3 id=\"更多属性\"><a class=\"anchor\" href=\"#更多属性\">#</a> 更多属性</h3>\n<p>如果我们要改变每个定点属性，就需要设置多个 uniform。下面介绍一种解决办法。</p>\n<p>在前面的教程中，我们了解了如何填充 VBO、配置顶点属性指针以及如何把它们都储存到一个 VAO 里。这次，我们同样打算把颜色数据加进顶点数据中。我们将把颜色数据添加为 3 个 float 值至 vertices 数组。我们将把三角形的三个角分别指定为红色、绿色和蓝色：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> vertices<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">// 位置              // 颜色</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>     <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>   <span class=\"token comment\">// 右下</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token operator\">-</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>   <span class=\"token comment\">// 左下</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>     <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span>    <span class=\"token comment\">// 顶部</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>由于现在有更多的数据要发送到顶点着色器，我们有必要去调整一下顶点着色器，使它能够接收颜色值作为一个顶点属性输入。需要注意的是我们用<mark> layout</mark> 标识符来把<mark> aColor</mark> 属性的位置值设置为 1：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> in vec3 aPos<span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 位置变量的属性位置值为 0 </span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> in vec3 aColor<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 颜色变量的属性位置值为 1</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>out vec3 ourColor<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 向片段着色器输出一个颜色</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>aPos<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    ourColor <span class=\"token operator\">=</span> aColor<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 将 ourColor 设置为我们从顶点数据那里得到的输入颜色</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>由于我们不再使用 uniform 来传递片段的颜色了，现在使用<mark> ourColor</mark> 输出变量，我们必须再修改一下片段着色器：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>out vec4 FragColor<span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>in vec3 ourColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>ourColor<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>因为我们添加了另一个顶点属性，并且更新了 VBO 的内存，我们就必须重新配置顶点属性指针。更新后的 VBO 内存中的数据现在看起来像这样：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/05/vertex_attribute_pointer_interleaved.png\" alt=\"image\" /></p>\n<p>知道了现在使用的布局，我们就可以使用 glVertexAttribPointer 函数更新顶点格式，</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 位置属性</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glVertexAttribPointer</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span> <span class=\"token number\">6</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glEnableVertexAttribArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// 颜色属性</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">glVertexAttribPointer</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span> <span class=\"token number\">6</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">glEnableVertexAttribArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>由于我们现在有了两个顶点属性，我们不得不重新计算步长值。为获得数据队列中下一个属性值（比如位置向量的下个 x 分量）我们必须向右移动<mark> 6 个 float</mark>，其中 3 个是位置值，另外 3 个是颜色值。这使我们的步长值为 6 乘以 float 的字节数（=24 字节）。<br />\n同样，这次我们必须指定一个<mark>偏移量</mark>。对于每个顶点来说，位置顶点属性在前，所以它的偏移量是 0。颜色属性紧随位置数据之后，所以偏移量就是<mark> 3 * sizeof (float)</mark>，用字节来计算就是 12 字节。</p>\n<p>运行程序你应该会看到如下结果：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/05/shaders3.png\" alt=\"image\" /></p>\n<p>这个图片可能不是你所期望的那种，因为我们只提供了 3 个颜色，而不是我们现在看到的大调色板。这是在片段着色器中进行的所谓<mark>片段插值</mark> (Fragment Interpolation) 的结果。当渲染一个三角形时，<mark>光栅化</mark> (Rasterization) 阶段通常会造成<mark>比原指定顶点更多的片段</mark>。光栅会根据每个片段在三角形形状上所处相对位置决定这些片段的位置。<br />\n基于这些位置，它会插值 (Interpolate) 所有片段着色器的输入变量。比如说，我们有一个线段，上面的端点是绿色的，下面的端点是蓝色的。如果一个片段着色器在线段的 70% 的位置运行，它的颜色输入属性就会是一个绿色和蓝色的线性结合；更精确地说就是<mark> 30% 蓝 + 70% 绿</mark>。</p>\n<p>这正是在这个三角形中发生了什么。我们有 3 个顶点，和相应的 3 个颜色，从这个三角形的像素来看它可能包含 50000 左右的片段，片段着色器为这些像素进行插值颜色。如果你仔细看这些颜色就应该能明白了：红首先变成到紫再变为蓝色。片段插值会被应用到片段着色器的所有输入属性上。</p>\n<h3 id=\"我们自己的着色器类\"><a class=\"anchor\" href=\"#我们自己的着色器类\">#</a> 我们自己的着色器类</h3>\n<p>编写、编译、管理着色器是件麻烦事。在着色器主题的最后，我们会写一个类来让我们的生活轻松一点，它可以从硬盘读取着色器，然后编译并链接它们，并对它们进行错误检测，这就变得很好用了。这也会让你了解该如何封装目前所学的知识到一个抽象对象中。</p>\n<p>我们会把着色器类全部放在在头文件里，主要是为了学习用途，当然也方便移植。我们先来添加必要的 include，并定义类结构：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">ifndef</span> <span class=\"token expression\">SHADER_H</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token expression\">SHADER_H</span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;glad/glad.h></span><span class=\"token expression\"><span class=\"token punctuation\">;</span> </span><span class=\"token comment\">// 包含 glad 来获取所有的必须 OpenGL 头文件</span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string></span></span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;fstream></span></span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;sstream></span></span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Shader</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token comment\">// 程序 ID</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> ID<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token comment\">// 构造器读取并构建着色器</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token function\">Shader</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> GLchar<span class=\"token operator\">*</span> vertexPath<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> GLchar<span class=\"token operator\">*</span> fragmentPath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token comment\">// 使用 / 激活程序</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token keyword\">void</span> <span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token comment\">//uniform 工具函数</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token keyword\">void</span> <span class=\"token function\">setBool</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> std<span class=\"token operator\">::</span>string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> value<span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token keyword\">void</span> <span class=\"token function\">setInt</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> std<span class=\"token operator\">::</span>string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> value<span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span>   </pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token keyword\">void</span> <span class=\"token function\">setFloat</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> std<span class=\"token operator\">::</span>string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> value<span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">endif</span></span></pre></td></tr></table></figure><p>着色器类储存了着色器程序的 ID。它的构造器需要顶点和片段着色器源代码的文件路径，这样我们就可以把源码的文本文件储存在硬盘上了。除此之外，为了让我们的生活更轻松一点，还加入了一些工具函数：<mark>use 用来激活着色器程序</mark>，所有的<mark> set… 函数能够查询一个 unform 的位置值并设置它的值</mark>。</p>\n<h3 id=\"从文件读取\"><a class=\"anchor\" href=\"#从文件读取\">#</a> 从文件读取</h3>\n<p>我们使用 cpp 文件流读取着色器内容，储存到几个 string 对象里：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">Shader</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> vertexPath<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> fragmentPath<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\">// 1. 从文件路径中获取顶点 / 片段着色器</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    std<span class=\"token operator\">::</span>string vertexCode<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    std<span class=\"token operator\">::</span>string fragmentCode<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    std<span class=\"token operator\">::</span>ifstream vShaderFile<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    std<span class=\"token operator\">::</span>ifstream fShaderFile<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\">// 保证 ifstream 对象可以抛出异常：</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    vShaderFile<span class=\"token punctuation\">.</span><span class=\"token function\">exceptions</span> <span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span>ifstream<span class=\"token operator\">::</span>failbit <span class=\"token operator\">|</span> std<span class=\"token operator\">::</span>ifstream<span class=\"token operator\">::</span>badbit<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    fShaderFile<span class=\"token punctuation\">.</span><span class=\"token function\">exceptions</span> <span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span>ifstream<span class=\"token operator\">::</span>failbit <span class=\"token operator\">|</span> std<span class=\"token operator\">::</span>ifstream<span class=\"token operator\">::</span>badbit<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">try</span> </pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token comment\">// 打开文件</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        vShaderFile<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span>vertexPath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        fShaderFile<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span>fragmentPath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        std<span class=\"token operator\">::</span>stringstream vShaderStream<span class=\"token punctuation\">,</span> fShaderStream<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token comment\">// 读取文件的缓冲内容到数据流中</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        vShaderStream <span class=\"token operator\">&lt;&lt;</span> vShaderFile<span class=\"token punctuation\">.</span><span class=\"token function\">rdbuf</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        fShaderStream <span class=\"token operator\">&lt;&lt;</span> fShaderFile<span class=\"token punctuation\">.</span><span class=\"token function\">rdbuf</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>       </pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token comment\">// 关闭文件处理器</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        vShaderFile<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        fShaderFile<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token comment\">// 转换数据流到 string</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        vertexCode   <span class=\"token operator\">=</span> vShaderStream<span class=\"token punctuation\">.</span><span class=\"token function\">str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        fragmentCode <span class=\"token operator\">=</span> fShaderStream<span class=\"token punctuation\">.</span><span class=\"token function\">str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     </pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span>ifstream<span class=\"token operator\">::</span>failure e<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>        std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ\"</span> <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> vShaderCode <span class=\"token operator\">=</span> vertexCode<span class=\"token punctuation\">.</span><span class=\"token function\">c_str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> fShaderCode <span class=\"token operator\">=</span> fragmentCode<span class=\"token punctuation\">.</span><span class=\"token function\">c_str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">]</span></pre></td></tr></table></figure><p>下一步，我们需要编译和链接着色器。注意，我们也将检查编译 / 链接是否失败，如果失败则打印编译时错误，调试的时候这些错误输出会及其重要（你总会需要这些错误日志的）：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 2. 编译着色器</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> vertex<span class=\"token punctuation\">,</span> fragment<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">int</span> success<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">char</span> infoLog<span class=\"token punctuation\">[</span><span class=\"token number\">512</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">// 顶点着色器</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>vertex <span class=\"token operator\">=</span> <span class=\"token function\">glCreateShader</span><span class=\"token punctuation\">(</span>GL_VERTEX_SHADER<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">glShaderSource</span><span class=\"token punctuation\">(</span>vertex<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>vShaderCode<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token function\">glCompileShader</span><span class=\"token punctuation\">(</span>vertex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">// 打印编译错误（如果有的话）</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token function\">glGetShaderiv</span><span class=\"token punctuation\">(</span>vertex<span class=\"token punctuation\">,</span> GL_COMPILE_STATUS<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>success<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>success<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token function\">glGetShaderInfoLog</span><span class=\"token punctuation\">(</span>vertex<span class=\"token punctuation\">,</span> <span class=\"token number\">512</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> infoLog<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n\"</span> <span class=\"token operator\">&lt;&lt;</span> infoLog <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token comment\">// 片段着色器也类似</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token comment\">// 着色器程序</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>ID <span class=\"token operator\">=</span> <span class=\"token function\">glCreateProgram</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token function\">glAttachShader</span><span class=\"token punctuation\">(</span>ID<span class=\"token punctuation\">,</span> vertex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token function\">glAttachShader</span><span class=\"token punctuation\">(</span>ID<span class=\"token punctuation\">,</span> fragment<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token function\">glLinkProgram</span><span class=\"token punctuation\">(</span>ID<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token comment\">// 打印连接错误（如果有的话）</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token function\">glGetProgramiv</span><span class=\"token punctuation\">(</span>ID<span class=\"token punctuation\">,</span> GL_LINK_STATUS<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>success<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>success<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token function\">glGetProgramInfoLog</span><span class=\"token punctuation\">(</span>ID<span class=\"token punctuation\">,</span> <span class=\"token number\">512</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> infoLog<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"ERROR::SHADER::PROGRAM::LINKING_FAILED\\n\"</span> <span class=\"token operator\">&lt;&lt;</span> infoLog <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre></pre></td></tr><tr><td data-num=\"34\"></td><td><pre><span class=\"token comment\">// 删除着色器，它们已经链接到我们的程序中了，已经不再需要了</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre><span class=\"token function\">glDeleteShader</span><span class=\"token punctuation\">(</span>vertex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre><span class=\"token function\">glDeleteShader</span><span class=\"token punctuation\">(</span>fragment<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>use 函数非常简单：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> </pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span> </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token function\">glUseProgram</span><span class=\"token punctuation\">(</span>ID<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>uniform 的 setter 函数也很类似：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">setBool</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> std<span class=\"token operator\">::</span>string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">bool</span> value<span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token function\">glUniform1i</span><span class=\"token punctuation\">(</span><span class=\"token function\">glGetUniformLocation</span><span class=\"token punctuation\">(</span>ID<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">.</span><span class=\"token function\">c_str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">setInt</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> std<span class=\"token operator\">::</span>string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> value<span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#123;</span> </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token function\">glUniform1i</span><span class=\"token punctuation\">(</span><span class=\"token function\">glGetUniformLocation</span><span class=\"token punctuation\">(</span>ID<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">.</span><span class=\"token function\">c_str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">setFloat</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> std<span class=\"token operator\">::</span>string <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> value<span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#123;</span> </pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token function\">glUniform1f</span><span class=\"token punctuation\">(</span><span class=\"token function\">glGetUniformLocation</span><span class=\"token punctuation\">(</span>ID<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">.</span><span class=\"token function\">c_str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>现在我们就写完了一个完整的着色器类。使用这个着色器类很简单；只要创建一个着色器对象，从那一点开始我们就可以开始使用了：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Shader <span class=\"token function\">ourShader</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"path/to/shaders/shader.vs\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"path/to/shaders/shader.fs\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    ourShader<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    ourShader<span class=\"token punctuation\">.</span><span class=\"token function\">setFloat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"someUniform\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token function\">DrawStuff</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们把顶点和片段着色器储存为两个叫做 shader.vs 和 shader.fs 的文件。你可以使用自己喜欢的名字命名着色器文件；我自己觉得用.vs 和.fs 作为扩展名很直观。</p>\n<p>你可以在这里找到使用新着色器类的源代码。注意你可以点击源码中的着色器文件路径来查看每一个着色器的源代码。</p>\n<h2 id=\"纹理\"><a class=\"anchor\" href=\"#纹理\">#</a> 纹理</h2>\n<p>我们已经了解到，我们可以为每个顶点添加颜色来增加图形的细节，从而创建出有趣的图像。但是，如果想让图形看起来更真实，我们就必须有足够多的顶点，从而指定足够多的颜色。这将会产生很多额外开销，因为每个模型都会需求更多的顶点，每个顶点又需求一个颜色属性。</p>\n<p>艺术家和程序员更喜欢使用<mark>纹理</mark> (Texture)。纹理是一个 2D 图片（甚至也有 1D 和 3D 的纹理），它可以用来添加物体的细节；你可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到你的 3D 的房子上，这样你的房子看起来就像有砖墙外表了。因为我们可以在一张图片上插入非常多的细节，这样就可以让物体非常精细而不用指定额外的顶点。</p>\n<blockquote>\n<p>除了图像以外，纹理也可以被用来储存大量的<mark>数据</mark>，这些数据可以发送到着色器上。</p>\n</blockquote>\n<p>为了能够把纹理映射 (Map) 到三角形上，我们需要指定三角形的<mark>每个顶点各自对应纹理的哪个部分</mark>。这样每个顶点就会关联着一个<mark>纹理坐标</mark> (Texture Coordinate)，用来标明该从纹理图像的哪个部分采样（译注：采集片段颜色）。之后在图形的其它片段上进行<mark>片段插值</mark> (Fragment Interpolation)。</p>\n<p>纹理坐标在 x 和 y 轴上，范围为 0 到 1 之间（注意我们使用的是 2D 纹理图像）。使用纹理坐标获取纹理颜色叫做<mark>采样</mark> (Sampling)。纹理坐标起始于 (0, 0)，也就是纹理图片的左下角，终始于 (1, 1)，即纹理图片的右上角。下面的图片展示了我们是如何把纹理坐标映射到三角形上的。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/06/tex_coords.png\" alt=\"image\" /></p>\n<p>我们为三角形指定了 3 个纹理坐标点。如上图所示，我们希望三角形的左下角对应纹理的左下角，因此我们把三角形左下角顶点的纹理坐标设置为 (0, 0)；三角形的上顶点对应于图片的上中位置所以我们把它的纹理坐标设置为 (0.5, 1.0)；同理右下方的顶点设置为 (1, 0)。我们只要给<mark>顶点着色器传递这三个纹理坐标</mark>就行了，接下来它们会被传片段着色器中，它会为每个片段进行纹理坐标的插值。</p>\n<p>纹理坐标看起来就像这样：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> texCoords<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 左下角</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 右下角</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span> <span class=\"token comment\">// 上中</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>对纹理采样的解释非常宽松，它可以采用几种不同的插值方式。所以我们需要自己告诉 OpenGL 该怎样对纹理<mark>采样</mark>。</p>\n<h3 id=\"纹理环绕方式\"><a class=\"anchor\" href=\"#纹理环绕方式\">#</a> 纹理环绕方式</h3>\n<p>纹理坐标的范围通常是从 (0, 0) 到 (1, 1)，那如果我们把纹理坐标设置在<mark>范围之外</mark>会发生什么？OpenGL 默认的行为是<mark>重复这个纹理图像</mark>（我们基本上忽略浮点纹理坐标的整数部分），但 OpenGL 提供了更多的选择：</p>\n<table>\n<thead>\n<tr>\n<th>环绕方式</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_REPEAT</td>\n<td>对纹理的默认行为。重复纹理图像。</td>\n</tr>\n<tr>\n<td>GL_MIRRORED_REPEAT</td>\n<td>和 GL_REPEAT 一样，但每次重复图片是镜像放置的。</td>\n</tr>\n<tr>\n<td>GL_CLAMP_TO_EDGE</td>\n<td>纹理坐标会被约束在 0 到 1 之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。</td>\n</tr>\n<tr>\n<td>GL_CLAMP_TO_BORDER</td>\n<td>超出的坐标为用户指定的边缘颜色。</td>\n</tr>\n</tbody>\n</table>\n<p>当纹理坐标超出默认范围时，每个选项都有不同的视觉效果输出。我们来看看这些纹理图像的例子：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/06/texture_wrapping.png\" alt=\"image\" /></p>\n<p>前面提到的每个选项都可以使用<mark> glTexParameter</mark> 函数对单独的一个坐标轴设置（s、t（如果是使用 3D 纹理那么还有一个 r）它们和 x、y、z 是等价的）：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_WRAP_S<span class=\"token punctuation\">,</span> GL_MIRRORED_REPEAT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_WRAP_T<span class=\"token punctuation\">,</span> GL_MIRRORED_REPEAT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>第一个参数指定了<mark>纹理目标</mark>；我们使用的是 2D 纹理，因此纹理目标是<mark> GL_TEXTURE_2D</mark>。第二个参数需要我们指定设置的选项与应用的<mark>纹理轴</mark>。我们打算配置的是 WRAP 选项，并且指定 S 和 T 轴。最后一个参数需要我们传递一个<mark>环绕方式</mark> (Wrapping)，在这个例子中 OpenGL 会给当前激活的纹理设定纹理环绕方式为 GL_MIRRORED_REPEAT。</p>\n<p>如果我们选择<mark> GL_CLAMP_TO_BORDER</mark> 选项，我们还需要指定一个<mark>边缘的颜色</mark>。这需要使用<mark> glTexParameter</mark> 函数的 fv 后缀形式，用 GL_TEXTURE_BORDER_COLOR 作为它的选项，并且传递一个 float 数组作为边缘的颜色值：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> borderColor<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glTexParameterfv</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_BORDER_COLOR<span class=\"token punctuation\">,</span> borderColor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"纹理过滤\"><a class=\"anchor\" href=\"#纹理过滤\">#</a> 纹理过滤</h3>\n<p>纹理坐标不依赖于分辨率 (Resolution)，它可以是任意浮点值，所以 OpenGL 需要知道怎样将<mark>纹理像素</mark> (Texture Pixel，也叫 Texel，译注 1) 映射到<mark>纹理坐标</mark>。当你有一个很大的物体但是纹理的分辨率很低的时候这就变得很重要了。你可能已经猜到了，OpenGL 也有对于<mark>纹理过滤</mark> (Texture Filtering) 的选项。纹理过滤有很多个选项，但是现在我们只讨论最重要的两种：GL_NEAREST 和 GL_LINEAR。</p>\n<blockquote>\n<p>Texture Pixel 也叫 Texel，你可以想象你打开一张.jpg 格式图片，不断放大你会发现它是由无数像素点组成的，这个点就是纹理像素；注意不要和纹理坐标搞混，纹理坐标是你给模型顶点设置的那个数组，OpenGL 以这个顶点的纹理坐标数据去查找纹理图像上的像素，然后进行采样提取纹理像素的颜色。(纹理像素是某点对应的颜色，纹理坐标是告诉 GPU 需要去图片中的哪个位置进行颜色采样)</p>\n</blockquote>\n<p><mark>GL_NEAREST</mark>（也叫邻近过滤，Nearest Neighbor Filtering）是 OpenGL 默认的纹理过滤方式。当设置为 GL_NEAREST 的时候，OpenGL 会选择中心点最接近纹理坐标的那个像素。下图中你可以看到四个像素，加号代表纹理坐标。左上角那个纹理像素的中心<mark>距离纹理坐标最近</mark>，所以它会被选择为样本颜色：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/06/filter_nearest.png\" alt=\"image\" /></p>\n<p><mark>GL_LINEAR</mark>（也叫线性过滤，(Bi) linear Filtering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。下图中你可以看到返回的颜色是<mark>邻近像素的混合色</mark>：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/06/filter_linear.png\" alt=\"image\" /></p>\n<p>那么这两种纹理过滤方式有怎样的视觉效果呢？让我们看看在一个很大的物体上应用一张低分辨率的纹理会发生什么吧（纹理被放大了，每个纹理像素都能看到）：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/06/texture_filtering.png\" alt=\"image\" /></p>\n<p>GL_NEAREST 产生了颗粒状的图案，我们能够清晰看到组成纹理的像素，而 GL_LINEAR 能够产生更平滑的图案，很难看出单个的纹理像素。GL_LINEAR 可以产生更真实的输出，但有些开发者更喜欢 8-bit 风格，所以他们会用 GL_NEAREST 选项。</p>\n<p>当进行放大 (Magnify) 和缩小 (Minify) 操作的时候可以设置纹理过滤的选项，比如你可以在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。我们需要使用<mark> glTexParameter</mark> 函数为放大和缩小指定过滤方式。这段代码看起来会和纹理环绕方式的设置很相似：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_MIN_FILTER<span class=\"token punctuation\">,</span> GL_NEAREST<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_MAG_FILTER<span class=\"token punctuation\">,</span> GL_LINEAR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"多级渐远纹理\"><a class=\"anchor\" href=\"#多级渐远纹理\">#</a> 多级渐远纹理</h3>\n<p>想象一下，假设我们有一个包含着上千物体的大房间，每个物体上都有纹理。有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率。由于远处的物体可能只产生很少的片段，OpenGL 从高分辨率纹理中为这些片段获取正确的颜色值就很困难，因为它需要对一个跨过纹理很大部分的片段只拾取一个纹理颜色。在小物体上这会产生不真实的感觉，更不用说对它们使用高分辨率纹理浪费内存的问题了。</p>\n<p>OpenGL 使用一种叫做<mark>多级渐远纹理</mark> (Mipmap) 的概念来解决这个问题，它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL 会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。让我们看一下多级渐远纹理是什么样子的：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/06/mipmaps.png\" alt=\"image\" /></p>\n<p>手工为每个纹理图像创建一系列多级渐远纹理很麻烦，幸好 OpenGL 有一个<mark> glGenerateMipmaps</mark> 函数，在创建完一个纹理后调用它 OpenGL 就会承担接下来的所有工作了。后面的教程中你会看到该如何使用它。</p>\n<p>在渲染中切换多级渐远纹理级别 (Level) 时，OpenGL 在两个不同级别的多级渐远纹理层之间会产生不真实的生硬边界。就像普通的纹理过滤一样，切换多级渐远纹理级别时你也<mark>可以在两个不同<strong>多级渐远纹理级别</strong>之间使用 NEAREST 和 LINEAR 过滤</mark>。为了指定不同多级渐远纹理级别之间的过滤方式，你可以使用下面四个选项中的一个代替原有的过滤方式：</p>\n<table>\n<thead>\n<tr>\n<th>过滤方式</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_NEAREST_MIPMAP_NEAREST</td>\n<td>使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样</td>\n</tr>\n<tr>\n<td>GL_LINEAR_MIPMAP_NEAREST</td>\n<td>使用最邻近的多级渐远纹理级别，并使用线性插值进行采样</td>\n</tr>\n<tr>\n<td>GL_NEAREST_MIPMAP_LINEAR</td>\n<td>在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样</td>\n</tr>\n<tr>\n<td>GL_LINEAR_MIPMAP_LINEAR</td>\n<td>在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样</td>\n</tr>\n</tbody>\n</table>\n<p>就像纹理过滤一样，我们可以使用<mark> glTexParameteri</mark> 将过滤方式设置为前面四种提到的方法之一：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_MIN_FILTER<span class=\"token punctuation\">,</span> GL_LINEAR_MIPMAP_LINEAR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_MAG_FILTER<span class=\"token punctuation\">,</span> GL_LINEAR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><blockquote>\n<p>一个常见的错误是，将放大过滤的选项设置为多级渐远纹理过滤选项之一。这样没有任何效果，<mark>因为多级渐远纹理主要是使用在纹理被<strong>缩小</strong>的情况下的</mark>：纹理放大不会使用多级渐远纹理，为放大过滤设置多级渐远纹理的选项会产生一个 GL_INVALID_ENUM 错误代码。</p>\n</blockquote>\n<h3 id=\"加载与创建纹理\"><a class=\"anchor\" href=\"#加载与创建纹理\">#</a> 加载与创建纹理</h3>\n<p>使用纹理之前要做的第一件事是把它们加载到我们的应用中。纹理图像可能被储存为各种各样的格式，每种都有自己的数据结构和排列，所以我们如何才能把这些图像加载到应用中呢？一个解决方案是选一个需要的文件格式，比如.PNG，然后自己写一个图像加载器，把图像转化为字节序列。写自己的图像加载器虽然不难，但仍然挺麻烦的，而且如果要支持更多文件格式呢？你就不得不为每种你希望支持的格式写加载器了。</p>\n<p>另一个解决方案也许是一种更好的选择，使用一个支持多种流行格式的图像加载库来为我们解决这个问题。比如说我们要用的<mark> stb_image.h</mark> 库。</p>\n<h4 id=\"stb_imageh\"><a class=\"anchor\" href=\"#stb_imageh\">#</a> stb_image.h</h4>\n<p>stb_image.h 是 Sean Barrett 的一个非常流行的单头文件图像加载库，它能够加载大部分流行的文件格式，并且能够很简单得整合到你的工程之中。stb_image.h 可以在这里下载。下载这一个头文件，将它以 stb_image.h 的名字加入你的工程，并另创建一个新的 cpp 文件，输入以下代码：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token expression\">STB_IMAGE_IMPLEMENTATION</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"stb_image.h\"</span></span></pre></td></tr></table></figure><p>通过定义 STB_IMAGE_IMPLEMENTATION，预处理器会修改头文件，让其只包含相关的函数定义源码，等于是将这个头文件变为一个 .cpp 文件了。现在只需要在你的程序中包含 stb_image.h 并编译就可以了。</p>\n<p>下面的教程中，我们会使用一张木箱的图片。要使用 stb_image.h 加载图片，我们需要使用它的<mark> stbi_load</mark> 函数：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">,</span> nrChannels<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>data <span class=\"token operator\">=</span> <span class=\"token function\">stbi_load</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"container.jpg\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>width<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>height<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>nrChannels<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这个函数首先接受一个图像文件的位置作为输入。接下来它需要三个 int 作为它的第二、第三和第四个参数，stb_image.h 将会用图像的宽度、高度和颜色通道的个数填充这三个变量。我们之后生成纹理的时候会用到的图像的宽度和高度的。</p>\n<h3 id=\"生成纹理\"><a class=\"anchor\" href=\"#生成纹理\">#</a> 生成纹理</h3>\n<p>和之前生成的 OpenGL 对象一样，纹理也是使用 ID 引用的。让我们来创建一个：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> texture<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glGenTextures</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>texture<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>glGenTextures 函数首先需要输入生成纹理的数量，然后把它们储存在第二个参数的 unsigned int 数组中（我们的例子中只是单独的一个 unsigned int），就像其他对象一样，我们需要绑定它，让之后任何的纹理指令都可以配置当前绑定的纹理：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> texture<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>现在纹理已经绑定了，我们可以使用前面载入的图片数据生成一个纹理了。纹理可以通过 glTexImage2D 来生成：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glTexImage2D</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> GL_RGB<span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> GL_RGB<span class=\"token punctuation\">,</span> GL_UNSIGNED_BYTE<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glGenerateMipmap</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><ul>\n<li>第一个参数指定了<mark>纹理目标</mark> (Target)。设置为 GL_TEXTURE_2D 意味着会生成与当前绑定的纹理对象在同一个目标上的纹理（任何绑定到 GL_TEXTURE_1D 和 GL_TEXTURE_3D 的纹理不会受到影响）。</li>\n<li>第二个参数为纹理指定<mark>多级渐远纹理的级别</mark>，如果你希望单独手动设置每个多级渐远纹理的级别的话。这里我们填 0，也就是基本级别。</li>\n<li>第三个参数告诉 OpenGL 我们希望把<mark>纹理储存为何种格式</mark>。我们的图像只有 RGB 值，因此我们也把纹理储存为 RGB 值。</li>\n<li>第四个和第五个参数设置最终的纹理的<mark>宽度</mark>和<mark>高度</mark>。我们之前加载图像的时候储存了它们，所以我们使用对应的变量。</li>\n<li>下个参数应该总是被设为 0（历史遗留的问题）。</li>\n<li>第七第八个参数定义了<mark>源图的格式</mark>和<mark>数据类型</mark>。我们使用 RGB 值加载这个图像，并把它们储存为 char (byte) 数组，我们将会传入对应值。<br />\n最后一个参数是真正的图像数据。</li>\n</ul>\n<p>当调用<mark> glTexImage2D</mark> 时，当前绑定的纹理对象就会被附加上纹理图像。然而，目前只有<mark>基本级别</mark> (Base-level) 的纹理图像被加载了，如果要使用多级渐远纹理，我们必须手动设置所有不同的图像（不断递增第二个参数）。或者，直接在生成纹理之后调用<mark> glGenerateMipmap</mark>。这会为当前绑定的纹理<mark>自动生成</mark>所有需要的<mark>多级渐远纹理</mark>。</p>\n<p>生成了纹理和相应的多级渐远纹理后，释放图像的内存是一个很好的习惯。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">stbi_image_free</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>生成一个纹理的过程应该看起来像这样：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> texture<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glGenTextures</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>texture<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> texture<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// 为当前绑定的纹理对象设置环绕、过滤方式</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_WRAP_S<span class=\"token punctuation\">,</span> GL_REPEAT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   </pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_WRAP_T<span class=\"token punctuation\">,</span> GL_REPEAT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_MIN_FILTER<span class=\"token punctuation\">,</span> GL_LINEAR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_MAG_FILTER<span class=\"token punctuation\">,</span> GL_LINEAR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">// 加载并生成纹理</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">int</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">,</span> nrChannels<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>data <span class=\"token operator\">=</span> <span class=\"token function\">stbi_load</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"container.jpg\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>width<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>height<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>nrChannels<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token function\">glTexImage2D</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> GL_RGB<span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> GL_RGB<span class=\"token punctuation\">,</span> GL_UNSIGNED_BYTE<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token function\">glGenerateMipmap</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token keyword\">else</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Failed to load texture\"</span> <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token function\">stbi_image_free</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"应用纹理\"><a class=\"anchor\" href=\"#应用纹理\">#</a> 应用纹理</h3>\n<p>后面的这部分我们会使用 glDrawElements 绘制「你好，三角形」教程最后一部分的矩形。我们需要告知 OpenGL 如何采样纹理，所以我们必须使用纹理坐标更新顶点数据：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> vertices<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">//     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>     <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>   <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>   <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span>   <span class=\"token comment\">// 右上</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>     <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>   <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>   <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>   <span class=\"token comment\">// 右下</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token operator\">-</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>   <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span>   <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>   <span class=\"token comment\">// 左下</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token operator\">-</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>   <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>   <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span>    <span class=\"token comment\">// 左上</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>由于我们添加了一个额外的顶点属性，我们必须告诉 OpenGL 我们新的顶点格式：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/06/vertex_attribute_pointer_interleaved_textures.png\" alt=\"image\" /></p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glVertexAttribPointer</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span> <span class=\"token number\">8</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glEnableVertexAttribArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>注意，我们同样需要调整前面两个顶点属性的步长参数为<mark> 8 * sizeof (float)</mark>。</p>\n<p>接着我们需要调整顶点着色器使其能够接受顶点坐标为一个顶点属性，并把坐标传给片段着色器：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> in vec3 aPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> in vec3 aColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> in vec2 aTexCoord<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>out vec3 ourColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>out vec2 TexCoord<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>aPos<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    ourColor <span class=\"token operator\">=</span> aColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    TexCoord <span class=\"token operator\">=</span> aTexCoord<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>片段着色器应该接下来会把输出变量 TexCoord 作为输入变量。</p>\n<p>片段着色器也应该能访问纹理对象，但是我们怎样能把纹理对象传给片段着色器呢？GLSL 有一个供纹理对象使用的内建数据类型，叫做<mark>采样器</mark> (Sampler)，它以纹理类型作为后缀，比如 sampler1D、sampler3D，或在我们的例子中的 sampler2D。我们可以简单声明一个 uniform sampler2D 把一个纹理添加到片段着色器中，稍后我们会把纹理赋值给这个 uniform。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>out vec4 FragColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>in vec3 ourColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>in vec2 TexCoord<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>uniform sampler2D ourTexture<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>ourTexture<span class=\"token punctuation\">,</span> TexCoord<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们使用 GLSL 内建的 texture 函数来采样纹理的颜色，它第一个参数是纹理采样器，第二个参数是对应的纹理坐标。texture 函数会使用之前设置的纹理参数对相应的颜色值进行采样。这个片段着色器的输出就是纹理的（插值）纹理坐标上的 (过滤后的) 颜色。</p>\n<p>现在只剩下在调用 glDrawElements 之前绑定纹理了，它会自动把纹理赋值给片段着色器的采样器：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> texture<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glBindVertexArray</span><span class=\"token punctuation\">(</span>VAO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glDrawElements</span><span class=\"token punctuation\">(</span>GL_TRIANGLES<span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> GL_UNSIGNED_INT<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>如果你跟着这个教程正确地做完了，你会看到下面的图像：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/06/textures2.png\" alt=\"image\" /></p>\n<p>我们还可以把得到的纹理颜色与顶点颜色混合，来获得更有趣的效果。我们只需把纹理颜色与顶点颜色在片段着色器中相乘来混合二者的颜色：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>FragColor <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>ourTexture<span class=\"token punctuation\">,</span> TexCoord<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>ourColor<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"纹理单元\"><a class=\"anchor\" href=\"#纹理单元\">#</a> 纹理单元</h3>\n<p>你可能会奇怪为什么 sampler2D 变量是个 uniform，我们却不用 glUniform 给它赋值。使用 glUniform1i，我们可以给纹理采样器分配一个位置值，这样的话我们能够在一个片段着色器中设置多个纹理。一个纹理的位置值通常称为一个纹理单元 (Texture Unit)。<mark>一个纹理的默认纹理单元是 0</mark>，它是<mark>默认</mark>的<mark>激活</mark>纹理单元，所以教程前面部分我们没有分配一个位置值。</p>\n<p>纹理单元的主要目的是让我们在着色器中可以使用多于一个的纹理。通过把纹理单元赋值给采样器，我们可以一次绑定多个纹理，只要我们首先激活对应的纹理单元。就像 glBindTexture 一样，我们可以使用 glActiveTexture 激活纹理单元，传入我们需要使用的纹理单元：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glActiveTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 在绑定纹理之前先激活纹理单元</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> texture<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>激活纹理单元之后，接下来的 glBindTexture 函数调用会绑定这个纹理到当前激活的纹理单元，纹理单元 GL_TEXTURE0<mark> 默认总是被激活</mark>，所以我们在前面的例子里当我们使用 glBindTexture 的时候，无需激活任何纹理单元。</p>\n<blockquote>\n<p>OpenGL 至少保证有<mark> 16</mark> 个纹理单元供你使用，也就是说你可以激活从 GL_TEXTURE0 到 GL_TEXTRUE15。它们都是按顺序定义的，所以我们也可以通过 GL_TEXTURE0 + 8 的方式获得 GL_TEXTURE8，这在当我们需要循环一些纹理单元的时候会很有用。</p>\n</blockquote>\n<p>我们仍然需要编辑片段着色器来接收另一个采样器。这应该相对来说非常直接了：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>uniform sampler2D texture1<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>uniform sampler2D texture2<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">mix</span><span class=\"token punctuation\">(</span><span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>texture1<span class=\"token punctuation\">,</span> TexCoord<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>texture2<span class=\"token punctuation\">,</span> TexCoord<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>最终输出颜色现在是两个纹理的结合。GLSL 内建的<mark> mix</mark> 函数需要接受两个值作为参数，并对它们根据第三个参数进行线性插值。如果第三个值是 0.0，它会返回第一个输入；如果是 1.0，会返回第二个输入值。0.2 会返回 80% 的第一个输入颜色和 20% 的第二个输入颜色，即返回两个纹理的混合色。</p>\n<p>我们现在需要载入并创建另一个纹理；你应该对这些步骤很熟悉了。记得创建另一个纹理对象，载入图片，使用 glTexImage2D 生成最终纹理。对于第二个纹理我们使用一张你学习 OpenGL 时的面部表情图片。</p>\n<p>为了使用第二个纹理（以及第一个），我们必须改变一点渲染流程，先绑定两个纹理到对应的纹理单元，然后定义哪个 uniform 采样器对应哪个纹理单元：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glActiveTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> texture1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glActiveTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> texture2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">glBindVertexArray</span><span class=\"token punctuation\">(</span>VAO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">glDrawElements</span><span class=\"token punctuation\">(</span>GL_TRIANGLES<span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> GL_UNSIGNED_INT<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>我们还要通过使用<mark> glUniform1i</mark> 设置每个采样器的方式告诉 OpenGL 每个着色器采样器属于哪个纹理单元。我们只需要设置一次即可，所以这个会放在渲染循环的前面：</p>\n<pre><code>ourShader.use(); // 别忘记在激活着色器前先设置uniform！\nglUniform1i(glGetUniformLocation(ourShader.ID, &quot;texture1&quot;), 0); // 手动设置\nourShader.setInt(&quot;texture2&quot;, 1); // 或者使用着色器类设置\n\nwhile(...) \n&#123;\n    [...]\n&#125;\n</code></pre>\n<p>通过使用 glUniform1i 设置采样器，我们保证了每个 uniform 采样器对应着正确的纹理单元。你应该能得到下面的结果：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/06/textures_combined.png\" alt=\"image\" /></p>\n<p>你可能注意到纹理上下颠倒了！这是因为 OpenGL 要求 y 轴 0.0 坐标是在图片的底部的，但是图片的 y 轴 0.0 坐标通常在顶部。很幸运，stb_image.h 能够在图像加载时帮助我们翻转 y 轴，只需要在加载任何图像前加入以下语句即可：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">stbi_set_flip_vertically_on_load</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在让 stb_image.h 在加载图片时翻转 y 轴之后你就应该能够获得下面的结果了：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/06/textures_combined2.png\" alt=\"image\" /></p>\n<h2 id=\"变换\"><a class=\"anchor\" href=\"#变换\">#</a> 变换</h2>\n<h3 id=\"向量-2\"><a class=\"anchor\" href=\"#向量-2\">#</a> 向量</h3>\n<p>下面你会看到 3 个向量，每个向量在 2D 图像中都用一个箭头 (x, y) 表示。我们在 2D 图片中展示这些向量，因为这样子会更直观一点。你可以把这些 2D 向量当做 z 坐标为 0 的 3D 向量。由于向量表示的是方向，起始于何处并不会改变它的值。下图我们可以看到向量 v¯ 和 w¯ 是相等的，尽管他们的起始点不同：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/07/vectors.png\" alt=\"image\" /></p>\n<p>数学家喜欢在字母上面加一横表示向量，比如说 v¯。当用在公式中时它们通常是这样的：</p>\n<pre><code class=\"language-math\">\\bar&#123;v&#125;=\\begin&#123;pmatrix&#125;\n   x \\\\\n   y \\\\\n   z  \\end&#123;pmatrix&#125;\n</code></pre>\n<p>由于向量是一个方向，所以有些时候会很难形象地将它们用位置 (Position) 表示出来。为了让其更为直观，我们通常设定这个方向的<mark>原点为 (0, 0, 0)</mark>，然后指向一个方向，对应一个点，使其变为位置向量 (Position Vector)（你也可以把起点设置为其他的点，然后说：这个向量从这个点起始指向另一个点）。比如说位置向量 (3, 5) 在图像中的起点会是 (0, 0)，并会指向 (3, 5)。我们可以使用向量在 2D 或 3D 空间中表示方向与位置.</p>\n<p>和普通数字一样，我们也可以用向量进行多种运算（其中一些你可能已经看到过了）。</p>\n<h3 id=\"向量与标量运算\"><a class=\"anchor\" href=\"#向量与标量运算\">#</a> 向量与标量运算</h3>\n<p>标量 (Scalar) 只是一个数字（或者说是仅有一个分量的向量）。当把一个向量加 / 减 / 乘 / 除一个标量，我们可以简单的把向量的每个分量分别进行该运算。对于加法来说会像这样:</p>\n<pre><code class=\"language-math\">\\begin&#123;pmatrix&#125;\n   1 \\\\\n   2 \\\\\n   3  \\end&#123;pmatrix&#125;+x\n   =  \\begin&#123;pmatrix&#125;\n   1+x \\\\\n   2+y \\\\\n   3+z  \\end&#123;pmatrix&#125;\n</code></pre>\n<p>其中的 + 可以是 +，-，・或 ÷，其中・是乘号。注意－和 ÷ 运算时不能颠倒（标量 -/÷ 向量），因为颠倒的运算是没有定义的。</p>\n<pre><code class=\"language-math\">-\\bar&#123;v&#125;=-\n\\begin&#123;pmatrix&#125;\n   v_x \\\\\n   v_y \\\\\n   v_z  \\end&#123;pmatrix&#125;=\n   \\begin&#123;pmatrix&#125;\n   -v_x \\\\\n   -v_y \\\\\n   -v_z  \\end&#123;pmatrix&#125;\n</code></pre>\n<h3 id=\"向量加减\"><a class=\"anchor\" href=\"#向量加减\">#</a> 向量加减</h3>\n<p>向量的加法可以被定义为是<mark>分量</mark>的 (Component-wise) 相加，即将一个向量中的每一个分量加上另一个向量的对应分量：</p>\n<pre><code class=\"language-math\">\\bar&#123;v&#125;=\n\\begin&#123;pmatrix&#125;\n   1 \\\\\n   2 \\\\\n   3  \\end&#123;pmatrix&#125;,\n   \\bar&#123;k&#125;=\n\\begin&#123;pmatrix&#125;\n   4 \\\\\n   5 \\\\\n   6  \\end&#123;pmatrix&#125;\\to\n   \\bar&#123;v&#125;+\\bar&#123;k&#125;\n\\begin&#123;pmatrix&#125;\n   1+4 \\\\\n   2+5 \\\\\n   3+6  \\end&#123;pmatrix&#125;=\n\\begin&#123;pmatrix&#125;\n   5 \\\\\n   7 \\\\\n   9  \\end&#123;pmatrix&#125;\n</code></pre>\n<p>向量 v = (4, 2) 和 k = (1, 2) 可以直观地表示为：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/07/vectors_addition.png\" alt=\"image\" /></p>\n<p>就像普通数字的加减一样，向量的减法等于加上第二个向量的相反向量：</p>\n<pre><code class=\"language-math\">\\bar&#123;v&#125;=\n\\begin&#123;pmatrix&#125;\n   1 \\\\\n   2 \\\\\n   3  \\end&#123;pmatrix&#125;,\n   \\bar&#123;k&#125;=\n\\begin&#123;pmatrix&#125;\n   4 \\\\\n   5 \\\\\n   6  \\end&#123;pmatrix&#125;\\to\n   \\bar&#123;v&#125;+-\\bar&#123;k&#125;\n   =\\begin&#123;pmatrix&#125;\n   1+(-4) \\\\\n   2+(-5) \\\\\n   3+(-6)  \\end&#123;pmatrix&#125;=\n\\begin&#123;pmatrix&#125;\n   -3 \\\\\n   -3 \\\\\n   -3  \\end&#123;pmatrix&#125;\n</code></pre>\n<p>两个向量的相减会得到这两个向量指向位置的差。这在我们想要获取两点的差会非常有用。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/07/vectors_subtraction.png\" alt=\"image\" /></p>\n<h3 id=\"长度\"><a class=\"anchor\" href=\"#长度\">#</a> 长度</h3>\n<p>我们使用<mark>勾股定理</mark> (Pythagoras Theorem) 来获取向量的长度 (Length)/ 大小 (Magnitude)。如果你把向量的 x 与 y 分量画出来，该向量会和 x 与 y 分量为边形成一个三角形:</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/07/vectors_triangle.png\" alt=\"image\" /></p>\n<p>因为两条边（x 和 y）是已知的，如果希望知道斜边 v¯ 的长度，我们可以直接通过勾股定理来计算：</p>\n<pre><code class=\"language-math\">\n\\|\\bar&#123;v&#125;\\|=\\sqrt&#123;x^&#123;2&#125;+y^&#123;2&#125;&#125;\n\n</code></pre>\n<pre><code class=\"language-math\">\\|\\bar&#123;v&#125;\\|表示向量\\bar&#123;v&#125;的长度，我们也可以加上z^&#123;2&#125;把这个公式拓展到三维空间。\n\n例子中向量(4, 2)的长度等于：\n\n\\|\\bar&#123;v&#125;\\|=\\sqrt&#123;4^&#123;2&#125;+2^&#123;2&#125;&#125;=\\sqrt&#123;16+4&#125;=\\sqrt&#123;20&#125;=4.47\n\n结果是4.47。\n\n有一个特殊类型的向量叫做单位向量(Unit Vector)。\n单位向量有一个特别的性质——它的长度是1。\n\n我们可以用任意向量的每个分量除以向量的长度得到它的单位向量\\hat&#123;n&#125;：\n\n\\hat&#123;n&#125;=\\cfrac&#123;\\bar&#123;v&#125;&#125;&#123;\\|\\bar&#123;v&#125;\\|&#125;\n\n</code></pre>\n<p>我们把这种方法叫做一个<mark>向量的标准化</mark> (Normalizing)。<mark>单位向量</mark>头上有一个 ^ 样子的记号。通常单位向量会变得很有用，特别是在我们只关心方向不关心长度的时候（如果改变向量的长度，它的方向并不会改变）。</p>\n<h3 id=\"向量相乘\"><a class=\"anchor\" href=\"#向量相乘\">#</a> 向量相乘</h3>\n<p>两个向量相乘是一种很奇怪的情况。普通的乘法在向量上是没有定义的，因为它在视觉上是没有意义的。但是在相乘的时候我们有两种特定情况可以选择：一个是<mark>点乘</mark> (Dot Product)，记作：</p>\n<pre><code class=\"language-math\">\\bar&#123;v&#125; \\cdotp \\bar&#123;k&#125;\n\n</code></pre>\n<p>另一个是<mark>叉乘</mark> (CrossProduct)，记作：</p>\n<pre><code class=\"language-math\">\\bar&#123;v&#125; × \\bar&#123;k&#125;\n\n</code></pre>\n<h3 id=\"点乘\"><a class=\"anchor\" href=\"#点乘\">#</a> 点乘</h3>\n<p>两个向量的点乘等于它们的<mark>数乘结果乘以两个向量之间夹角的余弦值</mark>。可能听起来有点费解，我们来看一下公式：</p>\n<pre><code class=\"language-math\">\\bar&#123;v&#125; \\cdotp \\bar&#123;k&#125;=\\|\\bar&#123;v&#125;\\| \\cdotp \\|\\bar&#123;k&#125;\\|\\cdotp\\cos\\theta\n\n</code></pre>\n<p>它们之间的夹角记作<em> θ</em><br />\n。为什么这很有用？想象如果 v 和 k 都是单位向量，它们的长度会等于 1。这样公式会有效简化成：</p>\n<pre><code class=\"language-math\">\\bar&#123;v&#125; \\cdotp \\bar&#123;k&#125;=1 \\cdotp 1\\cdotp\\cos\\theta=\\cos\\theta\n</code></pre>\n<p>现在<mark>点积</mark>只定义了两个向量的夹角。你也许记得 90 度的余弦值是 0，0 度的余弦值是 1。使用点乘可以很容易测试两个向量是否正交 (Orthogonal) 或平行（正交意味着两个向量互为直角）。如果你想要了解更多关于正弦或余弦函数的知识，我推荐你看可汗学院的基础三角学视频。</p>\n<blockquote>\n<p>你也可以通过点乘的结果计算两个非单位向量的夹角，点乘的结果除以两个向量的长度之积，得到的结果就是夹角的余弦值，即 cosθ。译注：通过上面点乘定义式可推出：</p>\n</blockquote>\n<pre><code class=\"language-math\">\\cos\\theta=\n\\cfrac&#123;\\bar&#123;v&#125; \\cdotp \\bar&#123;k&#125;&#125;\n&#123;\\|\\bar&#123;v&#125;\\| \\cdotp \\|\\bar&#123;k&#125;\\|&#125;\n\n</code></pre>\n<p>所以，我们该如何计算点乘呢？点乘是通过将对应分量逐个相乘，然后再把所得积相加来计算的。两个单位向量的（你可以验证它们的长度都为 1）点乘会像是这样：</p>\n<pre><code class=\"language-math\">\\begin&#123;pmatrix&#125;\n   0.6 \\\\\n   -0.8 \\\\\n   0  \\end&#123;pmatrix&#125;\n   \\cdotp\n\\begin&#123;pmatrix&#125;\n   0 \\\\\n   1 \\\\\n   0  \\end&#123;pmatrix&#125;\n   =\n   (0.6∗0)+(−0.8∗1)+(0∗0)=−0.8\n</code></pre>\n<p>要计算两个单位向量间的夹角，我们可以使用反余弦函数:</p>\n<pre><code class=\"language-math\">cos^&#123;-1&#125;\n</code></pre>\n<p>可得结果是 143.1 度。现在我们很快就计算出了这两个向量的夹角。点乘会在计算光照的时候非常有用。</p>\n<h3 id=\"叉乘\"><a class=\"anchor\" href=\"#叉乘\">#</a> 叉乘</h3>\n<p>叉乘只在 3D 空间中有定义，它需要<mark>两个不平行向量</mark>作为输入，生成一个<mark>正交</mark>于两个输入向量的第三个向量。如果输入的两个向量也是正交的，那么叉乘之后将会产生 3 个互相正交的向量。接下来的教程中这会非常有用。下面的图片展示了 3D 空间中叉乘的样子：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/07/vectors_crossproduct.png\" alt=\"image\" /></p>\n<blockquote>\n<p>正交：和另外两个向量垂直</p>\n</blockquote>\n<p>不同于其他运算，如果你没有钻研过线性代数，可能会觉得叉乘很反直觉，所以只记住公式就没问题啦（记不住也没问题）。下面你会看到两个正交向量 A 和 B 叉积：</p>\n<pre><code class=\"language-math\">\n\\begin&#123;pmatrix&#125;\n   A_x \\\\\n   A_y \\\\\n   A_z  \\end&#123;pmatrix&#125;\n   ×\n\\begin&#123;pmatrix&#125;\n   B_x \\\\\n   B_y \\\\\n   B_z  \\end&#123;pmatrix&#125;\n   =\n\\begin&#123;pmatrix&#125;\n   A_y \\cdotp B_z - A_z \\cdotp B_y \\\\\n   A_z \\cdotp B_x - A_x \\cdotp B_z \\\\\n   A_x \\cdotp B_y - A_y \\cdotp B_x  \\end&#123;pmatrix&#125;\n</code></pre>\n<p>是不是看起来毫无头绪？不过只要你按照步骤来了，你就能得到一个正交于两个输入向量的第三个向量。</p>\n<h3 id=\"矩阵\"><a class=\"anchor\" href=\"#矩阵\">#</a> 矩阵</h3>\n<p>现在我们已经讨论了向量的全部内容，是时候看看矩阵了！简单来说矩阵就是一个矩形的数字、符号或表达式数组。矩阵中每一项叫做矩阵的元素 (Element)。下面是一个 2×3 矩阵的例子：</p>\n<pre><code class=\"language-math\">\\begin&#123;bmatrix&#125;\n   1 &amp; 2 &amp; 3 \\\\\n   4 &amp; 5 &amp; 6\n\\end&#123;bmatrix&#125;\n</code></pre>\n<p>矩阵可以通过 (i, j) 进行索引，i 是行，j 是列，这就是上面的矩阵叫做 2×3 矩阵的原因（3 列 2 行，也叫做矩阵的<mark>维度</mark> (Dimension)）。这与你在索引 2D 图像时的 (x, y) 相反，获取 4 的索引是 (2, 1)（第二行，第一列）（译注：如果是图像索引应该是 (1, 2)，先算列，再算行）。</p>\n<p>矩阵基本也就是这些了，它就是一个矩形的数学表达式阵列。和向量一样，矩阵也有非常漂亮的数学属性。矩阵有几个运算，分别是：<mark>矩阵加法、减法和乘法</mark>。</p>\n<p>矩阵与标量之间的加减定义如下：</p>\n<pre><code class=\"language-math\">\\begin&#123;bmatrix&#125;\n   1 &amp; 2  \\\\\n   3 &amp; 4 \n\\end&#123;bmatrix&#125;\n+\n3\n=\n\\begin&#123;bmatrix&#125;\n   1 +3 &amp; 2+3 \\\\\n   3 +3 &amp; 4+3\n\\end&#123;bmatrix&#125;\n=\n\\begin&#123;bmatrix&#125;\n   4 &amp; 5 \\\\\n   6 &amp; 7\n\\end&#123;bmatrix&#125;\n</code></pre>\n<p>标量值要加到矩阵的每一个元素上。矩阵与标量的减法也相似：</p>\n<pre><code class=\"language-math\">\\begin&#123;bmatrix&#125;\n   1 &amp; 2  \\\\\n   3 &amp; 4 \n\\end&#123;bmatrix&#125;\n-3=\n\\begin&#123;bmatrix&#125;\n   1 -3 &amp; 2 -3 \\\\\n   3 -3 &amp; 4 -3\n\\end&#123;bmatrix&#125;\n=\n\\begin&#123;bmatrix&#125;\n   -2 &amp; -1 \\\\\n   0 &amp; 1\n\\end&#123;bmatrix&#125;\n</code></pre>\n<p>矩阵与矩阵之间的加减就是两个矩阵对应元素的加减运算，所以总体的规则和与标量运算是差不多的，只不过在相同索引下的元素才能进行运算。这也就是说加法和减法只对同维度的矩阵才是有定义的。一个 3×2 矩阵和一个 2×3 矩阵（或一个 3×3 矩阵与 4×4 矩阵）是不能进行加减的。我们看看两个 2×2 矩阵是怎样相加的：</p>\n<pre><code class=\"language-math\">\\begin&#123;bmatrix&#125;\n   1 &amp; 2  \\\\\n   3 &amp; 4 \n\\end&#123;bmatrix&#125;+\n\\begin&#123;bmatrix&#125;\n   5 &amp; 6  \\\\\n   7 &amp; 8 \n\\end&#123;bmatrix&#125;\n=\n\\begin&#123;bmatrix&#125;\n   1 + 5 &amp; 2 + 6 \\\\\n   3 + 7 &amp; 4 + 8\n\\end&#123;bmatrix&#125;\n=\n\\begin&#123;bmatrix&#125;\n   4 &amp; 8 \\\\\n   10 &amp; 12\n\\end&#123;bmatrix&#125;\n</code></pre>\n<p>同样的法则也适用于减法：</p>\n<pre><code class=\"language-math\">\\begin&#123;bmatrix&#125;\n   4 &amp; 2  \\\\\n   1 &amp; 6 \n\\end&#123;bmatrix&#125;-\n\\begin&#123;bmatrix&#125;\n   2 &amp; 4  \\\\\n   0 &amp; 1 \n\\end&#123;bmatrix&#125;\n=\n\\begin&#123;bmatrix&#125;\n   4-2 &amp; 2-4 \\\\\n   1-0 &amp; 6-1\n\\end&#123;bmatrix&#125;\n=\n\\begin&#123;bmatrix&#125;\n   2 &amp; -2 \\\\\n   1 &amp; 5\n\\end&#123;bmatrix&#125;\n</code></pre>\n<h3 id=\"矩阵的数乘\"><a class=\"anchor\" href=\"#矩阵的数乘\">#</a> 矩阵的数乘</h3>\n<p>和矩阵与标量的加减一样，矩阵与标量之间的乘法也是矩阵的每一个元素分别乘以该标量。下面的例子展示了乘法的过程：</p>\n<pre><code class=\"language-math\">2\\cdotp\n\\begin&#123;bmatrix&#125;\n   1 &amp; 2  \\\\\n   3 &amp; 4 \n\\end&#123;bmatrix&#125;\n=\n\\begin&#123;bmatrix&#125;\n   2\\cdotp1 &amp; 2\\cdotp2 \\\\\n   2\\cdotp3 &amp; 2\\cdotp4\n\\end&#123;bmatrix&#125;\n=\n\\begin&#123;bmatrix&#125;\n   2 &amp; 4 \\\\\n   6 &amp; 8\n\\end&#123;bmatrix&#125;\n</code></pre>\n<p>现在我们也就能明白为什么这些单独的数字要叫做标量 (Scalar) 了。简单来说，标量就是用它的值缩放 (Scale) 矩阵的所有元素（译注：注意 Scalar 是由 Scale + -ar 演变过来的）。前面那个例子中，所有的元素都被放大了 2 倍。</p>\n<p>到目前为止都还好，我们的例子都不复杂。不过矩阵与矩阵的乘法就不一样了。</p>\n<h3 id=\"矩阵相乘\"><a class=\"anchor\" href=\"#矩阵相乘\">#</a> 矩阵相乘</h3>\n<p>矩阵之间的乘法不见得有多复杂，但的确很难让人适应。矩阵乘法基本上意味着遵照规定好的法则进行相乘。当然，相乘还有一些限制：</p>\n<ul>\n<li>只有当左侧矩阵的列数与右侧矩阵的行数相等，两个矩阵才能相乘。</li>\n<li>矩阵相乘不遵守交换律 (Commutative)，也就是说 A⋅B≠B⋅A。</li>\n</ul>\n<p>我们先看一个两个 2×2 矩阵相乘的例子：</p>\n<pre><code class=\"language-math\">\\begin&#123;bmatrix&#125;\n   1 &amp; 2  \\\\\n   3 &amp; 4 \n\\end&#123;bmatrix&#125;\n\\cdotp\n\\begin&#123;bmatrix&#125;\n   5 &amp; 6  \\\\\n   7 &amp; 8 \n\\end&#123;bmatrix&#125;\n=\n\\begin&#123;bmatrix&#125;\n   1\\cdotp5+2\\cdotp7 &amp; 1\\cdotp6+2\\cdotp8 \\\\\n   3\\cdotp5+4\\cdotp7 &amp; 3\\cdotp6+4\\cdotp8 \n\\end&#123;bmatrix&#125;\n=\n\\begin&#123;bmatrix&#125;\n   19 &amp; 22 \\\\\n   43 &amp; 50\n\\end&#123;bmatrix&#125;\n</code></pre>\n<p>现在你可能会在想了：天哪，刚刚到底发生了什么？矩阵的乘法是一系列乘法和加法组合的结果，它使用到了左侧矩阵的行和右侧矩阵的列。我们可以看下面的图片：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/07/matrix_multiplication.png\" alt=\"image\" /></p>\n<h3 id=\"矩阵与向量相乘\"><a class=\"anchor\" href=\"#矩阵与向量相乘\">#</a> 矩阵与向量相乘</h3>\n<p>目前为止，通过这些教程我们已经相当了解向量了。我们用向量来表示位置，表示颜色，甚至是纹理坐标。让我们更深入了解一下向量，它其实就是一个 N×1 矩阵，N 表示向量分量的个数（也叫 N 维 (N-dimensional) 向量）。如果你仔细思考一下就会明白。向量和矩阵一样都是一个数字序列，但它只有 1 列。那么，这个新的定义对我们有什么帮助呢？如果我们有一个 M×N 矩阵，我们可以用这个矩阵乘以我们的 N×1 向量，因为这个矩阵的列数等于向量的行数，所以它们就能相乘。</p>\n<p>但是为什么我们会关心矩阵能否乘以一个向量？好吧，正巧，很多有趣的 2D/3D 变换都可以放在一个矩阵中，用这个矩阵乘以我们的向量将<mark>变换</mark> (Transform) 这个向量。如果你仍然有些困惑，我们来看一些例子，你很快就能明白了。</p>\n<h3 id=\"单位矩阵\"><a class=\"anchor\" href=\"#单位矩阵\">#</a> 单位矩阵</h3>\n<p>在 OpenGL 中，由于某些原因我们通常使用 4×4 的变换矩阵，而其中最重要的原因就是大部分的向量都是<mark> 4 分量</mark>的。我们能想到的最简单的变换矩阵就是单位矩阵 (Identity Matrix)。单位矩阵是一个除了对角线以外都是 0 的 N×N 矩阵。在下式中可以看到，这种变换矩阵使一个向量完全不变：</p>\n<pre><code class=\"language-math\">\\begin&#123;bmatrix&#125;\n   1 &amp; 0  &amp; 0  &amp; 0  \\\\\n   0 &amp; 1  &amp; 0  &amp; 0  \\\\\n   0 &amp; 0  &amp; 1  &amp; 0  \\\\\n   0 &amp; 0  &amp; 0  &amp; 1  \n\\end&#123;bmatrix&#125;\n\\cdotp\n\\begin&#123;bmatrix&#125;\n   1 \\\\\n   2 \\\\\n   3 \\\\\n   4 \n\\end&#123;bmatrix&#125;\n=\n\\begin&#123;bmatrix&#125;\n     1\\cdotp1 \\\\\n   1\\cdotp2 \\\\\n   1\\cdotp3 \\\\\n   1\\cdotp4 \n\\end&#123;bmatrix&#125;\n=\n\\begin&#123;bmatrix&#125;\n   1 \\\\\n   2 \\\\\n   3 \\\\\n   4 \n\\end&#123;bmatrix&#125;\n</code></pre>\n<h3 id=\"缩放\"><a class=\"anchor\" href=\"#缩放\">#</a> 缩放</h3>\n<p>对一个向量进行缩放 (Scaling) 就是对向量的长度进行缩放，而保持它的方向不变。由于我们进行的是 2 维或 3 维操作，我们可以分别定义一个有 2 或 3 个缩放变量的向量，每个变量缩放一个轴 (x、y 或 z)。</p>\n<p>我们先来尝试缩放向量 v=(3,2)。我们可以把向量沿着 x 轴缩放 0.5，使它的宽度缩小为原来的二分之一；我们将沿着 y 轴把向量的高度缩放为原来的两倍。我们看看把向量缩放 (0.5, 2) 倍所获得的 s 是什么样的：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/07/vectors_scale.png\" alt=\"image\" /></p>\n<p>我们刚刚的缩放操作是<mark>不均匀</mark> (Non-uniform) 缩放，因为每个轴的缩放因子 (Scaling Factor) 都不一样。如果每个轴的缩放因子都一样那么就叫<mark>均匀缩放</mark> (Uniform Scale)。</p>\n<p>我们下面会构造一个变换矩阵来为我们提供缩放功能。我们从单位矩阵了解到，每个对角线元素会分别与向量的对应元素相乘。如果我们把 1 变为 3 会怎样？这样子的话，我们就把向量的每个元素乘以 3 了，这事实上就把向量缩放 3 倍。如果我们把缩放变量表示为 (S1,S2,S3) 我们可以为任意向量 (x,y,z) 定义一个缩放矩阵：</p>\n<pre><code class=\"language-math\">\\begin&#123;bmatrix&#125;\n   S_1 &amp; 0  &amp; 0  &amp; 0  \\\\\n   0 &amp; S_2  &amp; 0  &amp; 0  \\\\\n   0 &amp; 0  &amp; S_3  &amp; 0  \\\\\n   0 &amp; 0  &amp; 0  &amp; 1  \n\\end&#123;bmatrix&#125;\n\\cdotp\n\\begin&#123;pmatrix&#125;\n   x \\\\\n   y \\\\\n   z \\\\\n   1 \n\\end&#123;pmatrix&#125;\n=\n\\begin&#123;pmatrix&#125;\n   S_1\\cdotp x\\\\\n   S_2\\cdotp y \\\\\n   S_3\\cdotp z \\\\\n   1 \n\\end&#123;pmatrix&#125;\n</code></pre>\n<p>注意，第四个缩放向量仍然是 1，因为在 3D 空间中缩放 w 分量是无意义的。w 分量另有其他用途，在后面我们会看到。</p>\n<h3 id=\"位移\"><a class=\"anchor\" href=\"#位移\">#</a> 位移</h3>\n<p>和缩放矩阵一样，在 4×4 矩阵上有几个特别的位置用来执行特定的操作，对于位移来说它们是第四列最上面的 3 个值。如果我们把位移向量表示为 (Tx,Ty,Tz)，我们就能把位移矩阵定义为：</p>\n<pre><code class=\"language-math\">\\begin&#123;bmatrix&#125;\n   1 &amp; 0  &amp; 0  &amp; T_x  \\\\\n   0 &amp; 1  &amp; 0  &amp; T_y  \\\\\n   0 &amp; 0  &amp; 1  &amp; T_z  \\\\\n   0 &amp; 0  &amp; 0  &amp; 1  \n\\end&#123;bmatrix&#125;\n\\cdotp\n\\begin&#123;pmatrix&#125;\n   x \\\\\n   y \\\\\n   z \\\\\n   1 \n\\end&#123;pmatrix&#125;\n=\n\\begin&#123;pmatrix&#125;\n   x+T_x\\\\\n   y+T_y \\\\\n   z+T_z \\\\\n   1 \n\\end&#123;pmatrix&#125;\n</code></pre>\n<blockquote>\n<p><strong>齐次坐标</strong> (Homogeneous Coordinates)</p>\n</blockquote>\n<blockquote>\n<p>向量的 w 分量也叫齐次坐标。想要从齐次向量得到 3D 向量，我们可以把 x、y 和 z 坐标分别除以 w 坐标。我们通常不会注意这个问题，因为 w 分量通常是 1.0。使用齐次坐标有几点好处：它允许我们在 3D 向量上进行位移（如果没有 w 分量我们是不能位移向量的），而且下一章我们会用 w 值创建 3D 视觉效果。</p>\n</blockquote>\n<blockquote>\n<p>如果一个向量的齐次坐标是 0，这个坐标就是方向向量 (Direction Vector)，因为 w 坐标是 0，这个向量就不能位移（译注：这也就是我们说的不能位移一个方向） 。</p>\n</blockquote>\n<h3 id=\"旋转\"><a class=\"anchor\" href=\"#旋转\">#</a> 旋转</h3>\n<blockquote>\n<p>大多数旋转函数需要用弧度制的角，但幸运的是角度制的角也可以很容易地转化为弧度制的：</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>弧度转角度：角度 = 弧度 * (180.0f / PI)</li>\n<li>角度转弧度：弧度 = 角度 * (PI / 180.0f)</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>PI 约等于 3.14159265359。</p>\n</blockquote>\n<p>转半圈会旋转 360/2 = 180 度，向右旋转 1/5 圈表示向右旋转 360/5 = 72 度。下图中展示的 2D 向量 v 是由 k 向右旋转 72 度所得的：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/07/vectors_angle.png\" alt=\"image\" /></p>\n<p>在 3D 空间中旋转需要定义一个<mark>角</mark>和一个<mark>旋转轴</mark> (Rotation Axis)。物体会沿着给定的旋转轴旋转特定角度。如果你想要更形象化的感受，可以试试向下看着一个特定的旋转轴，同时将你的头部旋转一定角度。当 2D 向量在 3D 空间中旋转时，我们把旋转轴设为 z 轴（尝试想象这种情况）。</p>\n<p>旋转矩阵在 3D 空间中每个单位轴都有不同定义，旋转角度用 θ 表示：</p>\n<p>沿 x 轴旋转：</p>\n<pre><code class=\"language-math\">\\begin&#123;bmatrix&#125;\n   1 &amp; 0  &amp; 0  &amp; 0  \\\\\n   0 &amp; \\cos\\theta  &amp; -\\sin\\theta  &amp; 0  \\\\\n   0 &amp; \\sin\\theta  &amp; \\cos\\theta  &amp; 0  \\\\\n   0 &amp; 0  &amp; 0  &amp; 1  \n\\end&#123;bmatrix&#125;\n\\cdotp\n\\begin&#123;pmatrix&#125;\n   x \\\\\n   y \\\\\n   z \\\\\n   1 \n\\end&#123;pmatrix&#125;\n=\n\\begin&#123;pmatrix&#125;\n    x\\\\\n   \\cos\\theta\\cdotp y-\\sin\\theta\\cdotp z \\\\\n   \\sin\\theta\\cdotp y +\\cos\\theta\\cdotp z\\\\\n   1 \n\\end&#123;pmatrix&#125;\n</code></pre>\n<p>沿 y 轴旋转：</p>\n<pre><code class=\"language-math\">\\begin&#123;bmatrix&#125;\n   \\cos\\theta &amp; 0  &amp; \\sin\\theta  &amp; 0  \\\\\n   0 &amp; 1  &amp; 0  &amp; 0  \\\\\n   -\\sin\\theta  &amp; 0 &amp; \\cos\\theta  &amp; 0  \\\\\n   0 &amp; 0  &amp; 0  &amp; 1  \n\\end&#123;bmatrix&#125;\n\\cdotp\n\\begin&#123;pmatrix&#125;\n   x \\\\\n   y \\\\\n   z \\\\\n   1 \n\\end&#123;pmatrix&#125;\n=\n\\begin&#123;pmatrix&#125;\n   \\cos\\theta\\cdotp x-\\sin\\theta\\cdotp y \\\\\n   y\\\\\n   -\\sin\\theta\\cdotp x +\\cos\\theta\\cdotp y\\\\\n   1 \n\\end&#123;pmatrix&#125;\n</code></pre>\n<p>沿 z 轴旋转：</p>\n<pre><code class=\"language-math\">\\begin&#123;bmatrix&#125;\n   \\cos\\theta &amp; -\\sin\\theta  &amp; 0  &amp; 0  \\\\\n   \\sin\\theta &amp; \\cos\\theta  &amp; 0  &amp; 0  \\\\\n   0 &amp; 0  &amp; 1  &amp; 0  \\\\\n   0 &amp; 0  &amp; 0  &amp; 1  \n\\end&#123;bmatrix&#125;\n\\cdotp\n\\begin&#123;pmatrix&#125;\n   x \\\\\n   y \\\\\n   z \\\\\n   1 \n\\end&#123;pmatrix&#125;\n=\n\\begin&#123;pmatrix&#125;\n   \\cos\\theta\\cdotp x-\\sin\\theta\\cdotp y \\\\\n   \\sin\\theta\\cdotp x +\\cos\\theta\\cdotp y\\\\\n   z\\\\\n   1 \n\\end&#123;pmatrix&#125;\n</code></pre>\n<p>利用旋转矩阵我们可以把任意位置向量沿一个单位旋转轴进行旋转。也可以将多个矩阵复合，比如先沿着 x 轴旋转再沿着 y 轴旋转。但是这会很快导致一个问题 ——<mark> 万向节死锁</mark>（Gimbal Lock，可以看看这个<span class=\"exturl\" data-url=\"aHR0cHM6Ly92LnlvdWt1LmNvbS92X3Nob3cvaWRfWE56a3lPVEl5TVRJPS5odG1s\">视频（优酷）</span>来了解）。在这里我们不会讨论它的细节，但是对于 3D 空间中的旋转，一个更好的模型是沿着任意的一个轴，比如单位向量<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>0.662</mn><mo separator=\"true\">,</mo><mn>0.2</mn><mo separator=\"true\">,</mo><mn>0.7222</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(0.662, 0.2, 0.7222)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mord\">.</span><span class=\"mord\">6</span><span class=\"mord\">6</span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">0</span><span class=\"mord\">.</span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">0</span><span class=\"mord\">.</span><span class=\"mord\">7</span><span class=\"mord\">2</span><span class=\"mord\">2</span><span class=\"mord\">2</span><span class=\"mclose\">)</span></span></span></span> 旋转，而不是对一系列旋转矩阵进行复合。这样的一个（超级麻烦的）矩阵是存在的，见下面这个公式，其中 (Rx,Ry,Rz) 代表任意旋转轴：</p>\n<pre><code class=\"language-math\">\\begin&#123;bmatrix&#125;\n\\cos\\theta+&#123;R_x&#125;^2(1-\\cos\\theta) &amp;\nR_xR_y(1-\\cos\\theta)-R_z\\sin\\theta &amp;\nR_xR_y(1-cos\\theta)+R_y\\sin\\theta &amp;\n0\n\\\\\nR_yR_z(1-\\cos\\theta)+R_z\\sin\\theta &amp;\n\\cos\\theta+&#123;R_y&#125;^2(1-\\cos\\theta) &amp;\nR_yR_z(1-cos\\theta)-R_z\\sin\\theta &amp;\n0\n\\\\\nR_zR_x(1-\\cos\\theta)-R_y\\sin\\theta &amp;\nR_zR_y(1-cos\\theta)+R_x\\sin\\theta &amp;\n\\cos\\theta+&#123;R_z&#125;^2(1-\\cos\\theta) &amp;\n0\n\\\\\n0 &amp; 0 &amp; 0 &amp; 1\n\\end&#123;bmatrix&#125;\n</code></pre>\n<p>避免万向节死锁的真正解决方案是使用<mark>四元数</mark> (Quaternion)，它不仅更安全，而且计算会更有效率。四元数可能会在后面的教程中讨论。</p>\n<blockquote>\n<p>对四元数的理解会用到非常多的数学知识。如果你想了解四元数与 3D 旋转之间的关系，可以来阅读我的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9rcmFzamV0LmdpdGh1Yi5pby9xdWF0ZXJuaW9uL3F1YXRlcm5pb24ucGRm\">教程</span>。如果你对万向节死锁的概念仍不是那么清楚，可以来阅读我教程的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9rcmFzamV0LmdpdGh1Yi5pby9xdWF0ZXJuaW9uL2JvbnVzX2dpbWJhbF9sb2NrLnBkZg==\"> Bonus 章节</span>。</p>\n</blockquote>\n<blockquote>\n<p>现在 3Blue1Brown 也已经开始了一个四元数的视频系列，他采用球极平面投影 (Stereographic Projection) 的方式将四元数投影到 3D 空间，同样有助于理解四元数的概念（仍在更新中）：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1kNEVnYmdUbTBCZw==\">https://www.youtube.com/watch?v=d4EgbgTm0Bg</span></p>\n</blockquote>\n<h3 id=\"矩阵的组合\"><a class=\"anchor\" href=\"#矩阵的组合\">#</a> 矩阵的组合</h3>\n<pre><code class=\"language-math\">Trans.Scale=\n\\begin&#123;bmatrix&#125;\n1 &amp; 0 &amp; 0 &amp; 1 \\\\\n0 &amp; 1 &amp; 0 &amp; 2 \\\\\n0 &amp; 0 &amp; 1 &amp; 3 \\\\\n0 &amp; 0 &amp; 0 &amp; 1\n\\end&#123;bmatrix&#125;\n\\cdotp\n\\begin&#123;bmatrix&#125;\n2 &amp; 0 &amp; 0 &amp; 0 \\\\\n0 &amp; 2 &amp; 0 &amp; 0 \\\\\n0 &amp; 0 &amp; 2 &amp; 0 \\\\\n0 &amp; 0 &amp; 0 &amp; 1\n\\end&#123;bmatrix&#125;\n=\n\\begin&#123;bmatrix&#125;\n2 &amp; 0 &amp; 0 &amp; 1 \\\\\n0 &amp; 2 &amp; 0 &amp; 2 \\\\\n0 &amp; 0 &amp; 2 &amp; 3 \\\\\n0 &amp; 0 &amp; 0 &amp; 1\n\\end&#123;bmatrix&#125;\n</code></pre>\n<p><mark>注意</mark>，当矩阵相乘时我们<strong>先</strong>写<mark>位移</mark><strong>再</strong>写<mark>缩放变换</mark>的。矩阵乘法是不遵守交换律的，这意味着它们的顺序很重要。当矩阵相乘时，在最右边的矩阵是第一个与向量相乘的，所以你应该从右向左读这个乘法。建议您在组合矩阵时，<strong>先</strong>进行<mark>缩放</mark>操作，然后是<mark>旋转</mark>，<strong>最后</strong>才是<mark>位移</mark>，否则它们会（消极地）互相影响。比如，如果你先位移再缩放，位移的向量也会同样被缩放（译注：比如向某方向移动 2 米，2 米也许会被缩放成 1 米）！</p>\n<p>用最终的变换矩阵左乘我们的向量会得到以下结果：</p>\n<pre><code class=\"language-math\">\\begin&#123;bmatrix&#125;\n2 &amp; 0 &amp; 0 &amp; 1 \\\\\n0 &amp; 2 &amp; 0 &amp; 2 \\\\\n0 &amp; 0 &amp; 2 &amp; 3 \\\\\n0 &amp; 0 &amp; 0 &amp; 1\n\\end&#123;bmatrix&#125;\n\\cdotp\n\\begin&#123;bmatrix&#125;\nx  \\\\\ny  \\\\\nz  \\\\\n1 \n\\end&#123;bmatrix&#125;\n=\n\\begin&#123;bmatrix&#125;\n2x+1 \\\\\n2y+2 \\\\\n2z+3 \\\\\n1 \n\\end&#123;bmatrix&#125;\n</code></pre>\n<h3 id=\"实践\"><a class=\"anchor\" href=\"#实践\">#</a> 实践</h3>\n<h3 id=\"glm\"><a class=\"anchor\" href=\"#glm\">#</a> GLM</h3>\n<p>GLM 是 OpenGL Mathematics 的缩写，它是一个只有头文件的库，也就是说我们只需包含对应的头文件就行了，不用链接和编译。GLM 可以在它们的网站上<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zb3VyY2Vmb3JnZS5uZXQvcHJvamVjdHMvb2dsLW1hdGgvZmlsZXMvbGF0ZXN0L2Rvd25sb2Fk\">下载</span>。把头文件的根目录复制到你的 includes 文件夹，然后你就可以使用这个库了。</p>\n<p>我们需要的 GLM 的大多数功能都可以从下面这 3 个头文件中找到：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;glm/glm.hpp></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;glm/gtc/matrix_transform.hpp></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;glm/gtc/type_ptr.hpp></span></span></pre></td></tr></table></figure><p>我们来看看是否可以利用我们刚学的变换知识把一个向量 (1, 0, 0) 位移 (1, 1, 0) 个单位（注意，我们把它定义为一个 glm::vec4 类型的值，齐次坐标设定为 1.0）：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span>vec4 <span class=\"token function\">vec</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// 译注：下面就是矩阵初始化的一个例子，如果使用的是 0.9.9 及以上版本</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// 下面这行代码就需要改为:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// glm::mat4 trans = glm::mat4(1.0f)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// 之后将不再进行提示</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>glm<span class=\"token operator\">::</span>mat4 trans<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>trans <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">translate</span><span class=\"token punctuation\">(</span>trans<span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>vec <span class=\"token operator\">=</span> trans <span class=\"token operator\">*</span> vec<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> vec<span class=\"token punctuation\">.</span>x <span class=\"token operator\">&lt;&lt;</span> vec<span class=\"token punctuation\">.</span>y <span class=\"token operator\">&lt;&lt;</span> vec<span class=\"token punctuation\">.</span>z <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>我们先用 GLM 内建的向量类定义一个叫做<mark> vec</mark> 的向量。接下来定义一个 mat4 类型的 trans，默认是一个 4×4 单位矩阵。下一步是创建一个变换矩阵，我们是把单位矩阵和一个位移向量传递给 glm::translate 函数来完成这个工作的（然后用给定的矩阵乘以位移矩阵就能获得最后需要的矩阵）。<br />\n之后我们把向量乘以位移矩阵并且输出最后的结果。如果你仍记得位移矩阵是如何工作的话，得到的向量应该是 (1 + 1, 0 + 1, 0 + 0)，也就是 (2, 1, 0)。这个代码片段将会输出 210，所以这个位移矩阵是正确的。</p>\n<p>我们来做些更有意思的事情，让我们来旋转和缩放之前教程中的那个箱子。首先我们把箱子逆时针旋转 90 度。然后缩放 0.5 倍，使它变成原来的一半大。我们先来创建变换矩阵：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span>mat4 trans<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>trans <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">rotate</span><span class=\"token punctuation\">(</span>trans<span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">radians</span><span class=\"token punctuation\">(</span><span class=\"token number\">90.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>trans <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">scale</span><span class=\"token punctuation\">(</span>trans<span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>首先，我们把箱子在每个轴都缩放到 0.5 倍，然后沿 z 轴旋转 90 度。GLM 希望它的角度是弧度制的 (Radian)，所以我们使用 glm::radians 将角度转化为弧度。注意有纹理的那面矩形是在 XY 平面上的，所以我们需要把它绕着 z 轴旋转。因为我们把这个矩阵传递给了 GLM 的每个函数，GLM 会自动将矩阵相乘，返回的结果是一个包括了多个变换的变换矩阵。</p>\n<p>下一个大问题是：如何把矩阵传递给着色器？我们在前面简单提到过 GLSL 里也有一个 mat4 类型。所以我们将修改顶点着色器让其接收一个 mat4 的 uniform 变量，然后再用矩阵 uniform 乘以位置向量：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> in vec3 aPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> in vec2 aTexCoord<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>out vec2 TexCoord<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>uniform mat4 transform<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> transform <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>aPos<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    TexCoord <span class=\"token operator\">=</span> <span class=\"token function\">vec2</span><span class=\"token punctuation\">(</span>aTexCoord<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span> <span class=\"token operator\">-</span> aTexCoord<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在把位置向量传给 gl_Position 之前，我们先添加一个 uniform，并且将其与变换矩阵相乘。我们的箱子现在应该是原来的二分之一大小并（向左）旋转了 90 度。当然，我们仍需要把变换矩阵传递给着色器：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> transformLoc <span class=\"token operator\">=</span> <span class=\"token function\">glGetUniformLocation</span><span class=\"token punctuation\">(</span>ourShader<span class=\"token punctuation\">.</span>ID<span class=\"token punctuation\">,</span> <span class=\"token string\">\"transform\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glUniformMatrix4fv</span><span class=\"token punctuation\">(</span>transformLoc<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">value_ptr</span><span class=\"token punctuation\">(</span>trans<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>我们首先查询 uniform 变量的地址，然后用有 Matrix4fv 后缀的 glUniform 函数把矩阵数据发送给着色器。第一个参数你现在应该很熟悉了，它是 uniform 的位置值。第二个参数告诉 OpenGL 我们将要发送多少个矩阵，这里是 1。第三个参数询问我们我们是否希望对我们的矩阵进行置换 (Transpose)，也就是说交换我们矩阵的行和列。OpenGL 开发者通常使用一种内部矩阵布局，叫做列主序 (Column-major Ordering) 布局。GLM 的默认布局就是列主序，所以并不需要置换矩阵，我们填 GL_FALSE。最后一个参数是真正的矩阵数据，但是 GLM 并不是把它们的矩阵储存为 OpenGL 所希望接受的那种，因此我们要先用 GLM 的自带的函数 value_ptr 来变换这些数据。</p>\n<p>我们创建了一个变换矩阵，在顶点着色器中声明了一个 uniform，并把矩阵发送给了着色器，着色器会变换我们的顶点坐标。最后的结果应该看起来像这样：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/07/transformations.png\" alt=\"image\" /></p>\n<p>完美！我们的箱子向左侧旋转，并是原来的一半大小，所以变换成功了。我们现在做些更有意思的，看看我们是否可以让箱子随着时间旋转，我们还会重新把箱子放在窗口的右下角。要让箱子随着时间推移旋转，我们必须在游戏循环中更新变换矩阵，因为它在每一次渲染迭代中都要更新。我们使用 GLFW 的时间函数来获取不同时间的角度：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span>mat4 trans<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>trans <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">translate</span><span class=\"token punctuation\">(</span>trans<span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>trans <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">rotate</span><span class=\"token punctuation\">(</span>trans<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span><span class=\"token function\">glfwGetTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h2 id=\"坐标系统\"><a class=\"anchor\" href=\"#坐标系统\">#</a> 坐标系统</h2>\n<p>在上一个教程中，我们学习了如何有效地利用矩阵的变换来对所有顶点进行变换。OpenGL 希望在每次顶点着色器运行后，我们可见的所有顶点都为<mark>标准化设备坐标</mark> (Normalized Device Coordinate, NDC)。也就是说，<mark>每个顶点的 x，y，z 坐标都应该在 - 1.0 到 1.0 之间</mark>，超出这个坐标范围的顶点都将不可见。我们通常会自己设定一个坐标的范围，之后再在顶点着色器中将这些坐标变换为标准化设备坐标。然后将这些标准化设备坐标传入光栅器 (Rasterizer)，将它们变换为屏幕上的二维坐标或像素。</p>\n<p>将坐标变换为标准化设备坐标，接着再转化为屏幕坐标的过程通常是分步进行的，也就是类似于流水线那样子。在流水线中，物体的顶点在最终转化为屏幕坐标之前还会被变换到多个坐标系统 (Coordinate System)。将物体的坐标变换到几个过渡坐标系 (Intermediate Coordinate System) 的优点在于，在这些特定的坐标系统中，一些操作或运算更加方便和容易，这一点很快就会变得很明显。对我们来说比较重要的总共有 5 个不同的坐标系统：</p>\n<ul>\n<li>局部空间 (Local Space，或者称为物体空间 (Object Space))</li>\n<li>世界空间 (World Space)</li>\n<li>观察空间 (View Space，或者称为视觉空间 (Eye Space))</li>\n<li>裁剪空间 (Clip Space)</li>\n<li>屏幕空间 (Screen Space)</li>\n</ul>\n<h3 id=\"概述\"><a class=\"anchor\" href=\"#概述\">#</a> 概述</h3>\n<p>为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是<mark>模型</mark> (Model)、<mark>观察</mark> (View)、<mark>投影</mark> (Projection) 三个矩阵。我们的顶点坐标起始于<mark>局部空间</mark> (Local Space)，在这里它称为<mark>局部坐标</mark> (Local Coordinate)，它在之后会变为<mark>世界坐标</mark> (World Coordinate)，<mark>观察坐标</mark> (View Coordinate)，<mark>裁剪坐标</mark> (Clip Coordinate)，并最后以<mark>屏幕坐标</mark> (Screen Coordinate) 的形式结束。下面的这张图展示了整个流程以及各个变换过程做了什么：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/08/coordinate_systems.png\" alt=\"image\" /></p>\n<ul>\n<li>局部坐标是对象相对于局部原点的坐标，也是物体<mark>起始的坐标</mark>。</li>\n<li>下一步是将局部坐标变换为世界空间坐标，世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其它物体一起相对于世界的原点进行摆放。</li>\n<li>接下来我们将世界坐标变换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的。</li>\n<li>坐标到达观察空间之后，我们需要将其投影到裁剪坐标。裁剪坐标会被处理至 - 1.0 到 1.0 的范围内，并判断哪些顶点将会出现在屏幕上。</li>\n<li>最后，我们将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换 (Viewport Transform) 的过程。视口变换将位于 - 1.0 到 1.0 范围的坐标变换到由 glViewport 函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段。</li>\n</ul>\n<p>你可能已经大致了解了每个坐标空间的作用。我们之所以将顶点变换到各个不同的空间的原因是有些操作在特定的坐标系统中才有意义且更方便。例如，当需要对物体进行修改的时候，在局部空间中来操作会更说得通；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等。如果我们愿意，我们也可以定义一个直接从局部空间变换到裁剪空间的变换矩阵，但那样会失去很多灵活性。</p>\n<h3 id=\"局部空间\"><a class=\"anchor\" href=\"#局部空间\">#</a> 局部空间</h3>\n<p>局部空间是指物体所在的坐标空间，即对象最开始所在的地方。想象你在一个建模软件（比如说 Blender）中创建了一个立方体。你创建的立方体的原点有可能位于 (0, 0, 0)，即便它有可能最后在程序中处于完全不同的位置。甚至有可能你创建的所有模型都以 (0, 0, 0) 为初始位置（译注：然而它们会最终出现在世界的不同位置）。所以，你的模型的所有顶点都是在局部空间中：它们相对于你的物体来说都是局部的。</p>\n<p>我们一直使用的那个箱子的顶点是被设定在 - 0.5 到 0.5 的坐标范围中，(0, 0) 是它的原点。这些都是局部坐标。</p>\n<h3 id=\"世界空间\"><a class=\"anchor\" href=\"#世界空间\">#</a> 世界空间</h3>\n<p>如果我们将我们所有的物体导入到程序当中，它们有可能会全挤在世界的原点 (0, 0, 0) 上，这并不是我们想要的结果。我们想为每一个物体定义一个位置，从而能在更大的世界当中放置它们。世界空间中的坐标正如其名：是指顶点相对于（游戏）世界的坐标。如果你希望将物体分散在世界上摆放（特别是非常真实的那样），这就是你希望物体变换到的空间。物体的坐标将会从局部变换到世界空间；该变换是由模型矩阵 (Model Matrix) 实现的。</p>\n<p>模型矩阵是一种变换矩阵，它能通过对物体进行位移、缩放、旋转来将它置于它本应该在的位置或朝向。你可以将它想像为变换一个房子，你需要先将它缩小（它在局部空间中太大了），并将其位移至郊区的一个小镇，然后在 y 轴上往左旋转一点以搭配附近的房子。你也可以把上一节将箱子到处摆放在场景中用的那个矩阵大致看作一个模型矩阵；我们将箱子的局部坐标变换到场景 / 世界中的不同位置。</p>\n<h3 id=\"观察空间\"><a class=\"anchor\" href=\"#观察空间\">#</a> 观察空间</h3>\n<p>观察空间经常被人们称之<mark> OpenGL 的摄像机</mark> (Camera)（所以有时也称为摄像机空间 (Camera Space) 或视觉空间 (Eye Space)）。观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果。因此观察空间就是从摄像机的视角所观察到的空间。而这通常是由一系列的位移和旋转的组合来完成，平移 / 旋转场景从而使得特定的对象被变换到摄像机的前方。这些组合在一起的变换通常存储在一个观察矩阵 (View Matrix) 里，它被用来将世界坐标变换到观察空间。在下一节中我们将深入讨论如何创建一个这样的观察矩阵来模拟一个摄像机。</p>\n<h3 id=\"裁剪空间\"><a class=\"anchor\" href=\"#裁剪空间\">#</a> 裁剪空间</h3>\n<p>在一个顶点着色器运行的最后，OpenGL 期望所有的坐标都能落在一个特定的范围内，<mark>且任何在这个范围之外的点都应该被裁剪掉 (Clipped)。被裁剪掉的坐标就会被忽略</mark>，所以剩下的坐标就将变为屏幕上可见的片段。这也就是裁剪空间 (Clip Space) 名字的由来。</p>\n<p>因为将所有可见的坐标都指定在 - 1.0 到 1.0 的范围内不是很直观，所以我们会指定自己的坐标集 (Coordinate Set) 并将它变换回标准化设备坐标系，就像 OpenGL 期望的那样。</p>\n<p>为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个投影矩阵 (Projection Matrix)，它指定了一个范围的坐标，比如在每个维度上的 - 1000 到 1000。投影矩阵接着会将在这个指定的范围内的坐标变换为标准化设备坐标的范围 (-1.0, 1.0)。所有在范围外的坐标不会被映射到在 - 1.0 到 1.0 的范围之间，所以会被裁剪掉。在上面这个投影矩阵所指定的范围内，坐标 (1250, 500, 750) 将是不可见的，这是由于它的 x 坐标超出了范围，它被转化为一个大于 1.0 的标准化设备坐标，所以被裁剪掉了。</p>\n<blockquote>\n<p>如果只是图元 (Primitive)，例如三角形，的一部分超出了裁剪体积 (Clipping Volume)，则 OpenGL 会重新构建这个三角形为一个或多个三角形让其能够适合这个裁剪范围。</p>\n</blockquote>\n<p>由投影矩阵创建的<mark>观察箱</mark> (Viewing Box) 被称为平截头体 (Frustum)，每个出现在平截头体范围内的坐标都会最终出现在用户的屏幕上。将特定范围内的坐标转化到标准化设备坐标系的过程（而且它很容易被映射到 2D 观察空间坐标）被称之为<mark>投影</mark> (Projection)，因为使用投影矩阵能将 3D 坐标投影 (Project) 到很容易映射到 2D 的标准化设备坐标系中。</p>\n<p>一旦所有顶点被变换到裁剪空间，最终的操作 ——<mark> 透视除法</mark> (Perspective Division) 将会执行，在这个过程中我们将位置向量的 x，y，z 分量分别除以向量的齐次 w 分量；<mark>透视除法是将 4D 裁剪空间坐标变换为 3D 标准化设备坐标的过程</mark>。这一步会在每一个顶点着色器运行的最后被自动执行。</p>\n<p>在这一阶段之后，最终的坐标将会被映射到屏幕空间中（使用 glViewport 中的设定），并被变换成片段。</p>\n<p>将观察坐标变换为裁剪坐标的投影矩阵可以为两种不同的形式，每种形式都定义了不同的平截头体。我们可以选择创建一个<mark>正射投影矩阵</mark> (Orthographic Projection Matrix) 或一个<mark>透视投影矩阵</mark> (Perspective Projection Matrix)。</p>\n<blockquote>\n<p>既：<mark>正交摄像机</mark>和<mark>透视摄像机</mark></p>\n</blockquote>\n<h3 id=\"正射投影\"><a class=\"anchor\" href=\"#正射投影\">#</a> 正射投影</h3>\n<p>正射投影矩阵定义了一个类似立方体的平截头箱，它定义了一个裁剪空间，在这空间之外的顶点都会被裁剪掉。创建一个正射投影矩阵需要指定可见平截头体的宽、高和长度。在使用正射投影矩阵变换至裁剪空间之后处于这个平截头体内的所有坐标将不会被裁剪掉。它的平截头体看起来像一个容器：<br />\n<img data-src=\"https://learnopengl-cn.github.io/img/01/08/orthographic_frustum.png\" alt=\"image\" /></p>\n<p>上面的平截头体定义了可见的坐标，它由由宽、高、近 (Near) 平面和远 (Far) 平面所指定。任何出现在近平面之前或远平面之后的坐标都会被裁剪掉。正射平截头体直接将平截头体内部的所有坐标映射为标准化设备坐标，因为每个向量的 w 分量都没有进行改变；如果 w 分量等于 1.0，透视除法则不会改变这个坐标。</p>\n<p>要创建一个正射投影矩阵，我们可以使用 GLM 的内置函数 glm::ortho：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span><span class=\"token function\">ortho</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">800.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">600.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.1f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><ul>\n<li>前两个参数指定了平截头体的左右坐标</li>\n<li>第三和第四参数指定了平截头体的底部和顶部。</li>\n<li>然后第五和第六个参数则定义了近平面和远平面的距离。</li>\n</ul>\n<p>通过前四个参数我们定义了近平面和远平面的大小，这个投影矩阵会将处于这些 x，y，z 值范围内的坐标变换为标准化设备坐标。</p>\n<p>正射投影矩阵直接将坐标映射到 2D 平面中，即你的屏幕，但实际上一个直接的投影矩阵会产生不真实的结果，因为这个投影没有<mark>将透视 (Perspective) 考虑进去</mark>。所以我们需要透视投影矩阵来解决这个问题。</p>\n<h3 id=\"透视投影\"><a class=\"anchor\" href=\"#透视投影\">#</a> 透视投影</h3>\n<p>如果你曾经体验过实际生活给你带来的景象，你就会注意到离你越远的东西看起来更小。这个奇怪的效果称之为透视 (Perspective)。透视的效果在我们看一条无限长的高速公路或铁路时尤其明显，正如下面图片显示的那样：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/08/perspective.png\" alt=\"image\" /></p>\n<p>正如你看到的那样，由于透视，这两条线在很远的地方看起来会相交。这正是透视投影想要模仿的效果，它是使用<mark>透视投影矩阵</mark>来完成的。这个投影矩阵将给定的平截头体范围映射到裁剪空间，除此之外还修改了每个顶点坐标的<mark> w</mark> 值，从而使得离观察者越远的顶点坐标 w 分量越大。被变换到裁剪空间的坐标都会在 - w 到 w 的范围之间（任何大于这个范围的坐标都会被裁剪掉）。OpenGL 要求所有可见的坐标都落在 - 1.0 到 1.0 范围内，作为顶点着色器最后的输出，因此，一旦坐标在裁剪空间内之后，透视除法就会被应用到裁剪空间坐标上：</p>\n<pre><code class=\"language-math\">out=\n\\begin&#123;pmatrix&#125;\n   x/w \\\\\n   y/w \\\\\n   z/w \n\\end&#123;pmatrix&#125;\n</code></pre>\n<p>顶点坐标的每个分量都会除以它的 w 分量，距离观察者越远顶点坐标就会越小。这是也是 w 分量非常重要的另一个原因，它能够帮助我们进行透视投影。最后的结果坐标就是处于标准化设备空间中的。如果你对正射投影矩阵和透视投影矩阵是如何计算的很感兴趣（且不会对数学感到恐惧的话）我推荐这篇由 Songho 写的<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zb25naG8uY2Evb3BlbmdsL2dsX3Byb2plY3Rpb25tYXRyaXguaHRtbA==\">文章</span>。</p>\n<p>在 GLM 中可以这样创建一个透视投影矩阵：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span>mat4 proj <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">perspective</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">radians</span><span class=\"token punctuation\">(</span><span class=\"token number\">45.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span>width<span class=\"token operator\">/</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span>height<span class=\"token punctuation\">,</span> <span class=\"token number\">0.1f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>同样，glm::perspective 所做的其实就是创建了一个定义了可视空间的大平截头体，任何在这个平截头体以外的东西最后都不会出现在裁剪空间体积内，并且将会受到裁剪。一个透视平截头体可以被看作一个不均匀形状的箱子，在这个箱子内部的每个坐标都会被映射到裁剪空间上的一个点。下面是一张透视平截头体的图片：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/08/perspective_frustum.png\" alt=\"image\" /></p>\n<ul>\n<li>它的第一个参数定义了 fov 的值，它表示的是<mark>视野</mark> (Field of View)，并且设置了观察空间的大小。如果想要一个真实的观察效果，它的值通常设置为<mark> 45.0f</mark>，但想要一个末日风格的结果你可以将其设置一个更大的值。</li>\n<li>第二个参数设置了宽高比，由视口的宽除以高所得。</li>\n<li>第三和第四个参数设置了平截头体的近和远平面。我们通常设置近距离为<mark> 0.1f</mark>，而远距离设为<mark> 100.0f</mark>。所有在近平面和远平面内且处于平截头体内的顶点都会被渲染。</li>\n</ul>\n<blockquote>\n<p>当你把透视矩阵的 near 值设置太大时（如 10.0f），OpenGL 会将靠近摄像机的坐标（在 0.0f 和 10.0f 之间）都裁剪掉，这会导致一个你在游戏中很熟悉的视觉效果：<mark>在太过靠近一个物体的时候你的视线会直接穿过去</mark>。</p>\n</blockquote>\n<p>当使用<mark>正射投影</mark>时，每一个顶点坐标都会直接映射到裁剪空间中而<mark>不经过任何精细的透视除法</mark>（它仍然会进行透视除法，只是 w 分量没有被改变（它保持为 1），因此没有起作用）。因为正射投影没有使用透视，远处的物体不会显得更小，所以产生奇怪的视觉效果。由于这个原因，正射投影主要用于二维渲染以及一些建筑或工程的程序，在这些场景中我们更希望顶点不会被透视所干扰。某些如 Blender 等进行三维建模的软件有时在建模时也会使用正射投影，因为它在各个维度下都更准确地描绘了每个物体。下面你能够看到在 Blender 里面使用两种投影方式的对比：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/08/perspective_orthographic.png\" alt=\"image\" /></p>\n<p>你可以看到，使用透视投影的话，远处的顶点看起来比较小，而在正射投影中每个顶点距离观察者的距离都是一样的。</p>\n<h3 id=\"把它们都组合到一起\"><a class=\"anchor\" href=\"#把它们都组合到一起\">#</a> 把它们都组合到一起</h3>\n<p>我们为上述的每一个步骤都创建了一个变换矩阵：模型矩阵、观察矩阵和投影矩阵。一个顶点坐标将会根据以下过程被变换到裁剪坐标:</p>\n<pre><code class=\"language-math\">V_&#123;clip&#125;=\nM_&#123;projection&#125; \\cdotp \nM_&#123;view&#125; \\cdotp \nM_&#123;model&#125;\\cdotp \nV_&#123;local&#125;\n</code></pre>\n<p>注意矩阵运算的顺序是相反的（记住我们需要<mark>从右往左</mark>阅读矩阵的乘法）。最后的顶点应该被赋值到顶点着色器中的<mark> gl_Position</mark>，OpenGL 将会自动进行透视除法和裁剪。</p>\n<blockquote>\n<p>然后呢？</p>\n</blockquote>\n<blockquote>\n<p>顶点着色器的输出要求所有的顶点都在裁剪空间内，这正是我们刚才使用变换矩阵所做的。OpenGL 然后对裁剪坐标执行透视除法从而将它们变换到标准化设备坐标。OpenGL 会使用 glViewPort 内部的参数来将标准化设备坐标映射到屏幕坐标，每个坐标都关联了一个屏幕上的点（在我们的例子中是一个 800x600 的屏幕）。这个过程称为<mark>视口变换</mark>。</p>\n</blockquote>\n<h3 id=\"进入3d\"><a class=\"anchor\" href=\"#进入3d\">#</a> 进入 3D</h3>\n<p>在开始进行 3D 绘图时，我们首先创建一个<mark>模型矩阵</mark>。这个模型矩阵包含了位移、缩放与旋转操作，它们会被应用到所有物体的顶点上，以变换它们到全局的世界空间。让我们变换一下我们的平面，将其绕着 x 轴旋转，使它看起来像放在地上一样。这个模型矩阵看起来是这样的：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span>mat4 model<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>model <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">rotate</span><span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">radians</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">55.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>通过将顶点坐标乘以这个模型矩阵，我们将该顶点坐标变换到世界坐标。我们的平面看起来就是在地板上，代表全局世界里的平面。</p>\n<p>接下来我们需要创建一个观察矩阵。我们想要在场景里面稍微往后移动，以使得物体变成可见的（当在世界空间时，我们位于原点 (0,0,0)）。要想在场景里面移动，先仔细想一想下面这个句子：</p>\n<blockquote>\n<p>将摄像机向后移动，和将整个场景向前移动是一样的。</p>\n</blockquote>\n<p>这正是观察矩阵所做的，我们以相反于摄像机移动的方向移动整个场景。因为我们想要往后移动，并且 OpenGL 是一个<mark>右手坐标系</mark> (Right-handed System)，所以我们需要沿着 z 轴的正方向移动。我们会通过将场景沿着 z 轴负方向平移来实现。它会给我们一种我们在往后移动的感觉。</p>\n<blockquote>\n<p>右手坐标系 (Right-handed System)</p>\n</blockquote>\n<blockquote>\n<p>按照惯例，OpenGL 是一个右手坐标系。简单来说，就是正 x 轴在你的右手边，正 y 轴朝上，而正 z 轴是朝向后方的。想象你的屏幕处于三个轴的中心，则正 z 轴穿过你的屏幕朝向你。坐标系画起来如下：</p>\n</blockquote>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/08/coordinate_systems_right_handed.png\" alt=\"image\" /></p>\n<blockquote>\n<p>为了理解为什么被称为右手坐标系，按如下的步骤做：</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>沿着正 y 轴方向伸出你的右臂，手指着上方。</li>\n<li>大拇指指向右方。</li>\n<li>食指指向上方。</li>\n<li>中指向下弯曲 90 度。</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>如果你的动作正确，那么你的大拇指指向正 x 轴方向，食指指向正 y 轴方向，中指指向正 z 轴方向。如果你用左臂来做这些动作，你会发现 z 轴的方向是相反的。这个叫做左手坐标系，它被 DirectX 广泛地使用。注意在标准化设备坐标系中 OpenGL 实际上使用的是左手坐标系（投影矩阵交换了左右手）。</p>\n</blockquote>\n<p>在下一个教程中我们将会详细讨论如何在场景中移动。就目前来说，观察矩阵是这样的：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span>mat4 view<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// 注意，我们将矩阵向我们要进行移动场景的反方向移动。</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>view <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">translate</span><span class=\"token punctuation\">(</span>view<span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">3.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>最后我们需要做的是定义一个投影矩阵。我们希望在场景中使用透视投影，所以像这样声明一个投影矩阵：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span>mat4 projection<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>projection <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">perspective</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">radians</span><span class=\"token punctuation\">(</span><span class=\"token number\">45.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> screenWidth <span class=\"token operator\">/</span> screenHeight<span class=\"token punctuation\">,</span> <span class=\"token number\">0.1f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>既然我们已经创建了变换矩阵，我们应该将它们传入着色器。首先，让我们在顶点着色器中声明一个 uniform 变换矩阵然后将它乘以顶点坐标：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> in vec3 aPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>uniform mat4 model<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>uniform mat4 view<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>uniform mat4 projection<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\">// 注意乘法要从右向左读</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> projection <span class=\"token operator\">*</span> view <span class=\"token operator\">*</span> model <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>aPos<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们还应该将矩阵传入着色器（这通常在每次的渲染迭代中进行，因为变换矩阵会经常变动）：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> modelLoc <span class=\"token operator\">=</span> <span class=\"token function\">glGetUniformLocation</span><span class=\"token punctuation\">(</span>ourShader<span class=\"token punctuation\">.</span>ID<span class=\"token punctuation\">,</span> <span class=\"token string\">\"model\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glUniformMatrix4fv</span><span class=\"token punctuation\">(</span>modelLoc<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">value_ptr</span><span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token comment\">// 观察矩阵和投影矩阵与之类似</span></pre></td></tr></table></figure><p>我们的顶点坐标已经使用模型、观察和投影矩阵进行变换了，最终的物体应该会：</p>\n<ul>\n<li>稍微向后倾斜至地板方向。</li>\n<li>离我们有一些距离。</li>\n<li>有透视效果（顶点越远，变得越小）。</li>\n</ul>\n<p>让我们检查一下结果是否满足这些要求：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/08/coordinate_systems_result.png\" alt=\"image\" /></p>\n<h3 id=\"更多的3d\"><a class=\"anchor\" href=\"#更多的3d\">#</a> 更多的 3D</h3>\n<p>到目前为止，我们一直都在使用一个 2D 平面，而且甚至是在 3D 空间里！所以，让我们大胆地拓展我们的 2D 平面为一个 3D 立方体。要想渲染一个立方体，我们一共需要 36 个顶点（6 个面 x 每个面有 2 个三角形组成 x 每个三角形有 3 个顶点），这 36 个顶点的位置你可以从<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWFybm9wZW5nbC5jb20vY29kZV92aWV3ZXIucGhwP2NvZGU9Z2V0dGluZy1zdGFydGVkL2N1YmVfdmVydGljZXM=\">这里获取</span>。</p>\n<p>为了有趣一点，我们将让立方体随着时间旋转：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>model <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">rotate</span><span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span><span class=\"token function\">glfwGetTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> glm<span class=\"token operator\">::</span><span class=\"token function\">radians</span><span class=\"token punctuation\">(</span><span class=\"token number\">50.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>然后我们使用 glDrawArrays 来绘制立方体，但这一次总共有 36 个顶点。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glDrawArrays</span><span class=\"token punctuation\">(</span>GL_TRIANGLES<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">36</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这的确有点像是一个立方体，但又有种说不出的奇怪。立方体的某些本应被遮挡住的面被绘制在了这个立方体其他面之上。之所以这样是因为 OpenGL 是一个三角形一个三角形地来绘制你的立方体的，所以即便之前那里有东西它也会覆盖之前的像素。因为这个原因，有些三角形会被绘制在其它三角形上面，虽然它们本不应该是被覆盖的。</p>\n<p>幸运的是，OpenGL 存储深度信息在一个叫做<mark> Z 缓冲</mark> (Z-buffer) 的缓冲中，它允许 OpenGL 决定何时覆盖一个像素而何时不覆盖。通过使用 Z 缓冲，我们可以配置 OpenGL 来进行深度测试。</p>\n<h3 id=\"z缓冲\"><a class=\"anchor\" href=\"#z缓冲\">#</a> Z 缓冲</h3>\n<p>OpenGL 存储它的所有深度信息于一个 Z 缓冲 (Z-buffer) 中，也被称为深度缓冲 (Depth Buffer)。GLFW 会自动为你生成这样一个缓冲（就像它也有一个颜色缓冲来存储输出图像的颜色）。深度值存储在每个片段里面（作为片段的 z 值），当片段想要输出它的颜色时，OpenGL 会将它的深度值和 z 缓冲进行比较，<mark>如果当前的片段在其它片段之后，它将会被丢弃</mark>，<mark>否则将会覆盖</mark>。这个过程称为深度测试 (Depth Testing)，它是由 OpenGL 自动完成的。</p>\n<p>然而，如果我们想要确定 OpenGL 真的执行了深度测试，首先我们要告诉 OpenGL 我们想要启用深度测试；它默认是关闭的。我们可以通过 glEnable 函数来开启深度测试。glEnable 和 glDisable 函数允许我们启用或禁用某个 OpenGL 功能。这个功能会一直保持启用 / 禁用状态，直到另一个调用来禁用 / 启用它。现在我们想启用深度测试，需要开启 GL_DEPTH_TEST：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glEnable</span><span class=\"token punctuation\">(</span>GL_DEPTH_TEST<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>因为我们使用了深度测试，我们也想要在每次渲染迭代之前清除深度缓冲（否则前一帧的深度信息仍然保存在缓冲中）。就像清除颜色缓冲一样，我们可以通过在 glClear 函数中指定 DEPTH_BUFFER_BIT 位来清除深度缓冲：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glClear</span><span class=\"token punctuation\">(</span>GL_COLOR_BUFFER_BIT <span class=\"token operator\">|</span> GL_DEPTH_BUFFER_BIT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"更多的立方体\"><a class=\"anchor\" href=\"#更多的立方体\">#</a> 更多的立方体！</h3>\n<p>现在我们想在屏幕上显示 10 个立方体。每个立方体看起来都是一样的，区别在于它们在世界的位置及旋转角度不同。立方体的图形布局已经定义好了，所以当渲染更多物体的时候我们不需要改变我们的缓冲数组和属性数组，我们唯一需要做的只是改变每个对象的模型矩阵来将立方体变换到世界坐标系中。</p>\n<p>首先，让我们为每个立方体定义一个位移向量来指定它在世界空间的位置。我们将在一个 glm::vec3 数组中定义 10 个立方体位置：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 cubePositions<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span> <span class=\"token number\">2.0f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">5.0f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">15.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1.5f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">2.2f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">2.5f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>  </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">3.8f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">2.0f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">12.3f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>  </pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span> <span class=\"token number\">2.4f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.4f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">3.5f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>  </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1.7f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">3.0f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">7.5f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>  </pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span> <span class=\"token number\">1.3f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">2.0f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">2.5f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>  </pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span> <span class=\"token number\">1.5f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">2.0f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">2.5f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> </pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span> <span class=\"token number\">1.5f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.2f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1.5f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> </pre></td></tr><tr><td data-num=\"11\"></td><td><pre>  glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1.3f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1.5f</span><span class=\"token punctuation\">)</span>  </pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>现在，在游戏循环中，我们调用 glDrawArrays 10 次，但这次在我们渲染之前每次传入一个不同的模型矩阵到顶点着色器中。我们将会在游戏循环中创建一个小的循环用不同的模型矩阵渲染我们的物体 10 次。注意我们也对每个箱子加了一点旋转：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glBindVertexArray</span><span class=\"token punctuation\">(</span>VAO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  glm<span class=\"token operator\">::</span>mat4 model<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  model <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">translate</span><span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">,</span> cubePositions<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token keyword\">float</span> angle <span class=\"token operator\">=</span> <span class=\"token number\">20.0f</span> <span class=\"token operator\">*</span> i<span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  model <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">rotate</span><span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">radians</span><span class=\"token punctuation\">(</span>angle<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.3f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.5f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  ourShader<span class=\"token punctuation\">.</span><span class=\"token function\">setMat4</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"model\"</span><span class=\"token punctuation\">,</span> model<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  <span class=\"token function\">glDrawArrays</span><span class=\"token punctuation\">(</span>GL_TRIANGLES<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">36</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这段代码将会在每次新立方体绘制出来的时候更新模型矩阵，如此总共重复 10 次。然后我们应该就能看到一个拥有 10 个正在奇葩地旋转着的立方体的世界。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/08/coordinate_systems_multiple_objects.png\" alt=\"image\" /></p>\n<h2 id=\"摄像机\"><a class=\"anchor\" href=\"#摄像机\">#</a> 摄像机</h2>\n<h3 id=\"摄像机观察空间\"><a class=\"anchor\" href=\"#摄像机观察空间\">#</a> 摄像机 / 观察空间</h3>\n<p>当我们讨论<mark>摄像机 / 观察空间</mark> (Camera/View Space) 的时候，是在讨论以摄像机的视角作为场景原点时场景中所有的顶点坐标：观察矩阵把所有的世界坐标变换为相对于摄像机位置与方向的观察坐标。要定义一个摄像机，我们需要它在世界空间中的<mark>位置</mark>、<mark>观察的方向</mark>、一个指向它右测的向量以及一个指向它上方的向量。细心的读者可能已经注意到我们实际上创建了一个三个单位轴相互垂直的、以摄像机的位置为原点的坐标系。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/09/camera_axes.png\" alt=\"image\" /></p>\n<h3 id=\"1-摄像机位置\"><a class=\"anchor\" href=\"#1-摄像机位置\">#</a> 1. 摄像机位置</h3>\n<p>获取摄像机位置很简单。摄像机位置简单来说就是世界空间中一个指向摄像机位置的向量。我们把摄像机位置设置为上一节中的那个相同的位置：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 cameraPos <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><blockquote>\n<p>不要忘记正 z 轴是从屏幕指向你的，如果我们希望摄像机向后移动，我们就沿着 z 轴的正方向移动。</p>\n</blockquote>\n<h3 id=\"2-摄像机方向\"><a class=\"anchor\" href=\"#2-摄像机方向\">#</a> 2. 摄像机方向</h3>\n<p>下一个需要的向量是摄像机的方向，这里指的是摄像机指向哪个方向。现在我们让摄像机指向场景原点：(0, 0, 0)。还记得如果将两个矢量相减，我们就能得到这两个矢量的差吗？用场景原点向量减去摄像机位置向量的结果就是摄像机的<mark>指向向量</mark>。由于我们知道摄像机指向<mark> z 轴负方向</mark>，但我们希望方向向量 (Direction Vector) 指向摄像机的 z 轴正方向。如果我们交换相减的顺序，我们就会获得一个指向摄像机正 z 轴方向的向量：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 cameraTarget <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 cameraDirection <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>cameraPos <span class=\"token operator\">-</span> cameraTarget<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"3-x轴\"><a class=\"anchor\" href=\"#3-x轴\">#</a> 3. X 轴</h3>\n<p>我们需要的另一个向量是一个<mark>右向量</mark> (Right Vector)，它代表摄像机空间的 x 轴的正方向。为获取右向量我们需要先使用一个小技巧：先定义一个<mark>上向量</mark> (Up Vector)。接下来把上向量和第二步得到的方向向量进行<mark>叉乘</mark>。两个向量叉乘的结果会同时垂直于两向量，因此我们会得到指向 x 轴正方向的那个向量（<mark>如果我们<strong>交换</strong>两个向量叉乘的顺序就会得到相反的指向<strong> x 轴负方向</strong>的向量</mark>）：</p>\n<pre><code>glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f); \nglm::vec3 cameraRight = glm::normalize(glm::cross(up, cameraDirection));\n</code></pre>\n<h4 id=\"4-y轴\"><a class=\"anchor\" href=\"#4-y轴\">#</a> 4. Y 轴</h4>\n<p>现在我们已经有了 x 轴向量和 z 轴向量，获取一个指向摄像机的正 y 轴向量就相对简单了：我们把右向量和方向向量进行叉乘：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 cameraUp <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">cross</span><span class=\"token punctuation\">(</span>cameraDirection<span class=\"token punctuation\">,</span> cameraRight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在叉乘和一些小技巧的帮助下，我们创建了所有构成观察 / 摄像机空间的向量。对于想学到更多数学原理的读者，提示一下，在线性代数中这个处理叫做<mark>格拉姆 — 施密特正交化</mark> (Gram-Schmidt Process)。使用这些摄像机向量我们就可以创建一个 LookAt 矩阵了，它在创建摄像机的时候非常有用。</p>\n<h3 id=\"look-at\"><a class=\"anchor\" href=\"#look-at\">#</a> Look At</h3>\n<p>使用矩阵的好处之一是如果你使用 3 个相互垂直（或非线性）的轴定义了一个坐标空间，你可以用这 3 个轴外加一个平移向量来创建一个矩阵，并且你可以用这个矩阵乘以任何向量来将其变换到那个坐标空间。这正是 LookAt 矩阵所做的，现在我们有了 3 个相互垂直的轴和一个定义摄像机空间的位置坐标，我们可以创建我们自己的 LookAt 矩阵了：</p>\n<pre><code class=\"language-math\">LookAt=\n\\begin&#123;bmatrix&#125;\n   R_x &amp; R_y  &amp; R_z  &amp; 0  \\\\\n   U_x &amp; U_y  &amp; U_z  &amp; 0  \\\\\n   D_x &amp; D_y  &amp; D_z  &amp; 0  \\\\\n   0 &amp; 0  &amp; 0  &amp; 1  \n\\end&#123;bmatrix&#125;\n*\n\\begin&#123;bmatrix&#125;\n   1 &amp; 0  &amp; 0  &amp; -P_x  \\\\\n   0 &amp; 1  &amp; 0  &amp; -P_y  \\\\\n   0 &amp; 0  &amp; 1  &amp; -P_z  \\\\\n   0 &amp; 0  &amp; 0  &amp; 1  \n\\end&#123;bmatrix&#125;\n</code></pre>\n<p>其中 R 是右向量 (<mark>X 轴</mark>)，U 是上向量 (<mark>Z 轴</mark>)，D 是方向向量 P 是摄像机位置向量。注意，位置向量是相反的，因为我们最终希望把世界平移到与我们自身移动的相反方向。把这个 LookAt 矩阵作为观察矩阵可以很高效地把所有世界坐标变换到刚刚定义的观察空间。LookAt 矩阵就像它的名字表达的那样：它会创建一个看着 (Look at) 给定目标的观察矩阵。</p>\n<p>幸运的是，GLM 已经提供了这些支持。我们要做的只是定义一个摄像机位置，一个目标位置和一个表示世界空间中的上向量的向量（我们计算右向量使用的那个上向量）。接着 GLM 就会创建一个 LookAt 矩阵，我们可以把它当作我们的观察矩阵：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span>mat4 view<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>view <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">lookAt</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>           glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>           glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>glm::LookAt 函数需要一个<mark>位置</mark>、<mark>目标</mark>和<mark>上向量</mark>。它会创建一个和在上一节使用的一样的观察矩阵。</p>\n<p>在讨论用户输入之前，我们先来做些有意思的事，把我们的摄像机在场景中旋转。我们会将摄像机的注视点保持在 (0, 0, 0)。</p>\n<p>我们需要用到一点三角学的知识来在每一帧创建一个 x 和 z 坐标，它会代表圆上的一点，我们将会使用它作为摄像机的位置。通过重新计算 x 和 y 坐标，我们会遍历圆上的所有点，这样摄像机就会绕着场景旋转了。我们预先定义这个圆的半径 radius，在每次渲染迭代中使用 GLFW 的 glfwGetTime 函数重新创建观察矩阵，来扩大这个圆。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> radius <span class=\"token operator\">=</span> <span class=\"token number\">10.0f</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">float</span> camX <span class=\"token operator\">=</span> <span class=\"token function\">sin</span><span class=\"token punctuation\">(</span><span class=\"token function\">glfwGetTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> radius<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">float</span> camZ <span class=\"token operator\">=</span> <span class=\"token function\">cos</span><span class=\"token punctuation\">(</span><span class=\"token function\">glfwGetTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> radius<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>glm<span class=\"token operator\">::</span>mat4 view<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>view <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">lookAt</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span>camX<span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> camZ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"自由移动\"><a class=\"anchor\" href=\"#自由移动\">#</a> 自由移动</h3>\n<p>让摄像机绕着场景转的确很有趣，但是让我们自己移动摄像机会更有趣！首先我们必须设置一个摄像机系统，所以在我们的程序前面定义一些摄像机变量很有用：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 cameraPos   <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">3.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 cameraFront <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 cameraUp    <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>LookAt 函数现在成了：</p>\n<pre><code>view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);\n</code></pre>\n<p>我们首先将摄像机位置设置为之前定义的 cameraPos。方向是当前的位置加上我们刚刚定义的方向向量。这样能保证无论我们怎么移动，摄像机都会注视着目标方向。让我们摆弄一下这些向量，在按下某些按钮时更新 cameraPos 向量。</p>\n<p>我们已经为 GLFW 的键盘输入定义过一个 processInput 函数了，我们来新添加几个需要检查的按键命令：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">processInput</span><span class=\"token punctuation\">(</span>GLFWwindow <span class=\"token operator\">*</span>window<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">float</span> cameraSpeed <span class=\"token operator\">=</span> <span class=\"token number\">0.05f</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// adjust accordingly</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">glfwGetKey</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">,</span> GLFW_KEY_W<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> GLFW_PRESS<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        cameraPos <span class=\"token operator\">+=</span> cameraSpeed <span class=\"token operator\">*</span> cameraFront<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">glfwGetKey</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">,</span> GLFW_KEY_S<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> GLFW_PRESS<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        cameraPos <span class=\"token operator\">-=</span> cameraSpeed <span class=\"token operator\">*</span> cameraFront<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">glfwGetKey</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">,</span> GLFW_KEY_A<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> GLFW_PRESS<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        cameraPos <span class=\"token operator\">-=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">cross</span><span class=\"token punctuation\">(</span>cameraFront<span class=\"token punctuation\">,</span> cameraUp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> cameraSpeed<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">glfwGetKey</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">,</span> GLFW_KEY_D<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> GLFW_PRESS<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        cameraPos <span class=\"token operator\">+=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">cross</span><span class=\"token punctuation\">(</span>cameraFront<span class=\"token punctuation\">,</span> cameraUp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> cameraSpeed<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>当我们按下 WASD 键的任意一个，摄像机的位置都会相应更新。如果我们希望向前或向后移动，我们就把位置向量加上或减去方向向量。如果我们希望向左右移动，我们使用叉乘来创建一个右向量 (Right Vector)，并沿着它相应移动就可以了。这样就创建了使用摄像机时熟悉的<mark>横移</mark> (Strafe) 效果。</p>\n<p>注意，我们对右向量进行了标准化。如果我们没对这个向量进行标准化，最后的叉乘结果会根据 cameraFront 变量返回大小不同的向量。如果我们不对向量进行标准化，我们就得根据摄像机的朝向不同加速或减速移动了，但如果进行了标准化移动就是匀速的。</p>\n<h3 id=\"移动速度\"><a class=\"anchor\" href=\"#移动速度\">#</a> 移动速度</h3>\n<p>目前我们的移动速度是个常量。理论上没什么问题，但是实际情况下根据处理器的能力不同，有些人可能会比其他人每秒绘制更多帧，也就是以更高的频率调用 processInput 函数。结果就是，根据配置的不同，有些人可能移动很快，而有些人会移动很慢。当你发布你的程序的时候，你必须确保它在所有硬件上移动速度都一样。</p>\n<p>图形程序和游戏通常会跟踪一个<mark>时间差</mark> (Deltatime) 变量，它储存了渲染上一帧所用的时间。我们把所有速度都去乘以 deltaTime 值。结果就是，如果我们的 deltaTime 很大，就意味着上一帧的渲染花费了更多时间，所以这一帧的速度需要变得更高来平衡渲染所花去的时间。使用这种方法时，无论你的电脑快还是慢，摄像机的速度都会相应平衡，这样每个用户的体验就都一样了。</p>\n<p>我们跟踪两个全局变量来计算出 deltaTime 值：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> deltaTime <span class=\"token operator\">=</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 当前帧与上一帧的时间差</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">float</span> lastFrame <span class=\"token operator\">=</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 上一帧的时间</span></pre></td></tr></table></figure><p>在每一帧中我们计算出新的 deltaTime 以备后用。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> currentFrame <span class=\"token operator\">=</span> <span class=\"token function\">glfwGetTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>deltaTime <span class=\"token operator\">=</span> currentFrame <span class=\"token operator\">-</span> lastFrame<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>lastFrame <span class=\"token operator\">=</span> currentFrame<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"视角移动\"><a class=\"anchor\" href=\"#视角移动\">#</a> 视角移动</h3>\n<p>只用键盘移动没什么意思。特别是我们还不能转向，移动很受限制。是时候加入鼠标了！</p>\n<p>为了能够改变视角，我们需要根据鼠标的输入改变 cameraFront 向量。然而，根据鼠标移动改变方向向量有点复杂，需要一些三角学知识。如果你对三角学知之甚少，别担心，你可以跳过这一部分，直接复制粘贴我们的代码；当你想了解更多的时候再回来看。</p>\n<h3 id=\"欧拉角\"><a class=\"anchor\" href=\"#欧拉角\">#</a> 欧拉角</h3>\n<p>欧拉角 (Euler Angle) 是可以表示 3D 空间中任何旋转的 3 个值，由莱昂哈德・欧拉 (Leonhard Euler) 在 18 世纪提出。一共有 3 种欧拉角：<mark>俯仰角</mark> (Pitch)、<mark>偏航角</mark> (Yaw) 和<mark>滚转角</mark> (Roll)，下面的图片展示了它们的含义：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/09/camera_pitch_yaw_roll.png\" alt=\"image\" /></p>\n<p><mark>俯仰角</mark>是描述我们如何往<mark>上或往下看</mark>的角，可以在第一张图中看到。第二张图展示了<mark>偏航角</mark>，偏航角表示我们<mark>往左和往右看</mark>的程度。<mark>滚转角</mark>代表我们如何<mark>翻滚摄像机</mark>，通常在太空飞船的摄像机中使用。每个欧拉角都有一个值来表示，把三个角结合起来我们就能够计算 3D 空间中任何的旋转向量了。</p>\n<p>对于我们的摄像机系统来说，我们只关心俯仰角和偏航角，所以我们不会讨论滚转角。给定一个俯仰角和偏航角，我们可以把它们转换为一个代表新的方向向量的 3D 向量。俯仰角和偏航角转换为方向向量的处理需要一些三角学知识，我们先从最基本的情况开始：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/09/camera_triangle.png\" alt=\"image\" /></p>\n<p>如果我们把斜边边长定义为 1，我们就能知道邻边的长度是 cos x/h=cos x/1=cos x，它的对边是 sin y/h=sin y/1=sin y。这样我们获得了能够得到 x 和 y 方向长度的通用公式，它们取决于所给的角度。我们使用它来计算方向向量的分量：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/09/camera_pitch.png\" alt=\"image\" /></p>\n<p>这个三角形看起来和前面的三角形很像，所以如果我们想象自己在 xz 平面上，看向 y 轴，我们可以基于第一个三角形计算来计算它的长度 /y 方向的强度 (Strength)（我们往上或往下看多少）。从图中我们可以看到对于一个给定俯仰角的 y 值等于 sin θ：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>direction<span class=\"token punctuation\">.</span>y <span class=\"token operator\">=</span> <span class=\"token function\">sin</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">radians</span><span class=\"token punctuation\">(</span>pitch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 注意我们先把角度转为弧度</span></pre></td></tr></table></figure><p>这里我们只更新了 y 值，仔细观察 x 和 z 分量也被影响了。从三角形中我们可以看到它们的值等于：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>direction<span class=\"token punctuation\">.</span>x <span class=\"token operator\">=</span> <span class=\"token function\">cos</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">radians</span><span class=\"token punctuation\">(</span>pitch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>direction<span class=\"token punctuation\">.</span>z <span class=\"token operator\">=</span> <span class=\"token function\">cos</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">radians</span><span class=\"token punctuation\">(</span>pitch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>看看我们是否能够为偏航角找到需要的分量：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/01/09/camera_yaw.png\" alt=\"image\" /></p>\n<p>就像俯仰角的三角形一样，我们可以看到 x 分量取决于 cos (yaw) 的值，z 值同样取决于偏航角的正弦值。把这个加到前面的值中，会得到基于俯仰角和偏航角的方向向量：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>direction<span class=\"token punctuation\">.</span>x <span class=\"token operator\">=</span> <span class=\"token function\">cos</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">radians</span><span class=\"token punctuation\">(</span>pitch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token function\">cos</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">radians</span><span class=\"token punctuation\">(</span>yaw<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 译注：direction 代表摄像机的前轴 (Front)，这个前轴是和本文第一幅图片的第二个摄像机的方向向量是相反的</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>direction<span class=\"token punctuation\">.</span>y <span class=\"token operator\">=</span> <span class=\"token function\">sin</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">radians</span><span class=\"token punctuation\">(</span>pitch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>direction<span class=\"token punctuation\">.</span>z <span class=\"token operator\">=</span> <span class=\"token function\">cos</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">radians</span><span class=\"token punctuation\">(</span>pitch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token function\">sin</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">radians</span><span class=\"token punctuation\">(</span>yaw<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这样我们就有了一个可以把俯仰角和偏航角转化为用来自由旋转视角的摄像机的 3 维方向向量了。你可能会奇怪：我们怎么得到俯仰角和偏航角？</p>\n<h3 id=\"鼠标输入\"><a class=\"anchor\" href=\"#鼠标输入\">#</a> 鼠标输入</h3>\n<p>偏航角和俯仰角是通过鼠标（或手柄）移动获得的，水平的移动影响偏航角，竖直的移动影响俯仰角。它的原理就是，储存上一帧鼠标的位置，在当前帧中我们当前计算鼠标位置与上一帧的位置相差多少。如果水平 / 竖直差别越大那么俯仰角或偏航角就改变越大，也就是摄像机需要移动更多的距离。</p>\n<p>首先我们要告诉 GLFW，它应该隐藏光标，并捕捉 (Capture) 它。捕捉光标表示的是，如果焦点在你的程序上（译注：即表示你正在操作这个程序，Windows 中拥有焦点的程序标题栏通常是有颜色的那个，而失去焦点的程序标题栏则是灰色的），光标应该停留在窗口中（除非程序失去焦点或者退出）。我们可以用一个简单地配置调用来完成：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glfwSetInputMode</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">,</span> GLFW_CURSOR<span class=\"token punctuation\">,</span> GLFW_CURSOR_DISABLED<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在调用这个函数之后，无论我们怎么去移动鼠标，光标都不会显示了，它也不会离开窗口。对于 FPS 摄像机系统来说非常完美。</p>\n<p>为了计算俯仰角和偏航角，我们需要让 GLFW<mark> 监听鼠标移动事件 (mouse_callback)</mark>。（和键盘输入相似）我们会用一个回调函数来完成，函数的原型如下：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">mouse_callback</span><span class=\"token punctuation\">(</span>GLFWwindow<span class=\"token operator\">*</span> window<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> xpos<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> ypos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这里的 xpos 和 ypos 代表当前鼠标的位置。当我们用 GLFW 注册了回调函数之后，鼠标一移动<mark> mouse_callback</mark> 函数就会被调用：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glfwSetCursorPosCallback</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">,</span> mouse_callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在处理 FPS 风格摄像机的鼠标输入的时候，我们必须在最终获取方向向量之前做下面这几步：</p>\n<ul>\n<li>计算鼠标距上一帧的<mark>偏移量</mark>。</li>\n<li>把偏移量添加到<mark>摄像机的俯仰角</mark>和<mark>偏航角</mark>中。</li>\n<li>对偏航角和俯仰角进行<mark>最大</mark>和<mark>最小值</mark>的<mark>限制</mark>。</li>\n<li>计算<mark>方向向量</mark>。</li>\n</ul>\n<p>第一步是计算鼠标自上一帧的偏移量。我们必须先在程序中储存上一帧的鼠标位置，我们把它的初始值设置为屏幕的中心（屏幕的尺寸是 800x600）：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> lastX <span class=\"token operator\">=</span> <span class=\"token number\">400</span><span class=\"token punctuation\">,</span> lastY <span class=\"token operator\">=</span> <span class=\"token number\">300</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>然后在鼠标的回调函数中我们计算当前帧和上一帧鼠标位置的偏移量：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> xoffset <span class=\"token operator\">=</span> xpos <span class=\"token operator\">-</span> lastX<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">float</span> yoffset <span class=\"token operator\">=</span> lastY <span class=\"token operator\">-</span> ypos<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 注意这里是相反的，因为 y 坐标是从底部往顶部依次增大的</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>lastX <span class=\"token operator\">=</span> xpos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>lastY <span class=\"token operator\">=</span> ypos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">float</span> sensitivity <span class=\"token operator\">=</span> <span class=\"token number\">0.05f</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>xoffset <span class=\"token operator\">*=</span> sensitivity<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>yoffset <span class=\"token operator\">*=</span> sensitivity<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>注意我们把偏移量乘以了 sensitivity（灵敏度）值。如果我们忽略这个值，鼠标移动就会太大了；你可以自己实验一下，找到适合自己的灵敏度值。</p>\n<p>接下来我们把偏移量加到全局变量 pitch 和 yaw 上：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>yaw   <span class=\"token operator\">+=</span> xoffset<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>pitch <span class=\"token operator\">+=</span> yoffset<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>第三步，我们需要给摄像机添加一些限制，这样摄像机就不会发生奇怪的移动了（这样也会避免一些奇怪的问题）。对于俯仰角，要让用户不能看向高于 89 度的地方（在 90 度时视角会发生逆转，所以我们把 89 度作为极限），同样也不允许小于 - 89 度。这样能够保证用户只能看到天空或脚下，但是不能超越这个限制。我们可以在值超过限制的时候将其改为极限值来实现：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>pitch <span class=\"token operator\">></span> <span class=\"token number\">89.0f</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  pitch <span class=\"token operator\">=</span>  <span class=\"token number\">89.0f</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>pitch <span class=\"token operator\">&lt;</span> <span class=\"token operator\">-</span><span class=\"token number\">89.0f</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  pitch <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">89.0f</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>注意我们没有给偏航角设置限制，这是因为我们不希望限制用户的水平旋转。当然，给偏航角设置限制也很容易，如果你愿意可以自己实现。</p>\n<p>第四也是最后一步，就是通过俯仰角和偏航角来计算以得到真正的方向向量：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 front<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>front<span class=\"token punctuation\">.</span>x <span class=\"token operator\">=</span> <span class=\"token function\">cos</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">radians</span><span class=\"token punctuation\">(</span>pitch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token function\">cos</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">radians</span><span class=\"token punctuation\">(</span>yaw<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>front<span class=\"token punctuation\">.</span>y <span class=\"token operator\">=</span> <span class=\"token function\">sin</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">radians</span><span class=\"token punctuation\">(</span>pitch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>front<span class=\"token punctuation\">.</span>z <span class=\"token operator\">=</span> <span class=\"token function\">cos</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">radians</span><span class=\"token punctuation\">(</span>pitch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token function\">sin</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">radians</span><span class=\"token punctuation\">(</span>yaw<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>cameraFront <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>front<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>计算出来的方向向量就会包含根据鼠标移动计算出来的所有旋转了。由于 cameraFront 向量已经包含在 GLM 的 lookAt 函数中，我们这就没什么问题了。</p>\n<p>如果你现在运行代码，你会发现在窗口第一次获取焦点的时候摄像机会突然跳一下。这个问题产生的原因是，在你的鼠标移动进窗口的那一刻，鼠标回调函数就会被调用，这时候的 xpos 和 ypos 会等于鼠标刚刚进入屏幕的那个位置。这通常是一个距离屏幕中心很远的地方，因而产生一个很大的偏移量，所以就会跳了。我们可以简单的使用一个 bool 变量检验我们是否是第一次获取鼠标输入，如果是，那么我们先把鼠标的初始位置更新为 xpos 和 ypos 值，这样就能解决这个问题；接下来的鼠标移动就会使用刚进入的鼠标位置坐标来计算偏移量了：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>firstMouse<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 这个 bool 变量初始时是设定为 true 的</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    lastX <span class=\"token operator\">=</span> xpos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    lastY <span class=\"token operator\">=</span> ypos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    firstMouse <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>最后的代码应该是这样的：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">mouse_callback</span><span class=\"token punctuation\">(</span>GLFWwindow<span class=\"token operator\">*</span> window<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> xpos<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> ypos<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>firstMouse<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        lastX <span class=\"token operator\">=</span> xpos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        lastY <span class=\"token operator\">=</span> ypos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        firstMouse <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">float</span> xoffset <span class=\"token operator\">=</span> xpos <span class=\"token operator\">-</span> lastX<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">float</span> yoffset <span class=\"token operator\">=</span> lastY <span class=\"token operator\">-</span> ypos<span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    lastX <span class=\"token operator\">=</span> xpos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    lastY <span class=\"token operator\">=</span> ypos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">float</span> sensitivity <span class=\"token operator\">=</span> <span class=\"token number\">0.05</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    xoffset <span class=\"token operator\">*=</span> sensitivity<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    yoffset <span class=\"token operator\">*=</span> sensitivity<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    yaw   <span class=\"token operator\">+=</span> xoffset<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    pitch <span class=\"token operator\">+=</span> yoffset<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>pitch <span class=\"token operator\">></span> <span class=\"token number\">89.0f</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        pitch <span class=\"token operator\">=</span> <span class=\"token number\">89.0f</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>pitch <span class=\"token operator\">&lt;</span> <span class=\"token operator\">-</span><span class=\"token number\">89.0f</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        pitch <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">89.0f</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    glm<span class=\"token operator\">::</span>vec3 front<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    front<span class=\"token punctuation\">.</span>x <span class=\"token operator\">=</span> <span class=\"token function\">cos</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">radians</span><span class=\"token punctuation\">(</span>yaw<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token function\">cos</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">radians</span><span class=\"token punctuation\">(</span>pitch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    front<span class=\"token punctuation\">.</span>y <span class=\"token operator\">=</span> <span class=\"token function\">sin</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">radians</span><span class=\"token punctuation\">(</span>pitch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    front<span class=\"token punctuation\">.</span>z <span class=\"token operator\">=</span> <span class=\"token function\">sin</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">radians</span><span class=\"token punctuation\">(</span>yaw<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token function\">cos</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">radians</span><span class=\"token punctuation\">(</span>pitch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    cameraFront <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>front<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"缩放-2\"><a class=\"anchor\" href=\"#缩放-2\">#</a> 缩放</h3>\n<p>作为我们摄像机系统的一个附加内容，我们还会来实现一个缩放 (Zoom) 接口。在之前的教程中我们说视野 (Field of View) 或 fov 定义了我们可以看到场景中多大的范围。当视野变小时，场景投影出来的空间就会减小，产生放大 (Zoom In) 了的感觉。我们会使用鼠标的滚轮来放大。与鼠标移动、键盘输入一样，我们需要一个鼠标滚轮的回调函数：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">scroll_callback</span><span class=\"token punctuation\">(</span>GLFWwindow<span class=\"token operator\">*</span> window<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> xoffset<span class=\"token punctuation\">,</span> <span class=\"token keyword\">double</span> yoffset<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>fov <span class=\"token operator\">>=</span> <span class=\"token number\">1.0f</span> <span class=\"token operator\">&amp;&amp;</span> fov <span class=\"token operator\">&lt;=</span> <span class=\"token number\">45.0f</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    fov <span class=\"token operator\">-=</span> yoffset<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>fov <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    fov <span class=\"token operator\">=</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>fov <span class=\"token operator\">>=</span> <span class=\"token number\">45.0f</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    fov <span class=\"token operator\">=</span> <span class=\"token number\">45.0f</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>当滚动鼠标滚轮的时候，yoffset 值代表我们竖直滚动的大小。当 scroll_callback 函数被调用后，我们改变全局变量 fov 变量的内容。因为 45.0f 是默认的视野值，我们将会把缩放级别 (Zoom Level) 限制在 1.0f 到 45.0f。</p>\n<p>我们现在在每一帧都必须把透视投影矩阵上传到 GPU，但现在使用 fov 变量作为它的视野：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>projection <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">perspective</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">radians</span><span class=\"token punctuation\">(</span>fov<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">800.0f</span> <span class=\"token operator\">/</span> <span class=\"token number\">600.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.1f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>最后不要忘记注册鼠标滚轮的回调函数：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glfwSetScrollCallback</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">,</span> scroll_callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><blockquote>\n<p>注意，使用欧拉角的摄像机系统并不完美。根据你的视角限制或者是配置，你仍然可能引入<mark>万向节死锁</mark>问题。最好的摄像机系统是使用<mark>四元数</mark> (Quaternions) 的，但我们将会把这个留到后面讨论。（译注：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2N5YmVyY3Nlci9PcGVuR0xfM18zX1R1dG9yaWFsX1RyYW5zbGF0aW9uL2Jsb2IvbWFzdGVyL1R1dG9yaWFsJTIwMTclMjBSb3RhdGlvbnMubWQ=\">这里可以查看四元数摄像机的实现</span>）</p>\n</blockquote>\n<h3 id=\"摄像机类\"><a class=\"anchor\" href=\"#摄像机类\">#</a> 摄像机类</h3>\n<p>接下来的教程中，我们将会一直使用一个摄像机来浏览场景，从各个角度观察结果。然而，由于一个摄像机会占用每篇教程很大的篇幅，我们将会从细节抽象出来，创建我们自己的摄像机对象，它会完成大多数的工作，而且还会提供一些附加的功能。与着色器教程不同，我们不会带你一步一步创建摄像机类，我们只会提供你一份（有完整注释的）代码，如果你想知道它的内部构造的话可以自己去阅读。</p>\n<p>和着色器对象一样，我们把摄像机类写在一个单独的头文件中。<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWFybm9wZW5nbC5jb20vY29kZV92aWV3ZXJfZ2gucGhwP2NvZGU9aW5jbHVkZXMvbGVhcm5vcGVuZ2wvY2FtZXJhLmg=\">你可以在这里找到它</span>，你现在应该能够理解所有的代码了。我们建议您至少看一看这个类，看看如何创建一个自己的摄像机类。</p>\n<blockquote>\n<p>注意 glm 矩阵中第一个下标是列，第二个下标才是行。即：</p>\n</blockquote>\n<pre><code>rotation[0][0] = xaxis.x; // 第一列，第一行\nrotation[0][2] = zaxis.x; // 第一列，第三行\n</code></pre>\n<h2 id=\"复习\"><a class=\"anchor\" href=\"#复习\">#</a> 复习</h2>\n<h3 id=\"词汇表\"><a class=\"anchor\" href=\"#词汇表\">#</a> 词汇表</h3>\n<ul>\n<li><strong>OpenGL</strong>： 一个定义了函数布局和输出的图形 API 的正式规范。</li>\n<li><strong>GLAD</strong>： 一个拓展加载库，用来为我们加载并设定所有 OpenGL 函数指针，从而让我们能够使用所有（现代）OpenGL 函数。</li>\n<li><strong>视口 (Viewport)</strong>： 我们需要渲染的窗口。</li>\n<li><strong>图形管线 (Graphics Pipeline)</strong>： 一个顶点在呈现为像素之前经过的全部过程。</li>\n<li><strong>着色器 (Shader)</strong>： 一个运行在显卡上的小型程序。很多阶段的图形管道都可以使用自定义的着色器来代替原有的功能。</li>\n<li><strong>标准化设备坐标 (Normalized Device Coordinates, NDC)</strong>： 顶点在通过在剪裁坐标系中剪裁与透视除法后最终呈现在的坐标系。所有位置在 NDC 下 - 1.0 到 1.0 的顶点将不会被丢弃并且可见。</li>\n<li><strong>顶点缓冲对象 (Vertex Buffer Object)</strong>： 一个调用显存并存储所有顶点数据供显卡使用的缓冲对象。</li>\n<li><strong>顶点数组对象 (Vertex Array Object)</strong>： 存储缓冲区和顶点属性状态。</li>\n<li><strong>索引缓冲对象 (Element Buffer Object)</strong>： 一个存储索引供索引化绘制使用的缓冲对象。</li>\n<li><strong>Uniform</strong>： 一个特殊类型的 GLSL 变量。它是全局的（在一个着色器程序中每一个着色器都能够访问 uniform 变量），并且只需要被设定一次。</li>\n<li><strong>纹理 (Texture)</strong>： 一种包裹着物体的特殊类型图像，给物体精细的视觉效果。</li>\n<li><strong>纹理缠绕 (Texture Wrapping)</strong>： 定义了一种当纹理顶点超出范围 (0, 1) 时指定 OpenGL 如何采样纹理的模式。</li>\n<li><strong>纹理过滤 (Texture Filtering)</strong>： 定义了一种当有多种纹素选择时指定 OpenGL 如何采样纹理的模式。这通常在纹理被放大情况下发生。</li>\n<li><strong>多级渐远纹理 (Mipmaps)</strong>： 被存储的材质的一些缩小版本，根据距观察者的距离会使用材质的合适大小。</li>\n<li><strong>stb_image.h</strong>： 图像加载库。</li>\n<li><strong>纹理单元 (Texture Units)</strong>： 通过绑定纹理到不同纹理单元从而允许多个纹理在同一对象上渲染。</li>\n<li><strong>向量 (Vector)</strong>： 一个定义了在空间中方向和 / 或位置的数学实体。</li>\n<li><strong>矩阵 (Matrix)</strong>： 一个矩形阵列的数学表达式。</li>\n<li><strong>GLM</strong>： 一个为 OpenGL 打造的数学库。</li>\n<li><strong>局部空间 (Local Space)</strong>： 一个物体的初始空间。所有的坐标都是相对于物体的原点的。</li>\n<li><strong>世界空间 (World Space)</strong>： 所有的坐标都相对于全局原点。</li>\n<li><strong>观察空间 (View Space)</strong>： 所有的坐标都是从摄像机的视角观察的。</li>\n<li><strong>裁剪空间 (Clip Space)</strong>： 所有的坐标都是从摄像机视角观察的，但是该空间应用了投影。这个空间应该是一个顶点坐标最终的空间，作为顶点着色器的输出。OpenGL 负责处理剩下的事情（裁剪 / 透视除法）。</li>\n<li><strong>屏幕空间 (Screen Space)</strong>： 所有的坐标都由屏幕视角来观察。坐标的范围是从 0 到屏幕的宽 / 高。</li>\n<li><strong>LookAt 矩阵</strong>： 一种特殊类型的观察矩阵，它创建了一个坐标系，其中所有坐标都根据从一个位置正在观察目标的用户旋转或者平移。</li>\n<li><strong>欧拉角 (Euler Angles)</strong>： 被定义为偏航角 (Yaw)，俯仰角 (Pitch)，和滚转角 (Roll) 从而允许我们通过这三个值构造任何 3D 方向。</li>\n</ul>\n",
            "tags": [
                "计算机科学",
                "学习笔记",
                "OpenGL"
            ]
        },
        {
            "id": "https://allengx.gitee.io/computer-science/study/opengl/%E4%BA%94%E3%80%81%E9%AB%98%E7%BA%A7%E5%85%89%E7%85%A7/",
            "url": "https://allengx.gitee.io/computer-science/study/opengl/%E4%BA%94%E3%80%81%E9%AB%98%E7%BA%A7%E5%85%89%E7%85%A7/",
            "title": "五、高级光照",
            "date_published": "2020-04-12T12:46:25.000Z",
            "content_html": "<div class=\"note info\">\n<p>以下为个人学习笔记整理</p>\n</div>\n<h2 id=\"高级光照\"><a class=\"anchor\" href=\"#高级光照\">#</a> 高级光照</h2>\n<p>在光照小节中，我们简单地介绍了冯氏光照模型，它让我们的场景有了一定的真实感。虽然冯氏模型看起来已经很不错了，但是使用它的时候仍然存在一些细节问题，我们将在这一节里讨论它们。</p>\n<h3 id=\"blinn-phong\"><a class=\"anchor\" href=\"#blinn-phong\">#</a> Blinn-Phong</h3>\n<p>冯氏光照不仅对真实光照有很好的近似，而且性能也很高。但是它的镜面反射会在一些情况下出现问题，特别是物体反光度很低时，会导致大片（粗糙的）高光区域。下面这张图展示了当反光度为 1.0 时地板会出现的效果：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/01/advanced_lighting_phong_limit.png\" alt=\"image\" /></p>\n<p>可以看到，在镜面高光区域的边缘出现了一道很明显的断层。出现这个问题的原因是观察向量和反射向量间的夹角不能大于 90 度。如果点积的结果为负数，镜面光分量会变为 0.0。你可能会觉得，当光线与视线夹角大于 90 度时你应该不会接收到任何光才对，所以这不是什么问题。</p>\n<p>然而，这种想法仅仅只适用于漫反射分量。当考虑漫反射光的时候，如果法线和光源夹角大于 90 度，光源会处于被照表面的下方，这个时候光照的漫反射分量的确是为 0.0。但是，在考虑镜面高光时，我们测量的角度并不是光源与法线的夹角，而是视线与反射光线向量的夹角。看一下下面这两张图：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/01/advanced_lighting_over_90.png\" alt=\"image\" /></p>\n<p>现在问题就应该很明显了。左图中是我们熟悉的冯氏光照中的反射向量，其中<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>θ</mi></mrow><annotation encoding=\"application/x-tex\">\\theta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">θ</span></span></span></span> 角小于 90 度。而右图中，视线与反射方向之间的夹角明显大于 90 度，这种情况下镜面光分量会变为 0.0。这在大多数情况下都不是什么问题，因为观察方向离反射方向都非常远。然而，当物体的镜面光分量非常小时，它产生的镜面高光半径足以让这些相反方向的光线对亮度产生足够大的影响。在这种情况下就不能忽略它们对镜面光分量的贡献了。</p>\n<p>1977 年，James F. Blinn 在冯氏着色模型上加以拓展，引入了<mark> Blinn-Phong</mark> 着色模型。Blinn-Phong 模型与冯氏模型非常相似，但是它对镜面光模型的处理上有一些不同，让我们能够解决之前提到的问题。Blinn-Phong 模型不再依赖于反射向量，而是采用了所谓的半程向量 (Halfway Vector)，即光线与视线夹角一半方向上的一个单位向量。当半程向量与法线向量越接近时，镜面光分量就越大。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/01/advanced_lighting_halfway_vector.png\" alt=\"image\" /></p>\n<p>当视线正好与（现在不需要的）反射向量对齐时，半程向量就会与法线完美契合。所以当观察者视线越接近于原本反射光线的方向时，镜面高光就会越强。</p>\n<p>现在，不论观察者向哪个方向看，半程向量与表面法线之间的夹角都不会超过 90 度（除非光源在表面以下）。它产生的效果会与冯氏光照有些许不同，但是大部分情况下看起来会更自然一点，特别是低高光的区域。Blinn-Phong 着色模型正是早期固定渲染管线时代时 OpenGL 所采用的光照模型。</p>\n<p>获取半程向量的方法很简单，只需要将光线的方向向量和观察向量加到一起，并将结果正规化 (Normalize) 就可以了：</p>\n<pre><code class=\"language-math\">H¯=\\frac&#123;\\bar&#123;L&#125;+\\bar&#123;V&#125;&#125;&#123;\\begin&#123;Vmatrix&#125;\n  \\bar&#123;L&#125;+\\bar&#123;V&#125;\\\\\n\\end&#123;Vmatrix&#125;&#125;\n</code></pre>\n<p>翻译成 GLSL 代码如下：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vec3 lightDir   <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>lightPos <span class=\"token operator\">-</span> FragPos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>vec3 viewDir    <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>viewPos <span class=\"token operator\">-</span> FragPos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>vec3 halfwayDir <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>lightDir <span class=\"token operator\">+</span> viewDir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>接下来，镜面光分量的实际计算只不过是对表面法线和半程向量进行一次约束点乘 (Clamped Dot Product)，让点乘结果不为负，从而获取它们之间夹角的余弦值，之后我们对这个值取反光度次方：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> spec <span class=\"token operator\">=</span> <span class=\"token function\">pow</span><span class=\"token punctuation\">(</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token function\">dot</span><span class=\"token punctuation\">(</span>normal<span class=\"token punctuation\">,</span> halfwayDir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> shininess<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>vec3 specular <span class=\"token operator\">=</span> lightColor <span class=\"token operator\">*</span> spec<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>除此之外 Blinn-Phong 模型就没什么好说的了，Blinn-Phong 与冯氏模型唯一的区别就是，Blinn-Phong 测量的是法线与半程向量之间的夹角，而冯氏模型测量的是观察方向与反射向量间的夹角。</p>\n<p>在引入半程向量之后，我们现在应该就不会再看到冯氏光照中高光断层的情况了。下面两个图片展示的是两种方法在镜面光分量为 0.5 时的对比：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/01/advanced_lighting_comparrison.png\" alt=\"image\" /></p>\n<p>除此之外，冯氏模型与 Blinn-Phong 模型也有一些细微的差别：半程向量与表面法线的夹角通常会小于观察与反射向量的夹角。所以，如果你想获得和冯氏着色类似的效果，就必须在使用 Blinn-Phong 模型时将镜面反光度设置更高一点。通常我们会选择冯氏着色时反光度分量的 2 到 4 倍。</p>\n<p>下面是冯氏着色反光度为 8.0，Blinn-Phong 着色反光度为 32.0 时的一个对比：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/01/advanced_lighting_comparrison2.png\" alt=\"image\" /></p>\n<p>你可以看到，Blinn-Phong 的镜面光分量会比冯氏模型更锐利一些。为了得到与冯氏模型类似的结果，你可能会需要不断进行一些微调，但 Blinn-Phong 模型通常会产出更真实的结果。</p>\n<p>这里，我们使用了一个简单的片段着色器，让我们能够在冯氏反射与 Blinn-Phong 反射间进行切换：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">float</span> spec <span class=\"token operator\">=</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>blinn<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        vec3 halfwayDir <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>lightDir <span class=\"token operator\">+</span> viewDir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        spec <span class=\"token operator\">=</span> <span class=\"token function\">pow</span><span class=\"token punctuation\">(</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token function\">dot</span><span class=\"token punctuation\">(</span>normal<span class=\"token punctuation\">,</span> halfwayDir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">16.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">else</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        vec3 reflectDir <span class=\"token operator\">=</span> <span class=\"token function\">reflect</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>lightDir<span class=\"token punctuation\">,</span> normal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        spec <span class=\"token operator\">=</span> <span class=\"token function\">pow</span><span class=\"token punctuation\">(</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token function\">dot</span><span class=\"token punctuation\">(</span>viewDir<span class=\"token punctuation\">,</span> reflectDir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"gamma校正\"><a class=\"anchor\" href=\"#gamma校正\">#</a> Gamma 校正</h2>\n<p>当我们计算出场景中所有像素的最终颜色以后，我们就必须把它们显示在监视器上。过去，大多数监视器是阴极射线管显示器（CRT）。这些监视器有一个物理特性就是两倍的输入电压产生的不是两倍的亮度。输入电压产生约为输入电压的 2.2 次幂的亮度，这叫做监视器 Gamma。</p>\n<blockquote>\n<p>Gamma 也叫灰度系数，每种显示设备都有自己的 Gamma 值，都不相同，有一个公式：设备输出亮度 = 电压的 Gamma 次幂，任何设备 Gamma 基本上都不会等于 1，等于 1 是一种理想的线性状态，这种理想状态是：如果电压和亮度都是在 0 到 1 的区间，那么多少电压就等于多少亮度。对于 CRT，Gamma 通常为 2.2，因而，输出亮度 = 输入电压的 2.2 次幂，你可以从本节第二张图中看到 Gamma2.2 实际显示出来的总会比预期暗，相反 Gamma0.45 就会比理想预期亮，如果你讲 Gamma0.45 叠加到 Gamma2.2 的显示设备上，便会对偏暗的显示效果做到校正，这个简单的思路就是本节的核心</p>\n</blockquote>\n<p>人类所感知的亮度恰好和 CRT 所显示出来相似的指数关系非常匹配。为了更好的理解所有含义，请看下面的图片：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/02/gamma_correction_brightness.png\" alt=\"image\" /></p>\n<p>第一行是人眼所感知到的正常的灰阶，亮度要增加一倍（比如从 0.1 到 0.2）你才会感觉比原来变亮了一倍（译注：这里的意思是说比如一个东西的亮度 0.3，让人感觉它比原来变亮一倍，那么现在这个亮度应该成为 0.6，而不是 0.4，也就是说人眼感知到的亮度的变化并非线性均匀分布的。问题的关键在于这样的一倍相当于一个亮度级，例如假设 0.1、0.2、0.4、0.8 是我们定义的四个亮度级别，在 0.1 和 0.2 之间人眼只能识别出 0.15 这个中间级，而虽然 0.4 到 0.8 之间的差距更大，这个区间人眼也只能识别出一个颜色）。然而，当我们谈论光的物理亮度，比如光源发射光子的数量的时候，底部（第二行）的灰阶显示出的才是物理世界真实的亮度。如底部的灰阶显示，亮度加倍时返回的也是真实的物理亮度（译注：这里亮度是指光子数量和正相关的亮度，即物理亮度，前面讨论的是人的感知亮度；物理亮度和感知亮度的区别在于，物理亮度基于光子数量，感知亮度基于人的感觉，比如第二个灰阶里亮度 0.1 的光子数量是 0.2 的二分之一），但是由于这与我们的眼睛感知亮度不完全一致（<mark>对比较暗的颜色变化更敏感</mark>），所以它看起来有差异。</p>\n<p>因为人眼看到颜色的亮度更倾向于顶部的灰阶，监视器使用的也是一种指数关系（电压的 2.2 次幂），所以物理亮度通过监视器能够被映射到顶部的非线性亮度；因此看起来效果不错（译注：CRT 亮度是是电压的 2.2 次幂而人眼相当于 2 次幂，因此 CRT 这个缺陷正好能满足人的需要）。</p>\n<p>监视器的这个非线性映射的确可以让亮度在我们眼中看起来更好，但当渲染图像时，会产生一个问题：我们在应用中配置的亮度和颜色是基于监视器所看到的，这样所有的配置实际上是非线性的亮度 / 颜色配置。请看下图：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/02/gamma_correction_gamma_curves.png\" alt=\"image\" /></p>\n<p>点线代表线性颜色 / 亮度值（译注：这表示的是理想状态，Gamma 为 1），<mark>实线</mark>代表监视器显示的颜色。如果我们把一个点线线性的颜色翻一倍，结果就是这个值的两倍。比如，光的颜色向量 L¯=(0.5,0.0,0.0) 代表的是暗红色。如果我们在线性空间中把它翻倍，就会变成 (1.0,0.0,0.0)，就像你在图中看到的那样。然而，由于我们定义的颜色仍然需要输出的监视器上，监视器上显示的实际颜色就会是 (0.218,0.0,0.0)。在这儿问题就出现了：当我们将理想中直线上的那个暗红色翻一倍时，在监视器上实际上亮度翻了 4.5 倍以上！</p>\n<p>直到现在，我们还一直假设我们所有的工作都是在线性空间中进行的（译注：Gamma 为 1），但最终还是要把所有的颜色输出到监视器上，所以我们配置的所有颜色和光照变量从物理角度来看都是不正确的，在我们的监视器上很少能够正确地显示。出于这个原因，我们（以及艺术家）通常将光照值设置得比本来更亮一些（由于监视器会将其亮度显示的更暗一些），如果不是这样，在线性空间里计算出来的光照就会不正确。同时，还要记住，监视器所显示出来的图像和线性图像的最小亮度是相同的，它们最大的亮度也是相同的；只是中间亮度部分会被压暗。</p>\n<p>因为所有中间亮度都是线性空间计算出来的（译注：计算的时候假设 Gamma 为 1）监视器显以后，实际上都会不正确。当使用更高级的光照算法时，这个问题会变得越来越明显，你可以看看下图：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/02/gamma_correction_example.png\" alt=\"image\" /></p>\n<h3 id=\"gamma校正-2\"><a class=\"anchor\" href=\"#gamma校正-2\">#</a> Gamma 校正</h3>\n<p>Gamma 校正 (Gamma Correction) 的思路是在最终的颜色输出上应用监视器 Gamma 的倒数。回头看前面的 Gamma 曲线图，你会有一个短划线，它是监视器 Gamma 曲线的翻转曲线。我们在颜色显示到监视器的时候把每个颜色输出都加上这个翻转的 Gamma 曲线，这样应用了监视器 Gamma 以后最终的颜色将会变为线性的。我们所得到的中间色调就会更亮，所以虽然监视器使它们变暗，但是我们又将其平衡回来了。</p>\n<p>我们来看另一个例子。还是那个暗红色 (0.5,0.0,0.0)。在将颜色显示到监视器之前，我们先对颜色应用 Gamma 校正曲线。线性的颜色显示在监视器上相当于降低了 2.2 次幂的亮度，所以倒数就是 1/2.2 次幂。Gamma 校正后的暗红色就会成为 (0.5,0.0,0.0)<sup>(1/2.2)=(0.5,0.0,0.0)</sup>(0.45)=(0.73,0.0,0.0)。校正后的颜色接着被发送给监视器，最终显示出来的颜色是 (0.73,0.0,0.0)^(2.2)=(0.5,0.0,0.0)。你会发现使用了 Gamma 校正，监视器最终会显示出我们在应用中设置的那种线性的颜色。</p>\n<blockquote>\n<p>2.2 通常是是大多数显示设备的大概平均 gamma 值。基于 gamma2.2 的颜色空间叫做 sRGB 颜色空间。每个监视器的 gamma 曲线都有所不同，但是 gamma2.2 在大多数监视器上表现都不错。出于这个原因，游戏经常都会为玩家提供改变游戏 gamma 设置的选项，以适应每个监视器（译注：现在 Gamma2.2 相当于一个标准，后文中你会看到。但现在你可能会问，前面不是说 Gamma2.2 看起来不是正好适合人眼么，为何还需要校正。这是因为你在程序中设置的颜色，比如光照都是基于线性 Gamma，即 Gamma1，所以你理想中的亮度和实际表达出的不一样，如果要表达出你理想中的亮度就要对这个光照进行校正）。</p>\n</blockquote>\n<p>有两种在你的场景中应用 gamma 校正的方式：</p>\n<p>使用 OpenGL 内建的 sRGB 帧缓冲。 自己在像素着色器中进行 gamma 校正。 第一个选项也许是最简单的方式，但是我们也会丧失一些控制权。开启 GL_FRAMEBUFFER_SRGB，可以告诉 OpenGL 每个后续的绘制命令里，在颜色储存到颜色缓冲之前先校正 sRGB 颜色。sRGB 这个颜色空间大致对应于 gamma2.2，它也是家用设备的一个标准。开启 GL_FRAMEBUFFER_SRGB 以后，每次像素着色器运行后续帧缓冲，OpenGL 将自动执行 gamma 校正，包括默认帧缓冲。</p>\n<p>开启 GL_FRAMEBUFFER_SRGB 简单的调用 glEnable 就行：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glEnable</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER_SRGB<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>自此，你渲染的图像就被进行 gamma 校正处理，你不需要做任何事情硬件就帮你处理了。有时候，你应该记得这个建议：gamma 校正将把线性颜色空间转变为非线性空间，所以在最后一步进行 gamma 校正是极其重要的。如果你在最后输出之前就进行 gamma 校正，所有的后续操作都是在操作不正确的颜色值。例如，如果你使用多个帧缓冲，你可能打算让两个帧缓冲之间传递的中间结果仍然保持线性空间颜色，只是给发送给监视器的最后的那个帧缓冲应用 gamma 校正。</p>\n<p>第二个方法稍微复杂点，但同时也是我们对 gamma 操作有完全的控制权。我们在每个相关像素着色器运行的最后应用 gamma 校正，所以在发送到帧缓冲前，颜色就被校正了。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\">// do super fancy lighting </span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token comment\">// apply gamma correction</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">float</span> gamma <span class=\"token operator\">=</span> <span class=\"token number\">2.2</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    fragColor<span class=\"token punctuation\">.</span>rgb <span class=\"token operator\">=</span> <span class=\"token function\">pow</span><span class=\"token punctuation\">(</span>fragColor<span class=\"token punctuation\">.</span>rgb<span class=\"token punctuation\">,</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span><span class=\"token operator\">/</span>gamma<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>最后一行代码，将 fragColor 的每个颜色元素应用有一个 1.0/gamma 的幂运算，校正像素着色器的颜色输出。</p>\n<p>这个方法有个问题就是为了保持一致，你必须在像素着色器里加上这个 gamma 校正，所以如果你有很多像素着色器，它们可能分别用于不同物体，那么你就必须在每个着色器里都加上 gamma 校正了。一个更简单的方案是在你的渲染循环中引入后处理阶段，在后处理四边形上应用 gamma 校正，这样你只要做一次就好了。</p>\n<p>这些单行代码代表了 gamma 校正的实现。不太令人印象深刻，但当你进行 gamma 校正的时候有一些额外的事情别忘了考虑。</p>\n<h3 id=\"srgb纹理\"><a class=\"anchor\" href=\"#srgb纹理\">#</a> sRGB 纹理</h3>\n<p>因为监视器总是在 sRGB 空间中显示应用了 gamma 的颜色，无论什么时候当你在计算机上绘制、编辑或者画出一个图片的时候，你所选的颜色都是根据你在监视器上看到的那种。这实际意味着所有你创建或编辑的图片并不是在线性空间，而是在 sRGB 空间中（译注：sRGB 空间定义的 gamma 接近于 2.2），假如在你的屏幕上对暗红色翻一倍，便是根据你所感知到的亮度进行的，并不等于将红色元素加倍。</p>\n<p>结果就是纹理编辑者，所创建的所有纹理都是在 sRGB 空间中的纹理，所以如果我们在渲染应用中使用这些纹理，我们必须考虑到这点。在我们应用 gamma 校正之前，这不是个问题，因为纹理在 sRGB 空间创建和展示，同样我们还是在 sRGB 空间中使用，从而不必 gamma 校正纹理显示也没问题。然而，现在我们是把所有东西都放在线性空间中展示的，纹理颜色就会变坏，如下图展示的那样：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/02/gamma_correction_srgbtextures.png\" alt=\"image\" /></p>\n<p>纹理图像实在太亮了，发生这种情况是因为，它们实际上进行了两次 gamma 校正！想一想，当我们基于监视器上看到的情况创建一个图像，我们就已经对颜色值进行了 gamma 校正，所以再次显示在监视器上就没错。由于我们在渲染中又进行了一次 gamma 校正，图片就实在太亮了。</p>\n<p>为了修复这个问题，我们得确保纹理制作者是在线性空间中进行创作的。但是，由于大多数纹理制作者并不知道什么是 gamma 校正，并且在 sRGB 空间中进行创作更简单，这也许不是一个好办法。</p>\n<p>另一个解决方案是重校，或把这些 sRGB 纹理在进行任何颜色值的计算前变回线性空间。我们可以这样做：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> gamma <span class=\"token operator\">=</span> <span class=\"token number\">2.2</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>vec3 diffuseColor <span class=\"token operator\">=</span> <span class=\"token function\">pow</span><span class=\"token punctuation\">(</span><span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>diffuse<span class=\"token punctuation\">,</span> texCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>rgb<span class=\"token punctuation\">,</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span>gamma<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>为每个 sRGB 空间的纹理做这件事非常烦人。幸好，OpenGL 给我们提供了另一个方案来解决我们的麻烦，这就是 GL_SRGB 和 GL_SRGB_ALPHA 内部纹理格式。</p>\n<p>如果我们在 OpenGL 中创建了一个纹理，把它指定为以上两种 sRGB 纹理格式其中之一，OpenGL 将自动把颜色校正到线性空间中，这样我们所使用的所有颜色值都是在线性空间中的了。我们可以这样把一个纹理指定为一个 sRGB 纹理：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glTexImage2D</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> GL_SRGB<span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> GL_RGB<span class=\"token punctuation\">,</span> GL_UNSIGNED_BYTE<span class=\"token punctuation\">,</span> image<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>如果你还打算在你的纹理中引入 alpha 元素，必究必须将纹理的内部格式指定为 GL_SRGB_ALPHA。</p>\n<p>因为不是所有纹理都是在 sRGB 空间中的所以当你把纹理指定为 sRGB 纹理时要格外小心。比如 diffuse 纹理，这种为物体上色的纹理几乎都是在 sRGB 空间中的。而为了获取光照参数的纹理，像 specular 贴图和法线贴图几乎都在线性空间中，所以如果你把它们也配置为 sRGB 纹理的话，光照就坏掉了。指定 sRGB 纹理时要当心。</p>\n<p>将 diffuse 纹理定义为 sRGB 纹理之后，你将获得你所期望的视觉输出，但这次每个物体都会只进行一次 gamma 校正。</p>\n<h3 id=\"衰减\"><a class=\"anchor\" href=\"#衰减\">#</a> 衰减</h3>\n<p>在使用了 gamma 校正之后，另一个不同之处是光照衰减 (Attenuation)。真实的物理世界中，光照的衰减和光源的距离的平方成反比。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> attenuation <span class=\"token operator\">=</span> <span class=\"token number\">1.0</span> <span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span>distance <span class=\"token operator\">*</span> distance<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>然而，当我们使用这个衰减公式的时候，衰减效果总是过于强烈，光只能照亮一小圈，看起来并不真实。出于这个原因，我们使用在基本光照教程中所讨论的那种衰减方程，它给了我们更大的控制权，此外我们还可以使用双曲线函数：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> attenuation <span class=\"token operator\">=</span> <span class=\"token number\">1.0</span> <span class=\"token operator\">/</span> distance<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>双曲线比使用二次函数变体在不用 gamma 校正的时候看起来更真实，不过但我们开启 gamma 校正以后线性衰减看起来太弱了，符合物理的二次函数突然出现了更好的效果。下图显示了其中的不同：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/02/gamma_correction_attenuation.png\" alt=\"image\" /></p>\n<p>这种差异产生的原因是，光的衰减方程改变了亮度值，而且屏幕上显示出来的也不是线性空间，在监视器上效果最好的衰减方程，并不是符合物理的。想想平方衰减方程，如果我们使用这个方程，而且不进行 gamma 校正，显示在监视器上的衰减方程实际上将变成 (1.0/distance<sup>(2))</sup>(2.2)。若不进行 gamma 校正，将产生更强烈的衰减。这也解释了为什么双曲线不用 gamma 校正时看起来更真实，因为它实际变成了 (1.0/distance)^(2.2) =1.0/distance^(2.2)。这和物理公式是很相似的。</p>\n<blockquote>\n<p>我们在基础光照教程中讨论的更高级的那个衰减方程在有 gamma 校正的场景中也仍然有用，因为它可以让我们对衰减拥有更多准确的控制权（不过，在进行 gamma 校正的场景中当然需要不同的参数）。</p>\n</blockquote>\n<p>我创建的这个简单的 demo 场景，你可以在这里找到源码以及顶点和像素着色器。按下空格就能在有 gamma 校正和无 gamma 校正的场景进行切换，两个场景使用的是相同的纹理和衰减。这不是效果最好的 demo，不过它能展示出如何应用所有这些技术。</p>\n<p>总而言之，gamma 校正使你可以在线性空间中进行操作。因为线性空间更符合物理世界，大多数物理公式现在都可以获得较好效果，比如真实的光的衰减。你的光照越真实，使用 gamma 校正获得漂亮的效果就越容易。这也正是为什么当引进 gamma 校正时，建议只去调整光照参数的原因。</p>\n<h3 id=\"附加资源\"><a class=\"anchor\" href=\"#附加资源\">#</a> 附加资源</h3>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY2FtYnJpZGdlaW5jb2xvdXIuY29tL3R1dG9yaWFscy9nYW1tYS1jb3JyZWN0aW9uLmh0bQ==\">cambridgeincolour.com</span>: 更多关于 gamma 和 gamma 校正的内容。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2Jsb2cud29sZmlyZS5jb20vMjAxMC8wMi9HYW1tYS1jb3JyZWN0LWxpZ2h0aW5n\">wolfire.com</span>: David Rosen 关于在渲染领域使用 gamma 校正的好处。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3JlbmRlcndvbmsuY29tL2Jsb2cvaW5kZXgucGhwL2FyY2hpdmUvYWR2ZW50dXJlcy13aXRoLWdhbW1hLWNvcnJlY3QtcmVuZGVyaW5nLw==\">renderwonk.com</span>: 一些额外的实践上的思考。</li>\n</ul>\n<h2 id=\"shadow-mapping\"><a class=\"anchor\" href=\"#shadow-mapping\">#</a> Shadow Mapping</h2>\n<p>阴影是由于遮挡导致的光线缺失的结果；当光源的光线没有撞到物体时，因为它被一些其他物体遮挡，物体处于阴影中。阴影为光照场景添加了大量的真实感，使观察者更容易观察物体之间的空间关系。它们为我们的场景和物体提供了更大的深度感。例如，查看带阴影和没有阴影的场景的以下图像：</p>\n<p><img data-src=\"https://learnopengl.com/img/advanced-lighting/shadow_mapping_with_without.png\" alt=\"image\" /></p>\n<p>你可以看到，对于阴影，对象如何相互关联变得更加明显。例如，当我们有阴影时，其中一个立方体浮动在其他立方体之上的事实会更加明显。</p>\n<p>然而，阴影实现起来有点棘手，特别是因为在当前的实时（光栅化图形）研究中，还没有开发出完美的阴影算法。有几种很好的阴影近似技术，但它们都有它们的小怪癖和烦恼，我们必须考虑到这些。</p>\n<p>大多数视频游戏使用的一种技术可以提供不错的结果并且相对容易实现 <strong>阴影贴图</strong>。阴影贴图不易理解，性能成本不高，并且很容易扩展到更高级的算法（如<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWFybm9wZW5nbC5jb20vQWR2YW5jZWQtTGlnaHRpbmcvU2hhZG93cy9Qb2ludC1TaGFkb3dz\">全向阴影贴图</span>和<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWFybm9wZW5nbC5jb20vQWR2YW5jZWQtTGlnaHRpbmcvU2hhZG93cy9DU00=\">级联阴影贴图</span>）。</p>\n<h3 id=\"阴影贴图\"><a class=\"anchor\" href=\"#阴影贴图\">#</a> 阴影贴图</h3>\n<p>阴影贴图背后的想法很简单：我们从灯光的角度渲染场景，我们从灯光的角度看到的一切都被照亮，我们看不到的一切都必须在阴影中。想象一下一个地板部分，它自身和一个光源之间有一个大盒子。由于光源在看方向时会看到这个方框而不是地板部分，特定的地板部分应该是阴影。</p>\n<p><img data-src=\"https://learnopengl.com/img/advanced-lighting/shadow_mapping_theory.png\" alt=\"image\" /></p>\n<p>这里所有的蓝线代表光源可以看到的碎片。被遮挡的碎片显示为黑色线条：这些被渲染为阴影。如果我们画一条线或射线从光源到最右边的盒子上的碎片我们可以看到射线在撞到最右边的容器之前首先撞到浮动容器。结果，浮动容器的片段被点亮，最右边的容器的片段不亮，因此处于阴影中。</p>\n<p>我们希望在射线首先击中一个物体并将该最近点与该射线上的其他点进行比较时获得一个点。然后，我们进行基本测试，以查看测试点的光线位置是否比光线位置更靠近光线，如果是这样，测试点必须处于阴影中。迭代来自这种光源的数千个光线是一种非常低效的方法，并且不适合实时渲染。我们可以做类似的事情，但不能投射光线。相反，我们使用我们非常熟悉的东西：<mark>深度缓冲</mark>区。</p>\n<p>您可能还记得深度测试教程中深度缓冲区中的值对应于从摄像机视角夹紧到 [0,1] 的片段的深度。如果我们从灯光的角度渲染场景并将结果深度值存储在纹理中，该怎么办？通过这种方式，我们可以从灯光的角度对最近的深度值进行采样。毕竟，深度值显示从灯光的角度可见的第一个片段。我们将所有这些深度值存储在我们称之为的纹理中<mark>深度图</mark>或者 <mark>阴影贴图</mark>。</p>\n<p><img data-src=\"https://learnopengl.com/img/advanced-lighting/shadow_mapping_theory_spaces.png\" alt=\"image\" /></p>\n<p>左图显示了定向光源（所有光线平行），在立方体下方的表面上投射阴影。使用存储在深度图中的深度值，我们找到最近的点并使用它来确定片段是否在阴影中。我们通过使用特定于该光源的视图和投影矩阵渲染场景（<mark>从光的角度</mark>）来创建深度图。该投影和视图矩阵一起形成 T 变换，它可以将任何三维位置转变到光源的可见坐标空间。</p>\n<blockquote>\n<p>定向光没有位置，因为它被建模为无限远。但是，为了阴影贴图，我们需要从灯光的角度渲染场景，从而从沿光线方向的某个位置渲染场景。</p>\n</blockquote>\n<p>在右边的图中我们显示出同样的平行光和观察者。我们渲染一个点 P 处的片元，需要决定它是否在阴影中。我们先得使用 T 把 P 变换到光源的坐标空间里。既然点 P 是从光的透视图中看到的，它的 z 坐标就对应于它的深度，例子中这个值是 0.9。使用点 P 在光源的坐标空间的坐标，我们可以索引深度贴图，来获得从光的视角中最近的可见深度，结果是点 C，最近的深度是 0.4。因为索引深度贴图的结果是一个小于点 P 的深度，我们可以断定 P 被挡住了，它在阴影中了。</p>\n<p>深度映射由两个步骤组成：首先，我们渲染深度贴图（<mark>用于判断阴影的深度值</mark>），然后我们像往常一样渲染场景，使用生成的深度贴图来计算片元是否在阴影之中。听起来有点复杂，但随着我们一步一步地讲解这个技术，就能理解了。</p>\n<h3 id=\"深度贴图\"><a class=\"anchor\" href=\"#深度贴图\">#</a> 深度贴图</h3>\n<p>第一步我们需要生成一张深度贴图 (Depth Map)。深度贴图是从光的透视图里渲染的深度纹理，用它计算阴影。因为我们需要将场景的渲染结果储存到一个纹理中，我们将再次需要帧缓冲。</p>\n<p>首先，我们要为渲染的深度贴图创建一个帧缓冲对象：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> depthMapFBO<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glGenFramebuffers</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>depthMapFBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>接下来，我们创建一个 2D 纹理，我们将其用作帧缓冲区的深度缓冲区：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">const</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> SHADOW_WIDTH <span class=\"token operator\">=</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">,</span> SHADOW_HEIGHT <span class=\"token operator\">=</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> depthMap<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glGenTextures</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>depthMap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> depthMap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">glTexImage2D</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> GL_DEPTH_COMPONENT<span class=\"token punctuation\">,</span> SHADOW_WIDTH<span class=\"token punctuation\">,</span> SHADOW_HEIGHT<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> GL_DEPTH_COMPONENT<span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_MIN_FILTER<span class=\"token punctuation\">,</span> GL_NEAREST<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_MAG_FILTER<span class=\"token punctuation\">,</span> GL_NEAREST<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_WRAP_S<span class=\"token punctuation\">,</span> GL_REPEAT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_WRAP_T<span class=\"token punctuation\">,</span> GL_REPEAT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>生成深度贴图不太复杂。因为我们只关心深度值，我们要把纹理格式指定为 GL_DEPTH_COMPONENT。我们还要把纹理的高宽设置为 1024：这是深度贴图的解析度。</p>\n<p>把我们把生成的深度纹理作为帧缓冲的深度缓冲：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glBindFramebuffer</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> depthMapFBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glFramebufferTexture2D</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> GL_DEPTH_ATTACHMENT<span class=\"token punctuation\">,</span> GL_TEXTURE_2D<span class=\"token punctuation\">,</span> depthMap<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glDrawBuffer</span><span class=\"token punctuation\">(</span>GL_NONE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glReadBuffer</span><span class=\"token punctuation\">(</span>GL_NONE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">glBindFramebuffer</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>我们需要的只是在从光的透视图下渲染场景的时候深度信息，所以颜色缓冲没有用。然而帧缓冲对象不是完全不包含颜色缓冲的，所以我们需要显式告诉 OpenGL 我们不适用任何颜色数据进行渲染。我们通过将调用 glDrawBuffer 和 glReadBuffer 把读和绘制缓冲设置为 GL_NONE 来做这件事。</p>\n<p>合理配置将深度值渲染到纹理的帧缓冲后，我们就可以开始第一步了：生成深度贴图。两个步骤的完整的渲染阶段，看起来有点像这样：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 1. 首选渲染深度贴图</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glViewport</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> SHADOW_WIDTH<span class=\"token punctuation\">,</span> SHADOW_HEIGHT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glBindFramebuffer</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> depthMapFBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token function\">glClear</span><span class=\"token punctuation\">(</span>GL_DEPTH_BUFFER_BIT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token function\">ConfigureShaderAndMatrices</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token function\">RenderScene</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">glBindFramebuffer</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">// 2. 像往常一样渲染场景，但这次使用深度贴图</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token function\">glViewport</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> SCR_WIDTH<span class=\"token punctuation\">,</span> SCR_HEIGHT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token function\">glClear</span><span class=\"token punctuation\">(</span>GL_COLOR_BUFFER_BIT <span class=\"token operator\">|</span> GL_DEPTH_BUFFER_BIT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token function\">ConfigureShaderAndMatrices</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> depthMap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token function\">RenderScene</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这段代码隐去了一些细节，但它表达了阴影映射的基本思路。这里一定要记得调用 glViewport。因为阴影贴图经常和我们原来渲染的场景（通常是窗口解析度）有着不同的解析度，我们需要改变视口（viewport）的参数以适应阴影贴图的尺寸。如果我们忘了更新视口参数，最后的深度贴图要么太小要么就不完整。</p>\n<h3 id=\"光源空间的变换\"><a class=\"anchor\" href=\"#光源空间的变换\">#</a> 光源空间的变换</h3>\n<p>前面那段代码中一个不清楚的函数是<mark> ConfigureShaderAndMatrices</mark>。它是用来在第二个步骤确保为每个物体设置了合适的投影和视图矩阵，以及相关的模型矩阵。然而，第一个步骤中，我们从光的位置的视野下使用了不同的投影和视图矩阵来渲染的场景。</p>\n<p>因为我们使用的是一个所有光线都平行的定向光。出于这个原因，我们将为光源使用正交投影矩阵，透视图将没有任何变形：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> near_plane <span class=\"token operator\">=</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> far_plane <span class=\"token operator\">=</span> <span class=\"token number\">7.5f</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>glm<span class=\"token operator\">::</span>mat4 lightProjection <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">ortho</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">10.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10.0f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">10.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10.0f</span><span class=\"token punctuation\">,</span> near_plane<span class=\"token punctuation\">,</span> far_plane<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这里有个本节教程的 demo 场景中使用的正交投影矩阵的例子。因为投影矩阵间接决定可视区域的范围，以及哪些东西不会被裁切，你需要保证投影视锥（frustum）的大小，以包含打算在深度贴图中包含的物体。当物体和片元不在深度贴图中时，它们就不会产生阴影。</p>\n<p>为了创建一个视图矩阵来变换每个物体，把它们变换到从光源视角可见的空间中，我们将使用 glm::lookAt 函数；这次从光源的位置看向场景中央。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span>mat4 lightView <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">lookAt</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">vec</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">2.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4.0f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>二者相结合为我们提供了一个光空间的变换矩阵，它将每个世界空间坐标变换到光源处所见到的那个空间；这正是我们渲染深度贴图所需要的。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span>mat4 lightSpaceMatrix <span class=\"token operator\">=</span> lightProjection <span class=\"token operator\">*</span> lightView<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这个 lightSpaceMatrix 正是前面我们称为<mark> T</mark> 的那个<mark>变换矩阵</mark>。有了 lightSpaceMatrix 只要给 shader 提供光空间的投影和视图矩阵，我们就能像往常那样渲染场景了。然而，我们只关心深度值，并非所有片元计算都在我们的着色器中进行。为了提升性能，我们将使用一个与之不同但更为简单的着色器来渲染出深度贴图。</p>\n<h3 id=\"渲染至深度贴图\"><a class=\"anchor\" href=\"#渲染至深度贴图\">#</a> 渲染至深度贴图</h3>\n<p>当我们以光的透视图进行场景渲染的时候，我们会用一个比较简单的着色器，这个着色器除了把顶点变换到光空间以外，不会做得更多了。这个简单的着色器叫做 simpleDepthShader，就是使用下面的这个着色器：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> in vec3 position<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>uniform mat4 lightSpaceMatrix<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>uniform mat4 model<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> lightSpaceMatrix <span class=\"token operator\">*</span> model <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>position<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这个顶点着色器将一个单独模型的一个顶点，使用 lightSpaceMatrix 变换到光空间中。</p>\n<p>由于我们没有颜色缓冲，最后的片元不需要任何处理，所以我们可以简单地使用一个空像素着色器：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#123;</span>             </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token comment\">// gl_FragDepth = gl_FragCoord.z;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这个空像素着色器什么也不干，运行完后，深度缓冲会被更新。我们可以取消那行的注释，来显式设置深度，但是这个（指注释掉那行之后）是更有效率的，因为底层无论如何都会默认去设置深度缓冲。</p>\n<p>渲染深度缓冲现在成了：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>simpleDepthShader<span class=\"token punctuation\">.</span><span class=\"token function\">Use</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glUniformMatrix4fv</span><span class=\"token punctuation\">(</span>lightSpaceMatrixLocation<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">value_ptr</span><span class=\"token punctuation\">(</span>lightSpaceMatrix<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glViewport</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> SHADOW_WIDTH<span class=\"token punctuation\">,</span> SHADOW_HEIGHT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">glBindFramebuffer</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> depthMapFBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token function\">glClear</span><span class=\"token punctuation\">(</span>GL_DEPTH_BUFFER_BIT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token function\">RenderScene</span><span class=\"token punctuation\">(</span>simpleDepthShader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">glBindFramebuffer</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这里的 RenderScene 函数的参数是一个着色器程序（shader program），它调用所有相关的绘制函数，并在需要的地方设置相应的模型矩阵。</p>\n<p>最后，在光的透视图视角下，很完美地用每个可见片元的最近深度填充了深度缓冲。通过将这个纹理投射到一个 2D 四边形上（和我们在帧缓冲一节做的后处理过程类似），就能在屏幕上显示出来，我们会获得这样的东西：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_depth_map.png\" alt=\"image\" /></p>\n<p>将深度贴图渲染到四边形上的像素着色器：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>out vec4 color<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>in vec2 TexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>uniform sampler2D depthMap<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#123;</span>             </pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">float</span> depthValue <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>depthMap<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>r<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    color <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span>depthValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>要注意的是当用透视投影矩阵取代正交投影矩阵来显示深度时，有一些轻微的改动，因为使用透视投影时，深度是非线性的。本节教程的最后，我们会讨论这些不同之处。</p>\n<h3 id=\"渲染阴影\"><a class=\"anchor\" href=\"#渲染阴影\">#</a> 渲染阴影</h3>\n<p>正确地生成深度贴图以后我们就可以开始生成阴影了。这段代码在像素着色器中执行，用来检验一个片元是否在阴影之中，不过我们在顶点着色器中进行光空间的变换：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> in vec3 position<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> in vec3 normal<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> in vec2 texCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>out vec2 TexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>out VS_OUT <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    vec3 FragPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    vec3 Normal<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    vec2 TexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    vec4 FragPosLightSpace<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span> vs_out<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>uniform mat4 projection<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>uniform mat4 view<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>uniform mat4 model<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>uniform mat4 lightSpaceMatrix<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> projection <span class=\"token operator\">*</span> view <span class=\"token operator\">*</span> model <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>position<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    vs_out<span class=\"token punctuation\">.</span>FragPos <span class=\"token operator\">=</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span>model <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>position<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    vs_out<span class=\"token punctuation\">.</span>Normal <span class=\"token operator\">=</span> <span class=\"token function\">transpose</span><span class=\"token punctuation\">(</span><span class=\"token function\">inverse</span><span class=\"token punctuation\">(</span><span class=\"token function\">mat3</span><span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> normal<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    vs_out<span class=\"token punctuation\">.</span>TexCoords <span class=\"token operator\">=</span> texCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    vs_out<span class=\"token punctuation\">.</span>FragPosLightSpace <span class=\"token operator\">=</span> lightSpaceMatrix <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>vs_out<span class=\"token punctuation\">.</span>FragPos<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这儿的新的地方是 FragPosLightSpace 这个输出向量。我们用同一个 lightSpaceMatrix，把世界空间顶点位置转换为光空间。顶点着色器传递一个普通的经变换的世界空间顶点位置 vs_out.FragPos 和一个光空间的 vs_out.FragPosLightSpace 给像素着色器。</p>\n<p>像素着色器使用 Blinn-Phong 光照模型渲染场景。我们接着计算出一个 shadow 值，当 fragment 在阴影中时是 1.0，在阴影外是 0.0。然后，diffuse 和 specular 颜色会乘以这个阴影元素。由于阴影不会是全黑的（由于散射），我们把 ambient 分量从乘法中剔除。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>out vec4 FragColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>in VS_OUT <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    vec3 FragPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    vec3 Normal<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    vec2 TexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    vec4 FragPosLightSpace<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span> fs_in<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>uniform sampler2D diffuseTexture<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>uniform sampler2D shadowMap<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>uniform vec3 lightPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>uniform vec3 viewPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token keyword\">float</span> <span class=\"token function\">ShadowCalculation</span><span class=\"token punctuation\">(</span>vec4 fragPosLightSpace<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token punctuation\">&#123;</span>           </pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    vec3 color <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>diffuseTexture<span class=\"token punctuation\">,</span> fs_in<span class=\"token punctuation\">.</span>TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>rgb<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    vec3 normal <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>fs_in<span class=\"token punctuation\">.</span>Normal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    vec3 lightColor <span class=\"token operator\">=</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token comment\">// Ambient</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    vec3 ambient <span class=\"token operator\">=</span> <span class=\"token number\">0.15</span> <span class=\"token operator\">*</span> color<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token comment\">// Diffuse</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    vec3 lightDir <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>lightPos <span class=\"token operator\">-</span> fs_in<span class=\"token punctuation\">.</span>FragPos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    <span class=\"token keyword\">float</span> diff <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token function\">dot</span><span class=\"token punctuation\">(</span>lightDir<span class=\"token punctuation\">,</span> normal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    vec3 diffuse <span class=\"token operator\">=</span> diff <span class=\"token operator\">*</span> lightColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    <span class=\"token comment\">// Specular</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>    vec3 viewDir <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>viewPos <span class=\"token operator\">-</span> fs_in<span class=\"token punctuation\">.</span>FragPos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>    vec3 reflectDir <span class=\"token operator\">=</span> <span class=\"token function\">reflect</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>lightDir<span class=\"token punctuation\">,</span> normal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>    <span class=\"token keyword\">float</span> spec <span class=\"token operator\">=</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>    vec3 halfwayDir <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>lightDir <span class=\"token operator\">+</span> viewDir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"38\"></td><td><pre>    spec <span class=\"token operator\">=</span> <span class=\"token function\">pow</span><span class=\"token punctuation\">(</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token function\">dot</span><span class=\"token punctuation\">(</span>normal<span class=\"token punctuation\">,</span> halfwayDir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">64.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>    vec3 specular <span class=\"token operator\">=</span> spec <span class=\"token operator\">*</span> lightColor<span class=\"token punctuation\">;</span>    </pre></td></tr><tr><td data-num=\"40\"></td><td><pre>    <span class=\"token comment\">// 计算阴影</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>    <span class=\"token keyword\">float</span> shadow <span class=\"token operator\">=</span> <span class=\"token function\">ShadowCalculation</span><span class=\"token punctuation\">(</span>fs_in<span class=\"token punctuation\">.</span>FragPosLightSpace<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>       </pre></td></tr><tr><td data-num=\"42\"></td><td><pre>    vec3 lighting <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>ambient <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span> <span class=\"token operator\">-</span> shadow<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>diffuse <span class=\"token operator\">+</span> specular<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> color<span class=\"token punctuation\">;</span>    </pre></td></tr><tr><td data-num=\"43\"></td><td><pre></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>lighting<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>像素着色器大部分是从高级光照教程中复制过来，只不过加上了个阴影计算。我们声明一个 shadowCalculation 函数，用它计算阴影。像素着色器的最后，我们我们把 diffuse 和 specular 乘以 (1 - 阴影元素)，这表示这个片元有多大成分不在阴影中。这个像素着色器还需要两个额外输入，一个是光空间的片元位置和第一个渲染阶段得到的深度贴图。</p>\n<p>首先要检查一个片元是否在阴影中，把光空间片元位置转换为裁切空间的标准化设备坐标。当我们在顶点着色器输出一个裁切空间顶点位置到 gl_Position 时，OpenGL 自动进行一个透视除法，将裁切空间坐标的范围 - w 到 w 转为 - 1 到 1，这要将 x、y、z 元素除以向量的 w 元素来实现。由于裁切空间的 FragPosLightSpace 并不会通过 gl_Position 传到像素着色器里，我们必须自己做透视除法：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> <span class=\"token function\">ShadowCalculation</span><span class=\"token punctuation\">(</span>vec4 fragPosLightSpace<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\">// 执行透视除法</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    vec3 projCoords <span class=\"token operator\">=</span> fragPosLightSpace<span class=\"token punctuation\">.</span>xyz <span class=\"token operator\">/</span> fragPosLightSpace<span class=\"token punctuation\">.</span>w<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这将返回片段在 [-1，1] 范围内的光空间位置。</p>\n<blockquote>\n<p>当使用正交投影矩阵，顶点 w 元素仍保持不变，所以这一步实际上毫无意义。可是，当使用透视投影的时候就是必须的了，所以为了保证在两种投影矩阵下都有效就得留着这行。</p>\n</blockquote>\n<p>因为深度图的深度在 [0，1] 范围内，我们还想使用 projCoords 从深度图中进行采样，因此我们将 NDC 坐标转换为范围 [ 0，1]：（译者注：这里的意思是，上面的 projCoords 的 xyz 分量都是 [-1,1]（下面会指出这对于远平面之类的点才成立），而为了和深度贴图的深度相比较，z 分量需要变换到 [0,1]；为了作为从深度贴图中采样的坐标，xy 分量也需要变换到 [0,1]。所以整个 projCoords 向量都需要变换到 [0,1] 范围。）</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>projCoords <span class=\"token operator\">=</span> projCoords <span class=\"token operator\">*</span> <span class=\"token number\">0.5</span> <span class=\"token operator\">+</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>有了这些投影坐标，我们就能从深度贴图中采样得到 0 到 1 的结果，从第一个渲染阶段的 projCoords 坐标直接对应于变换过的 NDC 坐标。我们将得到光的位置视野下最近的深度:</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> closestDepth <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>shadowMap<span class=\"token punctuation\">,</span> projCoords<span class=\"token punctuation\">.</span>xy<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>r<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>为了得到片元的当前深度，我们简单获取投影向量的 z 坐标，它等于来自光的透视视角的片元的深度。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> currentDepth <span class=\"token operator\">=</span> projCoords<span class=\"token punctuation\">.</span>z<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>实际的对比就是简单检查 currentDepth 是否高于 closetDepth，如果是，那么片元就在阴影中。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> shadow <span class=\"token operator\">=</span> currentDepth <span class=\"token operator\">></span> closestDepth  <span class=\"token operator\">?</span> <span class=\"token number\">1.0</span> <span class=\"token operator\">:</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>完整的 shadowCalculation 函数是这样的：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> <span class=\"token function\">ShadowCalculation</span><span class=\"token punctuation\">(</span>vec4 fragPosLightSpace<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\">// 执行透视除法</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    vec3 projCoords <span class=\"token operator\">=</span> fragPosLightSpace<span class=\"token punctuation\">.</span>xyz <span class=\"token operator\">/</span> fragPosLightSpace<span class=\"token punctuation\">.</span>w<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token comment\">// 变换到 [0,1] 的范围</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    projCoords <span class=\"token operator\">=</span> projCoords <span class=\"token operator\">*</span> <span class=\"token number\">0.5</span> <span class=\"token operator\">+</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token comment\">// 取得最近点的深度 (使用 [0,1] 范围下的 fragPosLight 当坐标)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">float</span> closestDepth <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>shadowMap<span class=\"token punctuation\">,</span> projCoords<span class=\"token punctuation\">.</span>xy<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>r<span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token comment\">// 取得当前片元在光源视角下的深度</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">float</span> currentDepth <span class=\"token operator\">=</span> projCoords<span class=\"token punctuation\">.</span>z<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token comment\">// 检查当前片元是否在阴影中</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">float</span> shadow <span class=\"token operator\">=</span> currentDepth <span class=\"token operator\">></span> closestDepth  <span class=\"token operator\">?</span> <span class=\"token number\">1.0</span> <span class=\"token operator\">:</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">return</span> shadow<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>激活这个着色器，绑定合适的纹理，激活第二个渲染阶段默认的投影以及视图矩阵，结果如下图所示：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_shadows.png\" alt=\"image\" /></p>\n<h3 id=\"改进阴影贴图\"><a class=\"anchor\" href=\"#改进阴影贴图\">#</a> 改进阴影贴图</h3>\n<p>我们试图让阴影映射工作，但是你也看到了，阴影映射还是有点不真实，我们修复它才能获得更好的效果，这是下面的部分所关注的焦点。</p>\n<h3 id=\"阴影失真\"><a class=\"anchor\" href=\"#阴影失真\">#</a> 阴影失真</h3>\n<p>前面的图片中明显有不对的地方。放大看会发现明显的线条样式：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_acne.png\" alt=\"image\" /></p>\n<p>我们可以看到地板四边形渲染出很大一块交替黑线。这种阴影贴图的不真实感叫做<mark>阴影失真</mark> (Shadow Acne)，下图解释了成因：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_acne_diagram.png\" alt=\"image\" /></p>\n<p>因为阴影贴图受限于解析度，在距离光源比较远的情况下，多个片元可能从深度贴图的同一个值中去采样。图片每个斜坡代表深度贴图一个单独的纹理像素。你可以看到，多个片元从同一个深度值进行采样。</p>\n<p>虽然很多时候没问题，但是当光源以一个角度朝向表面的时候就会出问题，这种情况下深度贴图也是从一个角度下进行渲染的。多个片元就会从同一个斜坡的深度纹理像素中采样，有些在地板上面，有些在地板下面；这样我们所得到的阴影就有了差异。因为这个，有些片元被认为是在阴影之中，有些不在，由此产生了图片中的条纹样式。</p>\n<p>我们可以用一个叫做<mark>阴影偏移</mark>（shadow bias）的技巧来解决这个问题，我们简单的对表面的深度（或深度贴图）应用一个偏移量，这样片元就不会被错误地认为在表面之下了。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_acne_bias.png\" alt=\"image\" /></p>\n<p>使用了偏移量后，所有采样点都获得了比表面深度更小的深度值，这样整个表面就正确地被照亮，没有任何阴影。我们可以这样实现这个偏移：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> bias <span class=\"token operator\">=</span> <span class=\"token number\">0.005</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">float</span> shadow <span class=\"token operator\">=</span> currentDepth <span class=\"token operator\">-</span> bias <span class=\"token operator\">></span> closestDepth  <span class=\"token operator\">?</span> <span class=\"token number\">1.0</span> <span class=\"token operator\">:</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>一个 0.005 的偏移就能帮到很大的忙，但是有些表面坡度很大，仍然会产生阴影失真。有一个更加可靠的办法能够根据表面朝向光线的角度更改偏移量：使用点乘：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> bias <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.05</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span> <span class=\"token operator\">-</span> <span class=\"token function\">dot</span><span class=\"token punctuation\">(</span>normal<span class=\"token punctuation\">,</span> lightDir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.005</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这里我们有一个偏移量的最大值 0.05，和一个最小值 0.005，它们是基于表面法线和光照方向的。这样像地板这样的表面几乎与光源垂直，得到的偏移就很小，而比如立方体的侧面这种表面得到的偏移就更大。下图展示了同一个场景，但使用了阴影偏移，效果的确更好：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_with_bias.png\" alt=\"image\" /></p>\n<p>选用正确的偏移数值，在不同的场景中需要一些像这样的轻微调校，但大多情况下，实际上就是增加偏移量直到所有失真都被移除的问题。</p>\n<h3 id=\"悬浮\"><a class=\"anchor\" href=\"#悬浮\">#</a> 悬浮</h3>\n<p>使用阴影偏移的一个缺点是你对物体的实际深度应用了平移。偏移有可能足够大，以至于可以看出阴影相对实际物体位置的偏移，你可以从下图看到这个现象（这是一个夸张的偏移值）：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_peter_panning.png\" alt=\"image\" /></p>\n<p>这个阴影失真叫做<mark>悬浮</mark> (Peter Panning)，因为物体看起来轻轻悬浮在表面之上（译注 Peter Pan 就是童话彼得潘，而 panning 有平移、悬浮之意，而且彼得潘是个会飞的男孩…）。我们可以使用一个叫技巧解决大部分的 Peter panning 问题：当渲染深度贴图时候使用<mark>正面剔除</mark>（front face culling）你也许记得在面剔除教程中 OpenGL 默认是背面剔除。我们要告诉 OpenGL 我们要剔除正面。</p>\n<p>因为我们只需要深度贴图的深度值，对于实体物体无论我们用它们的正面还是背面都没问题。使用背面深度不会有错误，因为阴影在物体内部有错误我们也看不见。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_culling.png\" alt=\"image\" /></p>\n<p>为了修复 peter 游移，我们要进行正面剔除，先必须开启 GL_CULL_FACE：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glCullFace</span><span class=\"token punctuation\">(</span>GL_FRONT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">RenderSceneToDepthMap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glCullFace</span><span class=\"token punctuation\">(</span>GL_BACK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 不要忘记设回原先的 culling face</span></pre></td></tr></table></figure><p>这十分有效地解决了 peter panning 的问题，但只针对实体物体，内部不会对外开口。我们的场景中，在立方体上工作的很好，但在地板上无效，因为正面剔除完全移除了地板。地面是一个单独的平面，不会被完全剔除。如果有人打算使用这个技巧解决 peter panning 必须考虑到只有剔除物体的正面才有意义。</p>\n<p>另一个要考虑到的地方是接近阴影的物体仍然会出现不正确的效果。必须考虑到何时使用正面剔除对物体才有意义。不过使用普通的偏移值通常就能避免 peter panning。</p>\n<h3 id=\"采样过多\"><a class=\"anchor\" href=\"#采样过多\">#</a> 采样过多</h3>\n<p>无论你喜不喜欢还有一个视觉差异，就是光的视锥不可见的区域一律被认为是处于阴影中，不管它真的处于阴影之中。出现这个状况是因为超出光的视锥的投影坐标比 1.0 大，这样采样的深度纹理就会超出他默认的 0 到 1 的范围。根据纹理环绕方式，我们将会得到不正确的深度结果，它不是基于真实的来自光源的深度值。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_outside_frustum.png\" alt=\"image\" /></p>\n<p>你可以在图中看到，光照有一个区域，超出该区域就成为了阴影；这个区域实际上代表着深度贴图的大小，这个贴图投影到了地板上。发生这种情况的原因是我们之前将深度贴图的环绕方式设置成了 GL_REPEAT。</p>\n<p>我们宁可让所有超出深度贴图的坐标的深度范围是 1.0，这样超出的坐标将永远不在阴影之中。我们可以储存一个边框颜色，然后把深度贴图的纹理环绕选项设置为 GL_CLAMP_TO_BORDER：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_WRAP_S<span class=\"token punctuation\">,</span> GL_CLAMP_TO_BORDER<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_WRAP_T<span class=\"token punctuation\">,</span> GL_CLAMP_TO_BORDER<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>GLfloat borderColor<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glTexParameterfv</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_BORDER_COLOR<span class=\"token punctuation\">,</span> borderColor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>现在如果我们采样深度贴图 0 到 1 坐标范围以外的区域，纹理函数总会返回一个 1.0 的深度值，阴影值为 0.0。结果看起来会更真实：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_clamp_edge.png\" alt=\"image\" /></p>\n<p>仍有一部分是黑暗区域。那里的坐标超出了光的<mark>正交视锥的远平面</mark>。你可以看到这片黑色区域总是出现在光源视锥的极远处。</p>\n<p>当一个点比光的远平面还要远时，它的投影坐标的 z 坐标大于 1.0。这种情况下，GL_CLAMP_TO_BORDER 环绕方式不起作用，因为我们把坐标的 z 元素和深度贴图的值进行了对比；它总是为大于 1.0 的 z 返回 true。</p>\n<p>解决这个问题也很简单，只要投影向量的 z 坐标大于 1.0，我们就把 shadow 的值强制设为 0.0：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> <span class=\"token function\">ShadowCalculation</span><span class=\"token punctuation\">(</span>vec4 fragPosLightSpace<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>projCoords<span class=\"token punctuation\">.</span>z <span class=\"token operator\">></span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        shadow <span class=\"token operator\">=</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">return</span> shadow<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>检查远平面，并将深度贴图限制为一个手工指定的边界颜色，就能解决深度贴图采样超出的问题，我们最终会得到下面我们所追求的效果：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_over_sampling_fixed.png\" alt=\"image\" /></p>\n<p>这些结果意味着，只有在深度贴图范围以内的被投影的 fragment 坐标才有阴影，所以任何超出范围的都将会没有阴影。由于在游戏中通常这只发生在远处，就会比我们之前的那个明显的黑色区域效果更真实。</p>\n<h3 id=\"pcf\"><a class=\"anchor\" href=\"#pcf\">#</a> PCF</h3>\n<p>阴影现在已经附着到场景中了，不过这仍不是我们想要的。如果你放大看阴影，阴影映射对解析度的依赖很快变得很明显。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_zoom.png\" alt=\"image\" /></p>\n<p>因为深度贴图有一个固定的解析度，多个片元对应于一个纹理像素。结果就是多个片元会从深度贴图的同一个深度值进行采样，这几个片元便得到的是同一个阴影，这就会产生锯齿边。</p>\n<p>你可以通过增加深度贴图解析度的方式来降低锯齿块，也可以尝试尽可能的让光的视锥接近场景。</p>\n<p>另一个（并不完整的）解决方案叫做 PCF（percentage-closer filtering），这是一种多个不同过滤方式的组合，它产生柔和阴影，使它们出现更少的锯齿块和硬边。核心思想是从<mark>深度贴图中多次采样</mark>，每一次采样的纹理坐标都稍有不同。每个独立的样本可能在也可能不再阴影中。所有的次生结果接着结合在一起，进行平均化，我们就得到了柔和阴影。</p>\n<p>一个简单的 PCF 的实现是简单的从纹理像素四周对深度贴图采样，然后把结果平均起来：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> shadow <span class=\"token operator\">=</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>vec2 texelSize <span class=\"token operator\">=</span> <span class=\"token number\">1.0</span> <span class=\"token operator\">/</span> <span class=\"token function\">textureSize</span><span class=\"token punctuation\">(</span>shadowMap<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> x <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>x<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> y <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> y <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>y<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token keyword\">float</span> pcfDepth <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>shadowMap<span class=\"token punctuation\">,</span> projCoords<span class=\"token punctuation\">.</span>xy <span class=\"token operator\">+</span> <span class=\"token function\">vec2</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> texelSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>r<span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        shadow <span class=\"token operator\">+=</span> currentDepth <span class=\"token operator\">-</span> bias <span class=\"token operator\">></span> pcfDepth <span class=\"token operator\">?</span> <span class=\"token number\">1.0</span> <span class=\"token operator\">:</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">;</span>        </pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span>    </pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>shadow <span class=\"token operator\">/=</span> <span class=\"token number\">9.0</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这个 textureSize 返回一个给定采样器纹理的 0 级 mipmap 的 vec2 类型的宽和高。用 1 除以它返回一个单独纹理像素的大小，我们用以对纹理坐标进行偏移，确保每个新样本，来自不同的深度值。这里我们采样得到 9 个值，它们在投影坐标的 x 和 y 值的周围，为阴影阻挡进行测试，并最终通过样本的总数目将结果平均化。</p>\n<p>使用更多的样本，更改 texelSize 变量，你就可以增加阴影的柔和程度。下面你可以看到应用了 PCF 的阴影：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_soft_shadows.png\" alt=\"image\" /></p>\n<p>从稍微远一点的距离看去，阴影效果好多了，也不那么生硬了。如果你放大，仍会看到阴影贴图解析度的不真实感，但通常对于大多数应用来说效果已经很好了。</p>\n<p>实际上 PCF 还有更多的内容，以及很多技术要点需要考虑以提升柔和阴影的效果，但处于本章内容长度考虑，我们将留在以后讨论。</p>\n<h3 id=\"正交-vs-投影\"><a class=\"anchor\" href=\"#正交-vs-投影\">#</a> 正交 vs 投影</h3>\n<p>在渲染深度贴图的时候，正交 (Orthographic) 和投影 (Projection) 矩阵之间有所不同。正交投影矩阵并不会将场景用透视图进行变形，所有视线 / 光线都是平行的，这使它对于定向光来说是个很好的投影矩阵。然而透视投影矩阵，会将所有顶点根据透视关系进行变形，结果因此而不同。下图展示了两种投影方式所产生的不同阴影区域：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_projection.png\" alt=\"image\" /></p>\n<p>透视投影对于光源来说更合理，不像定向光，它是有自己的位置的。透视投影因此更经常用在点光源和聚光灯上，而正交投影经常用在定向光上。</p>\n<p>另一个细微差别是，透视投影矩阵，将深度缓冲视觉化经常会得到一个几乎全白的结果。发生这个是因为透视投影下，深度变成了非线性的深度值，它的大多数可辨范围接近于近平面。为了可以像使用正交投影一样合适的观察到深度值，你必须先讲过非线性深度值转变为线性的，我们在深度测试教程中已经讨论过。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>out vec4 color<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>in vec2 TexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>uniform sampler2D depthMap<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>uniform <span class=\"token keyword\">float</span> near_plane<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>uniform <span class=\"token keyword\">float</span> far_plane<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">float</span> <span class=\"token function\">LinearizeDepth</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span> depth<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">float</span> z <span class=\"token operator\">=</span> depth <span class=\"token operator\">*</span> <span class=\"token number\">2.0</span> <span class=\"token operator\">-</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Back to NDC </span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token number\">2.0</span> <span class=\"token operator\">*</span> near_plane <span class=\"token operator\">*</span> far_plane<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span>far_plane <span class=\"token operator\">+</span> near_plane <span class=\"token operator\">-</span> z <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>far_plane <span class=\"token operator\">-</span> near_plane<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#123;</span>             </pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token keyword\">float</span> depthValue <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>depthMap<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>r<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    color <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token function\">LinearizeDepth</span><span class=\"token punctuation\">(</span>depthValue<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> far_plane<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// perspective</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token comment\">// color = vec4(vec3(depthValue), 1.0); // orthographic</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这个深度值与我们见到的用正交投影的很相似。需要注意的是，这个只适用于调试；正交或投影矩阵的深度检查仍然保持原样，因为相关的深度并没有改变。</p>\n<h3 id=\"附加资源-2\"><a class=\"anchor\" href=\"#附加资源-2\">#</a> 附加资源</h3>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5vcGVuZ2wtdHV0b3JpYWwub3JnL2ludGVybWVkaWF0ZS10dXRvcmlhbHMvdHV0b3JpYWwtMTYtc2hhZG93LW1hcHBpbmcv\">Tutorial 16 : Shadow mapping</span>：提供的类似的阴影映射教程，里面有一些额外的解释。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL29nbGRldi5hdHNwYWNlLmNvLnVrL3d3dy90dXRvcmlhbDIzL3R1dG9yaWFsMjMuaHRtbA==\">Shadow Mapping – Part 1：ogldev</span>：提供的另一个阴影映射教程。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1Fc2NjZ2VVcGRzTQ==\">How Shadow Mapping Works</span>：的一个第三方 YouTube 视频教程，里面解释了阴影映射及其实现。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vemgtY24vd2luZG93cy9kZXNrdG9wL0R4VGVjaEFydHMvY29tbW9uLXRlY2huaXF1ZXMtdG8taW1wcm92ZS1zaGFkb3ctZGVwdGgtbWFwcw==\">Common Techniques to Improve Shadow Depth Maps</span>：微软的一篇好文章，其中理出了很多提升阴影贴图质量的技术。</li>\n</ul>\n<h2 id=\"点光源阴影\"><a class=\"anchor\" href=\"#点光源阴影\">#</a> 点光源阴影</h2>\n<p>上个教程我们学到了如何使用阴影映射技术创建动态阴影。效果不错，但它只适合定向光，因为阴影只是在单一定向光源下生成的。所以它也叫定向阴影映射，深度（阴影）贴图生成自定向光的视角。</p>\n<blockquote>\n<p>本节我们的焦点是在各种方向生成<strong>动态阴影</strong>。这个技术可以适用于点光源，生成所有方向上的阴影。</p>\n</blockquote>\n<p>这个技术叫做点<mark>光阴影</mark>，过去的名字是<mark>万向阴影贴图</mark>（omnidirectional shadow maps）技术。</p>\n<p>本节代码基于前面的阴影映射教程，所以如果你对传统阴影映射不熟悉，还是建议先读一读阴影映射教程。 算法和定向阴影映射差不多：我们从光的透视图生成一个深度贴图，基于当前 fragment 位置来对深度贴图采样，然后用储存的深度值和每个 fragment 进行对比，看看它是否在阴影中。定向阴影映射和万向阴影映射的主要不同在于深度贴图的使用上。</p>\n<p>对于深度贴图，我们需要从一个点光源的所有渲染场景，普通 2D 深度贴图不能工作；如果我们使用立方体贴图会怎样？因为立方体贴图可以储存 6 个面的环境数据，它可以将整个场景渲染到立方体贴图的每个面上，把它们当作点光源四周的深度值来采样。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/03/02/point_shadows_diagram.png\" alt=\"image\" /></p>\n<p>生成后的深度立方体贴图被传递到光照像素着色器，它会用一个方向向量来采样立方体贴图，从而得到当前的 fragment 的深度（从光的透视图）。大部分复杂的事情已经在阴影映射教程中讨论过了。算法只是在深度立方体贴图生成上稍微复杂一点。</p>\n<h3 id=\"生成深度立方体贴图\"><a class=\"anchor\" href=\"#生成深度立方体贴图\">#</a> 生成深度立方体贴图</h3>\n<p>为创建一个光周围的深度值的立方体贴图，我们必须渲染场景 6 次：每次一个面。显然渲染场景 6 次需要 6 个不同的视图矩阵，每次把一个不同的立方体贴图面附加到帧缓冲对象上。这看起来是这样的：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">6</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    GLuint face <span class=\"token operator\">=</span> GL_TEXTURE_CUBE_MAP_POSITIVE_X <span class=\"token operator\">+</span> i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token function\">glFramebufferTexture2D</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> GL_DEPTH_ATTACHMENT<span class=\"token punctuation\">,</span> face<span class=\"token punctuation\">,</span> depthCubemap<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token function\">BindViewMatrix</span><span class=\"token punctuation\">(</span>lightViewMatrices<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token function\">RenderScene</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这会很耗费性能因为一个深度贴图下需要进行很多渲染调用。这个教程中我们将转而使用另外的一个小技巧来做这件事，几何着色器允许我们使用一次渲染过程来建立深度立方体贴图。</p>\n<p>首先，我们需要创建一个立方体贴图：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> depthCubemap<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glGenTextures</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>depthCubemap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>然后生成立方体贴图的每个面，将它们作为 2D 深度值纹理图像：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">const</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> SHADOW_WIDTH <span class=\"token operator\">=</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">,</span> SHADOW_HEIGHT <span class=\"token operator\">=</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE_CUBE_MAP<span class=\"token punctuation\">,</span> depthCubemap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">6</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token function\">glTexImage2D</span><span class=\"token punctuation\">(</span>GL_TEXTURE_CUBE_MAP_POSITIVE_X <span class=\"token operator\">+</span> i<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> GL_DEPTH_COMPONENT<span class=\"token punctuation\">,</span>SHADOW_WIDTH<span class=\"token punctuation\">,</span> SHADOW_HEIGHT<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> GL_DEPTH_COMPONENT<span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>不要忘记设置合适的纹理参数：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_CUBE_MAP<span class=\"token punctuation\">,</span> GL_TEXTURE_MAG_FILTER<span class=\"token punctuation\">,</span> GL_NEAREST<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_CUBE_MAP<span class=\"token punctuation\">,</span> GL_TEXTURE_MIN_FILTER<span class=\"token punctuation\">,</span> GL_NEAREST<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_CUBE_MAP<span class=\"token punctuation\">,</span> GL_TEXTURE_WRAP_S<span class=\"token punctuation\">,</span> GL_CLAMP_TO_EDGE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_CUBE_MAP<span class=\"token punctuation\">,</span> GL_TEXTURE_WRAP_T<span class=\"token punctuation\">,</span> GL_CLAMP_TO_EDGE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_CUBE_MAP<span class=\"token punctuation\">,</span> GL_TEXTURE_WRAP_R<span class=\"token punctuation\">,</span> GL_CLAMP_TO_EDGE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>还要记得调用 glDrawBuffer 和 glReadBuffer：当生成一个深度立方体贴图时我们只关心深度值，所以我们必须显式告诉 OpenGL 这个帧缓冲对象不会渲染到一个颜色缓冲里。</p>\n<p>万向阴影贴图有两个渲染阶段：首先我们生成深度贴图，然后我们正常使用深度贴图渲染，在场景中创建阴影。帧缓冲对象和立方体贴图的处理看起是这样的：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 1. first render to depth cubemap</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glViewport</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> SHADOW_WIDTH<span class=\"token punctuation\">,</span> SHADOW_HEIGHT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glBindFramebuffer</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> depthMapFBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glClear</span><span class=\"token punctuation\">(</span>GL_DEPTH_BUFFER_BIT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">ConfigureShaderAndMatrices</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">RenderScene</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">glBindFramebuffer</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">// 2. then render scene as normal with shadow mapping (using depth cubemap)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token function\">glViewport</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> SCR_WIDTH<span class=\"token punctuation\">,</span> SCR_HEIGHT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token function\">glClear</span><span class=\"token punctuation\">(</span>GL_COLOR_BUFFER_BIT <span class=\"token operator\">|</span> GL_DEPTH_BUFFER_BIT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token function\">ConfigureShaderAndMatrices</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE_CUBE_MAP<span class=\"token punctuation\">,</span> depthCubemap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token function\">RenderScene</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这个过程和默认的阴影映射一样，尽管这次我们渲染和使用的是一个立方体贴图深度纹理，而不是 2D 深度纹理。在我们实际开始从光的视角的所有方向渲染场景之前，我们先得计算出合适的变换矩阵。</p>\n<h3 id=\"光空间的变换\"><a class=\"anchor\" href=\"#光空间的变换\">#</a> 光空间的变换</h3>\n<p>设置了帧缓冲和立方体贴图，我们需要一些方法来讲场景的所有几何体变换到 6 个光的方向中相应的光空间。与阴影映射教程类似，我们将需要一个光空间的变换矩阵 T，但是这次是每个面都有一个。</p>\n<p>每个光空间的变换矩阵包含了投影和视图矩阵。对于投影矩阵来说，我们将使用一个透视投影矩阵；光源代表一个空间中的点，所以透视投影矩阵更有意义。每个光空间变换矩阵使用同样的投影矩阵：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> aspect <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span>SHADOW_WIDTH<span class=\"token operator\">/</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span>SHADOW_HEIGHT<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">float</span> near <span class=\"token operator\">=</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">float</span> far <span class=\"token operator\">=</span> <span class=\"token number\">25.0f</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>glm<span class=\"token operator\">::</span>mat4 shadowProj <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">perspective</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">radians</span><span class=\"token punctuation\">(</span><span class=\"token number\">90.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> aspect<span class=\"token punctuation\">,</span> near<span class=\"token punctuation\">,</span> far<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>非常重要的一点是，这里 glm::perspective 的视野参数，设置为 90 度。90 度我们才能保证视野足够大到可以合适地填满立方体贴图的一个面，立方体贴图的所有面都能与其他面在边缘对齐。</p>\n<p>因为投影矩阵在每个方向上并不会改变，我们可以在 6 个变换矩阵中重复使用。我们要为每个方向提供一个不同的视图矩阵。用 glm::lookAt 创建 6 个观察方向，每个都按顺序注视着立方体贴图的的一个方向：右、左、上、下、近、远：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span>glm<span class=\"token operator\">::</span>mat4<span class=\"token operator\">></span> shadowTransforms<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>shadowTransforms<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>shadowProj <span class=\"token operator\">*</span> glm<span class=\"token operator\">::</span><span class=\"token function\">lookAt</span><span class=\"token punctuation\">(</span>lightPos<span class=\"token punctuation\">,</span> lightPos <span class=\"token operator\">+</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span><span class=\"token operator\">-</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>shadowTransforms<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>shadowProj <span class=\"token operator\">*</span> glm<span class=\"token operator\">::</span><span class=\"token function\">lookAt</span><span class=\"token punctuation\">(</span>lightPos<span class=\"token punctuation\">,</span> lightPos <span class=\"token operator\">+</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span><span class=\"token operator\">-</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>shadowTransforms<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>shadowProj <span class=\"token operator\">*</span> glm<span class=\"token operator\">::</span><span class=\"token function\">lookAt</span><span class=\"token punctuation\">(</span>lightPos<span class=\"token punctuation\">,</span> lightPos <span class=\"token operator\">+</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>shadowTransforms<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>shadowProj <span class=\"token operator\">*</span> glm<span class=\"token operator\">::</span><span class=\"token function\">lookAt</span><span class=\"token punctuation\">(</span>lightPos<span class=\"token punctuation\">,</span> lightPos <span class=\"token operator\">+</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span><span class=\"token operator\">-</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span><span class=\"token operator\">-</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>shadowTransforms<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>shadowProj <span class=\"token operator\">*</span> glm<span class=\"token operator\">::</span><span class=\"token function\">lookAt</span><span class=\"token punctuation\">(</span>lightPos<span class=\"token punctuation\">,</span> lightPos <span class=\"token operator\">+</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span><span class=\"token operator\">-</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>shadowTransforms<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>shadowProj <span class=\"token operator\">*</span> glm<span class=\"token operator\">::</span><span class=\"token function\">lookAt</span><span class=\"token punctuation\">(</span>lightPos<span class=\"token punctuation\">,</span> lightPos <span class=\"token operator\">+</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span><span class=\"token operator\">-</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span><span class=\"token operator\">-</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这里我们创建了 6 个视图矩阵，把它们乘以投影矩阵，来得到 6 个不同的光空间变换矩阵。glm::lookAt 的 target 参数是它注视的立方体贴图的面的一个方向。</p>\n<p>这些变换矩阵发送到着色器渲染到立方体贴图里。</p>\n<h3 id=\"深度着色器\"><a class=\"anchor\" href=\"#深度着色器\">#</a> 深度着色器</h3>\n<p>为了把值渲染到深度立方体贴图，我们将需要 3 个着色器：顶点和像素着色器，以及一个它们之间的几何着色器。</p>\n<p>几何着色器是负责将所有世界空间的顶点变换到 6 个不同的光空间的着色器。因此顶点着色器简单地将顶点变换到世界空间，然后直接发送到几何着色器：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> in vec3 position<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>uniform mat4 model<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> model <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>position<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>紧接着几何着色器以 3 个三角形的顶点作为输入，它还有一个光空间变换矩阵的 uniform 数组。几何着色器接下来会负责将顶点变换到光空间；这里它开始变得有趣了。</p>\n<p>几何着色器有一个内建变量叫做 gl_Layer，它指定发散出基本图形送到立方体贴图的哪个面。当不管它时，几何着色器就会像往常一样把它的基本图形发送到输送管道的下一阶段，但当我们更新这个变量就能控制每个基本图形将渲染到立方体贴图的哪一个面。当然这只有当我们有了一个附加到激活的帧缓冲的立方体贴图纹理才有效：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>triangles<span class=\"token punctuation\">)</span> in<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>triangle_strip<span class=\"token punctuation\">,</span> max_vertices<span class=\"token operator\">=</span><span class=\"token number\">18</span><span class=\"token punctuation\">)</span> out<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>uniform mat4 shadowMatrices<span class=\"token punctuation\">[</span><span class=\"token number\">6</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>out vec4 FragPos<span class=\"token punctuation\">;</span> <span class=\"token comment\">// FragPos from GS (output per emitvertex)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> face <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> face <span class=\"token operator\">&lt;</span> <span class=\"token number\">6</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>face<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        gl_Layer <span class=\"token operator\">=</span> face<span class=\"token punctuation\">;</span> <span class=\"token comment\">// built-in variable that specifies to which face we render.</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token comment\">// for each triangle's vertices</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>            FragPos <span class=\"token operator\">=</span> gl_in<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>gl_Position<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>            gl_Position <span class=\"token operator\">=</span> shadowMatrices<span class=\"token punctuation\">[</span>face<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> FragPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>            <span class=\"token function\">EmitVertex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span>    </pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token function\">EndPrimitive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>几何着色器相对简单。我们输入一个三角形，输出总共 6 个三角形（6*3 顶点，所以总共 18 个顶点）。在 main 函数中，我们遍历立方体贴图的 6 个面，我们每个面指定为一个输出面，把这个面的 interger（整数）存到 gl_Layer。然后，我们通过把面的光空间变换矩阵乘以 FragPos，将每个世界空间顶点变换到相关的光空间，生成每个三角形。注意，我们还要将最后的 FragPos 变量发送给像素着色器，我们需要计算一个深度值。</p>\n<p>上个教程，我们使用的是一个空的像素着色器，让 OpenGL 配置深度贴图的深度值。这次我们将计算自己的深度，这个深度就是每个 fragment 位置和光源位置之间的线性距离。计算自己的深度值使得之后的阴影计算更加直观。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>in vec4 FragPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>uniform vec3 lightPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>uniform <span class=\"token keyword\">float</span> far_plane<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token comment\">// get distance between fragment and light source</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">float</span> lightDistance <span class=\"token operator\">=</span> <span class=\"token function\">length</span><span class=\"token punctuation\">(</span>FragPos<span class=\"token punctuation\">.</span>xyz <span class=\"token operator\">-</span> lightPos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token comment\">// map to [0;1] range by dividing by far_plane</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    lightDistance <span class=\"token operator\">=</span> lightDistance <span class=\"token operator\">/</span> far_plane<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token comment\">// write this as modified depth</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    gl_FragDepth <span class=\"token operator\">=</span> lightDistance<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>像素着色器将来自几何着色器的 FragPos、光的位置向量和视锥的远平面值作为输入。这里我们把 fragment 和光源之间的距离，映射到 0 到 1 的范围，把它写入为 fragment 的深度值。</p>\n<p>使用这些着色器渲染场景，立方体贴图附加的帧缓冲对象激活以后，你会得到一个完全填充的深度立方体贴图，以便于进行第二阶段的阴影计算。</p>\n<h3 id=\"万向阴影贴图\"><a class=\"anchor\" href=\"#万向阴影贴图\">#</a> 万向阴影贴图</h3>\n<p>所有事情都做好了，是时候来渲染万向阴影 (Omnidirectional Shadow) 了。这个过程和定向阴影映射教程相似，尽管这次我们绑定的深度贴图是一个立方体贴图，而不是 2D 纹理，并且将光的投影的远平面发送给了着色器。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glViewport</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> SCR_WIDTH<span class=\"token punctuation\">,</span> SCR_HEIGHT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glClear</span><span class=\"token punctuation\">(</span>GL_COLOR_BUFFER_BIT <span class=\"token operator\">|</span> GL_DEPTH_BUFFER_BIT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>shader<span class=\"token punctuation\">.</span><span class=\"token function\">Use</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// ... send uniforms to shader (including light's far_plane value)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">glActiveTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE_CUBE_MAP<span class=\"token punctuation\">,</span> depthCubemap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">// ... bind other textures</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">RenderScene</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这里的 renderScene 函数在一个大立方体房间中渲染一些立方体，它们散落在大立方体各处，光源在场景中央。</p>\n<p>顶点着色器和像素着色器和原来的阴影映射着色器大部分都一样：不同之处是在光空间中像素着色器不再需要一个 fragment 位置，现在我们可以使用一个方向向量采样深度值。</p>\n<p>因为这个顶点着色器不再需要将他的位置向量变换到光空间，所以我们可以去掉 FragPosLightSpace 变量：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> in vec3 position<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> in vec3 normal<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> in vec2 texCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>out vec2 TexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>out VS_OUT <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    vec3 FragPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    vec3 Normal<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    vec2 TexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span> vs_out<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>uniform mat4 projection<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>uniform mat4 view<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>uniform mat4 model<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> projection <span class=\"token operator\">*</span> view <span class=\"token operator\">*</span> model <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>position<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    vs_out<span class=\"token punctuation\">.</span>FragPos <span class=\"token operator\">=</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span>model <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>position<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    vs_out<span class=\"token punctuation\">.</span>Normal <span class=\"token operator\">=</span> <span class=\"token function\">transpose</span><span class=\"token punctuation\">(</span><span class=\"token function\">inverse</span><span class=\"token punctuation\">(</span><span class=\"token function\">mat3</span><span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> normal<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    vs_out<span class=\"token punctuation\">.</span>TexCoords <span class=\"token operator\">=</span> texCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>片段着色器的 Blinn-Phong 光照代码和我们之前阴影相乘的结尾部分一样：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>out vec4 FragColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>in VS_OUT <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    vec3 FragPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    vec3 Normal<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    vec2 TexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span> fs_in<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>uniform sampler2D diffuseTexture<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>uniform samplerCube depthMap<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>uniform vec3 lightPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>uniform vec3 viewPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>uniform <span class=\"token keyword\">float</span> far_plane<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token keyword\">float</span> <span class=\"token function\">ShadowCalculation</span><span class=\"token punctuation\">(</span>vec3 fragPos<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token punctuation\">&#123;</span>           </pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    vec3 color <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>diffuseTexture<span class=\"token punctuation\">,</span> fs_in<span class=\"token punctuation\">.</span>TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>rgb<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    vec3 normal <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>fs_in<span class=\"token punctuation\">.</span>Normal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    vec3 lightColor <span class=\"token operator\">=</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token comment\">// Ambient</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    vec3 ambient <span class=\"token operator\">=</span> <span class=\"token number\">0.3</span> <span class=\"token operator\">*</span> color<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token comment\">// Diffuse</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    vec3 lightDir <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>lightPos <span class=\"token operator\">-</span> fs_in<span class=\"token punctuation\">.</span>FragPos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    <span class=\"token keyword\">float</span> diff <span class=\"token operator\">=</span> <span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token function\">dot</span><span class=\"token punctuation\">(</span>lightDir<span class=\"token punctuation\">,</span> normal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>    vec3 diffuse <span class=\"token operator\">=</span> diff <span class=\"token operator\">*</span> lightColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>    <span class=\"token comment\">// Specular</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>    vec3 viewDir <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>viewPos <span class=\"token operator\">-</span> fs_in<span class=\"token punctuation\">.</span>FragPos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>    vec3 reflectDir <span class=\"token operator\">=</span> <span class=\"token function\">reflect</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>lightDir<span class=\"token punctuation\">,</span> normal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>    <span class=\"token keyword\">float</span> spec <span class=\"token operator\">=</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>    vec3 halfwayDir <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>lightDir <span class=\"token operator\">+</span> viewDir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"39\"></td><td><pre>    spec <span class=\"token operator\">=</span> <span class=\"token function\">pow</span><span class=\"token punctuation\">(</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token function\">dot</span><span class=\"token punctuation\">(</span>normal<span class=\"token punctuation\">,</span> halfwayDir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">64.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>    vec3 specular <span class=\"token operator\">=</span> spec <span class=\"token operator\">*</span> lightColor<span class=\"token punctuation\">;</span>    </pre></td></tr><tr><td data-num=\"41\"></td><td><pre>    <span class=\"token comment\">// Calculate shadow</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>    <span class=\"token keyword\">float</span> shadow <span class=\"token operator\">=</span> <span class=\"token function\">ShadowCalculation</span><span class=\"token punctuation\">(</span>fs_in<span class=\"token punctuation\">.</span>FragPos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                      </pre></td></tr><tr><td data-num=\"43\"></td><td><pre>    vec3 lighting <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>ambient <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span> <span class=\"token operator\">-</span> shadow<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>diffuse <span class=\"token operator\">+</span> specular<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> color<span class=\"token punctuation\">;</span>    </pre></td></tr><tr><td data-num=\"44\"></td><td><pre></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>lighting<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>有一些细微的不同：光照代码一样，但我们现在有了一个 uniform 变量 samplerCube，shadowCalculation 函数用 fragment 的位置作为它的参数，取代了光空间的 fragment 位置。我们现在还要引入光的视锥的远平面值，后面我们会需要它。像素着色器的最后，我们计算出阴影元素，当 fragment 在阴影中时它是 1.0，不在阴影中时是 0.0。我们使用计算出来的阴影元素去影响光照的 diffuse 和 specular 元素。</p>\n<p>在 ShadowCalculation 函数中有很多不同之处，现在是从立方体贴图中进行采样，不再使用 2D 纹理了。我们来一步一步的讨论一下的它的内容。</p>\n<p>我们需要做的第一件事是获取立方体贴图的深度。你可能已经从教程的立方体贴图部分想到，我们已经将深度储存为 fragment 和光位置之间的距离了；我们这里采用相似的处理方式：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> <span class=\"token function\">ShadowCalculation</span><span class=\"token punctuation\">(</span>vec3 fragPos<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    vec3 fragToLight <span class=\"token operator\">=</span> fragPos <span class=\"token operator\">-</span> lightPos<span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">float</span> closestDepth <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>depthMap<span class=\"token punctuation\">,</span> fragToLight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>r<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在这里，我们得到了 fragment 的位置与光的位置之间的不同的向量，使用这个向量作为一个方向向量去对立方体贴图进行采样。方向向量不需要是单位向量，所以无需对它进行标准化。最后的 closestDepth 是光源和它最接近的可见 fragment 之间的标准化的深度值。</p>\n<p>closestDepth 值现在在 0 到 1 的范围内了，所以我们先将其转换会 0 到 far_plane 的范围，这需要把他乘以 far_plane：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>closestDepth <span class=\"token operator\">*=</span> far_plane<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>下一步我们获取当前 fragment 和光源之间的深度值，我们可以简单的使用 fragToLight 的长度来获取它，这取决于我们如何计算立方体贴图中的深度值：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> currentDepth <span class=\"token operator\">=</span> <span class=\"token function\">length</span><span class=\"token punctuation\">(</span>fragToLight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>返回的是和 closestDepth 范围相同的深度值。</p>\n<p>现在我们可以将两个深度值对比一下，看看哪一个更接近，以此决定当前的 fragment 是否在阴影当中。我们还要包含一个阴影偏移，所以才能避免阴影失真，这在前面教程中已经讨论过了。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> bias <span class=\"token operator\">=</span> <span class=\"token number\">0.05</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">float</span> shadow <span class=\"token operator\">=</span> currentDepth <span class=\"token operator\">-</span>  bias <span class=\"token operator\">></span> closestDepth <span class=\"token operator\">?</span> <span class=\"token number\">1.0</span> <span class=\"token operator\">:</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>完整的 ShadowCalculation 现在变成了这样：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> <span class=\"token function\">ShadowCalculation</span><span class=\"token punctuation\">(</span>vec3 fragPos<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\">// Get vector between fragment position and light position</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    vec3 fragToLight <span class=\"token operator\">=</span> fragPos <span class=\"token operator\">-</span> lightPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token comment\">// Use the light to fragment vector to sample from the depth map    </span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">float</span> closestDepth <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>depthMap<span class=\"token punctuation\">,</span> fragToLight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>r<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token comment\">// It is currently in linear range between [0,1]. Re-transform back to original value</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    closestDepth <span class=\"token operator\">*=</span> far_plane<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token comment\">// Now get current linear depth as the length between the fragment and light position</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">float</span> currentDepth <span class=\"token operator\">=</span> <span class=\"token function\">length</span><span class=\"token punctuation\">(</span>fragToLight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token comment\">// Now test for shadows</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">float</span> bias <span class=\"token operator\">=</span> <span class=\"token number\">0.05</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">float</span> shadow <span class=\"token operator\">=</span> currentDepth <span class=\"token operator\">-</span>  bias <span class=\"token operator\">></span> closestDepth <span class=\"token operator\">?</span> <span class=\"token number\">1.0</span> <span class=\"token operator\">:</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">return</span> shadow<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>有了这些着色器，我们已经能得到非常好的阴影效果了，这次从一个点光源所有周围方向上都有阴影。有一个位于场景中心的点光源，看起来会像这样：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/03/02/point_shadows.png\" alt=\"image\" /></p>\n<h3 id=\"显示立方体贴图深度缓冲\"><a class=\"anchor\" href=\"#显示立方体贴图深度缓冲\">#</a> 显示立方体贴图深度缓冲</h3>\n<p>如果你想我一样第一次并没有做对，那么就要进行调试排错，将深度贴图显示出来以检查其是否正确。因为我们不再用 2D 深度贴图纹理，深度贴图的显示不会那么显而易见。</p>\n<p>一个简单的把深度缓冲显示出来的技巧是，在 ShadowCalculation 函数中计算标准化的 closestDepth 变量，把变量显示为：</p>\n<pre><code>FragColor = vec4(vec3(closestDepth / far_plane), 1.0);\n</code></pre>\n<p>结果是一个灰度场景，每个颜色代表着场景的线性深度值：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/03/02/point_shadows_depth_cubemap.png\" alt=\"image\" /></p>\n<p>你可能也注意到了带阴影部分在墙外。如果看起来和这个差不多，你就知道深度立方体贴图生成的没错。否则你可能做错了什么，也许是 closestDepth 仍然还在 0 到 far_plane 的范围。</p>\n<h3 id=\"pcf-2\"><a class=\"anchor\" href=\"#pcf-2\">#</a> PCF</h3>\n<p>由于万向阴影贴图基于传统阴影映射的原则，它便也继承了由解析度产生的非真实感。如果你放大就会看到锯齿边了。PCF 或称 Percentage-closer filtering 允许我们通过对 fragment 位置周围过滤多个样本，并对结果平均化。</p>\n<p>如果我们用和前面教程同样的那个简单的 PCF 过滤器，并加入第三个维度，就是这样的：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> shadow <span class=\"token operator\">=</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">float</span> bias <span class=\"token operator\">=</span> <span class=\"token number\">0.05</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">float</span> samples <span class=\"token operator\">=</span> <span class=\"token number\">4.0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">float</span> offset <span class=\"token operator\">=</span> <span class=\"token number\">0.1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span> x <span class=\"token operator\">=</span> <span class=\"token operator\">-</span>offset<span class=\"token punctuation\">;</span> x <span class=\"token operator\">&lt;</span> offset<span class=\"token punctuation\">;</span> x <span class=\"token operator\">+=</span> offset <span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span>samples <span class=\"token operator\">*</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span> y <span class=\"token operator\">=</span> <span class=\"token operator\">-</span>offset<span class=\"token punctuation\">;</span> y <span class=\"token operator\">&lt;</span> offset<span class=\"token punctuation\">;</span> y <span class=\"token operator\">+=</span> offset <span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span>samples <span class=\"token operator\">*</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span> z <span class=\"token operator\">=</span> <span class=\"token operator\">-</span>offset<span class=\"token punctuation\">;</span> z <span class=\"token operator\">&lt;</span> offset<span class=\"token punctuation\">;</span> z <span class=\"token operator\">+=</span> offset <span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span>samples <span class=\"token operator\">*</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>            <span class=\"token keyword\">float</span> closestDepth <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>depthMap<span class=\"token punctuation\">,</span> fragToLight <span class=\"token operator\">+</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">,</span> z<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>r<span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"12\"></td><td><pre>            closestDepth <span class=\"token operator\">*=</span> far_plane<span class=\"token punctuation\">;</span>   <span class=\"token comment\">// Undo mapping [0;1]</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>currentDepth <span class=\"token operator\">-</span> bias <span class=\"token operator\">></span> closestDepth<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>                shadow <span class=\"token operator\">+=</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>shadow <span class=\"token operator\">/=</span> <span class=\"token punctuation\">(</span>samples <span class=\"token operator\">*</span> samples <span class=\"token operator\">*</span> samples<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这段代码和我们传统的阴影映射没有多少不同。这里我们根据样本的数量动态计算了纹理偏移量，我们在三个轴向采样三次，最后对子样本进行平均化。</p>\n<p>现在阴影看起来更加柔和平滑了，由此得到更加真实的效果：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/03/02/point_shadows_soft.png\" alt=\"image\" /></p>\n<p>然而，samples 设置为 4.0，每个 fragment 我们会得到总共 64 个样本，这太多了！</p>\n<p>大多数这些样本都是多余的，它们在原始方向向量近处采样，不如在采样方向向量的垂直方向进行采样更有意义。可是，没有（简单的）方式能够指出哪一个子方向是多余的，这就难了。有个技巧可以使用，用一个偏移量方向数组，它们差不多都是分开的，每一个指向完全不同的方向，剔除彼此接近的那些子方向。下面就是一个有着 20 个偏移方向的数组：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vec3 sampleOffsetDirections<span class=\"token punctuation\">[</span><span class=\"token number\">20</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> vec3<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>   <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>   <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>   <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>   <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>   <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>然后我们把 PCF 算法与从 sampleOffsetDirections 得到的样本数量进行适配，使用它们从立方体贴图里采样。这么做的好处是与之前的 PCF 算法相比，我们需要的样本数量变少了。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> shadow <span class=\"token operator\">=</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">float</span> bias <span class=\"token operator\">=</span> <span class=\"token number\">0.15</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">int</span> samples <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">float</span> viewDistance <span class=\"token operator\">=</span> <span class=\"token function\">length</span><span class=\"token punctuation\">(</span>viewPos <span class=\"token operator\">-</span> fragPos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">float</span> diskRadius <span class=\"token operator\">=</span> <span class=\"token number\">0.05</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> samples<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">float</span> closestDepth <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>depthMap<span class=\"token punctuation\">,</span> fragToLight <span class=\"token operator\">+</span> sampleOffsetDirections<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> diskRadius<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>r<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    closestDepth <span class=\"token operator\">*=</span> far_plane<span class=\"token punctuation\">;</span>   <span class=\"token comment\">// Undo mapping [0;1]</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>currentDepth <span class=\"token operator\">-</span> bias <span class=\"token operator\">></span> closestDepth<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        shadow <span class=\"token operator\">+=</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>shadow <span class=\"token operator\">/=</span> <span class=\"token keyword\">float</span><span class=\"token punctuation\">(</span>samples<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这里我们把一个偏移量添加到指定的 diskRadius 中，它在 fragToLight 方向向量周围从立方体贴图里采样。</p>\n<p>另一个在这里可以应用的有意思的技巧是，我们可以基于观察者里一个 fragment 的距离来改变 diskRadius；这样我们就能根据观察者的距离来增加偏移半径了，当距离更远的时候阴影更柔和，更近了就更锐利。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> diskRadius <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>viewDistance <span class=\"token operator\">/</span> far_plane<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">25.0</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>PCF 算法的结果如果没有变得更好，也是非常不错的，这是柔和的阴影效果：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/03/02/point_shadows_soft_better.png\" alt=\"image\" /></p>\n<p>当然了，我们添加到每个样本的 bias（偏移）高度依赖于上下文，总是要根据场景进行微调的。试试这些值，看看怎样影响了场景。 这里是最终版本的顶点和像素着色器。</p>\n<p>我还要提醒一下使用几何着色器来生成深度贴图不会一定比每个面渲染场景 6 次更快。使用几何着色器有它自己的性能局限，在第一个阶段使用它可能获得更好的性能表现。这取决于环境的类型，以及特定的显卡驱动等等，所以如果你很关心性能，就要确保对两种方法有大致了解，然后选择对你场景来说更高效的那个。我个人还是喜欢使用几何着色器来进行阴影映射，原因很简单，因为它们使用起来更简单。</p>\n<h3 id=\"附加资源-3\"><a class=\"anchor\" href=\"#附加资源-3\">#</a> 附加资源</h3>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdW5hbmRibGFja2NhdC5jb20vdGlwRnVsbFZpZXcucGhwP2w9ZW5nJmFtcDt0b3BpY2lkPTM2\">Shadow Mapping for point light sources in OpenGL</span>：sunandblackcat 的万向阴影映射教程。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL29nbGRldi5hdHNwYWNlLmNvLnVrL3d3dy90dXRvcmlhbDQzL3R1dG9yaWFsNDMuaHRtbA==\">Multipass Shadow Mapping With Point Lights</span>：ogldev 的万向阴影映射教程。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5jZy50dXdpZW4uYWMuYXQvfmh1c2t5L1JUUi9PbW5pZGlyU2hhZG93cy13aHlDYXBzLnBkZg==\">Omni-directional Shadows</span>：Peter Houska 的关于万向阴影映射的一组很好的 ppt。</li>\n</ul>\n<h2 id=\"法线贴图\"><a class=\"anchor\" href=\"#法线贴图\">#</a> 法线贴图</h2>\n<p>我们的场景中已经充满了多边形物体，其中每个都可能由成百上千平坦的三角形组成。我们以向三角形上附加纹理的方式来增加额外细节，提升真实感，隐藏多边形几何体是由无数三角形组成的事实。纹理确有助益，然而当你近看它们时，这个事实便隐藏不住了。现实中的物体表面并非是平坦的，而是表现出无数（凹凸不平的）细节。</p>\n<p>例如，砖块的表面。砖块的表面非常粗糙，显然不是完全平坦的：它包含着接缝处水泥凹痕，以及非常多的细小的空洞。如果我们在一个有光的场景中看这样一个砖块的表面，问题就出来了。下图中我们可以看到砖块纹理应用到了平坦的表面，并被一个点光源照亮。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/04/normal_mapping_flat.png\" alt=\"image\" /></p>\n<p>光照并没有呈现出任何裂痕和孔洞，完全忽略了砖块之间凹进去的线条；表面看起来完全就是平的。我们可以使用 specular 贴图根据深度或其他细节阻止部分表面被照的更亮，以此部分地解决问题，但这并不是一个好方案。我们需要的是某种可以告知光照系统给所有有关物体表面类似深度这样的细节的方式。</p>\n<p>如果我们以光的视角来看这个问题：是什么使表面被视为完全平坦的表面来照亮？答案会是表面的法线向量。以光照算法的视角考虑的话，只有一件事决定物体的形状，这就是垂直于它的法线向量。砖块表面只有一个法线向量，表面完全根据这个法线向量被以一致的方式照亮。如果每个 fragment 都是用自己的不同的法线会怎样？这样我们就可以根据表面细微的细节对法线向量进行改变；这样就会获得一种表面看起来要复杂得多的幻觉：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/04/normal_mapping_surfaces.png\" alt=\"image\" /></p>\n<p>每个 fragment 使用了自己的法线，我们就可以让光照相信一个表面由很多微小的（垂直于法线向量的）平面所组成，物体表面的细节将会得到极大提升。这种每个 fragment 使用各自的法线，替代一个面上所有 fragment 使用同一个法线的技术叫做法线贴图（normal mapping）或凹凸贴图（bump mapping）。应用到砖墙上，效果像这样：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/04/normal_mapping_compare.png\" alt=\"image\" /></p>\n<p>你可以看到细节获得了极大提升，开销却不大。因为我们只需要改变每个 fragment 的法线向量，并不需要改变所有光照公式。现在我们是为每个 fragment 传递一个法线，不再使用插值表面法线。这样光照使表面拥有了自己的细节。</p>\n<h3 id=\"法线贴图-2\"><a class=\"anchor\" href=\"#法线贴图-2\">#</a> 法线贴图</h3>\n<p>为使法线贴图工作，我们需要为每个 fragment 提供一个法线。像 diffuse 贴图和 specular 贴图一样，我们可以使用一个 2D 纹理来储存法线数据。2D 纹理不仅可以储存颜色和光照数据，还可以储存法线向量。这样我们可以从 2D 纹理中采样得到特定纹理的法线向量。</p>\n<p>由于法线向量是个几何工具，而纹理通常只用于储存颜色信息，用纹理储存法线向量不是非常直接。如果你想一想，就会知道纹理中的颜色向量用 r、g、b 元素代表一个 3D 向量。类似的我们也可以将法线向量的 x、y、z 元素储存到纹理中，代替颜色的 r、g、b 元素。<mark>法线向量的范围在 - 1 到 1 之间</mark>，所以我们先要将其映射到 0 到 1 的范围：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vec3 rgb_normal <span class=\"token operator\">=</span> normal <span class=\"token operator\">*</span> <span class=\"token number\">0.5</span> <span class=\"token operator\">+</span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 从 [-1,1] 转换至 [0,1]</span></pre></td></tr></table></figure><p>将法线向量变换为像这样的 RGB 颜色元素，我们就能把根据表面的形状的 fragment 的法线保存在 2D 纹理中。教程开头展示的那个砖块的例子的法线贴图如下所示：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/04/normal_mapping_normal_map.png\" alt=\"image\" /></p>\n<p>这会是一种偏蓝色调的纹理（你在网上找到的几乎所有法线贴图都是这样的）。这是因为所有法线的指向都偏向 z 轴（0, 0, 1）这是一种偏蓝的颜色。法线向量从 z 轴方向也向其他方向轻微偏移，颜色也就发生了轻微变化，这样看起来便有了一种深度。例如，你可以看到在每个砖块的顶部，颜色倾向于偏绿，这是因为砖块的顶部的法线偏向于指向正 y 轴方向（0, 1, 0），这样它就是绿色的了。</p>\n<p>在一个简单的朝向正 z 轴的平面上，我们可以用这个<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWFybm9wZW5nbC5jb20vaW1nL3RleHR1cmVzL2JyaWNrd2FsbC5qcGc=\"> diffuse 纹理</span>和这个<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWFybm9wZW5nbC5jb20vaW1nL3RleHR1cmVzL2JyaWNrd2FsbF9ub3JtYWwuanBn\">法线贴图</span>来渲染前面部分的图片。要注意的是这个链接里的法线贴图和上面展示的那个不一样。原因是 OpenGL 读取的纹理的 y（或 V）坐标和纹理通常被创建的方式相反。链接里的法线贴图的 y（或绿色）元素是相反的（你可以看到绿色现在在下边）；如果你没考虑这个，光照就不正确了（译注：如果你现在不再使用 SOIL 了，那就不要用链接里的那个法线贴图，这个问题是 SOIL 载入纹理上下颠倒所致，它也会把法线在 y 方向上颠倒）。加载纹理，把它们绑定到合适的纹理单元，然后使用下面的改变了的像素着色器来渲染一个平面：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>uniform sampler2D normalMap<span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#123;</span>           </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token comment\">// 从法线贴图范围 [0,1] 获取法线</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    normal <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>normalMap<span class=\"token punctuation\">,</span> fs_in<span class=\"token punctuation\">.</span>TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>rgb<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token comment\">// 将法线向量转换为范围 [-1,1]</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    normal <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>normal <span class=\"token operator\">*</span> <span class=\"token number\">2.0</span> <span class=\"token operator\">-</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   </pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token comment\">// 像往常那样处理光照</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这里我们将被采样的法线颜色从 0 到 1 重新映射回 - 1 到 1，便能将 RGB 颜色重新处理成法线，然后使用采样出的法线向量应用于光照的计算。在例子中我们使用的是 Blinn-Phong 着色器。</p>\n<p>通过慢慢随着时间慢慢移动光源，你就能明白法线贴图是什么意思了。运行这个例子你就能得到本教程开始的那个效果：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/04/normal_mapping_correct.png\" alt=\"image\" /></p>\n<p>然而有个问题限制了刚才讲的那种法线贴图的使用。我们使用的那个法线贴图里面的所有法线向量都是指向正 z 方向的。上面的例子能用，是因为那个平面的表面法线也是指向正 z 方向的。可是，如果我们在表面法线指向正 y 方向的平面上使用同一个法线贴图会发生什么？</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/04/normal_mapping_ground.png\" alt=\"image\" /></p>\n<p>光照看起来完全不对！发生这种情况是平面的表面法线现在指向了 y，而采样得到的法线仍然指向的是 z。结果就是光照仍然认为表面法线和之前朝向正 z 方向时一样；这样光照就不对了。下面的图片展示了这个表面上采样的法线的近似情况：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/04/normal_mapping_ground_normals.png\" alt=\"image\" /></p>\n<p>你可以看到所有法线都指向 z 方向，它们本该朝着表面法线指向 y 方向的。一个可行方案是为每个表面制作一个单独的法线贴图。如果是一个立方体的话我们就需要 6 个法线贴图，但是如果模型上有无数的朝向不同方向的表面，这就不可行了（译注：实际上对于复杂模型可以把朝向各个方向的法线储存在同一张贴图上，你可能看到过不只是蓝色的法线贴图，不过用那样的法线贴图有个问题是你必须记住模型的起始朝向，如果模型运动了还要记录模型的变换，这是非常不方便的；此外就像作者所说的，如果把一个 diffuse 纹理应用在同一个物体的不同表面上，就像立方体那样的，就需要做 6 个法线贴图，这也不可取）。</p>\n<p>另一个稍微有点难的解决方案是，在一个不同的坐标空间中进行光照，这个坐标空间里，法线贴图向量总是指向这个坐标空间的正 z 方向；所有的光照向量都相对与这个正 z 方向进行变换。这样我们就能始终使用同样的法线贴图，不管朝向问题。这个坐标空间叫做<mark>切线空间</mark>（tangent space）。</p>\n<h3 id=\"切线空间\"><a class=\"anchor\" href=\"#切线空间\">#</a> 切线空间</h3>\n<p>法线贴图中的法线向量在切线空间中，法线永远指着正 z 方向。切线空间是位于三角形表面之上的空间：法线相对于单个三角形的本地参考框架。它就像法线贴图向量的本地空间；它们都被定义为指向正 z 方向，无论最终变换到什么方向。使用一个特定的矩阵我们就能将本地 / 切线空寂中的法线向量转成世界或视图坐标，使它们转向到最终的贴图表面的方向。</p>\n<p>我们可以说，上个部分那个朝向正 y 的法线贴图错误的贴到了表面上。法线贴图被定义在切线空间中，所以一种解决问题的方式是计算出一种矩阵，把法线从切线空间变换到一个不同的空间，这样它们就能和表面法线方向对齐了：法线向量都会指向正 y 方向。切线空间的一大好处是我们可以为任何类型的表面计算出一个这样的矩阵，由此我们可以把切线空间的 z 方向和表面的法线方向对齐。</p>\n<p>这种矩阵叫做 TBN 矩阵这三个字母分别代表<mark> tangent</mark>、<mark>bitangent</mark> 和<mark> normal</mark> 向量。这是建构这个矩阵所需的向量。要建构这样一个把切线空间转变为不同空间的变异矩阵，我们需要三个相互垂直的向量，它们沿一个表面的法线贴图对齐于：上、右、前；这和我们在摄像机教程中做的类似。</p>\n<p>已知上向量是表面的法线向量。右和前向量是切线 (Tagent) 和副切线 (Bitangent) 向量。下面的图片展示了一个表面的三个向量：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/04/normal_mapping_tbn_vectors.png\" alt=\"image\" /></p>\n<p>计算出切线和副切线并不像法线向量那么容易。从图中可以看到法线贴图的切线和副切线与纹理坐标的两个方向对齐。我们就是用到这个特性计算每个表面的切线和副切线的。需要用到一些数学才能得到它们；请看下图：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/04/normal_mapping_surface_edges.png\" alt=\"image\" /></p>\n<p>注意上图中边 E2 与纹理坐标的差 ΔU2、ΔV2 构成一个三角形。ΔU2 与切线向量 T 方向相同，而 ΔV2 与副切线向量 B 方向相同。这也就是说，所以我们可以将三角形的边 E1 与 E2 写成切线向量 \\T 和副切线向量 B 的线性组合：</p>\n<pre><code class=\"language-math\">E_1=ΔU_1T+ΔV_1B\n \nE_2=ΔU_2T+ΔV_2B\n</code></pre>\n<p>我们也可以写成这样：</p>\n<pre><code class=\"language-math\">(E_&#123;1x&#125;,E_&#123;1y&#125;,E_&#123;1z&#125;)=ΔU_1(T_x,T_y,T_z)+ΔV_1(B_x,B_y,B_z)\n \n(E_&#123;2x&#125;,E_&#123;2y&#125;,E_&#123;2z&#125;)=ΔU_2(T_x,T_y,T_z)+ΔV_2(B_x,B_y,B_z)\n</code></pre>\n<p>E 是两个向量位置的差，ΔU 和 ΔV 是纹理坐标的差。然后我们得到两个未知数（切线 T 和副切线 B）和两个等式。你可能想起你的代数课了，这是让我们去解 T 和 B。</p>\n<p>上面的方程允许我们把它们写成另一种格式：矩阵乘法</p>\n<pre><code class=\"language-math\">\\begin&#123;bmatrix&#125;\n   E_&#123;1x&#125; &amp; E_&#123;1y&#125; &amp;E_&#123;1z&#125; \\\\\n   E_&#123;2x&#125; &amp; E_&#123;2y&#125; &amp;E_&#123;2z&#125;\n\\end&#123;bmatrix&#125;\n=\n\\begin&#123;bmatrix&#125;\n   ΔU_1 &amp; ΔV_1 \\\\\n   ΔU_2 &amp; ΔV_2\n\\end&#123;bmatrix&#125;\n\\begin&#123;bmatrix&#125;\n   T_x &amp; T_y &amp; T_z \\\\\n   B_x &amp; B_y &amp; B_z\n\\end&#123;bmatrix&#125;\n</code></pre>\n<p>尝试会意一下矩阵乘法，它们确实是同一种等式。把等式写成矩阵形式的好处是，解 T 和 B 会因此变得很容易。两边都乘以 ΔUΔV 的逆矩阵等于：</p>\n<pre><code class=\"language-math\">\\begin&#123;bmatrix&#125;\n   ΔU_1 &amp; ΔV_1 \\\\\n   ΔU_2 &amp; ΔV_2\n\\end&#123;bmatrix&#125;^&#123;-1&#125;\n\\begin&#123;bmatrix&#125;\n   E_&#123;1x&#125; &amp; E_&#123;1y&#125; &amp;E_&#123;1z&#125; \\\\\n   E_&#123;2x&#125; &amp; E_&#123;2y&#125; &amp;E_&#123;2z&#125;\n\\end&#123;bmatrix&#125;\n=\n\\begin&#123;bmatrix&#125;\n   T_x &amp; T_y &amp; T_z \\\\\n   B_x &amp; B_y &amp; B_z\n\\end&#123;bmatrix&#125;\n</code></pre>\n<p>这样我们就可以解出 T 和 B 了。这需要我们计算出 delta 纹理坐标矩阵的逆矩阵。我不打算讲解计算逆矩阵的细节，但大致是把它变化为，1 除以矩阵的行列式，再乘以它的<mark>伴随矩阵</mark> (Adjugate Matrix)。</p>\n<pre><code class=\"language-math\">\\begin&#123;bmatrix&#125;\n   T_x &amp; T_y &amp; T_z \\\\\n   B_x &amp; B_y &amp; B_z\n\\end&#123;bmatrix&#125;\n=\n\\cfrac&#123;1&#125;&#123;ΔU_1ΔV_2−ΔU_2ΔV_1&#125;\n\\begin&#123;bmatrix&#125;\n   ΔV_2 &amp; -ΔV_1 \\\\\n   -ΔU_2 &amp; ΔU_1\n\\end&#123;bmatrix&#125;\n\\begin&#123;bmatrix&#125;\n   E_&#123;1x&#125; &amp; E_&#123;1y&#125; &amp;E_&#123;1z&#125; \\\\\n   E_&#123;2x&#125; &amp; E_&#123;2y&#125; &amp;E_&#123;2z&#125;\n\\end&#123;bmatrix&#125;\n</code></pre>\n<p>有了最后这个等式，我们就可以用公式、三角形的两条边以及纹理坐标计算出<mark>切线向量 T</mark> 和<mark>副切线 B</mark>。</p>\n<p>如果你对这些数学内容不理解也不用担心。当你知道我们可以用一个三角形的顶点和纹理坐标（因为纹理坐标和切线向量在同一空间中）计算出切线和副切线你就已经部分地达到目的了（译注：上面的推导已经很清楚了，如果你不明白可以参考任意线性代数教材，就像作者所说的记住求得切线空间的公式也行，不过不管怎样都得理解切线空间的含义）。</p>\n<h3 id=\"手工计算切线和副切线\"><a class=\"anchor\" href=\"#手工计算切线和副切线\">#</a> 手工计算切线和副切线</h3>\n<p>这个教程的 demo 场景中有一个简单的 2D 平面，它朝向正 z 方向。这次我们会使用切线空间来实现法线贴图，所以我们可以使平面朝向任意方向，法线贴图仍然能够工作。使用前面讨论的数学方法，我们来手工计算出表面的切线和副切线向量。</p>\n<p>假设平面使用下面的向量建立起来（1、2、3 和 1、3、4，它们是两个三角形）：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// positions</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 <span class=\"token function\">pos1</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 <span class=\"token function\">pos2</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 <span class=\"token function\">pos3</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 <span class=\"token function\">pos4</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">// texture coordinates</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>glm<span class=\"token operator\">::</span>vec2 <span class=\"token function\">uv1</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>glm<span class=\"token operator\">::</span>vec2 <span class=\"token function\">uv2</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>glm<span class=\"token operator\">::</span>vec2 <span class=\"token function\">uv3</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>glm<span class=\"token operator\">::</span>vec2 <span class=\"token function\">uv4</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token comment\">// normal vector</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 <span class=\"token function\">nm</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>我们先计算第一个三角形的边和 deltaUV 坐标：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 edge1 <span class=\"token operator\">=</span> pos2 <span class=\"token operator\">-</span> pos1<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>glm<span class=\"token operator\">::</span>vec3 edge2 <span class=\"token operator\">=</span> pos3 <span class=\"token operator\">-</span> pos1<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>glm<span class=\"token operator\">::</span>vec2 deltaUV1 <span class=\"token operator\">=</span> uv2 <span class=\"token operator\">-</span> uv1<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>glm<span class=\"token operator\">::</span>vec2 deltaUV2 <span class=\"token operator\">=</span> uv3 <span class=\"token operator\">-</span> uv1<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>有了计算切线和副切线的必备数据，我们就可以开始写出来自于前面部分中的下列等式：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>GLfloat f <span class=\"token operator\">=</span> <span class=\"token number\">1.0f</span> <span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span>deltaUV1<span class=\"token punctuation\">.</span>x <span class=\"token operator\">*</span> deltaUV2<span class=\"token punctuation\">.</span>y <span class=\"token operator\">-</span> deltaUV2<span class=\"token punctuation\">.</span>x <span class=\"token operator\">*</span> deltaUV1<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>tangent1<span class=\"token punctuation\">.</span>x <span class=\"token operator\">=</span> f <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>deltaUV2<span class=\"token punctuation\">.</span>y <span class=\"token operator\">*</span> edge1<span class=\"token punctuation\">.</span>x <span class=\"token operator\">-</span> deltaUV1<span class=\"token punctuation\">.</span>y <span class=\"token operator\">*</span> edge2<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>tangent1<span class=\"token punctuation\">.</span>y <span class=\"token operator\">=</span> f <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>deltaUV2<span class=\"token punctuation\">.</span>y <span class=\"token operator\">*</span> edge1<span class=\"token punctuation\">.</span>y <span class=\"token operator\">-</span> deltaUV1<span class=\"token punctuation\">.</span>y <span class=\"token operator\">*</span> edge2<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>tangent1<span class=\"token punctuation\">.</span>z <span class=\"token operator\">=</span> f <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>deltaUV2<span class=\"token punctuation\">.</span>y <span class=\"token operator\">*</span> edge1<span class=\"token punctuation\">.</span>z <span class=\"token operator\">-</span> deltaUV1<span class=\"token punctuation\">.</span>y <span class=\"token operator\">*</span> edge2<span class=\"token punctuation\">.</span>z<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>tangent1 <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>tangent1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>bitangent1<span class=\"token punctuation\">.</span>x <span class=\"token operator\">=</span> f <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>deltaUV2<span class=\"token punctuation\">.</span>x <span class=\"token operator\">*</span> edge1<span class=\"token punctuation\">.</span>x <span class=\"token operator\">+</span> deltaUV1<span class=\"token punctuation\">.</span>x <span class=\"token operator\">*</span> edge2<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>bitangent1<span class=\"token punctuation\">.</span>y <span class=\"token operator\">=</span> f <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>deltaUV2<span class=\"token punctuation\">.</span>x <span class=\"token operator\">*</span> edge1<span class=\"token punctuation\">.</span>y <span class=\"token operator\">+</span> deltaUV1<span class=\"token punctuation\">.</span>x <span class=\"token operator\">*</span> edge2<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>bitangent1<span class=\"token punctuation\">.</span>z <span class=\"token operator\">=</span> f <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>deltaUV2<span class=\"token punctuation\">.</span>x <span class=\"token operator\">*</span> edge1<span class=\"token punctuation\">.</span>z <span class=\"token operator\">+</span> deltaUV1<span class=\"token punctuation\">.</span>x <span class=\"token operator\">*</span> edge2<span class=\"token punctuation\">.</span>z<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>bitangent1 <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>bitangent1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">// 对平面的第二个三角形采用类似步骤计算切线和副切线</span></pre></td></tr></table></figure><p>我们预先计算出等式的分数部分 f，然后把它和每个向量的元素进行相应矩阵乘法。如果你把代码和最终的等式对比你会发现，这就是直接套用。最后我们还要进行标准化，来确保切线 / 副切线向量最后是单位向量。</p>\n<p>因为一个三角形永远是平坦的形状，我们只需为每个三角形计算一个切线 / 副切线，它们对于每个三角形上的顶点都是一样的。要注意的是大多数实现通常三角形和三角形之间都会共享顶点。这种情况下开发者通常将每个顶点的法线和切线 / 副切线等顶点属性平均化，以获得更加柔和的效果。我们的平面的三角形之间分享了一些顶点，但是因为两个三角形相互并行，因此并不需要将结果平均化，但无论何时只要你遇到这种情况记住它就是件好事。</p>\n<p>最后的切线和副切线向量的值应该是 (1, 0, 0) 和 (0, 1, 0)，它们和法线 (0, 0, 1) 组成相互垂直的 TBN 矩阵。在平面上显示出来 TBN 应该是这样的：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/04/normal_mapping_tbn_shown.png\" alt=\"image\" /></p>\n<p>每个顶点定义了切线和副切线向量，我们就可以开始实现正确的法线贴图了。</p>\n<h3 id=\"切线空间法线贴图\"><a class=\"anchor\" href=\"#切线空间法线贴图\">#</a> 切线空间法线贴图</h3>\n<p>为让法线贴图工作，我们先得在着色器中创建一个 TBN 矩阵。我们先将前面计算出来的切线和副切线向量传给顶点着色器，作为它的属性：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> in vec3 position<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> in vec3 normal<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> in vec2 texCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> in vec3 tangent<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span> in vec3 bitangent<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在顶点着色器的 main 函数中我们创建 TBN 矩阵：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>   <span class=\"token punctuation\">[</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>   vec3 T <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span>model <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>tangent<span class=\"token punctuation\">,</span>   <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>   vec3 B <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span>model <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>bitangent<span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>   vec3 N <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span>model <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>normal<span class=\"token punctuation\">,</span>    <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>   mat3 TBN <span class=\"token operator\">=</span> <span class=\"token function\">mat3</span><span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">,</span> B<span class=\"token punctuation\">,</span> N<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们先将所有 TBN 向量变换到我们所操作的坐标系中，现在是世界空间，我们可以乘以 model 矩阵。然后我们创建实际的 TBN 矩阵，直接把相应的向量应用到 mat3 构造器就行。注意，如果我们希望更精确的话就不要将 TBN 向量乘以 model 矩阵，而是使用法线矩阵，但我们只关心向量的方向，不会平移也和缩放这个变换。</p>\n<blockquote>\n<p>从技术上讲，顶点着色器中无需副切线。所有的这三个 TBN 向量都是相互垂直的所以我们可以在顶点着色器中用 T 和 N 向量的叉乘，自己计算出副切线：<strong>vec3 B = cross(T, N)</strong>;</p>\n</blockquote>\n<p>现在我们有了 TBN 矩阵，如果来使用它呢？通常来说有两种方式使用它，我们会把这两种方式都说明一下：</p>\n<ul>\n<li>我们直接使用 TBN 矩阵，这个矩阵可以把切线坐标空间的向量转换到世界坐标空间。因此我们把它传给片段着色器中，把通过采样得到的法线坐标左乘上 TBN 矩阵，转换到世界坐标空间中，这样所有法线和其他光照变量就在同一个坐标系中了。</li>\n<li>我们也可以使用 TBN 矩阵的逆矩阵，这个矩阵可以把世界坐标空间的向量转换到切线坐标空间。因此我们使用这个矩阵左乘其他光照变量，把他们转换到切线空间，这样法线和其他光照变量再一次在一个坐标系中了。</li>\n</ul>\n<p><strong>我们来看看第一种情况</strong>。我们从法线贴图重采样得来的法线向量，是以切线空间表达的，尽管其他光照向量是以世界空间表达的。把 TBN 传给像素着色器，我们就能将采样得来的切线空间的法线乘以这个 TBN 矩阵，将法线向量变换到和其他光照向量一样的参考空间中。这种方式随后所有光照计算都可以简单的理解。</p>\n<p>把 TBN 矩阵发给像素着色器很简单：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>out VS_OUT <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    vec3 FragPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    vec2 TexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    mat3 TBN<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span> vs_out<span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    vs_out<span class=\"token punctuation\">.</span>TBN <span class=\"token operator\">=</span> <span class=\"token function\">mat3</span><span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">,</span> B<span class=\"token punctuation\">,</span> N<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在像素着色器中我们用 mat3 作为输入变量：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>in VS_OUT <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    vec3 FragPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    vec2 TexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    mat3 TBN<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span> fs_in<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>有了 TBN 矩阵我们现在就可以更新法线贴图代码，引入切线到世界空间变换：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>normal <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>normalMap<span class=\"token punctuation\">,</span> fs_in<span class=\"token punctuation\">.</span>TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>rgb<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>normal <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>normal <span class=\"token operator\">*</span> <span class=\"token number\">2.0</span> <span class=\"token operator\">-</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>normal <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>fs_in<span class=\"token punctuation\">.</span>TBN <span class=\"token operator\">*</span> normal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>因为最后的 normal 现在在世界空间中了，就不用改变其他像素着色器的代码了，因为光照代码就是假设法线向量在世界空间中。</p>\n<p>我们同样看看第二种情况。我们用 TBN 矩阵的逆矩阵将所有相关的世界空间向量转变到采样所得法线向量的空间：切线空间。TBN 的建构还是一样，但我们在将其发送给像素着色器之前先要求逆矩阵：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vs_out<span class=\"token punctuation\">.</span>TBN <span class=\"token operator\">=</span> <span class=\"token function\">transpose</span><span class=\"token punctuation\">(</span><span class=\"token function\">mat3</span><span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">,</span> B<span class=\"token punctuation\">,</span> N<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>注意，这里我们使用 transpose 函数，而不是 inverse 函数。正交矩阵（每个轴既是单位向量同时相互垂直）的一大属性是一个<mark>正交矩阵的置换矩阵</mark>与<mark>它的逆矩阵</mark><strong>相等</strong>。这个属性很重要因为逆矩阵的求得比求置换开销大；结果却是一样的。</p>\n<p>在像素着色器中我们不用对法线向量变换，但我们要把其他相关向量转换到切线空间，它们是 lightDir 和 viewDir。这样每个向量还是在同一个空间（切线空间）中了。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span>           </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    vec3 normal <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>normalMap<span class=\"token punctuation\">,</span> fs_in<span class=\"token punctuation\">.</span>TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>rgb<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    normal <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>normal <span class=\"token operator\">*</span> <span class=\"token number\">2.0</span> <span class=\"token operator\">-</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   </pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    vec3 lightDir <span class=\"token operator\">=</span> fs_in<span class=\"token punctuation\">.</span>TBN <span class=\"token operator\">*</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>lightPos <span class=\"token operator\">-</span> fs_in<span class=\"token punctuation\">.</span>FragPos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    vec3 viewDir  <span class=\"token operator\">=</span> fs_in<span class=\"token punctuation\">.</span>TBN <span class=\"token operator\">*</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>viewPos <span class=\"token operator\">-</span> fs_in<span class=\"token punctuation\">.</span>FragPos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    </pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>第二种方法看似要做的更多，它还需要在像素着色器中进行更多的乘法操作，所以为何还用第二种方法呢？</p>\n<p>将向量从世界空间转换到切线空间有个额外好处，我们可以把所有相关向量在顶点着色器中转换到切线空间，不用在像素着色器中做这件事。这是可行的，因为 lightPos 和 viewPos 不是每个 fragment 运行都要改变，对于 fs_in.FragPos，我们也可以在顶点着色器计算它的切线空间位置。基本上，不需要把任何向量在像素着色器中进行变换，而第一种方法中就是必须的，因为采样出来的法线向量对于每个像素着色器都不一样。</p>\n<p>所以现在不是把 TBN 矩阵的逆矩阵发送给像素着色器，而是将切线空间的光源位置，观察位置以及顶点位置发送给像素着色器。这样我们就不用在像素着色器里进行矩阵乘法了。这是一个极佳的优化，因为顶点着色器通常比像素着色器运行的少。这也是为什么这种方法是一种更好的实现方式的原因。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>out VS_OUT <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    vec3 FragPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    vec2 TexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    vec3 TangentLightPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    vec3 TangentViewPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    vec3 TangentFragPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span> vs_out<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>uniform vec3 lightPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>uniform vec3 viewPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#123;</span>    </pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    mat3 TBN <span class=\"token operator\">=</span> <span class=\"token function\">transpose</span><span class=\"token punctuation\">(</span><span class=\"token function\">mat3</span><span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">,</span> B<span class=\"token punctuation\">,</span> N<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    vs_out<span class=\"token punctuation\">.</span>TangentLightPos <span class=\"token operator\">=</span> TBN <span class=\"token operator\">*</span> lightPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    vs_out<span class=\"token punctuation\">.</span>TangentViewPos  <span class=\"token operator\">=</span> TBN <span class=\"token operator\">*</span> viewPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    vs_out<span class=\"token punctuation\">.</span>TangentFragPos  <span class=\"token operator\">=</span> TBN <span class=\"token operator\">*</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span>model <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>position<span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在像素着色器中我们使用这些新的输入变量来计算切线空间的光照。因为法线向量已经在切线空间中了，光照就有意义了。</p>\n<p>将法线贴图应用到切线空间上，我们会得到混合教程一开始那个例子相似的结果，但这次我们可以将平面朝向各个方向，光照一直都会是正确的：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span>mat4 model<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>model <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">rotate</span><span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>GLfloat<span class=\"token punctuation\">)</span><span class=\"token function\">glfwGetTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token operator\">-</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glUniformMatrix4fv</span><span class=\"token punctuation\">(</span>modelLoc <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">value_ptr</span><span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">RenderQuad</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>看起来是正确的法线贴图：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/04/normal_mapping_correct_tangent.png\" alt=\"image\" /></p>\n<h3 id=\"复杂物体\"><a class=\"anchor\" href=\"#复杂物体\">#</a> 复杂物体</h3>\n<p>我们已经说明了如何通过手工计算切线和副切线向量，来使用切线空间和法线贴图。幸运的是，计算这些切线和副切线向量对于你来说不是经常能遇到的事；大多数时候，在模型加载器中实现了一次就行了，我们是在使用了 Assimp 的那个加载器中实现的。</p>\n<p>Assimp 有个很有用的配置，在我们加载模型的时候调用 aiProcess_CalcTangentSpace。当 aiProcess_CalcTangentSpace 应用到 Assimp 的 ReadFile 函数时，Assimp 会为每个加载的顶点计算出柔和的切线和副切线向量，它所使用的方法和我们本教程使用的类似。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">const</span> aiScene<span class=\"token operator\">*</span> scene <span class=\"token operator\">=</span> importer<span class=\"token punctuation\">.</span><span class=\"token function\">ReadFile</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    path<span class=\"token punctuation\">,</span> aiProcess_Triangulate <span class=\"token operator\">|</span> aiProcess_FlipUVs <span class=\"token operator\">|</span> aiProcess_CalcTangentSpace</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>我们可以通过下面的代码用 Assimp 获取计算出来的切线空间：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vector<span class=\"token punctuation\">.</span>x <span class=\"token operator\">=</span> mesh<span class=\"token operator\">-></span>mTangents<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>vector<span class=\"token punctuation\">.</span>y <span class=\"token operator\">=</span> mesh<span class=\"token operator\">-></span>mTangents<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>vector<span class=\"token punctuation\">.</span>z <span class=\"token operator\">=</span> mesh<span class=\"token operator\">-></span>mTangents<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>z<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>vertex<span class=\"token punctuation\">.</span>Tangent <span class=\"token operator\">=</span> vector<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>然后，你还必须更新模型加载器，用以从带纹理模型中加载法线贴图。wavefront 的模型格式（.obj）导出的法线贴图有点不一样，Assimp 的 aiTextureType_NORMAL 并不会加载它的法线贴图，而 aiTextureType_HEIGHT 却能，所以我们经常这样加载它们：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vector<span class=\"token operator\">&lt;</span>Texture<span class=\"token operator\">></span> specularMaps <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token operator\">-></span><span class=\"token function\">loadMaterialTextures</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    material<span class=\"token punctuation\">,</span> aiTextureType_HEIGHT<span class=\"token punctuation\">,</span> <span class=\"token string\">\"texture_normal\"</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>当然，对于每个模型的类型和文件格式来说都是不同的。同样了解 aiProcess_CalcTangentSpace 并不能总是很好的工作也很重要。计算切线是需要根据纹理坐标的，有些模型制作者使用一些纹理小技巧比如镜像一个模型上的纹理表面时也镜像了另一半的纹理坐标；这样当不考虑这个镜像的特别操作的时候（Assimp 就不考虑）结果就不对了。</p>\n<p>运行程序，用新的模型加载器，加载一个有 specular 和法线贴图的模型，看起来会像这样：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/04/normal_mapping_complex_compare.png\" alt=\"image\" /></p>\n<p>你可以看到在没有太多点的额外开销的情况下法线贴图难以置信地提升了物体的细节。</p>\n<p>使用法线贴图也是一种提升你的场景的表现的重要方式。在使用法线贴图之前你不得不使用相当多的顶点才能表现出一个更精细的网格，但使用了法线贴图我们可以使用更少的顶点表现出同样丰富的细节。下图来自 Paolo Cignoni，图中对比了两种方式：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/04/normal_mapping_comparison.png\" alt=\"image\" /></p>\n<p>高精度网格和使用法线贴图的低精度网格几乎区分不出来。所以法线贴图不仅看起来漂亮，它也是一个将高精度多边形转换为低精度多边形而不失细节的重要工具。</p>\n<h3 id=\"最后一件事\"><a class=\"anchor\" href=\"#最后一件事\">#</a> 最后一件事</h3>\n<p>关于法线贴图还有最后一个技巧要讨论，它可以在不必花费太多性能开销的情况下稍稍提升画质表现。</p>\n<p>当在更大的网格上计算切线向量的时候，它们往往有很大数量的共享顶点，当法向贴图应用到这些表面时将切线向量平均化通常能获得更好更平滑的结果。这样做有个问题，就是 TBN 向量可能会不能互相垂直，这意味着 TBN 矩阵不再是正交矩阵了。法线贴图可能会稍稍偏移，但这仍然可以改进。</p>\n<p>使用叫做<mark>格拉姆 - 施密特正交化过程</mark>（Gram-Schmidt process）的数学技巧，我们可以对 TBN 向量进行<mark>重正交化</mark>，这样每个向量就又会重新垂直了。在顶点着色器中我们这样做：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vec3 T <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span>model <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>tangent<span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>vec3 N <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span>model <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>normal<span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// re-orthogonalize T with respect to N</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>T <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>T <span class=\"token operator\">-</span> <span class=\"token function\">dot</span><span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">,</span> N<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> N<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// then retrieve perpendicular vector B with the cross product of T and N</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>vec3 B <span class=\"token operator\">=</span> <span class=\"token function\">cross</span><span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">,</span> N<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>mat3 TBN <span class=\"token operator\">=</span> <span class=\"token function\">mat3</span><span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">,</span> B<span class=\"token punctuation\">,</span> N<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>这样稍微花费一些性能开销就能对法线贴图进行一点提升。看看最后的那个附加资源： Normal Mapping Mathematics 视频，里面有对这个过程的解释。</p>\n<h3 id=\"附加资源-4\"><a class=\"anchor\" href=\"#附加资源-4\">#</a> 附加资源</h3>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL29nbGRldi5hdHNwYWNlLmNvLnVrL3d3dy90dXRvcmlhbDI2L3R1dG9yaWFsMjYuaHRtbA==\">Tutorial 26: Normal Mapping</span>：ogldev 的法线贴图教程。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1MSU9QWW1rbmo1UQ==\">How Normal Mapping Works</span>：TheBennyBox 的讲述法线贴图如何工作的视频。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj00RmFXTGdzY3RxWQ==\">Normal Mapping Mathematics</span>：TheBennyBox 关于法线贴图的数学原理的教程。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5vcGVuZ2wtdHV0b3JpYWwub3JnL2ludGVybWVkaWF0ZS10dXRvcmlhbHMvdHV0b3JpYWwtMTMtbm9ybWFsLW1hcHBpbmcv\">Tutorial 13: Normal Mapping</span>：opengl-tutorial.org 提供的法线贴图教程。</li>\n</ul>\n<h2 id=\"视差贴图\"><a class=\"anchor\" href=\"#视差贴图\">#</a> 视差贴图</h2>\n<p><mark>视差贴图</mark> (Parallax Mapping) 技术和法线贴图差不多，但它有着不同的原则。和法线贴图一样视差贴图能够极大<mark>提升表面细节</mark>，使之具有深度感。它也是利用了视错觉，然而对深度有着更好的表达，与法线贴图一起用能够产生难以置信的效果。视差贴图<mark>和光照无关</mark>，我在这里是作为法线贴图的技术延续来讨论它的。需要注意的是在开始学习视差贴图之前强烈建议先对法线贴图，特别是切线空间有较好的理解。</p>\n<p>视差贴图属于 == 位移贴图 (==Displacement Mapping) 技术的一种，它对根据储存在纹理中的几何信息对顶点进行位移或偏移。一种实现的方式是比如有 1000 个顶点，根据纹理中的数据对平面特定区域的顶点的高度进行位移。这样的每个纹理像素包含了高度值纹理叫做高度贴图。一张简单的砖块表面的高度贴图如下所示：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/05/parallax_mapping_height_map.png\" alt=\"image\" /></p>\n<p>整个平面上的每个顶点都根据从高度贴图采样出来的高度值进行位移，根据材质的几何属性平坦的平面变换成凹凸不平的表面。例如一个平坦的平面利用上面的高度贴图进行置换能得到以下结果：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/05/parallax_mapping_plane_heightmap.png\" alt=\"image\" /></p>\n<p>置换顶点有一个问题就是平面必须由很多顶点组成才能获得具有真实感的效果，否则看起来效果并不会很好。一个平坦的表面上有 1000 个顶点计算量太大了。我们能否不用这么多的顶点就能取得相似的效果呢？事实上，上面的表面就是用 6 个顶点渲染出来的（两个三角形）。上面的那个表面使用视差贴图技术渲染，位移贴图技术不需要额外的顶点数据来表达深度，它像法线贴图一样采用一种聪明的手段欺骗用户的眼睛。</p>\n<p>视差贴图背后的思想是修改纹理坐标使一个 fragment 的表面看起来比实际的更高或者更低，所有这些都根据观察方向和高度贴图。为了理解它如何工作，看看下面砖块表面的图片：</p>\n<p>这里粗糙的红线代表高度贴图中的数值的立体表达，向量 V¯ 代表观察方向。如果平面进行实际位移，观察者会在点 B 看到表面。然而我们的平面没有实际上进行位移，观察方向将在点 A 与平面接触。视差贴图的目的是，在 A 位置上的 fragment 不再使用点 A 的纹理坐标而是使用点 B 的。随后我们用点 B 的纹理坐标采样，观察者就像看到了点 B 一样。</p>\n<p>这个技巧就是描述如何从点 A 得到点 B 的纹理坐标。视差贴图尝试通过对从 fragment 到观察者的方向向量 V¯ 进行缩放的方式解决这个问题，缩放的大小是 A 处 fragment 的高度。所以我们将 V¯ 的长度缩放为高度贴图在点 A 处 H (A) 采样得来的值。下图展示了经缩放得到的向量 P¯：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/05/parallax_mapping_scaled_height.png\" alt=\"image\" /></p>\n<p>我们随后选出 P¯ 以及这个向量与平面对齐的坐标作为纹理坐标的偏移量。这能工作是因为向量 P¯ 是使用从高度贴图得到的高度值计算出来的，所以一个 fragment 的高度越高位移的量越大。</p>\n<p>这个技巧在大多数时候都没问题，但点 B 是粗略估算得到的。当表面的高度变化很快的时候，看起来就不会真实，因为向量 P¯ 最终不会和 B 接近，就像下图这样：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/05/parallax_mapping_incorrect_p.png\" alt=\"image\" /></p>\n<p>视差贴图的另一个问题是，当表面被任意旋转以后很难指出从 P¯ 获取哪一个坐标。我们在视差贴图中使用了另一个坐标空间，这个空间 P¯ 向量的 x 和 y 元素总是与纹理表面对齐。如果你看了法线贴图教程，你也许猜到了，我们实现它的方法，是的，我们还是在切线空间中实现视差贴图。</p>\n<p>将 fragment 到观察者的向量 V¯ 转换到切线空间中，经变换的 P¯ 向量的 x 和 y 元素将于表面的切线和副切线向量对齐。由于切线和副切线向量与表面纹理坐标的方向相同，我们可以用 P¯ 的 x 和 y 元素作为纹理坐标的偏移量，这样就不用考虑表面的方向了。</p>\n<p>理论都有了，下面我们来动手实现视差贴图。</p>\n<h3 id=\"视差贴图-2\"><a class=\"anchor\" href=\"#视差贴图-2\">#</a> 视差贴图</h3>\n<p>我们将使用一个简单的 2D 平面，在把它发送给 GPU 之前我们先计算它的切线和副切线向量；和法线贴图教程做的差不多。我们将向平面贴 diffuse 纹理、法线贴图以及一个位移贴图，你可以点击链接下载。这个例子中我们将视差贴图和法线贴图连用。因为视差贴图生成表面位移了的幻觉，当光照不匹配时这种幻觉就被破坏了。法线贴图通常根据高度贴图生成，法线贴图和高度贴图一起用能保证光照能和位移想匹配。</p>\n<p>你可能已经注意到，上面链接上的那个位移贴图和教程一开始的那个高度贴图相比是颜色是相反的。这是因为使用反色高度贴图（也叫深度贴图）去模拟深度比模拟高度更容易。下图反映了这个轻微的改变：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/05/parallax_mapping_depth.png\" alt=\"image\" /></p>\n<p>我们再次获得 A 和 B，但是这次我们用向量 V¯ 减去点 A 的纹理坐标得到 P¯。我们通过在着色器中用 1.0 减去采样得到的高度贴图中的值来取得深度值，而不再是高度值，或者简单地在图片编辑软件中把这个纹理进行反色操作，就像我们对连接中的那个深度贴图所做的一样。</p>\n<p>位移贴图是在像素着色器中实现的，因为三角形表面的所有位移效果都不同。在像素着色器中我们将需要计算 fragment 到观察者到方向向量 V¯ 所以我们需要观察者位置和在切线空间中的 fragment 位置。法线贴图教程中我们已经有了一个顶点着色器，它把这些向量发送到切线空间，所以我们可以复制那个顶点着色器：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> in vec3 position<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> in vec3 normal<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> in vec2 texCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> in vec3 tangent<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span> in vec3 bitangent<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>out VS_OUT <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    vec3 FragPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    vec2 TexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    vec3 TangentLightPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    vec3 TangentViewPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    vec3 TangentFragPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span> vs_out<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>uniform mat4 projection<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>uniform mat4 view<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>uniform mat4 model<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>uniform vec3 lightPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>uniform vec3 viewPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    gl_Position      <span class=\"token operator\">=</span> projection <span class=\"token operator\">*</span> view <span class=\"token operator\">*</span> model <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>position<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    vs_out<span class=\"token punctuation\">.</span>FragPos   <span class=\"token operator\">=</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span>model <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>position<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   </pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    vs_out<span class=\"token punctuation\">.</span>TexCoords <span class=\"token operator\">=</span> texCoords<span class=\"token punctuation\">;</span>    </pre></td></tr><tr><td data-num=\"28\"></td><td><pre></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    vec3 T   <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span><span class=\"token function\">mat3</span><span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> tangent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    vec3 B   <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span><span class=\"token function\">mat3</span><span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> bitangent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    vec3 N   <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span><span class=\"token function\">mat3</span><span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> normal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    mat3 TBN <span class=\"token operator\">=</span> <span class=\"token function\">transpose</span><span class=\"token punctuation\">(</span><span class=\"token function\">mat3</span><span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">,</span> B<span class=\"token punctuation\">,</span> N<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>    vs_out<span class=\"token punctuation\">.</span>TangentLightPos <span class=\"token operator\">=</span> TBN <span class=\"token operator\">*</span> lightPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>    vs_out<span class=\"token punctuation\">.</span>TangentViewPos  <span class=\"token operator\">=</span> TBN <span class=\"token operator\">*</span> viewPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>    vs_out<span class=\"token punctuation\">.</span>TangentFragPos  <span class=\"token operator\">=</span> TBN <span class=\"token operator\">*</span> vs_out<span class=\"token punctuation\">.</span>FragPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在这里有件事很重要，我们需要把 position 和在切线空间中的观察者的位置 viewPos 发送给像素着色器。</p>\n<p>在像素着色器中，我们实现视差贴图的逻辑。像素着色器看起来会是这样的：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>out vec4 FragColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>in VS_OUT <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    vec3 FragPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    vec2 TexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    vec3 TangentLightPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    vec3 TangentViewPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    vec3 TangentFragPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span> fs_in<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>uniform sampler2D diffuseMap<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>uniform sampler2D normalMap<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>uniform sampler2D depthMap<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>uniform <span class=\"token keyword\">float</span> height_scale<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>vec2 <span class=\"token function\">ParallaxMapping</span><span class=\"token punctuation\">(</span>vec2 texCoords<span class=\"token punctuation\">,</span> vec3 viewDir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token punctuation\">&#123;</span>           </pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token comment\">// Offset texture coordinates with Parallax Mapping</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    vec3 viewDir   <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>fs_in<span class=\"token punctuation\">.</span>TangentViewPos <span class=\"token operator\">-</span> fs_in<span class=\"token punctuation\">.</span>TangentFragPos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    vec2 texCoords <span class=\"token operator\">=</span> <span class=\"token function\">ParallaxMapping</span><span class=\"token punctuation\">(</span>fs_in<span class=\"token punctuation\">.</span>TexCoords<span class=\"token punctuation\">,</span>  viewDir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token comment\">// then sample textures with new texture coords</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    vec3 diffuse <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>diffuseMap<span class=\"token punctuation\">,</span> texCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    vec3 normal  <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>normalMap<span class=\"token punctuation\">,</span> texCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    normal <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>normal <span class=\"token operator\">*</span> <span class=\"token number\">2.0</span> <span class=\"token operator\">-</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token comment\">// proceed with lighting code</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">]</span>    </pre></td></tr><tr><td data-num=\"32\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们定义了一个叫做 ParallaxMapping 的函数，它把 fragment 的纹理坐标作和切线空间中的 fragment 到观察者的方向向量为输入。这个函数返回经位移的纹理坐标。然后我们使用这些经位移的纹理坐标进行 diffuse 和法线贴图的采样。最后 fragment 的 diffuse 颜色和法线向量就正确的对应于表面的经位移的位置上了。</p>\n<p>我们来看看 ParallaxMapping 函数的内部：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vec2 <span class=\"token function\">ParallaxMapping</span><span class=\"token punctuation\">(</span>vec2 texCoords<span class=\"token punctuation\">,</span> vec3 viewDir<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span> </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">float</span> height <span class=\"token operator\">=</span>  <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>depthMap<span class=\"token punctuation\">,</span> texCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>r<span class=\"token punctuation\">;</span>    </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    vec2 p <span class=\"token operator\">=</span> viewDir<span class=\"token punctuation\">.</span>xy <span class=\"token operator\">/</span> viewDir<span class=\"token punctuation\">.</span>z <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>height <span class=\"token operator\">*</span> height_scale<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">return</span> texCoords <span class=\"token operator\">-</span> p<span class=\"token punctuation\">;</span>    </pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这个相对简单的函数是我们所讨论过的内容的直接表述。我们用本来的纹理坐标 texCoords 从高度贴图中来采样出当前 fragment 高度 H (A)。然后计算出 P¯，x 和 y 元素在切线空间中，viewDir 向量除以它的 z 元素，用 fragment 的高度对它进行缩放。我们同时引入额一个 height_scale 的 uniform，来进行一些额外的控制，因为视差效果如果没有一个缩放参数通常会过于强烈。然后我们用 P¯ 减去纹理坐标来获得最终的经过位移纹理坐标。</p>\n<p>有一个地方需要注意，就是 viewDir.xy 除以 viewDir.z 那里。因为 viewDir 向量是经过了标准化的，viewDir.z 会在 0.0 到 1.0 之间的某处。当 viewDir 大致平行于表面时，它的 z 元素接近于 0.0，除法会返回比 viewDir 垂直于表面的时候更大的 P¯ 向量。所以基本上我们增加了 P¯ 的大小，当以一个角度朝向一个表面相比朝向顶部时它对纹理坐标会进行更大程度的缩放；这回在角上获得更大的真实度。</p>\n<p>有些人更喜欢在等式中不使用 viewDir.z，因为普通的视差贴图会在角上产生不想要的结果；这个技术叫做有偏移量限制的视差贴图（Parallax Mapping with Offset Limiting）。选择哪一个技术是个人偏好问题，但我倾向于普通的视差贴图。</p>\n<p>最后的纹理坐标随后被用来进行采样（diffuse 和法线）贴图，下图所展示的位移效果中 height_scale 等于 1：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/05/parallax_mapping.png\" alt=\"image\" /></p>\n<p>这里你会看到只用法线贴图和与视差贴图相结合的法线贴图的不同之处。因为视差贴图尝试模拟深度，它实际上能够根据你观察它们的方向使砖块叠加到其他砖块上。</p>\n<p>在视差贴图的那个平面里你仍然能看到在边上有古怪的失真。原因是在平面的边缘上，纹理坐标超出了 0 到 1 的范围进行采样，根据纹理的环绕方式导致了不真实的结果。解决的方法是当它超出默认纹理坐标范围进行采样的时候就丢弃这个 fragment：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>texCoords <span class=\"token operator\">=</span> <span class=\"token function\">ParallaxMapping</span><span class=\"token punctuation\">(</span>fs_in<span class=\"token punctuation\">.</span>TexCoords<span class=\"token punctuation\">,</span>  viewDir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>texCoords<span class=\"token punctuation\">.</span>x <span class=\"token operator\">></span> <span class=\"token number\">1.0</span> <span class=\"token operator\">||</span> texCoords<span class=\"token punctuation\">.</span>y <span class=\"token operator\">></span> <span class=\"token number\">1.0</span> <span class=\"token operator\">||</span> texCoords<span class=\"token punctuation\">.</span>x <span class=\"token operator\">&lt;</span> <span class=\"token number\">0.0</span> <span class=\"token operator\">||</span> texCoords<span class=\"token punctuation\">.</span>y <span class=\"token operator\">&lt;</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    discard<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>丢弃了超出默认范围的纹理坐标的所有 fragment，视差贴图的表面边缘给出了正确的结果。注意，这个技巧不能在所有类型的表面上都能工作，但是应用于平面上它还是能够是平面看起来真的进行位移了：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/05/parallax_mapping_edge_fix.png\" alt=\"image\" /></p>\n<p>看起来不错，运行起来也很快，因为我们只要给视差贴图提供一个额外的纹理样本就能工作。当从一个角度看过去的时候，会有一些问题产生（和法线贴图相似），陡峭的地方会产生不正确的结果，从下图你可以看到：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/05/parallax_mapping_issues.png\" alt=\"image\" /></p>\n<p>问题的原因是这只是一个大致近似的视差映射。还有一些技巧让我们在陡峭的高度上能够获得几乎完美的结果，即使当以一定角度观看的时候。例如，我们不再使用单一样本，取而代之使用多样本来找到最近点 B 会得到怎样的结果？</p>\n<h3 id=\"陡峭视差映射\"><a class=\"anchor\" href=\"#陡峭视差映射\">#</a> 陡峭视差映射</h3>\n<p>陡峭视差映射 (Steep Parallax Mapping) 是视差映射的扩展，原则是一样的，但不是使用一个样本而是多个样本来确定向量 P¯ 到 B。它能得到更好的结果，它将总深度范围分布到同一个深度 / 高度的多个层中。从每个层中我们沿着 P¯ 方向移动采样纹理坐标，直到我们找到了一个采样得到的低于当前层的深度值的深度值。看看下面的图片：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/05/parallax_mapping_steep_parallax_mapping_diagram.png\" alt=\"image\" /></p>\n<p>我们从上到下遍历深度层，我们把每个深度层和储存在深度贴图中的它的深度值进行对比。如果这个层的深度值小于深度贴图的值，就意味着这一层的 P¯ 向量部分在表面之下。我们继续这个处理过程直到有一层的深度高于储存在深度贴图中的值：这个点就在（经过位移的）表面下方。</p>\n<p>这个例子中我们可以看到第二层 (D (2) = 0.73) 的深度贴图的值仍低于第二层的深度值 0.4，所以我们继续。下一次迭代，这一层的深度值 0.6 大于深度贴图中采样的深度值 (D (3) = 0.37)。我们便可以假设第三层向量 P¯ 是可用的位移几何位置。我们可以用从向量 P3¯ 的纹理坐标偏移 T3 来对 fragment 的纹理坐标进行位移。你可以看到随着深度曾的增加精确度也在提高。</p>\n<p>为实现这个技术，我们只需要改变 ParallaxMapping 函数，因为所有需要的变量都有了：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vec2 <span class=\"token function\">ParallaxMapping</span><span class=\"token punctuation\">(</span>vec2 texCoords<span class=\"token punctuation\">,</span> vec3 viewDir<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span> </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\">// number of depth layers</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">const</span> <span class=\"token keyword\">float</span> numLayers <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token comment\">// calculate the size of each layer</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">float</span> layerDepth <span class=\"token operator\">=</span> <span class=\"token number\">1.0</span> <span class=\"token operator\">/</span> numLayers<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token comment\">// depth of current layer</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">float</span> currentLayerDepth <span class=\"token operator\">=</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token comment\">// the amount to shift the texture coordinates per layer (from vector P)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    vec2 P <span class=\"token operator\">=</span> viewDir<span class=\"token punctuation\">.</span>xy <span class=\"token operator\">*</span> height_scale<span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">float</span> deltaTexCoords <span class=\"token operator\">=</span> P <span class=\"token operator\">/</span> numLayers<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">]</span>     </pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们先定义层的数量，计算每一层的深度，最后计算纹理坐标偏移，每一层我们必须沿着 P¯ 的方向进行移动。</p>\n<p>然后我们遍历所有层，从上开始，知道找到小于这一层的深度值的深度贴图值：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// get initial values</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>vec2  currentTexCoords     <span class=\"token operator\">=</span> texCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">float</span> currentDepthMapValue <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>depthMap<span class=\"token punctuation\">,</span> currentTexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>r<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>currentLayerDepth <span class=\"token operator\">&lt;</span> currentDepthMapValue<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token comment\">// shift texture coordinates along direction of P</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    currentTexCoords <span class=\"token operator\">-=</span> deltaTexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token comment\">// get depthmap value at current texture coordinates</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    currentDepthMapValue <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>depthMap<span class=\"token punctuation\">,</span> currentTexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>r<span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token comment\">// get depth of next layer</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    currentLayerDepth <span class=\"token operator\">+=</span> layerDepth<span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token keyword\">return</span> texCoords <span class=\"token operator\">-</span> currentTexCoords<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这里我们循环每一层深度，直到沿着 P¯ 向量找到第一个返回低于（位移）表面的深度的纹理坐标偏移量。从 fragment 的纹理坐标减去最后的偏移量，来得到最终的经过位移的纹理坐标向量，这次就比传统的视差映射更精确了。</p>\n<p>有 10 个样本砖墙从一个角度看上去就已经很好了，但是当有一个强前面展示的木制表面一样陡峭的表面时，陡峭的视差映射的威力就显示出来了：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/05/parallax_mapping_steep_parallax_mapping.png\" alt=\"image\" /></p>\n<p>我们可以通过对视差贴图的一个属性的利用，对算法进行一点提升。当垂直看一个表面的时候纹理时位移比以一定角度看时的小。我们可以在垂直看时使用更少的样本，以一定角度看时增加样本数量：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">const</span> <span class=\"token keyword\">float</span> minLayers <span class=\"token operator\">=</span> <span class=\"token number\">8</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">const</span> <span class=\"token keyword\">float</span> maxLayers <span class=\"token operator\">=</span> <span class=\"token number\">32</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">float</span> numLayers <span class=\"token operator\">=</span> <span class=\"token function\">mix</span><span class=\"token punctuation\">(</span>maxLayers<span class=\"token punctuation\">,</span> minLayers<span class=\"token punctuation\">,</span> <span class=\"token function\">abs</span><span class=\"token punctuation\">(</span><span class=\"token function\">dot</span><span class=\"token punctuation\">(</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> viewDir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这里我们得到 viewDir 和正 z 方向的点乘，使用它的结果根据我们看向表面的角度调整样本数量（注意正 z 方向等于切线空间中的表面的法线）。如果我们所看的方向平行于表面，我们就是用 32 层。</p>\n<p>你可以在这里找到最新的像素着色器代码。这里也提供木制玩具箱的表面贴图：diffuse、法线、深度。</p>\n<p>陡峭视差贴图同样有自己的问题。因为这个技术是基于有限的样本数量的，我们会遇到锯齿效果以及图层之间有明显的断层：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/05/parallax_mapping_steep_artifact.png\" alt=\"image\" /></p>\n<p>我们可以通过增加样本的方式减少这个问题，但是很快就会花费很多性能。有些旨在修复这个问题的方法：不适用低于表面的第一个位置，而是在两个接近的深度层进行插值找出更匹配 B 的。</p>\n<p>两种最流行的解决方法叫做 Relief Parallax Mapping 和 Parallax Occlusion Mapping，Relief Parallax Mapping 更精确一些，但是比 Parallax Occlusion Mapping 性能开销更多。因为 Parallax Occlusion Mapping 的效果和前者差不多但是效率更高，因此这种方式更经常使用，所以我们将在下面讨论一下。</p>\n<h3 id=\"视差遮蔽映射\"><a class=\"anchor\" href=\"#视差遮蔽映射\">#</a> 视差遮蔽映射</h3>\n<p>视差遮蔽映射 (Parallax Occlusion Mapping) 和陡峭视差映射的原则相同，但不是用触碰的第一个深度层的纹理坐标，而是在触碰之前和之后，在深度层之间进行线性插值。我们根据表面的高度距离啷个深度层的深度层值的距离来确定线性插值的大小。看看下面的图片就能了解它是如何工作的：</p>\n<p>你可以看到大部分和陡峭视差映射一样，不一样的地方是有个额外的步骤，两个深度层的纹理坐标围绕着交叉点的线性插值。这也是近似的，但是比陡峭视差映射更精确。</p>\n<p>视差遮蔽映射的代码基于陡峭视差映射，所以并不难：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">// steep parallax mapping code here</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// get texture coordinates before collision (reverse operations)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>vec2 prevTexCoords <span class=\"token operator\">=</span> currentTexCoords <span class=\"token operator\">+</span> deltaTexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">// get depth after and before collision for linear interpolation</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">float</span> afterDepth  <span class=\"token operator\">=</span> currentDepthMapValue <span class=\"token operator\">-</span> currentLayerDepth<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">float</span> beforeDepth <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>depthMap<span class=\"token punctuation\">,</span> prevTexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>r <span class=\"token operator\">-</span> currentLayerDepth <span class=\"token operator\">+</span> layerDepth<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">// interpolation of texture coordinates</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">float</span> weight <span class=\"token operator\">=</span> afterDepth <span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span>afterDepth <span class=\"token operator\">-</span> beforeDepth<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>vec2 finalTexCoords <span class=\"token operator\">=</span> prevTexCoords <span class=\"token operator\">*</span> weight <span class=\"token operator\">+</span> currentTexCoords <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span> <span class=\"token operator\">-</span> weight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">return</span> finalTexCoords<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在对（位移的）表面几何进行交叉，找到深度层之后，我们获取交叉前的纹理坐标。然后我们计算来自相应深度层的几何之间的深度之间的距离，并在两个值之间进行插值。线性插值的方式是在两个层的纹理坐标之间进行的基础插值。函数最后返回最终的经过插值的纹理坐标。</p>\n<p>视差遮蔽映射的效果非常好，尽管有一些可以看到的轻微的不真实和锯齿的问题，这仍是一个好交易，因为除非是放得非常大或者观察角度特别陡，否则也看不到。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/05/parallax_mapping_parallax_occlusion_mapping.png\" alt=\"image\" /></p>\n<p>视差贴图是提升场景细节非常好的技术，但是使用的时候还是要考虑到它会带来一点不自然。大多数时候视差贴图用在地面和墙壁表面，这种情况下查明表面的轮廓并不容易，同时观察角度往往趋向于垂直于表面。这样视差贴图的不自然也就很难能被注意到了，对于提升物体的细节可以祈祷难以置信的效果。</p>\n<h3 id=\"附加资源-5\"><a class=\"anchor\" href=\"#附加资源-5\">#</a> 附加资源</h3>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3N1bmFuZGJsYWNrY2F0LmNvbS90aXBGdWxsVmlldy5waHA/dG9waWNpZD0yOA==\">Parallax Occlusion Mapping in GLSL</span>：sunandblackcat.com 上的视差贴图教程。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj14dk9UNjJMLWZRSQ==\">How Parallax Displacement Mapping Works</span>：TheBennyBox 的关于视差贴图原理的视频教程。</li>\n</ul>\n<h2 id=\"hdr\"><a class=\"anchor\" href=\"#hdr\">#</a> HDR</h2>\n<p>一般来说，当存储在帧缓冲 (Framebuffer) 中时，亮度和颜色的值是默认被限制在 0.0 到 1.0 之间的。这个看起来无辜的语句使我们一直将亮度与颜色的值设置在这个范围内，尝试着与场景契合。这样是能够运行的，也能给出还不错的效果。但是如果我们遇上了一个特定的区域，其中有多个亮光源使这些数值总和超过了 1.0，又会发生什么呢？答案是这些片段中超过 1.0 的亮度或者颜色值会被约束在 1.0，从而导致场景混成一片，难以分辨：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/06/hdr_clamped.png\" alt=\"image\" /></p>\n<p>这是由于大量片段的颜色值都非常接近 1.0，在很大一个区域内每一个亮的片段都有相同的白色。这损失了很多的细节，使场景看起来非常假。</p>\n<p>解决这个问题的一个方案是减小光源的强度从而保证场景内没有一个片段亮于 1.0。然而这并不是一个好的方案，因为你需要使用不切实际的光照参数。一个更好的方案是让颜色暂时超过 1.0，然后将其转换至 0.0 到 1.0 的区间内，从而防止损失细节。</p>\n<p>显示器被限制为只能显示值为 0.0 到 1.0 间的颜色，但是在光照方程中却没有这个限制。通过使片段的颜色超过 1.0，我们有了一个更大的颜色范围，这也被称作 HDR (High Dynamic Range, 高动态范围)。有了 HDR，亮的东西可以变得非常亮，暗的东西可以变得非常暗，而且充满细节。</p>\n<p>HDR 原本只是被运用在摄影上，摄影师对同一个场景采取不同曝光拍多张照片，捕捉大范围的色彩值。这些图片被合成为 HDR 图片，从而综合不同的曝光等级使得大范围的细节可见。看下面这个例子，左边这张图片在被光照亮的区域充满细节，但是在黑暗的区域就什么都看不见了；但是右边这张图的高曝光却可以让之前看不出来的黑暗区域显现出来。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/06/hdr_image.png\" alt=\"image\" /></p>\n<p>这与我们眼睛工作的原理非常相似，也是 HDR 渲染的基础。当光线很弱的啥时候，人眼会自动调整从而使过暗和过亮的部分变得更清晰，就像人眼有一个能自动根据场景亮度调整的自动曝光滑块。</p>\n<p>HDR 渲染和其很相似，我们允许用更大范围的颜色值渲染从而获取大范围的黑暗与明亮的场景细节，最后将所有 HDR 值转换成在 [0.0, 1.0] 范围的 LDR (Low Dynamic Range, 低动态范围)。转换 HDR 值到 LDR 值得过程叫做色调映射 (Tone Mapping)，现在现存有很多的色调映射算法，这些算法致力于在转换过程中保留尽可能多的 HDR 细节。这些色调映射算法经常会包含一个选择性倾向黑暗或者明亮区域的参数。</p>\n<p>在实时渲染中，HDR 不仅允许我们超过 LDR 的范围 [0.0, 1.0] 与保留更多的细节，同时还让我们能够根据光源的真实强度指定它的强度。比如太阳有比闪光灯之类的东西更高的强度，那么我们为什么不这样子设置呢？(比如说设置一个 10.0 的漫亮度) 这允许我们用更现实的光照参数恰当地配置一个场景的光照，而这在 LDR 渲染中是不能实现的，因为他们会被上限约束在 1.0。</p>\n<p>因为显示器只能显示在 0.0 到 1.0 范围之内的颜色，我们肯定要做一些转换从而使得当前的 HDR 颜色值符合显示器的范围。简单地取平均值重新转换这些颜色值并不能很好的解决这个问题，因为明亮的地方会显得更加显著。我们能做的是用一个不同的方程与 / 或曲线来转换这些 HDR 值到 LDR 值，从而给我们对于场景的亮度完全掌控，这就是之前说的色调变换，也是 HDR 渲染的最终步骤。</p>\n<h3 id=\"浮点帧缓冲\"><a class=\"anchor\" href=\"#浮点帧缓冲\">#</a> 浮点帧缓冲</h3>\n<p>在实现 HDR 渲染之前，我们首先需要一些防止颜色值在每一个片段着色器运行后被限制约束的方法。当帧缓冲使用了一个标准化的定点格式 (像 GL_RGB) 为其颜色缓冲的内部格式，OpenGL 会在将这些值存入帧缓冲前自动将其约束到 0.0 到 1.0 之间。这一操作对大部分帧缓冲格式都是成立的，除了专门用来存放被拓展范围值的浮点格式。</p>\n<p>当一个帧缓冲的颜色缓冲的内部格式被设定成了 GL_RGB16F, GL_RGBA16F, GL_RGB32F 或者 GL_RGBA32F 时，这些帧缓冲被叫做浮点帧缓冲 (Floating Point Framebuffer)，浮点帧缓冲可以存储超过 0.0 到 1.0 范围的浮点值，所以非常适合 HDR 渲染。</p>\n<p>想要创建一个浮点帧缓冲，我们只需要改变颜色缓冲的内部格式参数就行了（注意 GL_FLOAT 参数)：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> colorBuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glTexImage2D</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> GL_RGB16F<span class=\"token punctuation\">,</span> SCR_WIDTH<span class=\"token punctuation\">,</span> SCR_HEIGHT<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> GL_RGB<span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>默认的帧缓冲默认一个颜色分量只占用 8 位 (bits)。当使用一个使用 32 位每颜色分量的浮点帧缓冲时 (使用 GL_RGB32F 或者 GL_RGBA32F)，我们需要四倍的内存来存储这些颜色。所以除非你需要一个非常高的精确度，32 位不是必须的，使用 GLRGB16F 就足够了。</p>\n<p>有了一个带有浮点颜色缓冲的帧缓冲，我们可以放心渲染场景到这个帧缓冲中。在这个教程的例子当中，我们先渲染一个光照的场景到浮点帧缓冲中，之后再在一个铺屏四边形 (Screen-filling Quad) 上应用这个帧缓冲的颜色缓冲，代码会是这样子：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glBindFramebuffer</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> hdrFBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token function\">glClear</span><span class=\"token punctuation\">(</span>GL_COLOR_BUFFER_BIT <span class=\"token operator\">|</span> GL_DEPTH_BUFFER_BIT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\">// [...] 渲染 (光照的) 场景</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glBindFramebuffer</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">// 现在使用一个不同的着色器将 HDR 颜色缓冲渲染至 2D 铺屏四边形上</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>hdrShader<span class=\"token punctuation\">.</span><span class=\"token function\">Use</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">glActiveTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> hdrColorBufferTexture<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token function\">RenderQuad</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这里场景的颜色值存在一个可以包含任意颜色值的浮点颜色缓冲中，值可能是超过 1.0 的。这个简单的演示中，场景被创建为一个被拉伸的立方体通道和四个点光源，其中一个非常亮的在隧道的尽头：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>std<span class=\"token operator\">::</span>vector<span class=\"token operator\">&lt;</span>glm<span class=\"token operator\">::</span>vec3<span class=\"token operator\">></span> lightColors<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>lightColors<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">200.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">200.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">200.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>lightColors<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.1f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>lightColors<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.2f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>lightColors<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.1f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>渲染至浮点帧缓冲和渲染至一个普通的帧缓冲是一样的。新的东西就是这个的 hdrShader 的片段着色器，用来渲染最终拥有浮点颜色缓冲纹理的 2D 四边形。我们来定义一个简单的直通片段着色器 (Pass-through Fragment Shader)：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>out vec4 color<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>in vec2 TexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>uniform sampler2D hdrBuffer<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#123;</span>             </pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    vec3 hdrColor <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>hdrBuffer<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>rgb<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    color <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>hdrColor<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这里我们直接采样了浮点颜色缓冲并将其作为片段着色器的输出。然而，这个 2D 四边形的输出是被直接渲染到默认的帧缓冲中，导致所有片段着色器的输出值被约束在 0.0 到 1.0 间，尽管我们已经有了一些存在浮点颜色纹理的值超过了 1.0。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/06/hdr_direct.png\" alt=\"image\" /></p>\n<p>很明显，在隧道尽头的强光的值被约束在 1.0，因为一大块区域都是白色的，过程中超过 1.0 的地方损失了所有细节。因为我们直接转换 HDR 值到 LDR 值，这就像我们根本就没有应用 HDR 一样。为了修复这个问题我们需要做的是无损转化所有浮点颜色值回 0.0-1.0 范围中。我们需要应用到色调映射。</p>\n<h3 id=\"色调映射\"><a class=\"anchor\" href=\"#色调映射\">#</a> 色调映射</h3>\n<p>色调映射 (Tone Mapping) 是一个损失很小的转换浮点颜色值至我们所需的 LDR [0.0, 1.0] 范围内的过程，通常会伴有特定的风格的色平衡 (Stylistic Color Balance)。</p>\n<p>最简单的色调映射算法是 Reinhard 色调映射，它涉及到分散整个 HDR 颜色值到 LDR 颜色值上，所有的值都有对应。Reinhard 色调映射算法平均得将所有亮度值分散到 LDR 上。我们将 Reinhard 色调映射应用到之前的片段着色器上，并且为了更好的测量加上一个 Gamma 校正过滤 (包括 SRGB 纹理的使用)：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span>             </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">const</span> <span class=\"token keyword\">float</span> gamma <span class=\"token operator\">=</span> <span class=\"token number\">2.2</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    vec3 hdrColor <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>hdrBuffer<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>rgb<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">// Reinhard 色调映射</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    vec3 mapped <span class=\"token operator\">=</span> hdrColor <span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span>hdrColor <span class=\"token operator\">+</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\">// Gamma 校正</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    mapped <span class=\"token operator\">=</span> <span class=\"token function\">pow</span><span class=\"token punctuation\">(</span>mapped<span class=\"token punctuation\">,</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span> <span class=\"token operator\">/</span> gamma<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    color <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>mapped<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>有了 Reinhard 色调映射的应用，我们不再会在场景明亮的地方损失细节。当然，这个算法是倾向明亮的区域的，暗的区域会不那么精细也不那么有区分度。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/06/hdr_reinhard.png\" alt=\"image\" /></p>\n<p>现在你可以看到在隧道的尽头木头纹理变得可见了。用了这个非常简单地色调映射算法，我们可以合适的看到存在浮点帧缓冲中整个范围的 HDR 值，给我们对于无损场景光照精确的控制。</p>\n<p>另一个有趣的色调映射应用是曝光 (Exposure) 参数的使用。你可能还记得之前我们在介绍里讲到的，HDR 图片包含在不同曝光等级的细节。如果我们有一个场景要展现日夜交替，我们当然会在白天使用低曝光，在夜间使用高曝光，就像人眼调节方式一样。有了这个曝光参数，我们可以去设置可以同时在白天和夜晚不同光照条件工作的光照参数，我们只需要调整曝光参数就行了。</p>\n<p>一个简单的曝光色调映射算法会像这样：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>uniform <span class=\"token keyword\">float</span> exposure<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#123;</span>             </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">const</span> <span class=\"token keyword\">float</span> gamma <span class=\"token operator\">=</span> <span class=\"token number\">2.2</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    vec3 hdrColor <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>hdrBuffer<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>rgb<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token comment\">// 曝光色调映射</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    vec3 mapped <span class=\"token operator\">=</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token function\">exp</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>hdrColor <span class=\"token operator\">*</span> exposure<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\">// Gamma 校正 </span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    mapped <span class=\"token operator\">=</span> <span class=\"token function\">pow</span><span class=\"token punctuation\">(</span>mapped<span class=\"token punctuation\">,</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span> <span class=\"token operator\">/</span> gamma<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    color <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>mapped<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在这里我们将 exposure 定义为默认为 1.0 的 uniform，从而允许我们更加精确设定我们是要注重黑暗还是明亮的区域的 HDR 颜色值。举例来说，高曝光值会使隧道的黑暗部分显示更多的细节，然而低曝光值会显著减少黑暗区域的细节，但允许我们看到更多明亮区域的细节。下面这组图片展示了在不同曝光值下的通道：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/06/hdr_exposure.png\" alt=\"image\" /></p>\n<p>这个图片清晰地展示了 HDR 渲染的优点。通过改变曝光等级，我们可以看见场景的很多细节，而这些细节可能在 LDR 渲染中都被丢失了。比如说隧道尽头，在正常曝光下木头结构隐约可见，但用低曝光木头的花纹就可以清晰看见了。对于近处的木头花纹来说，在高曝光下会能更好的看见。</p>\n<h3 id=\"hdr拓展\"><a class=\"anchor\" href=\"#hdr拓展\">#</a> HDR 拓展</h3>\n<p>在这里展示的两个色调映射算法仅仅是大量 (更先进) 的色调映射算法中的一小部分，这些算法各有长短。一些色调映射算法倾向于特定的某种颜色 / 强度，也有一些算法同时显示低于高曝光颜色从而能够显示更加多彩和精细的图像。也有一些技巧被称作自动曝光调整 (Automatic Exposure Adjustment) 或者叫人眼适应 (Eye Adaptation) 技术，它能够检测前一帧场景的亮度并且缓慢调整曝光参数模仿人眼使得场景在黑暗区域逐渐变亮或者在明亮区域逐渐变暗，</p>\n<p>HDR 渲染的真正优点在庞大和复杂的场景中应用复杂光照算法会被显示出来，但是出于教学目的创建这样复杂的演示场景是很困难的，这个教程用的场景是很小的，而且缺乏细节。但是如此简单的演示也是能够显示出 HDR 渲染的一些优点：在明亮和黑暗区域无细节损失，因为它们可以由色调映射重新获取；多个光照的叠加不会导致亮度被约束的区域；光照可以被设定为他们原来的亮度而不是被 LDR 值限定。而且，HDR 渲染也使一些有趣的效果更加可行和真实；其中一个效果叫做泛光 (Bloom)，我们将在下一节讨论他。</p>\n<h3 id=\"附加资源-6\"><a class=\"anchor\" href=\"#附加资源-6\">#</a> 附加资源</h3>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2dhbWVkZXYuc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzYyODM2L2RvZXMtaGRyLXJlbmRlcmluZy1oYXZlLWFueS1iZW5lZml0cy1pZi1ibG9vbS13b250LWJlLWFwcGxpZWQ=\">如果泛光效果不被应用 HDR 渲染还有好处吗？</span>: 一个 StackExchange 问题，其中有一个答案非常详细地解释 HDR 渲染的好处。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3Bob3RvLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy83NjMwL3doYXQtaXMtdG9uZS1tYXBwaW5nLWhvdy1kb2VzLWl0LXJlbGF0ZS10by1oZHI=\">什么是色调映射？它与 HDR 有什么联系？</span>: 另一个非常有趣的答案，用了大量图片解释色调映射。</li>\n</ul>\n<h2 id=\"泛光\"><a class=\"anchor\" href=\"#泛光\">#</a> 泛光</h2>\n<p>明亮的光源和区域经常很难向观察者表达出来，因为监视器的亮度范围是有限的。一种区分明亮光源的方式是使它们在监视器上发出光芒，光源的的光芒向四周发散。这样观察者就会产生光源或亮区的确是强光区。（译注：这个问题的提出简单来说是为了解决这样的问题：例如有一张在阳光下的白纸，白纸在监视器上显示出是出白色，而前方的太阳也是纯白色的，所以基本上白纸和太阳就是一样的了，给太阳加一个光晕，这样太阳看起来似乎就比白纸更亮了）</p>\n<p><mark>光晕效果</mark>可以使用一个后处理特效泛光来实现。泛光使所有明亮区域产生光晕效果。下面是一个使用了和没有使用光晕的对比（图片生成自虚幻引擎）：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/07/bloom_example.png\" alt=\"image\" /></p>\n<p>Bloom 是我们能够注意到一个明亮的物体真的有种明亮的感觉。泛光可以极大提升场景中的光照效果，并提供了极大的效果提升，尽管做到这一切只需一点改变。</p>\n<p>Bloom 和 HDR 结合使用效果很好。常见的一个误解是 HDR 和泛光是一样的，很多人认为两种技术是可以互换的。但是它们是两种不同的技术，用于各自不同的目的上。可以使用默认的 8 位精确度的帧缓冲，也可以在不使用泛光效果的时候，使用 HDR。只不过在有了 HDR 之后再实现泛光就更简单了。</p>\n<p>为实现泛光，我们像平时那样渲染一个有光场景，提取出场景的 HDR 颜色缓冲以及只有这个场景明亮区域可见的图片。被提取的带有亮度的图片接着被模糊，结果被添加到 HDR 场景上面。</p>\n<p>我们来一步一步解释这个处理过程。我们在场景中渲染一个带有 4 个立方体形式不同颜色的明亮的光源。带有颜色的发光立方体的亮度在 1.5 到 15.0 之间。如果我们将其渲染至 HDR 颜色缓冲，场景看起来会是这样的：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/07/bloom_scene.png\" alt=\"image\" /></p>\n<p>我们得到这个 HDR 颜色缓冲纹理，提取所有超出一定亮度的 fragment。这样我们就会获得一个只有 fragment 超过了一定阈限的颜色区域：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/07/bloom_extracted.png\" alt=\"image\" /></p>\n<p>我们将这个超过一定亮度阈限的纹理进行模糊。泛光效果的强度很大程度上被模糊过滤器的范围和强度所决定。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/07/bloom_blurred.png\" alt=\"image\" /></p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/07/bloom_blurred.png\" alt=\"image\" /></p>\n<p>最终的被模糊化的纹理就是我们用来获得发出光晕效果的东西。这个已模糊的纹理要添加到原来的 HDR 场景纹理的上部。因为模糊过滤器的应用明亮区域发出光晕，所以明亮区域在长和宽上都有所扩展。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/07/bloom_small.png\" alt=\"image\" /></p>\n<p>泛光本身并不是个复杂的技术，但很难获得正确的效果。它的品质很大程度上取决于所用的模糊过滤器的质量和类型。简单的改改模糊过滤器就会极大的改变泛光效果的品质。</p>\n<p>下面这几步就是泛光后处理特效的过程，它总结了实现泛光所需的步骤。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/07/bloom_steps.png\" alt=\"image\" /></p>\n<p>首先我们需要根据一定的阈限提取所有明亮的颜色。我们先来做这件事。</p>\n<h3 id=\"提取亮色\"><a class=\"anchor\" href=\"#提取亮色\">#</a> 提取亮色</h3>\n<p>第一步我们要从渲染出来的场景中提取两张图片。我们可以渲染场景两次，每次使用一个不同的不同的着色器渲染到不同的帧缓冲中，但我们可以使用一个叫做<mark> MRT</mark>（Multiple Render Targets 多渲染目标）的小技巧，这样我们就能定义多个像素着色器了；有了它我们还能够在一个单独渲染处理中提取头两个图片。在像素着色器的输出前，我们指定一个布局 location 标识符，这样我们便可控制一个像素着色器写入到哪个颜色缓冲：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> out vec4 FragColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> out vec4 BrightColor<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>只有我们真的具有多个地方可写的时候这才能工作。使用多个像素着色器输出的必要条件是，有多个颜色缓冲附加到了当前绑定的帧缓冲对象上。你可能从帧缓冲教程那里回忆起，当把一个纹理链接到帧缓冲的颜色缓冲上时，我们可以指定一个颜色附件。直到现在，我们一直使用着 GL_COLOR_ATTACHMENT0，但通过使用 GL_COLOR_ATTACHMENT1，我们可以得到一个附加了两个颜色缓冲的帧缓冲对象：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// Set up floating point framebuffer to render scene to</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>GLuint hdrFBO<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glGenFramebuffers</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>hdrFBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glBindFramebuffer</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> hdrFBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>GLuint colorBuffers<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">glGenTextures</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> colorBuffers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>GLuint i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> colorBuffers<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token function\">glTexImage2D</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        GL_TEXTURE_2D<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> GL_RGB16F<span class=\"token punctuation\">,</span> SCR_WIDTH<span class=\"token punctuation\">,</span> SCR_HEIGHT<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> GL_RGB<span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_MIN_FILTER<span class=\"token punctuation\">,</span> GL_LINEAR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_MAG_FILTER<span class=\"token punctuation\">,</span> GL_LINEAR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_WRAP_S<span class=\"token punctuation\">,</span> GL_CLAMP_TO_EDGE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_WRAP_T<span class=\"token punctuation\">,</span> GL_CLAMP_TO_EDGE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token comment\">// attach texture to framebuffer</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token function\">glFramebufferTexture2D</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> GL_COLOR_ATTACHMENT0 <span class=\"token operator\">+</span> i<span class=\"token punctuation\">,</span> GL_TEXTURE_2D<span class=\"token punctuation\">,</span> colorBuffers<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们需要显式告知 OpenGL 我们正在通过 glDrawBuffers 渲染到多个颜色缓冲，否则 OpenGL 只会渲染到帧缓冲的第一个颜色附件，而忽略所有其他的。我们可以通过传递多个颜色附件的枚举来做这件事，我们以下面的操作进行渲染：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>GLuint attachments<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span> GL_COLOR_ATTACHMENT0<span class=\"token punctuation\">,</span> GL_COLOR_ATTACHMENT1 <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glDrawBuffers</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> attachments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>当渲染到这个帧缓冲中的时候，一个着色器使用一个布局 location 修饰符，那么 fragment 就会用相应的颜色缓冲就会被用来渲染。这很棒，因为这样省去了我们为提取明亮区域的额外渲染步骤，因为我们现在可以直接从将被渲染的 fragment 提取出它们：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> out vec4 FragColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> out vec4 BrightColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#123;</span>            </pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">// first do normal lighting calculations and output results</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>lighting<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token comment\">// Check whether fragment output is higher than threshold, if so output as brightness color</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">float</span> brightness <span class=\"token operator\">=</span> <span class=\"token function\">dot</span><span class=\"token punctuation\">(</span>FragColor<span class=\"token punctuation\">.</span>rgb<span class=\"token punctuation\">,</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.2126</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.7152</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0722</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>brightness <span class=\"token operator\">></span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        BrightColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>FragColor<span class=\"token punctuation\">.</span>rgb<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这里我们先正常计算光照，将其传递给第一个像素着色器的输出变量 FragColor。然后我们使用当前储存在 FragColor 的东西来决定它的亮度是否超过了一定阈限。我们通过恰当地将其转为灰度的方式计算一个 fragment 的亮度，如果它超过了一定阈限，我们就把颜色输出到第二个颜色缓冲，那里保存着所有亮部；渲染发光的立方体也是一样的。</p>\n<p>这也说明了为什么泛光在 HDR 基础上能够运行得很好。因为 HDR 中，我们可以将颜色值指定超过 1.0 这个默认的范围，我们能够得到对一个图像中的亮度的更好的控制权。没有 HDR 我们必须将阈限设置为小于 1.0 的数，虽然可行，但是亮部很容易变得很多，这就导致光晕效果过重。</p>\n<p>有了两个颜色缓冲，我们就有了一个正常场景的图像和一个提取出的亮区的图像；这些都在一个渲染步骤中完成。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/07/bloom_attachments.png\" alt=\"image\" /></p>\n<p>有了一个提取出的亮区图像，我们现在就要把这个图像进行模糊处理。我们可以使用帧缓冲教程后处理部分的那个简单的盒子过滤器，但不过我们最好还是使用一个更高级的更漂亮的模糊过滤器：<mark>高斯模糊</mark> (Gaussian blur)。</p>\n<h3 id=\"高斯模糊\"><a class=\"anchor\" href=\"#高斯模糊\">#</a> 高斯模糊</h3>\n<p>在后处理教程那里，我们采用的模糊是一个图像中所有周围像素的均值，它的确为我们提供了一个简易实现的模糊，但是效果并不好。高斯模糊基于高斯曲线，高斯曲线通常被描述为一个钟形曲线，中间的值达到最大化，随着距离的增加，两边的值不断减少。高斯曲线在数学上有不同的形式，但是通常是这样的形状：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/07/bloom_gaussian.png\" alt=\"image\" /></p>\n<p>高斯曲线在它的中间处的面积最大，使用它的值作为权重使得近处的样本拥有最大的优先权。比如，如果我们从 fragment 的 32×32 的四方形区域采样，这个权重随着和 fragment 的距离变大逐渐减小；通常这会得到更好更真实的模糊效果，这种模糊叫做高斯模糊。</p>\n<p>要实现高斯模糊过滤我们需要一个二维四方形作为权重，从这个二维高斯曲线方程中去获取它。然而这个过程有个问题，就是很快会消耗极大的性能。以一个 32×32 的模糊 kernel 为例，我们必须对每个 fragment 从一个纹理中采样 1024 次！</p>\n<p>幸运的是，高斯方程有个非常巧妙的特性，它允许我们把二维方程分解为两个更小的方程：一个描述水平权重，另一个描述垂直权重。我们首先用水平权重在整个纹理上进行水平模糊，然后在经改变的纹理上进行垂直模糊。利用这个特性，结果是一样的，但是可以节省难以置信的性能，因为我们现在只需做 32+32 次采样，不再是 1024 了！这叫做两步高斯模糊。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/07/bloom_gaussian_two_pass.png\" alt=\"image\" /></p>\n<p>这意味着我们如果对一个图像进行模糊处理，至少需要两步，最好使用帧缓冲对象做这件事。具体来说，我们将实现像乒乓球一样的帧缓冲来实现高斯模糊。它的意思是，有一对儿帧缓冲，我们把另一个帧缓冲的颜色缓冲放进当前的帧缓冲的颜色缓冲中，使用不同的着色效果渲染指定的次数。基本上就是不断地切换帧缓冲和纹理去绘制。这样我们先在场景纹理的第一个缓冲中进行模糊，然后在把第一个帧缓冲的颜色缓冲放进第二个帧缓冲进行模糊，接着，将第二个帧缓冲的颜色缓冲放进第一个，循环往复。</p>\n<p>在我们研究帧缓冲之前，先讨论高斯模糊的像素着色器：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>out vec4 FragColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>in vec2 TexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>uniform sampler2D image<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>uniform <span class=\"token keyword\">bool</span> horizontal<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>uniform <span class=\"token keyword\">float</span> weight<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">float</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0.227027</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.1945946</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.1216216</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.054054</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.016216</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#123;</span>             </pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    vec2 tex_offset <span class=\"token operator\">=</span> <span class=\"token number\">1.0</span> <span class=\"token operator\">/</span> <span class=\"token function\">textureSize</span><span class=\"token punctuation\">(</span>image<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// gets size of single texel</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    vec3 result <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>image<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>rgb <span class=\"token operator\">*</span> weight<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// current fragment's contribution</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>horizontal<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>            result <span class=\"token operator\">+=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>image<span class=\"token punctuation\">,</span> TexCoords <span class=\"token operator\">+</span> <span class=\"token function\">vec2</span><span class=\"token punctuation\">(</span>tex_offset<span class=\"token punctuation\">.</span>x <span class=\"token operator\">*</span> i<span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>rgb <span class=\"token operator\">*</span> weight<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>            result <span class=\"token operator\">+=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>image<span class=\"token punctuation\">,</span> TexCoords <span class=\"token operator\">-</span> <span class=\"token function\">vec2</span><span class=\"token punctuation\">(</span>tex_offset<span class=\"token punctuation\">.</span>x <span class=\"token operator\">*</span> i<span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>rgb <span class=\"token operator\">*</span> weight<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token keyword\">else</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>            result <span class=\"token operator\">+=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>image<span class=\"token punctuation\">,</span> TexCoords <span class=\"token operator\">+</span> <span class=\"token function\">vec2</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> tex_offset<span class=\"token punctuation\">.</span>y <span class=\"token operator\">*</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>rgb <span class=\"token operator\">*</span> weight<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>            result <span class=\"token operator\">+=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>image<span class=\"token punctuation\">,</span> TexCoords <span class=\"token operator\">-</span> <span class=\"token function\">vec2</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> tex_offset<span class=\"token punctuation\">.</span>y <span class=\"token operator\">*</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>rgb <span class=\"token operator\">*</span> weight<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这里我们使用一个比较小的高斯权重做例子，每次我们用它来指定当前 fragment 的水平或垂直样本的特定权重。你会发现我们基本上是将模糊过滤器根据我们在 uniform 变量 horizontal 设置的值分割为一个水平和一个垂直部分。通过用 1.0 除以纹理的大小（从 textureSize 得到一个 vec2）得到一个纹理像素的实际大小，以此作为偏移距离的根据。</p>\n<p>我们为图像的模糊处理创建两个基本的帧缓冲，每个只有一个颜色缓冲纹理：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>GLuint pingpongFBO<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>GLuint pingpongBuffer<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glGenFramebuffers</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> pingpongFBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glGenTextures</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> pingpongBuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>GLuint i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token function\">glBindFramebuffer</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> pingpongFBO<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> pingpongBuffer<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token function\">glTexImage2D</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        GL_TEXTURE_2D<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> GL_RGB16F<span class=\"token punctuation\">,</span> SCR_WIDTH<span class=\"token punctuation\">,</span> SCR_HEIGHT<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> GL_RGB<span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_MIN_FILTER<span class=\"token punctuation\">,</span> GL_LINEAR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_MAG_FILTER<span class=\"token punctuation\">,</span> GL_LINEAR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_WRAP_S<span class=\"token punctuation\">,</span> GL_CLAMP_TO_EDGE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_WRAP_T<span class=\"token punctuation\">,</span> GL_CLAMP_TO_EDGE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token function\">glFramebufferTexture2D</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> GL_COLOR_ATTACHMENT0<span class=\"token punctuation\">,</span> GL_TEXTURE_2D<span class=\"token punctuation\">,</span> pingpongBuffer<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>得到一个 HDR 纹理后，我们用提取出来的亮区纹理填充一个帧缓冲，然后对其模糊处理 10 次（5 次垂直 5 次水平）：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>GLboolean horizontal <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> first_iteration <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>GLuint amount <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>shaderBlur<span class=\"token punctuation\">.</span><span class=\"token function\">Use</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>GLuint i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> amount<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token function\">glBindFramebuffer</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> pingpongFBO<span class=\"token punctuation\">[</span>horizontal<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token function\">glUniform1i</span><span class=\"token punctuation\">(</span><span class=\"token function\">glGetUniformLocation</span><span class=\"token punctuation\">(</span>shaderBlur<span class=\"token punctuation\">.</span>Program<span class=\"token punctuation\">,</span> <span class=\"token string\">\"horizontal\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> horizontal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        GL_TEXTURE_2D<span class=\"token punctuation\">,</span> first_iteration <span class=\"token operator\">?</span> colorBuffers<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">:</span> pingpongBuffers<span class=\"token punctuation\">[</span><span class=\"token operator\">!</span>horizontal<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token function\">RenderQuad</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    horizontal <span class=\"token operator\">=</span> <span class=\"token operator\">!</span>horizontal<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>first_iteration<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        first_iteration <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token function\">glBindFramebuffer</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>每次循环我们根据我们打算渲染的是水平还是垂直来绑定两个缓冲其中之一，而将另一个绑定为纹理进行模糊。第一次迭代，因为两个颜色缓冲都是空的所以我们随意绑定一个去进行模糊处理。重复这个步骤 10 次，亮区图像就进行一个重复 5 次的高斯模糊了。这样我们可以对任意图像进行任意次模糊处理；高斯模糊循环次数越多，模糊的强度越大。</p>\n<p>通过对提取亮区纹理进行 5 次模糊，我们就得到了一个正确的模糊的场景亮区图像。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/07/bloom_blurred_large.png\" alt=\"image\" /></p>\n<p>泛光的最后一步是把模糊处理的图像和场景原来的 HDR 纹理进行结合。</p>\n<h3 id=\"把两个纹理混合\"><a class=\"anchor\" href=\"#把两个纹理混合\">#</a> 把两个纹理混合</h3>\n<p>有了场景的 HDR 纹理和模糊处理的亮区纹理，我们只需把它们结合起来就能实现泛光或称光晕效果了。最终的像素着色器（大部分和 HDR 教程用的差不多）要把两个纹理混合：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>out vec4 FragColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>in vec2 TexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>uniform sampler2D scene<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>uniform sampler2D bloomBlur<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>uniform <span class=\"token keyword\">float</span> exposure<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#123;</span>             </pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">const</span> <span class=\"token keyword\">float</span> gamma <span class=\"token operator\">=</span> <span class=\"token number\">2.2</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    vec3 hdrColor <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>scene<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>rgb<span class=\"token punctuation\">;</span>      </pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    vec3 bloomColor <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>bloomBlur<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>rgb<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    hdrColor <span class=\"token operator\">+=</span> bloomColor<span class=\"token punctuation\">;</span> <span class=\"token comment\">// additive blending</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token comment\">// tone mapping</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    vec3 result <span class=\"token operator\">=</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token function\">exp</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>hdrColor <span class=\"token operator\">*</span> exposure<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token comment\">// also gamma correct while we're at it       </span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    result <span class=\"token operator\">=</span> <span class=\"token function\">pow</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span> <span class=\"token operator\">/</span> gamma<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>要注意的是我们要在<mark>应用色调映射</mark><strong>之前</strong><mark>添加泛光</mark>效果。这样添加的亮区的泛光，也会柔和转换为 LDR，光照效果相对会更好。</p>\n<p>把两个纹理结合以后，场景亮区便有了合适的光晕特效：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/05/07/bloom.png\" alt=\"image\" /></p>\n<p>有颜色的立方体看起来仿佛更亮，它向外发射光芒，的确是一个更好的视觉效果。这个场景比较简单，所以泛光效果不算十分令人瞩目，但在更好的场景中合理配置之后效果会有巨大的不同。</p>\n<p>这个教程我们只是用了一个相对简单的高斯模糊过滤器，它在每个方向上只有 5 个样本。通过沿着更大的半径或重复更多次数的模糊，进行采样我们就可以提升模糊的效果。因为模糊的质量与泛光效果的质量正相关，提升模糊效果就能够提升泛光效果。有些提升将模糊过滤器与不同大小的模糊 kernel 或采用多个高斯曲线来选择性地结合权重结合起来使用。来自 Kalogirou 和 EpicGames 的附加资源讨论了如何通过提升高斯模糊来显著提升泛光效果。</p>\n<h3 id=\"附加资源-7\"><a class=\"anchor\" href=\"#附加资源-7\">#</a> 附加资源</h3>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3Jhc3RlcmdyaWQuY29tL2Jsb2cvMjAxMC8wOS9lZmZpY2llbnQtZ2F1c3NpYW4tYmx1ci13aXRoLWxpbmVhci1zYW1wbGluZy8=\">Efficient Gaussian Blur with linear sampling</span>：非常详细地描述了高斯模糊，以及如何使用 OpenGL 的双线性纹理采样提升性能。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly91ZG4uZXBpY2dhbWVzLmNvbS9UaHJlZS9CbG9vbS5odG1s\">Bloom Post Process Effect</span>：来自 Epic Games 关于通过对权重的多个高斯曲线结合来提升泛光效果的文章。</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2thbG9naXJvdS5uZXQvMjAwNi8wNS8yMC9ob3ctdG8tZG8tZ29vZC1ibG9vbS1mb3ItaGRyLXJlbmRlcmluZy8=\">How to do good bloom for HDR rendering</span>：Kalogirou 的文章描述了如何使用更好的高斯模糊算法来提升泛光效果。</li>\n</ul>\n",
            "tags": [
                "计算机科学",
                "学习笔记",
                "OpenGL"
            ]
        },
        {
            "id": "https://allengx.gitee.io/computer-science/study/opengl/%E5%9B%9B%E3%80%81%E9%AB%98%E7%BA%A7OpenGL/",
            "url": "https://allengx.gitee.io/computer-science/study/opengl/%E5%9B%9B%E3%80%81%E9%AB%98%E7%BA%A7OpenGL/",
            "title": "四、高级OpenGL",
            "date_published": "2020-04-12T12:46:25.000Z",
            "content_html": "<div class=\"note info\">\n<p>以下为个人学习笔记整理</p>\n</div>\n<h1 id=\"高级opengl\"><a class=\"anchor\" href=\"#高级opengl\">#</a> 高级 OpenGL</h1>\n<h2 id=\"深度测试\"><a class=\"anchor\" href=\"#深度测试\">#</a> 深度测试</h2>\n<p>在坐标系统小节中，我们渲染了一个 3D 箱子，并且运用了<mark>深度缓冲</mark> (Depth Buffer) 来防止被阻挡的面渲染到其它面的前面。在这一节中，我们将会更加深入地讨论这些储存在深度缓冲（或 z 缓冲 (z-buffer)）中的深度值 (Depth Value)，以及它们是如何确定一个片段是处于其它片段后方的。</p>\n<p>深度缓冲就像颜色缓冲 (Color Buffer)（储存所有的片段颜色：视觉输出）一样，在每个片段中储存了信息，并且（通常）和颜色缓冲有着一样的宽度和高度。深度缓冲是由窗口系统自动创建的，它会以 16、24 或 32 位 float 的形式储存它的深度值。在大部分的系统中，深度缓冲的精度都是 24 位的。</p>\n<p>当深度测试 (Depth Testing) 被启用的时候，OpenGL 会将一个片段的的深度值与深度缓冲的内容进行对比。OpenGL 会执行一个<mark>深度测试</mark>，如果这个测试通过了的话，深度缓冲将会更新为新的深度值。如果深度测试失败了，<mark>片段将会被丢弃</mark>。</p>\n<p>深度缓冲是在片段着色器运行之后（以及模板测试 (Stencil Testing) 运行之后，我们将在下一节中讨论）在屏幕空间中运行的。屏幕空间坐标与通过 OpenGL 的 glViewport 所定义的视口密切相关，并且可以直接使用 GLSL 内建变量 gl_FragCoord 从片段着色器中直接访问。gl_FragCoord 的 x 和 y 分量代表了片段的屏幕空间坐标（其中 (0, 0) 位于左下角）。gl_FragCoord 中也包含了一个 z 分量，它包含了片段真正的深度值。z 值就是需要与深度缓冲内容所对比的那个值。</p>\n<blockquote>\n<p>现在大部分的 GPU 都提供一个叫做<mark>提前深度测试</mark> (Early Depth Testing) 的硬件特性。提前深度测试允许<mark>深度测试在片段着色器之前运行</mark>。只要我们清楚一个片段永远不会是可见的（它在其他物体之后），我们就能提前丢弃这个片段。</p>\n</blockquote>\n<blockquote>\n<p>片段着色器通常开销都是很大的，所以我们应该尽可能避免运行它们。当使用提前深度测试时，片段着色器的一个限制是你不能写入片段的深度值。如果一个片段着色器对它的深度值进行了写入，提前深度测试是不可能的。OpenGL 不能提前知道深度值。</p>\n</blockquote>\n<p>深度测试默认是<mark>禁用的</mark>，所以如果要启用深度测试的话，我们需要用 GL_DEPTH_TEST 选项来启用它：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glEnable</span><span class=\"token punctuation\">(</span>GL_DEPTH_TEST<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>当它启用的时候，如果一个片段通过了深度测试的话，OpenGL 会在深度缓冲中储存该片段的<mark> z 值</mark>；如果没有通过深度缓冲，则会丢弃该片段。如果你启用了深度缓冲，你还应该在每个渲染迭代之前使用 GL_DEPTH_BUFFER_BIT 来<mark>清除深度缓冲</mark>，否则你会仍在使用上一次渲染迭代中的写入的深度值：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glClear</span><span class=\"token punctuation\">(</span>GL_COLOR_BUFFER_BIT <span class=\"token operator\">|</span> GL_DEPTH_BUFFER_BIT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>可以想象，在某些情况下你会需要对所有片段都执行深度测试并丢弃相应的片段，但不希望更新深度缓冲。基本上来说，你在使用一个只读的 (Read-only) 深度缓冲。OpenGL 允许我们<mark>禁用深度缓冲的写入</mark>，只需要设置它的深度掩码 (Depth Mask) 设置为 GL_FALSE 就可以了：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glDepthMask</span><span class=\"token punctuation\">(</span>GL_FALSE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><blockquote>\n<p>注意这只在深度测试被启用的时候才有效果。</p>\n</blockquote>\n<h3 id=\"深度测试函数\"><a class=\"anchor\" href=\"#深度测试函数\">#</a> 深度测试函数</h3>\n<p>OpenGL 允许我们修改深度测试中使用的比较运算符。这允许我们来控制 OpenGL 什么时候该通过或丢弃一个片段，什么时候去更新深度缓冲。我们可以调用 glDepthFunc 函数来设置比较运算符（或者说深度函数 (Depth Function)）：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glDepthFunc</span><span class=\"token punctuation\">(</span>GL_LESS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这个函数接受下面表格中的比较运算符：</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_ALWAYS</td>\n<td>永远通过深度测试</td>\n</tr>\n<tr>\n<td>GL_NEVER</td>\n<td>永远不通过深度测试</td>\n</tr>\n<tr>\n<td>GL_LESS</td>\n<td>在片段深度值小于缓冲的深度值时通过测试</td>\n</tr>\n<tr>\n<td>GL_EQUAL</td>\n<td>在片段深度值等于缓冲区的深度值时通过测试</td>\n</tr>\n<tr>\n<td>GL_LEQUAL</td>\n<td>在片段深度值小于等于缓冲区的深度值时通过测试</td>\n</tr>\n<tr>\n<td>GL_GREATER</td>\n<td>在片段深度值大于缓冲区的深度值时通过测试</td>\n</tr>\n<tr>\n<td>GL_NOTEQUAL</td>\n<td>在片段深度值不等于缓冲区的深度值时通过测试</td>\n</tr>\n<tr>\n<td>GL_GEQUAL</td>\n<td>在片段深度值大于等于缓冲区的深度值时通过测试</td>\n</tr>\n</tbody>\n</table>\n<p>默认情况下使用的深度函数是 GL_LESS，它将会丢弃深度值大于等于当前深度缓冲值的所有片段。</p>\n<p>让我们看看改变深度函数会对视觉输出有什么影响。我们将使用一个新的代码配置，它会显示一个没有光照的基本场景，里面有两个有纹理的立方体，放置在一个有纹理的地板上。你可以在这里找到源代码。</p>\n<p>在源代码中，我们将深度函数改为 GL_ALWAYS：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glEnable</span><span class=\"token punctuation\">(</span>GL_DEPTH_TEST<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glDepthFunc</span><span class=\"token punctuation\">(</span>GL_ALWAYS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这将会模拟我们没有启用深度测试时所得到的结果。深度测试将会永远通过，所以最后绘制的片段将会总是会渲染在之前绘制片段的上面，即使之前绘制的片段本就应该渲染在最前面。因为我们是最后渲染地板的，它会覆盖所有的箱子片段：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/01/depth_testing_func_always.png\" alt=\"image\" /></p>\n<p>将它重新设置为 GL_LESS，这会将场景还原为原有的样子：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/01/depth_testing_func_less.png\" alt=\"image\" /></p>\n<h3 id=\"深度值精度\"><a class=\"anchor\" href=\"#深度值精度\">#</a> 深度值精度</h3>\n<p>深度缓冲包含了一个介于 0.0 和 1.0 之间的深度值，它将会与观察者视角所看见的场景中所有物体的 z 值进行比较。观察空间的 z 值可能是投影平截头体的<mark>近平面</mark> (Near) 和<mark>远平面</mark> (Far) 之间的任何值。我们需要一种方式来将这些观察空间的 z 值变换到 [0, 1] 范围之间，其中的一种方式就是将它们线性变换到 [0, 1] 范围之间。下面这个（线性）方程将 z 值变换到了 0.0 到 1.0 之间的深度值：</p>\n<pre><code class=\"language-math\">F_&#123;depth&#125;=\\cfrac&#123;z−near&#125;&#123;far−near&#125;\n</code></pre>\n<p>这里的 near 和 far 值是我们之前提供给投影矩阵设置可视平截头体的（见坐标系统）那个 near 和 far 值。这个方程需要平截头体中的一个 z 值，并将它变换到了 [0, 1] 的范围中。z 值和对应的深度值之间的关系可以在下图中看到：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/01/depth_linear_graph.png\" alt=\"image\" /></p>\n<blockquote>\n<p>注意所有的方程都会将非常近的物体的深度值设置为接近 0.0 的值，而当物体非常接近远平面的时候，它的深度值会非常接近 1.0。</p>\n</blockquote>\n<p>然而，在实践中是几乎永远不会使用这样的<mark>线性深度缓冲</mark> (Linear Depth Buffer) 的。要想有正确的投影性质，需要使用一个非线性的深度方程，它是与 <mark>1/z 成正比的</mark>。它做的就是在 z 值很小的时候提供非常高的精度，而在 z 值很远的时候提供更少的精度。花时间想想这个：我们真的需要对 1000 单位远的深度值和只有 1 单位远的充满细节的物体使用相同的精度吗？线性方程并不会考虑这一点。</p>\n<p>由于非线性方程与 1/z 成正比，在 1.0 和 2.0 之间的 z 值将会变换至 1.0 到 0.5 之间的深度值，这就是一个 float 提供给我们的一半精度了，这在 z 值很小的情况下提供了非常大的精度。在 50.0 和 100.0 之间的 z 值将会只占 2% 的 float 精度，这正是我们所需要的。这样的一个考虑了远近距离的方程是这样的：</p>\n<pre><code class=\"language-math\">F_&#123;depth&#125;=\\cfrac&#123;1/z−1/near&#125;&#123;1/far−1/near&#125;\n</code></pre>\n<p>如果你不知道这个方程是怎么回事也不用担心。重要的是要记住深度缓冲中的值在屏幕空间中不是线性的（在透视矩阵应用之前在观察空间中是线性的）。深度缓冲中 0.5 的值并不代表着物体的 z 值是位于平截头体的中间了，这个顶点的 z 值实际上非常接近近平面！你可以在下图中看到 z 值和最终的深度缓冲值之间的非线性关系：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/01/depth_non_linear_graph.png\" alt=\"image\" /></p>\n<p>可以看到，深度值很大一部分是由很小的 z 值所决定的，这给了近处的物体很大的深度精度。这个（从观察者的视角）变换 z 值的方程是嵌入在投影矩阵中的，所以当我们想将一个顶点坐标从观察空间至裁剪空间的时候这个非线性方程就被应用了。如果你想深度了解投影矩阵究竟做了什么，我建议<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zb25naG8uY2Evb3BlbmdsL2dsX3Byb2plY3Rpb25tYXRyaXguaHRtbA==\">阅读这篇文章</span>。</p>\n<p>如果我们想要可视化深度缓冲的话，非线性方程的效果很快就会变得很清楚。</p>\n<h3 id=\"深度缓冲的可视化\"><a class=\"anchor\" href=\"#深度缓冲的可视化\">#</a> 深度缓冲的可视化</h3>\n<p>我们知道片段着色器中，内建<mark> gl_FragCoord</mark> 向量的 z 值包含了那个特定片段的深度值。如果我们将这个深度值输出为颜色，我们可以显示场景中所有片段的深度值。我们可以根据片段的深度值返回一个颜色向量来完成这一工作：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span>gl_FragCoord<span class=\"token punctuation\">.</span>z<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>如果你再次运行程序的话，你可能会注意到所有东西都是白色的，看起来就想我们所有的深度值都是最大的 1.0。所以为什么没有靠近 0.0（即变暗）的深度值呢？</p>\n<p>你可能还记得在上一部分中说到，屏幕空间中的深度值是非线性的，即它在 z 值很小的时候有很高的精度，而 z 值很大的时候有较低的精度。片段的深度值会随着距离迅速增加，所以<mark>几乎所有的顶点的深度值都是接近于 1.0 的</mark>。如果我们小心地靠近物体，你可能会最终注意到颜色会渐渐变暗，显示它们的 z 值在逐渐变小：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/01/depth_testing_visible_depth.png\" alt=\"image\" /></p>\n<p>这很清楚地展示了深度值的非线性性质。近处的物体比起远处的物体对深度值有着更大的影响。只需要移动几厘米就能让颜色从暗完全变白。</p>\n<p>然而，我们也可以让片段非线性的深度值变换为线性的。要实现这个，我们需要仅仅反转深度值的投影变换。这也就意味着我们需要首先将深度值 == 从 [0, 1] 范围重新变换到 [-1, 1]== 范围的标准化设备坐标（裁剪空间）。接下来我们需要像投影矩阵那样反转这个非线性方程（方程 2），并将这个反转的方程应用到最终的深度值上。最终的结果就是一个线性的深度值了。听起来是可行的，对吧？</p>\n<p>首先我们将深度值变换为 NDC，不是非常困难：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> z <span class=\"token operator\">=</span> depth <span class=\"token operator\">*</span> <span class=\"token number\">2.0</span> <span class=\"token operator\">-</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>接下来使用获取到的 z 值，应用逆变换来获取线性的深度值：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> linearDepth <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">2.0</span> <span class=\"token operator\">*</span> near <span class=\"token operator\">*</span> far<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span>far <span class=\"token operator\">+</span> near <span class=\"token operator\">-</span> z <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>far <span class=\"token operator\">-</span> near<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这个方程是用投影矩阵推导得出的，它使用了方程 2 来非线性化深度值，返回一个 near 与 far 之间的深度值。这篇<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zb25naG8uY2Evb3BlbmdsL2dsX3Byb2plY3Rpb25tYXRyaXguaHRtbA==\">注重数学的文章</span>为感兴趣的读者详细解释了投影矩阵，它也展示了这些方程是怎么来的。</p>\n<p>将屏幕空间中非线性的深度值变换至线性深度值的完整片段着色器如下：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>out vec4 FragColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">float</span> near <span class=\"token operator\">=</span> <span class=\"token number\">0.1</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">float</span> far  <span class=\"token operator\">=</span> <span class=\"token number\">100.0</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">float</span> <span class=\"token function\">LinearizeDepth</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span> depth<span class=\"token punctuation\">)</span> </pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">float</span> z <span class=\"token operator\">=</span> depth <span class=\"token operator\">*</span> <span class=\"token number\">2.0</span> <span class=\"token operator\">-</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// back to NDC </span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token number\">2.0</span> <span class=\"token operator\">*</span> near <span class=\"token operator\">*</span> far<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span>far <span class=\"token operator\">+</span> near <span class=\"token operator\">-</span> z <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>far <span class=\"token operator\">-</span> near<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    </pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#123;</span>             </pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">float</span> depth <span class=\"token operator\">=</span> <span class=\"token function\">LinearizeDepth</span><span class=\"token punctuation\">(</span>gl_FragCoord<span class=\"token punctuation\">.</span>z<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> far<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 为了演示除以 far</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span>depth<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>由于线性化的深度值处于 near 与 far 之间，它的大部分值都会大于 1.0 并显示为完全的白色。通过在 main 函数中将线性深度值除以 far，我们近似地将线性深度值转化到 [0, 1] 的范围之间。这样子我们就能逐渐看到一个片段越接近投影平截头体的远平面，它就会变得越亮，更适用于展示目的。</p>\n<p>如果我们现在运行程序，我们就能看见深度值随着距离增大是线性的了。尝试在场景中移动，看看深度值是怎样以线性变化的。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/01/depth_testing_visible_linear.png\" alt=\"image\" /></p>\n<p>颜色大部分都是黑色，因为深度值的范围是 0.1 的近平面到 100 的远平面，远平面离我们还是非常远的。结果就是，我们相对靠近近平面，所以会得到更低的（更暗的）深度值。</p>\n<h3 id=\"深度冲突\"><a class=\"anchor\" href=\"#深度冲突\">#</a> 深度冲突</h3>\n<p>一个很常见的视觉错误会在两个平面或者三角形非常紧密地平行排列在一起时会发生，深度缓冲没有足够的精度来决定两个形状哪个在前面。结果就是<mark>这两个形状不断地在切换前后顺序</mark>，这会导致很奇怪的花纹。这个现象叫做<mark>深度冲突</mark> (Z-fighting)，因为它看起来像是这两个形状在争夺 (Fight) 谁该处于顶端。</p>\n<p>在我们一直使用的场景中，有几个地方的深度冲突还是非常明显的。箱子被放置在地板的同一高度上，这也就意味着箱子的底面和地板是<mark>共面的</mark> (Coplanar)。这两个面的深度值都是一样的，所以深度测试没有办法决定应该显示哪一个。</p>\n<p>如果你将摄像机移动到其中一个箱子的内部，你就能清楚地看到这个效果的，箱子的底部不断地在箱子底面与地板之间切换，形成一个锯齿的花纹：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/01/depth_testing_z_fighting.png\" alt=\"image\" /></p>\n<p>深度冲突是深度缓冲的一个常见问题，当物体在远处时效果会更明显（因为深度缓冲在 z 值比较大的时候有着更小的精度）。深度冲突<mark>不能够被完全避免</mark>，但一般会有一些技巧有助于在你的场景中减轻或者完全避免深度冲突。</p>\n<h3 id=\"防止深度冲突\"><a class=\"anchor\" href=\"#防止深度冲突\">#</a> 防止深度冲突</h3>\n<p>第一个也是最重要的技巧是<mark>永远不要把多个物体摆得太靠近</mark>，以至于它们的一些三角形会重叠。通过在两个物体之间设置一个用户无法注意到的偏移值，你可以完全避免这两个物体之间的深度冲突。在箱子和地板的例子中，我们可以将箱子沿着正 y 轴稍微移动一点。箱子位置的这点微小改变将不太可能被注意到，但它能够完全减少深度冲突的发生。然而，这需要对每个物体都手动调整，并且需要进行彻底的测试来保证场景中没有物体会产生深度冲突。</p>\n<p>第二个技巧是尽可能<mark>将近平面设置远一些</mark>。在前面我们提到了<mark>精度在靠近近平面时是非常高的</mark>，所以如果我们将近平面远离观察者，我们将会对整个平截头体有着更大的精度。然而，将近平面设置太远将会导致近处的物体被裁剪掉，所以这通常需要实验和微调来决定最适合你的场景的近平面距离。</p>\n<p>另外一个很好的技巧是牺牲一些性能，使用<mark>更高精度的深度缓冲</mark>。大部分深度缓冲的精度都是 24 位的，但现在大部分的显卡都支持 32 位的深度缓冲，这将会极大地提高精度。所以，牺牲掉一些性能，你就能获得更高精度的深度测试，减少深度冲突。</p>\n<p>我们上面讨论的三个技术是最普遍也是很容易实现的抗深度冲突技术了。还有一些更复杂的技术，但它们依然不能完全消除深度冲突。深度冲突是一个常见的问题，但如果你组合使用了上面列举出来的技术，你可能不会再需要处理深度冲突了。</p>\n<h2 id=\"模板测试\"><a class=\"anchor\" href=\"#模板测试\">#</a> 模板测试</h2>\n<p>当片段着色器处理完一个片段之后，<mark>模板测试</mark> (Stencil Test) 会开始执行，和深度测试一样，它也可能会丢弃片段。接下来，<mark>被保留的片段会进入<strong>深度测试</strong></mark>，它可能会丢弃更多的片段。模板测试是根据又一个缓冲来进行的，它叫做<mark>模板缓冲</mark> (Stencil Buffer)，我们可以在渲染的时候更新它来获得一些很有意思的效果。</p>\n<p>一个模板缓冲中，（通常）每个模板值 (Stencil Value) 是 8 位的。所以每个像素 / 片段一共能有 256 种不同的模板值。我们可以将这些模板值设置为我们想要的值，然后当某一个片段有某一个模板值的时候，我们就可以选择丢弃或是保留这个片段了。</p>\n<blockquote>\n<p>每个窗口库都需要为你配置一个模板缓冲。GLFW 自动做了这件事，所以我们不需要告诉 GLFW 来创建一个，但其它的窗口库可能不会默认给你创建一个模板库，所以记得要查看库的文档。</p>\n</blockquote>\n<p>模板缓冲的一个简单的例子如下（类似于视频遮罩）：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/02/stencil_buffer.png\" alt=\"image\" /></p>\n<p>模板缓冲首先会被清除为 0，之后在模板缓冲中使用 1 填充了一个空心矩形。场景中的片段将会只在片段的模板值为 1 的时候会被渲染（其它的都被丢弃了）。</p>\n<p>模板缓冲操作允许我们在渲染片段时将模板缓冲设定为一个特定的值。通过在渲染时修改模板缓冲的内容，我们写入了模板缓冲。在同一个（或者接下来的）渲染迭代中，我们可以读取这些值，来决定丢弃还是保留某个片段。使用模板缓冲的时候你可以尽情发挥，但大体的步骤如下：</p>\n<ul>\n<li>启用模板缓冲的写入。</li>\n<li>渲染物体，更新模板缓冲的内容。</li>\n<li>禁用模板缓冲的写入。</li>\n<li>渲染（其它）物体，这次根据模板缓冲的内容丢弃特定的片段。</li>\n</ul>\n<p>所以，通过使用模板缓冲，我们可以根据场景中已绘制的其它物体的片段，来决定是否丢弃特定的片段。</p>\n<p>你可以启用 GL_STENCIL_TEST 来启用模板测试。在这一行代码之后，所有的渲染调用都会以某种方式影响着模板缓冲。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glEnable</span><span class=\"token punctuation\">(</span>GL_STENCIL_TEST<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>注意，和颜色和深度缓冲一样，你也需要在每次迭代之前清除模板缓冲。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glClear</span><span class=\"token punctuation\">(</span>GL_COLOR_BUFFER_BIT <span class=\"token operator\">|</span> GL_DEPTH_BUFFER_BIT <span class=\"token operator\">|</span> GL_STENCIL_BUFFER_BIT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>和深度测试的 glDepthMask 函数一样，模板缓冲也有一个类似的函数。glStencilMask 允许我们设置一个位掩码 (Bitmask)，它会与将要写入缓冲的模板值进行<mark>与</mark> (AND) 运算。默认情况下设置的位掩码所有位都为 1，不影响输出，但如果我们将它设置为 0x00，写入缓冲的所有模板值最后都会变成 0. 这与深度测试中的 glDepthMask (GL_FALSE) 是等价的。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glStencilMask</span><span class=\"token punctuation\">(</span><span class=\"token number\">0xFF</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 每一位写入模板缓冲时都保持原样</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glStencilMask</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x00</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 每一位在写入模板缓冲时都会变成 0（禁用写入）</span></pre></td></tr></table></figure><p>大部分情况下你都只会使用 0x00 或者 0xFF 作为模板掩码 (Stencil Mask)，但是知道有选项可以设置自定义的位掩码总是好的。</p>\n<h3 id=\"模板函数\"><a class=\"anchor\" href=\"#模板函数\">#</a> 模板函数</h3>\n<p>和深度测试一样，我们对模板缓冲应该通过还是失败，以及它应该如何影响模板缓冲，也是有一定控制的。一共有两个函数能够用来配置模板测试：<mark>glStencilFunc</mark> 和<mark> glStencilOp</mark>。</p>\n<p><mark><strong>glStencilFunc</strong></mark> (GLenum func, GLint ref, GLuint mask) 一共包含三个参数：</p>\n<ul>\n<li>func：设置<mark>模板测试函数</mark> (Stencil Test Function)。这个测试函数将会应用到已储存的模板值上和 glStencilFunc 函数的 ref 值上。可用的选项有：GL_NEVER、GL_LESS、GL_LEQUAL、GL_GREATER、GL_GEQUAL、GL_EQUAL、GL_NOTEQUAL 和 GL_ALWAYS。它们的语义和深度缓冲的函数类似。</li>\n<li>ref：设置了模板测试的<mark>参考值</mark> (Reference Value)。模板缓冲的内容将会与这个值进行比较。</li>\n<li>mask：设置一个<mark>掩码</mark>，它将会与参考值和储存的模板值在测试比较它们之前进行与 (AND) 运算。初始情况下所有位都为 1。</li>\n</ul>\n<p>在一开始的那个简单的模板例子中，函数被设置为：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glStencilFunc</span><span class=\"token punctuation\">(</span>GL_EQUAL<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0xFF</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>这会告诉 OpenGL，只要一个片段的模板值等于 (GL_EQUAL) 参考值 1，片段将会通过测试并被绘制，否则会被丢弃。</p>\n<p>但是 glStencilFunc 仅仅描述了<mark> OpenGL 如何处理模板缓冲区内容</mark>，而不是我们应该如何<mark>更新缓冲</mark>。这就需要<mark> glStencilOp</mark> 这个函数了。</p>\n<p><mark><strong>glStencilOp</strong></mark> (GLenum sfail, GLenum dpfail, GLenum dppass) 一共包含三个选项，我们能够设定每个选项应该采取的行为：</p>\n<ul>\n<li>sfail：<mark>模板测试失败</mark>时采取的<mark>行为</mark>。</li>\n<li>dpfail：模板测试通过，但<mark>深度测试失败</mark>时采取的行为。</li>\n<li>dppass：模板测试和深度测试<mark>都通过</mark>时采取的行为。</li>\n</ul>\n<p>每个选项都可以选用以下的其中一种行为：</p>\n<table>\n<thead>\n<tr>\n<th>行为</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_KEEP</td>\n<td>保持当前储存的模板值</td>\n</tr>\n<tr>\n<td>GL_ZERO</td>\n<td>将模板值设置为 0</td>\n</tr>\n<tr>\n<td>GL_REPLACE</td>\n<td>将模板值设置为 glStencilFunc 函数设置的 ref 值</td>\n</tr>\n<tr>\n<td>GL_INCR</td>\n<td>如果模板值小于最大值则将模板值加 1</td>\n</tr>\n<tr>\n<td>GL_INCR_WRAP</td>\n<td>与 GL_INCR 一样，但如果模板值超过了最大值则归零</td>\n</tr>\n<tr>\n<td>GL_DECR</td>\n<td>如果模板值大于最小值则将模板值减 1</td>\n</tr>\n<tr>\n<td>GL_DECR_WRAP</td>\n<td>与 GL_DECR 一样，但如果模板值小于 0 则将其设置为最大值</td>\n</tr>\n<tr>\n<td>GL_INVERT</td>\n<td>按位翻转当前的模板缓冲值</td>\n</tr>\n</tbody>\n</table>\n<p>默认情况下 glStencilOp 是设置为 (GL_KEEP, GL_KEEP, GL_KEEP) 的，所以不论任何测试的结果是如何，模板缓冲都会保留它的值。默认的行为不会更新模板缓冲，所以如果你想写入模板缓冲的话，你需要至少对其中一个选项设置不同的值。</p>\n<p>所以，通过使用 glStencilFunc 和 glStencilOp，我们可以精确地指定更新模板缓冲的时机与行为了，我们也可以指定什么时候该让模板缓冲通过，即什么时候片段需要被丢弃。</p>\n<h3 id=\"物体轮廓\"><a class=\"anchor\" href=\"#物体轮廓\">#</a> 物体轮廓</h3>\n<p>仅仅看了前面的部分你还是不太可能能够完全理解模板测试的工作原理，所以我们将会展示一个使用模板测试就可以完成的有用特性，它叫做<mark>物体轮廓</mark> (Object Outlining)。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/02/stencil_object_outlining.png\" alt=\"image\" /></p>\n<p>物体轮廓所能做的事情正如它名字所描述的那样。我们将会为每个（或者一个）物体在它的周围创建一个很小的有色边框。当你想要在策略游戏中选中一个单位进行操作的，想要告诉玩家选中的是哪个单位的时候，这个效果就非常有用了。为物体创建轮廓的步骤如下：</p>\n<ol>\n<li>在绘制（需要添加轮廓的）物体之前，将模板函数设置为 GL_ALWAYS，每当物体的片段被渲染时，将模板缓冲更新为 1。</li>\n<li>渲染物体。</li>\n<li>禁用模板写入以及深度测试。</li>\n<li>将每个物体缩放一点点。</li>\n<li>使用一个不同的片段着色器，输出一个单独的（边框）颜色。</li>\n<li>再次绘制物体，但只在它们片段的模板值不等于 1 时才绘制。</li>\n<li>再次启用模板写入和深度测试。</li>\n</ol>\n<p>这个过程将每个物体的片段的模板缓冲设置为 1，当我们想要绘制边框的时候，我们主要绘制放大版本的物体中模板测试通过的部分，也就是物体的边框的位置。我们主要使用模板缓冲丢弃了放大版本中属于原物体片段的部分。</p>\n<p>所以我们首先来创建一个很简单的片段着色器，它会输出一个边框颜色。我们简单地给它设置一个硬编码的颜色值，将这个着色器命名为 shaderSingleColor：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.04</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.28</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.26</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们只想给那两个箱子加上边框，所以我们让地板不参与这个过程。我们希望首先绘制地板，再绘制两个箱子（并写入模板缓冲），之后绘制放大的箱子（并丢弃覆盖了之前绘制的箱子片段的那些片段）。</p>\n<p>我们首先启用模板测试，并设置测试通过或失败时的行为：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glEnable</span><span class=\"token punctuation\">(</span>GL_DEPTH_TEST<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glStencilOp</span><span class=\"token punctuation\">(</span>GL_KEEP<span class=\"token punctuation\">,</span> GL_KEEP<span class=\"token punctuation\">,</span> GL_REPLACE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>如果其中的一个测试失败了，我们什么都不做，我们仅仅保留当前储存在模板缓冲中的值。如果模板测试和深度测试都通过了，那么我们希望将储存的模板值设置为参考值，参考值能够通过<mark> glStencilFunc</mark> 来设置，我们之后会设置为 1。</p>\n<p>我们将模板缓冲清除为 0，对箱子中所有绘制的片段，将模板值更新为 1：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glStencilFunc</span><span class=\"token punctuation\">(</span>GL_ALWAYS<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0xFF</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 所有的片段都应该更新模板缓冲</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glStencilMask</span><span class=\"token punctuation\">(</span><span class=\"token number\">0xFF</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 启用模板缓冲写入</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>normalShader<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">DrawTwoContainers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>通过使用 GL_ALWAYS 模板测试函数，我们保证了箱子的每个片段都会将模板缓冲的模板值更新为 1。因为片段永远会通过模板测试，在绘制片段的地方，模板缓冲会被更新为参考值。</p>\n<p>现在模板缓冲在箱子被绘制的地方都更新为 1 了，我们将要绘制放大的箱子，但这次要禁用模板缓冲的写入：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glStencilFunc</span><span class=\"token punctuation\">(</span>GL_NOTEQUAL<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0xFF</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glStencilMask</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x00</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 禁止模板缓冲的写入</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glDisable</span><span class=\"token punctuation\">(</span>GL_DEPTH_TEST<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>shaderSingleColor<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">DrawTwoScaledUpContainers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>我们将模板函数设置为<mark> GL_NOTEQUAL</mark>，它会保证我们只绘制箱子上模板值不为 1 的部分，即只绘制箱子在之前绘制的箱子之外的部分。注意我们也禁用了深度测试，让放大的箱子，即边框，不会被地板所覆盖。</p>\n<p>记得要在完成之后重新启用深度缓冲。</p>\n<p>场景中物体轮廓的完整步骤会看起来像这样：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glEnable</span><span class=\"token punctuation\">(</span>GL_DEPTH_TEST<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glStencilOp</span><span class=\"token punctuation\">(</span>GL_KEEP<span class=\"token punctuation\">,</span> GL_KEEP<span class=\"token punctuation\">,</span> GL_REPLACE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glClear</span><span class=\"token punctuation\">(</span>GL_COLOR_BUFFER_BIT <span class=\"token operator\">|</span> GL_DEPTH_BUFFER_BIT <span class=\"token operator\">|</span> GL_STENCIL_BUFFER_BIT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">glStencilMask</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x00</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 记得保证我们在绘制地板的时候不会更新模板缓冲</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>normalShader<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">DrawFloor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  </pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token function\">glStencilFunc</span><span class=\"token punctuation\">(</span>GL_ALWAYS<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0xFF</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token function\">glStencilMask</span><span class=\"token punctuation\">(</span><span class=\"token number\">0xFF</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token function\">DrawTwoContainers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token function\">glStencilFunc</span><span class=\"token punctuation\">(</span>GL_NOTEQUAL<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0xFF</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token function\">glStencilMask</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x00</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token function\">glDisable</span><span class=\"token punctuation\">(</span>GL_DEPTH_TEST<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>shaderSingleColor<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token function\">DrawTwoScaledUpContainers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token function\">glStencilMask</span><span class=\"token punctuation\">(</span><span class=\"token number\">0xFF</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token function\">glEnable</span><span class=\"token punctuation\">(</span>GL_DEPTH_TEST<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>只要你理解了模板缓冲背后的大体思路，这个代码片段就不是那么难理解了。如果还是不能理解的话，尝试再次仔细阅读之前的部分，并尝试通过上面使用的范例，完全理解每个函数的功能。</p>\n<p>在深度测试小节的场景中，这个轮廓算法的结果看起来会像是这样的：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/02/stencil_scene_outlined.png\" alt=\"image\" /></p>\n<blockquote>\n<p>你可以看到这两个箱子的边框重合了，这通常都是我们想要的结果（想想策略游戏中，我们希望选择 10 个单位，合并边框通常是我们想需要的结果）。如果你想让每个物体都有一个完整的边框，你需要对每个物体都清空模板缓冲，并有创意地利用深度缓冲。</p>\n</blockquote>\n<p>你看到的物体轮廓算法在需要显示选中物体的游戏（想想策略游戏）中非常常见。这样的算法能够在一个模型类中轻松实现。你可以在模型类中设置一个 boolean 标记，来设置需不需要绘制边框。如果你有创造力的话，你也可以使用后期处理滤镜 (Filter)，像是高斯模糊 (Gaussian Blur)，让边框看起来更自然。</p>\n<p>除了物体轮廓之外，模板测试还有很多用途，比如在一个后视镜中绘制纹理，让它能够<mark>绘制到镜子</mark>形状中，或者使用一个叫做阴影体积 (Shadow Volume) 的模板缓冲技术渲染实时阴影。模板缓冲为我们已经很丰富的 OpenGL 工具箱又提供了一个很好的工具。</p>\n<h2 id=\"混合\"><a class=\"anchor\" href=\"#混合\">#</a> 混合</h2>\n<p>OpenGL 中，<mark>混合</mark> (Blending) 通常是实现物体<mark>透明度</mark> (Transparency) 的一种技术。透明就是说一个物体（或者其中的一部分）不是<mark>纯色</mark> (Solid Color) 的，它的颜色是物体本身的颜色和它背后其它物体的颜色的不同强度结合。一个有色玻璃窗是一个透明的物体，玻璃有它自己的颜色，但它最终的颜色还包含了玻璃之后所有物体的颜色。这也是混合这一名字的出处，我们混合 (Blend)（不同物体的）多种颜色为一种颜色。所以透明度能让我们看穿物体。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/03/blending_transparency.png\" alt=\"image\" /></p>\n<p>透明的物体可以是完全透明的（让所有的颜色穿过），或者是半透明的（它让颜色通过，同时也会显示自身的颜色）。一个物体的透明度是通过它颜色的<mark> aplha</mark> 值来决定的。Alpha 颜色值是颜色向量的第四个分量，你可能已经看到过它很多遍了。在这个教程之前我们都将这个第四个分量设置为 1.0，让这个物体的透明度为 0.0，而当 alpha 值为 0.0 时物体将会是完全透明的。当 alpha 值为 0.5 时，物体的颜色有 50% 是来自物体自身的颜色，50% 来自背后物体的颜色。</p>\n<p>我们目前一直使用的纹理有三个颜色分量：红、绿、蓝。但一些材质会有一个内嵌的 alpha 通道，对每个纹素 (Texel) 都包含了一个 alpha 值。这个 alpha 值精确地告诉我们纹理各个部分的透明度。比如说，下面这个窗户纹理中的玻璃部分的 alpha 值为 0.25（它在一般情况下是完全的红色，但由于它有 75% 的透明度，能让很大一部分的网站背景颜色穿过，让它看起来不那么红了），边框的 alpha 值是 0.0。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/03/blending_transparent_window.png\" alt=\"image\" /></p>\n<p>我们很快就会将这个窗户纹理添加到场景中，但是首先我们需要讨论一个更简单的技术，来实现只有完全透明和完全不透明的纹理的透明度。</p>\n<h3 id=\"丢弃片段\"><a class=\"anchor\" href=\"#丢弃片段\">#</a> 丢弃片段</h3>\n<p>有些图片并不需要半透明，只需要根据纹理颜色值，显示一部分，或者不显示一部分，没有中间情况。比如说草，如果想不太费劲地创建草这种东西，你需要将一个草的纹理贴在一个 2D 四边形 (Quad) 上，然后将这个四边形放到场景中。然而，草的形状和 2D 四边形的形状并不完全相同，所以你只想显示草纹理的某些部分，而忽略剩下的部分。</p>\n<p>下面这个纹理正是这样的，它要么是完全不透明的（alpha 值为 1.0），要么是完全透明的（alpha 值为 0.0），没有中间情况。你可以看到，只要不是草的部分，这个图片显示的都是网站的背景颜色而不是它本身的颜色。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/03/grass.png\" alt=\"image\" /></p>\n<p>所以当添加像草这样的植被到场景中时，我们不希望看到草的方形图像，而是只显示草的部分，并能看透图像其余的部分。我们想要丢弃 (Discard) 显示纹理中透明部分的片段，不将这些片段存储到颜色缓冲中。在此之前，我们还要学习如何加载一个透明的纹理。</p>\n<p>要想加载有 alpha 值的纹理，我们并不需要改很多东西，stb_image 在纹理有 alpha 通道的时候会自动加载，但我们仍要在纹理生成过程中告诉 OpenGL，我们的纹理现在使用 alpha 通道了：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glTexImage2D</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> GL_RGBA<span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> GL_RGBA<span class=\"token punctuation\">,</span> GL_UNSIGNED_BYTE<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>同样，保证你在片段着色器中获取了纹理的全部 4 个颜色分量，而不仅仅是 RGB 分量：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\">// FragColor = vec4(vec3(texture(texture1, TexCoords)), 1.0);</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>texture1<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>既然我们已经知道该如何加载透明的纹理了，是时候将它带入实战了，我们将会在深度测试小节的场景中加入几棵草。</p>\n<p>我们会创建一个 vector，向里面添加几个 glm::vec3 变量来代表草的位置：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vector<span class=\"token operator\">&lt;</span>glm<span class=\"token operator\">::</span>vec3<span class=\"token operator\">></span> vegetation<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>vegetation<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1.5f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.48f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>vegetation<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span> <span class=\"token number\">1.5f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.51f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>vegetation<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.7f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>vegetation<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">0.3f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">2.3f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>vegetation<span class=\"token punctuation\">.</span><span class=\"token function\">push_back</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span> <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.6f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>每个草都被渲染到了一个四边形上，贴上草的纹理。这并不能完美地表示 3D 的草，但这比加载复杂的模型要快多了。使用一些小技巧，比如在同一个位置加入一些旋转后的草四边形，你仍然能获得比较好的结果的。</p>\n<p>因为草的纹理是添加到四边形对象上的，我们还需要创建另外一个 VAO，填充 VBO，设置正确的顶点属性指针。接下来，在绘制完地板和两个立方体后，我们将会绘制草：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glBindVertexArray</span><span class=\"token punctuation\">(</span>vegetationVAO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> grassTexture<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> vegetation<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> </pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    model <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">mat4</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    model <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">translate</span><span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">,</span> vegetation<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>               </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    shader<span class=\"token punctuation\">.</span><span class=\"token function\">setMat4</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"model\"</span><span class=\"token punctuation\">,</span> model<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token function\">glDrawArrays</span><span class=\"token punctuation\">(</span>GL_TRIANGLES<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>运行程序你将看到：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/03/blending_no_discard.png\" alt=\"image\" /></p>\n<p>出现这种情况是因为 OpenGL 默认是不知道怎么处理 alpha 值的，更不知道什么时候应该丢弃片段。我们需要自己手动来弄。幸运的是，有了着色器，这还是非常容易的。GLSL 给了我们<mark> discard</mark> 命令，一旦被调用，它就会保证<mark>片段不会被进一步处理</mark>，所以就不会进入颜色缓冲。有了这个指令，我们就能够在片段着色器中检测一个片段的 alpha 值是否低于某个阈值，如果是的话，则丢弃这个片段，就好像它不存在一样：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>out vec4 FragColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>in vec2 TexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>uniform sampler2D texture1<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#123;</span>             </pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    vec4 texColor <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>texture1<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>texColor<span class=\"token punctuation\">.</span>a <span class=\"token operator\">&lt;</span> <span class=\"token number\">0.1</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        discard<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> texColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这里，我们检测被采样的纹理颜色的 alpha 值是否低于 0.1 的阈值，如果是的话，则丢弃这个片段。片段着色器保证了它只会渲染不是（几乎）完全透明的片段。现在它看起来就正常了：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/03/blending_discard.png\" alt=\"image\" /></p>\n<blockquote>\n<p>注意，当采样纹理的边缘的时候，OpenGL 会对边缘的值和纹理下一个重复的值进行插值（因为我们将它的环绕方式设置为了 GL_REPEAT。这通常是没问题的，但是由于我们使用了透明值，纹理图像的顶部将会与底部边缘的纯色值进行插值。这样的结果是一个半透明的有色边框，你可能会看见它环绕着你的纹理四边形。要想避免这个，每当你 alpha 纹理的时候，请将纹理的环绕方式设置为 GL_CLAMP_TO_EDGE：</p>\n</blockquote>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span> GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_WRAP_S<span class=\"token punctuation\">,</span> GL_CLAMP_TO_EDGE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span> GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_WRAP_T<span class=\"token punctuation\">,</span> GL_CLAMP_TO_EDGE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// 最终效果如下，你可能需要区分不同的渲染实现不一样的纹理设置</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_WRAP_S<span class=\"token punctuation\">,</span> format <span class=\"token operator\">==</span> GL_RGBA <span class=\"token operator\">?</span> GL_CLAMP_TO_EDGE <span class=\"token operator\">:</span> GL_REPEAT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// for this tutorial: use GL_CLAMP_TO_EDGE to prevent semi-transparent borders. Due to interpolation it takes texels from next repeat </span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_WRAP_T<span class=\"token punctuation\">,</span> format <span class=\"token operator\">==</span> GL_RGBA <span class=\"token operator\">?</span> GL_CLAMP_TO_EDGE <span class=\"token operator\">:</span> GL_REPEAT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"混合-2\"><a class=\"anchor\" href=\"#混合-2\">#</a> 混合</h3>\n<p>虽然直接丢弃片段很好，但它不能让我们渲染半透明的图像。我们要么渲染一个片段，要么完全丢弃它。要想渲染有多个透明度级别的图像，我们需要启用<mark>混合</mark> (Blending)。和 OpenGL 大多数的功能一样，我们可以启用 GL_BLEND 来启用混合：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glEnable</span><span class=\"token punctuation\">(</span>GL_BLEND<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>启用了混合之后，我们需要告诉 OpenGL 它该如何混合。</p>\n<p>OpenGL 中的混合是通过下面这个方程来实现的：</p>\n<pre><code class=\"language-math\">\\bar&#123;C&#125;_&#123;result&#125;=\\bar&#123;C&#125;_&#123;source&#125;∗F_&#123;source&#125;+\\bar&#123;C&#125;_&#123;destination&#125;∗F_&#123;destination&#125;\n</code></pre>\n<pre><code class=\"language-math\">\\begin&#123;array&#125;&#123;l&#125;\n\\bar&#123;C&#125;_&#123;source&#125;：源颜色向量。这是源自纹理的颜色向量。\\\\\n\\bar&#123;C&#125;_&#123;destination&#125;：目标颜色向量。这是当前储存在颜色缓冲中的颜色向量。\\\\\nF_&#123;source&#125;：源因子值。指定了alpha值对源颜色的影响。\\\\\nF_&#123;destination&#125;：目标因子值。指定了alpha值对目标颜色的影响。\\\\\n\\end&#123;array&#125;\n</code></pre>\n<p>片段着色器运行完成后，并且所有的测试都通过之后，这个混合方程 (Blend Equation) 才会应用到片段颜色输出与当前颜色缓冲中的值（当前片段之前储存的之前片段的颜色）上。源颜色和目标颜色将会由 OpenGL 自动设定，但源因子和目标因子的值可以由我们来决定。我们先来看一个简单的例子：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/03/blending_equation.png\" alt=\"image\" /></p>\n<p>我们有两个方形，我们希望将这个半透明的绿色方形绘制在红色方形之上。红色的方形将会是目标颜色（所以它应该先在颜色缓冲中），我们将要在这个红色方形之上绘制这个绿色方形。</p>\n<p>问题来了：我们将因子值设置为什么？嘛，我们至少想让绿色方形乘以它的 alpha 值，所以我们想要将 Fsrc 设置为源颜色向量的 alpha 值，也就是 0.6。接下来就应该清楚了，目标方形的贡献应该为剩下的 alpha 值。如果绿色方形对最终颜色贡献了 60%，那么红色方块应该对最终颜色贡献了 40%，即 1.0 - 0.6。所以我们将 Fdestination 设置为 1 减去源颜色向量的 alpha 值。这个方程变成了：</p>\n<pre><code class=\"language-math\">\n\\bar&#123;C&#125;_&#123;result&#125;=\n\\begin&#123;pmatrix&#125;\n0.0\\\\\n1.0\\\\\n0.0\\\\\n0.6\n\\end&#123;pmatrix&#125;\n* 0.6+\n\\begin&#123;pmatrix&#125;\n1.0\\\\\n0.0\\\\\n0.0\\\\\n1.6\n\\end&#123;pmatrix&#125;\n*(1-0.6)\n</code></pre>\n<p>结果就是重叠方形的片段包含了一个 60% 绿色，40% 红色的一种脏兮兮的颜色：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/03/blending_equation_mixed.png\" alt=\"image\" /></p>\n<p>最终的颜色将会被储存到颜色缓冲中，替代之前的颜色。</p>\n<p>这样子很不错，但我们该如何让 OpenGL 使用这样的因子呢？正好有一个专门的函数，叫做<mark> glBlendFunc</mark>。</p>\n<p>glBlendFunc (GLenum sfactor, GLenum dfactor) 函数接受两个参数，来设置源和目标因子。OpenGL 为我们定义了很多个选项，我们将在下面列出大部分最常用的选项。注意常数<mark>颜色向量</mark>可以通过 glBlendColor 函数来另外设置。</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_ZERO</td>\n<td>因子等于 0</td>\n</tr>\n<tr>\n<td>GL_ONE</td>\n<td>因子等于 1</td>\n</tr>\n<tr>\n<td>GL_SRC_COLOR</td>\n<td>因子等于源颜色向量 C¯source</td>\n</tr>\n<tr>\n<td>GL_ONE_MINUS_SRC_COLOR</td>\n<td>因子等于 1−C¯source</td>\n</tr>\n<tr>\n<td>GL_DST_COLOR</td>\n<td>因子等于目标颜色向量 C¯destination</td>\n</tr>\n<tr>\n<td>GL_ONE_MINUS_DST_COLOR</td>\n<td>因子等于 1−C¯destination</td>\n</tr>\n<tr>\n<td>GL_SRC_ALPHA</td>\n<td>因子等于 C¯source 的 alpha 分量</td>\n</tr>\n<tr>\n<td>GL_ONE_MINUS_SRC_ALPHA</td>\n<td>因子等于 1− C¯source 的 alpha 分量</td>\n</tr>\n<tr>\n<td>GL_DST_ALPHA</td>\n<td>因子等于 C¯destination 的 alpha 分量</td>\n</tr>\n<tr>\n<td>GL_ONE_MINUS_DST_ALPHA</td>\n<td>因子等于 1− C¯destination 的 alpha 分量</td>\n</tr>\n<tr>\n<td>GL_CONSTANT_COLOR</td>\n<td>因子等于常数颜色向量 C¯constant</td>\n</tr>\n<tr>\n<td>GL_ONE_MINUS_CONSTANT_COLOR</td>\n<td>因子等于 1−C¯constant</td>\n</tr>\n<tr>\n<td>GL_CONSTANT_ALPHA</td>\n<td>因子等于 C¯constant 的 alpha 分量</td>\n</tr>\n<tr>\n<td>GL_ONE_MINUS_CONSTANT_ALPHA</td>\n<td>因子等于 1− C¯constant 的 alpha 分量</td>\n</tr>\n</tbody>\n</table>\n<p>为了获得之前两个方形的混合结果，我们需要使用源颜色向量的 alpha 作为源因子，使用 1−alpha 作为目标因子。这将会产生以下的 glBlendFunc：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glBlendFunc</span><span class=\"token punctuation\">(</span>GL_SRC_ALPHA<span class=\"token punctuation\">,</span> GL_ONE_MINUS_SRC_ALPHA<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>也可以使用 glBlendFuncSeparate 为 RGB 和 alpha 通道分别设置不同的选项：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glBlendFuncSeparate</span><span class=\"token punctuation\">(</span>GL_SRC_ALPHA<span class=\"token punctuation\">,</span> GL_ONE_MINUS_SRC_ALPHA<span class=\"token punctuation\">,</span> GL_ONE<span class=\"token punctuation\">,</span> GL_ZERO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这个函数和我们之前设置的那样设置了 RGB 分量，但这样只能让最终的 alpha 分量被源颜色向量的 alpha 值所影响到。</p>\n<p>OpenGL 甚至给了我们更多的灵活性，允许我们改变方程中源和目标部分的运算符。当前源和目标是相加的，但如果愿意的话，我们也可以让它们相减。glBlendEquation (GLenum mode) 允许我们设置运算符，它提供了三个选项：</p>\n<ul>\n<li>GL_FUNC_ADD：默认选项，将两个分量相加：C¯result=Src+Dst。</li>\n<li>GL_FUNC_SUBTRACT：将两个分量相减： C¯result=Src−Dst。</li>\n<li>GL_FUNC_REVERSE_SUBTRACT：将两个分量相减，但顺序相反：C¯result=Dst−Src。</li>\n</ul>\n<p>通常我们都可以省略调用 glBlendEquation，因为 GL_FUNC_ADD 对大部分的操作来说都是我们希望的混合方程，但如果你真的想打破主流，其它的方程也可能符合你的要求。</p>\n<h3 id=\"渲染半透明纹理\"><a class=\"anchor\" href=\"#渲染半透明纹理\">#</a> 渲染半透明纹理</h3>\n<p>既然我们已经知道 OpenGL 是如何处理混合的了，是时候将我们的知识运用到实战中了，我们将会在场景中添加几个半透明的窗户。我们将使用本节开始的那个场景，但是这次不再是渲染草的纹理了，我们现在将使用本节开始时的那个透明的窗户纹理。</p>\n<p>首先，在初始化时我们启用混合，并设定相应的混合函数：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glEnable</span><span class=\"token punctuation\">(</span>GL_BLEND<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glBlendFunc</span><span class=\"token punctuation\">(</span>GL_SRC_ALPHA<span class=\"token punctuation\">,</span> GL_ONE_MINUS_SRC_ALPHA<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>由于启用了混合，我们就不需要丢弃片段了，所以我们把片段着色器还原：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>out vec4 FragColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>in vec2 TexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>uniform sampler2D texture1<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#123;</span>             </pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>texture1<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>现在（每当 OpenGL 渲染了一个片段时）它都会将当前片段的颜色和当前颜色缓冲中的片段颜色根据 alpha 值来进行混合。由于窗户纹理的玻璃部分是半透明的，我们应该能通窗户中看到背后的场景了。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/03/blending_incorrect_order.png\" alt=\"image\" /></p>\n<p>如果你仔细看的话，你可能会注意到有些不对劲。<mark>最前面窗户的透明部分遮蔽了背后的窗户</mark>？这为什么会发生呢？</p>\n<p>发生这一现象的原因是，深度测试和混合一起使用的话会产生一些麻烦。当写入深度缓冲时，深度缓冲不会检查片段是否是透明的，所以透明的部分会和其它值一样写入到深度缓冲中。结果就是窗户的整个四边形不论透明度都会进行深度测试。即使透明的部分应该显示背后的窗户，深度测试仍然丢弃了它们。</p>\n<p>所以我们不能随意地决定如何渲染窗户，让深度缓冲解决所有的问题了。这也是混合变得有些麻烦的部分。要想保证窗户中能够显示它们背后的窗户，我们需要首<mark>先绘制背后的这部分窗户</mark>。这也就是说在绘制的时候，我们必须先手动将窗户按照<mark>最远到最近来排序</mark>，再按照顺序渲染。</p>\n<blockquote>\n<p>注意，对于草这种全透明的物体，我们可以选择丢弃透明的片段而不是混合它们，这样就解决了这些头疼的问题（没有深度问题）。</p>\n</blockquote>\n<h3 id=\"不要打乱顺序\"><a class=\"anchor\" href=\"#不要打乱顺序\">#</a> 不要打乱顺序</h3>\n<p>要想让混合在多个物体上工作，我们需要最先绘制最远的物体，最后绘制最近的物体。普通不需要混合的物体仍然可以使用深度缓冲正常绘制，所以它们不需要排序。但我们仍要保证它们在绘制（排序的）透明物体之前已经绘制完毕了。当绘制一个有不透明和透明物体的场景的时候，大体的原则如下：</p>\n<ul>\n<li>先绘制所有不透明的物体。</li>\n<li>对所有透明的物体排序。</li>\n<li>按顺序绘制所有透明的物体。</li>\n</ul>\n<p>排序透明物体的一种方法是，从观察者视角获取物体的距离。这可以通过计算摄像机位置向量和物体的位置向量之间的距离所获得。接下来我们把距离和它对应的位置向量存储到一个 STL 库的 map 数据结构中。map 会自动根据键值 (Key) 对它的值排序，所以只要我们添加了所有的位置，并以它的距离作为键，它们就会自动根据距离值排序了。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>std<span class=\"token operator\">::</span>map<span class=\"token operator\">&lt;</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span>vec3<span class=\"token operator\">></span> sorted<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> windows<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">float</span> distance <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span>camera<span class=\"token punctuation\">.</span>Position <span class=\"token operator\">-</span> windows<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    sorted<span class=\"token punctuation\">[</span>distance<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> windows<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>结果就是一个排序后的容器对象，它根据 distance 键值从低到高储存了每个窗户的位置。</p>\n<p>之后，这次在渲染的时候，我们将以逆序（从远到近）从 map 中获取值，之后以正确的顺序绘制对应的窗户：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>std<span class=\"token operator\">::</span>map<span class=\"token operator\">&lt;</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">,</span>glm<span class=\"token operator\">::</span>vec3<span class=\"token operator\">></span><span class=\"token operator\">::</span>reverse_iterator it <span class=\"token operator\">=</span> sorted<span class=\"token punctuation\">.</span><span class=\"token function\">rbegin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> it <span class=\"token operator\">!=</span> sorted<span class=\"token punctuation\">.</span><span class=\"token function\">rend</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>it<span class=\"token punctuation\">)</span> </pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    model <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">mat4</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    model <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">translate</span><span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">,</span> it<span class=\"token operator\">-></span>second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>              </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    shader<span class=\"token punctuation\">.</span><span class=\"token function\">setMat4</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"model\"</span><span class=\"token punctuation\">,</span> model<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token function\">glDrawArrays</span><span class=\"token punctuation\">(</span>GL_TRIANGLES<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们使用了 map 的一个反向迭代器 (Reverse Iterator)，反向遍历其中的条目，并将每个窗户四边形位移到对应的窗户位置上。这是排序透明物体的一个比较简单的实现，它能够修复之前的问题，现在场景看起来是这样的：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/03/blending_sorted.png\" alt=\"image\" /></p>\n<p>虽然按照距离排序物体这种方法对我们这个场景能够正常工作，但它并没有考虑旋转、缩放或者其它的变换，奇怪形状的物体需要一个不同的计量，而不是仅仅一个位置向量。</p>\n<p>在场景中<mark>排序物体是一个很困难的技术</mark>，很大程度上由你场景的类型所决定，更别说它额外需要消耗的处理能力了。完整渲染一个包含不透明和透明物体的场景并不是那么容易。更高级的技术还有<mark>次序无关透明度</mark> (Order Independent Transparency, OIT)，但这超出本教程的范围了。现在，你还是必须要普通地混合你的物体，但如果你很小心，并且知道目前方法的限制的话，你仍然能够获得一个比较不错的混合实现。</p>\n<h2 id=\"面剔除\"><a class=\"anchor\" href=\"#面剔除\">#</a> 面剔除</h2>\n<p>尝试在脑子中想象一个 3D 立方体，数数你从任意方向最多能同时看到几个面。如果你的想象力不是过于丰富了，你应该能得出最大的面数是 3。你可以从任意位置和任意方向看向这个球体，但你永远不能看到 3 个以上的面。所以我们为什么要浪费时间绘制我们不能看见的那 3 个面呢？如果我们能够以某种方式丢弃这几个看不见的面，我们能省下超过 50% 的片段着色器执行数！</p>\n<blockquote>\n<p>我说的是超过 50% 而不是 50%，因为从特定角度来看的话只能看见 2 个甚至是 1 个面。在这种情况下，我们就能省下超过 50% 了。</p>\n</blockquote>\n<p>这是一个很好的主意，但我们仍有一个问题需要解决：我们如何知道一个物体的某一个面不能从观察者视角看到呢？<br />\n如果我们想象任何一个闭合形状，它的每一个面都有两侧，每一侧要么面向用户，要么背对用户。如果我们能够只绘制面向观察者的面呢？</p>\n<p>这正是<mark>面剔除</mark> (Face Culling) 所做的。OpenGL 能够检查所有面向 (Front Facing) 观察者的面，并渲染它们，而丢弃那些背向 (Back Facing) 的面，节省我们很多的片段着色器调用（它们的开销很大！）。但我们仍要告诉 OpenGL 哪些面是正向面 (Front Face)，哪些面是背向面 (Back Face)。OpenGL 使用了一个很聪明的技巧，<mark>分析顶点数据的环绕顺序 (Winding Order)</mark>。</p>\n<h3 id=\"环绕顺序\"><a class=\"anchor\" href=\"#环绕顺序\">#</a> 环绕顺序</h3>\n<p>当我们定义一组三角形顶点时，我们会以特定的环绕顺序来定义它们，可能是顺时针 (Clockwise) 的，也可能是逆时针 (Counter-clockwise) 的。每个三角形由 3 个顶点所组成，我们会从三角形中间来看，为这 3 个顶点设定一个环绕顺序。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/04/faceculling_windingorder.png\" alt=\"image\" /></p>\n<p>可以看到，我们首先定义了顶点 1，之后我们可以选择定义顶点 2 或者顶点 3，这个选择将定义了这个三角形的环绕顺序。下面的代码展示了这点：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> vertices<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">// 顺时针</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    vertices<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 顶点 1</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    vertices<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 顶点 2</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    vertices<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 顶点 3</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">// 逆时针</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    vertices<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 顶点 1</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    vertices<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 顶点 3</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    vertices<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>  <span class=\"token comment\">// 顶点 2  </span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>每组组成三角形图元的三个顶点就包含了一个环绕顺序。OpenGL 在渲染图元的时候将使用这个信息来决定一个三角形是一个正向三角形还是背向三角形。默认情况下，<mark>逆时针</mark>顶点所定义的三角形将会被处理为<mark>正向三角形</mark>。</p>\n<p>当你定义顶点顺序的时候，你应该想象对应的三角形是面向你的，所以你定义的三角形从正面看去应该是逆时针的。这样定义顶点很棒的一点是，实际的环绕顺序是在光栅化阶段进行的，也就是顶点着色器运行之后。这些顶点就是从观察者视角所见的了。</p>\n<p>观察者所面向的所有三角形顶点就是我们所指定的正确环绕顺序了，而立方体另一面的三角形顶点则是以相反的环绕顺序所渲染的。这样的结果就是，我们所面向的三角形将会是正向三角形，而背面的三角形则是背向三角形。下面这张图显示了这个效果：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/04/faceculling_frontback.png\" alt=\"image\" /></p>\n<p>在顶点数据中，我们将两个三角形都以逆时针顺序定义（正面的三角形是 1、2、3，背面的三角形也是 1、2、3（如果我们从正面看这个三角形的话））。然而，如果从观察者当前视角使用 1、2、3 的顺序来绘制的话，从观察者的方向来看，<mark>背面的三角形</mark>将会是以<mark>顺时针顺序渲染</mark>的。虽然背面的三角形是以<mark>逆时针定义</mark>的，它现在是以顺时针顺序渲染的了。这正是我们想要剔除（Cull，丢弃）的不可见面了！</p>\n<blockquote>\n<p>即：把看不见的面顺时针渲染</p>\n</blockquote>\n<p>在顶点数据中，我们定义的是两个逆时针顺序的三角形。然而，从观察者的方面看，后面的三角形是顺时针的，如果我们仍以 1、2、3 的顺序以观察者当面的视野看的话。即使我们以逆时针顺序定义后面的三角形，它现在还是变为<mark>顺时针</mark>。它正是我们打算<mark>剔除</mark>（丢弃）的<mark>不可见的面</mark>！</p>\n<h3 id=\"面剔除-2\"><a class=\"anchor\" href=\"#面剔除-2\">#</a> 面剔除</h3>\n<p>在本节的开头我们就说过，OpenGL 能够<mark>丢弃</mark>那些渲染为<mark>背向三角形</mark>的三角形图元。既然已经知道如何设置顶点的环绕顺序了，我们就可以使用 OpenGL 的面剔除选项了，它默认是禁用状态的。</p>\n<p>在之前教程中使用的立方体顶点数据并不是按照逆时针环绕顺序定义的，所以我更新了顶点数据，来反映逆时针的环绕顺序，你可以从这里复制它们。尝试想象这些顶点，确认在每个三角形中它们都是以逆时针定义的，这是一个很好的习惯。</p>\n<p>要想启用面剔除，我们只需要启用 OpenGL 的<mark> GL_CULL_FACE</mark> 选项：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glEnable</span><span class=\"token punctuation\">(</span>GL_CULL_FACE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>从这一句代码之后，所有背向面都将被丢弃（尝试飞进立方体内部，看看所有的内面是不是都被丢弃了）。目前我们在渲染片段的时候能够节省 50% 以上的性能，但注意这只对像立方体这样的封闭形状有效。当我们想要绘制上一节中的草时，我们必须要再次禁用面剔除，因为它们的正向面和背向面都应该是可见的。</p>\n<p>OpenGL 允许我们改变需要剔除的面的类型。如果我们只想剔除正向面而不是背向面会怎么样？我们可以调用<mark> glCullFace</mark> 来定义这一行为：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glCullFace</span><span class=\"token punctuation\">(</span>GL_FRONT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>glCullFace 函数有三个可用的选项：</p>\n<ul>\n<li>GL_BACK：只剔除<mark>背</mark>向面。</li>\n<li>GL_FRONT：只剔除<mark>正</mark>向面。</li>\n<li>GL_FRONT_AND_BACK：剔除<mark>正向面和背向面</mark>。</li>\n</ul>\n<p>glCullFace 的初始值是 GL_BACK。除了需要剔除的面之外，我们也可以通过调用 glFrontFace，告诉 OpenGL 我们希望<mark>将顺时针的面（而不是逆时针的面）定义为正向面</mark>：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glFrontFace</span><span class=\"token punctuation\">(</span>GL_CCW<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>默认值是<mark> GL_CCW</mark>，它代表的是<mark>逆时针</mark>的环绕顺序，另一个选项是<mark> GL_CW</mark>，它（显然）代表的是<mark>顺时针</mark>顺序。</p>\n<p>我们可以来做一个实验，告诉 OpenGL 现在顺时针顺序代表的是正向面：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glEnable</span><span class=\"token punctuation\">(</span>GL_CULL_FACE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glCullFace</span><span class=\"token punctuation\">(</span>GL_BACK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glFrontFace</span><span class=\"token punctuation\">(</span>GL_CW<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p><img data-src=\"https://learnopengl-cn.github.io/img/04/04/faceculling_reverse.png\" alt=\"image\" /></p>\n<p>注意你可以仍使用默认的逆时针环绕顺序，但剔除正向面，来达到相同的效果：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glEnable</span><span class=\"token punctuation\">(</span>GL_CULL_FACE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glCullFace</span><span class=\"token punctuation\">(</span>GL_FRONT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h2 id=\"帧缓冲\"><a class=\"anchor\" href=\"#帧缓冲\">#</a> 帧缓冲</h2>\n<p>到目前为止，我们已经使用了很多屏幕缓冲了：用于写入颜色值的颜色缓冲、用于写入深度信息的深度缓冲和允许我们根据一些条件丢弃特定片段的模板缓冲。这些缓冲结合起来叫做<mark>帧缓冲</mark> (Framebuffer)，它被储存在内存中。OpenGL 允许我们定义我们自己的帧缓冲，也就是说我们能够定义我们自己的颜色缓冲，甚至是深度缓冲和模板缓冲。</p>\n<p>我们目前所做的所有操作都是在默认帧缓冲的渲染缓冲上进行的。<mark>默认</mark>的<mark>帧缓冲</mark>是在你创建窗口的时候生成和配置的（GLFW 帮我们做了这些）。有了我们自己的帧缓冲，我们就能够有更多方式来渲染了。</p>\n<p>你可能不能很快理解帧缓冲的应用，但渲染你的场景到不同的帧缓冲能够让我们在场景中加入类似镜子的东西，或者做出很酷的后期处理效果。首先我们会讨论它是如何工作的，之后我们将来实现这些炫酷的后期处理效果。</p>\n<h3 id=\"创建一个帧缓冲\"><a class=\"anchor\" href=\"#创建一个帧缓冲\">#</a> 创建一个帧缓冲</h3>\n<p>和 OpenGL 中的其它对象一样，我们会使用一个叫做<mark> glGenFramebuffers</mark> 的函数来创建一个帧缓冲对象 (Framebuffer Object, FBO)：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> fbo<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glGenFramebuffers</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>fbo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这种创建和使用对象的方式我们已经见过很多次了，所以它的使用函数也和其它的对象类似。首先我们创建一个帧缓冲对象，将它绑定为激活的 (Active) 帧缓冲，做一些操作，之后解绑帧缓冲。我们使用<mark> glBindFramebuffer</mark> 来绑定帧缓冲。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glBindFramebuffer</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> fbo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在绑定到<mark> GL_FRAMEBUFFER</mark> 目标之后，所有的读取和写入帧缓冲的操作将会影响当前绑定的帧缓冲。我们也可以使用<mark> GL_READ_FRAMEBUFFER</mark> 或<mark> GL_DRAW_FRAMEBUFFER</mark>，将一个帧缓冲分别绑定到读取目标或写入目标。绑定到 GL_READ_FRAMEBUFFER 的帧缓冲将会使用像是 glReadPixels 的<mark>读取操作中</mark>，而绑定到 GL_DRAW_FRAMEBUFFER 的帧缓冲将会被用作<mark>渲染</mark>、<mark>清除</mark>等<mark>写入操作</mark>的目标。大部分情况你都不需要区分它们，通常都会使用 GL_FRAMEBUFFER，绑定到两个上。</p>\n<p>不幸的是，我们现在还不能使用我们的帧缓冲，因为它还不完整 (Complete)，一个完整的帧缓冲需要满足以下的条件：</p>\n<ul>\n<li>附加<mark>至少一个</mark>缓冲（颜色、深度或模板缓冲）。</li>\n<li>至少有<mark>一个颜色附件</mark> (Attachment)。</li>\n<li>所有的附件都必须是<mark>完整</mark>的（保留了内存）。</li>\n<li>每个缓冲都应该有<mark>相同</mark>的样本数。</li>\n</ul>\n<p>从上面的条件中可以知道，我们需要为帧缓冲创建一些附件，并将附件附加到帧缓冲上。在完成所有的条件之后，我们可以以 GL_FRAMEBUFFER 为参数调用<mark> glCheckFramebufferStatus</mark>，检查帧缓冲是否完整。它将会检测当前绑定的帧缓冲，并返回规范中这些值的其中之一。如果它返回的是<mark> GL_FRAMEBUFFER_COMPLETE</mark>，帧缓冲就是<mark>完整的</mark>了。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">glCheckFramebufferStatus</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> GL_FRAMEBUFFER_COMPLETE<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token comment\">// 执行胜利的舞蹈</span></pre></td></tr></table></figure><p>之后所有的渲染操作将会渲染到当前绑定帧缓冲的附件中。由于我们的帧缓冲不是默认帧缓冲，渲染指令将不会对窗口的视觉输出有任何影响。出于这个原因，渲染到一个不同的帧缓冲被叫做<mark>离屏渲染</mark> (Off-screen Rendering)。要保证所有的渲染操作在主窗口中有视觉效果，我们需要再次激活默认帧缓冲，将它绑定到 0。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glBindFramebuffer</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在完成所有的帧缓冲操作之后，不要忘记删除这个帧缓冲对象：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glDeleteFramebuffers</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>fbo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>在完整性检查执行之前，我们需要给帧缓冲附加一个附件。<mark>附件</mark>是一个<mark>内存位置</mark>，它能够作为帧缓冲的一个缓冲，可以将它想象为一个图像。当创建一个附件的时候我们有两个选项：纹理或渲染缓冲对象 (Renderbuffer Object)。</p>\n<h3 id=\"纹理附件\"><a class=\"anchor\" href=\"#纹理附件\">#</a> 纹理附件</h3>\n<p>当把一个纹理附加到帧缓冲的时候，所有的渲染指令将会写入到这个纹理中，就想它是一个普通的颜色 / 深度或模板缓冲一样。使用纹理的优点是，所有渲染操作的结果将会被储存在一个纹理图像中，我们之后可以在着色器中很方便地使用它。</p>\n<p>为帧缓冲创建一个纹理和创建一个普通的纹理差不多：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> texture<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glGenTextures</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>texture<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> texture<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">glTexImage2D</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> GL_RGB<span class=\"token punctuation\">,</span> <span class=\"token number\">800</span><span class=\"token punctuation\">,</span> <span class=\"token number\">600</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> GL_RGB<span class=\"token punctuation\">,</span> GL_UNSIGNED_BYTE<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_MIN_FILTER<span class=\"token punctuation\">,</span> GL_LINEAR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_MAG_FILTER<span class=\"token punctuation\">,</span> GL_LINEAR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>主要的区别就是，我们将维度设置为了屏幕大小（尽管这不是必须的），并且我们给纹理的 data 参数传递了<mark> NULL</mark>。对于这个纹理，我们仅<mark>仅分配了内存而没有填充它</mark>。填充这个纹理将会在我们渲染到帧缓冲之后来进行。同样注意我们并不关心环绕方式或多级渐远纹理，我们在大多数情况下都不会需要它们。</p>\n<blockquote>\n<p>如果你想将你的屏幕渲染到一个更小或更大的纹理上，你需要（在<mark>渲染到你的帧缓冲之前</mark>）再次调用<mark> glViewport</mark>，使用纹理的新维度作为参数，否则只有一小部分的纹理或屏幕会被渲染到这个纹理上。</p>\n</blockquote>\n<p>现在我们已经创建好一个纹理了，要做的最后一件事就是将它附加到帧缓冲上了：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glFramebufferTexture2D</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> GL_COLOR_ATTACHMENT0<span class=\"token punctuation\">,</span> GL_TEXTURE_2D<span class=\"token punctuation\">,</span> texture<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>glFrameBufferTexture2D 有以下的参数：</p>\n<ul>\n<li>target：帧缓冲的目标（绘制、读取或者两者皆有）</li>\n<li>attachment：我们想要附加的附件类型。当前我们正在附加一个颜色附件。注意最后的 0 意味着我们可以附加多个颜色附件。我们将在之后的教程中提到。</li>\n<li>textarget：你希望附加的纹理类型</li>\n<li>texture：要附加的纹理本身</li>\n<li>level：多级渐远纹理的级别。我们将它保留为 0。</li>\n</ul>\n<p>除了颜色附件之外，我们还可以附加一个深度和模板缓冲纹理到帧缓冲对象中。要附加深度缓冲的话，我们将附件类型设置为<mark> GL_DEPTH_ATTACHMENT</mark>。注意纹理的格式 (Format) 和内部格式 (Internalformat) 类型将变为 GL_DEPTH_COMPONENT，来反映深度缓冲的储存格式。要附加模板缓冲的话，你要将第二个参数设置为 GL_STENCIL_ATTACHMENT，并将纹理的格式设定为 GL_STENCIL_INDEX。</p>\n<p>也可以将深度缓冲和模板缓冲附加为一个单独的纹理。纹理的每 32 位数值将包含 24 位的深度信息和 8 位的模板信息。要将深度和模板缓冲附加为一个纹理的话，我们使用 GL_DEPTH_STENCIL_ATTACHMENT 类型，并配置纹理的格式，让它包含合并的深度和模板值。将一个深度和模板缓冲附加为一个纹理到帧缓冲的例子可以在下面找到：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glTexImage2D</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  GL_TEXTURE_2D<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> GL_DEPTH24_STENCIL8<span class=\"token punctuation\">,</span> <span class=\"token number\">800</span><span class=\"token punctuation\">,</span> <span class=\"token number\">600</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  GL_DEPTH_STENCIL<span class=\"token punctuation\">,</span> GL_UNSIGNED_INT_24_8<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">glFramebufferTexture2D</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> GL_DEPTH_STENCIL_ATTACHMENT<span class=\"token punctuation\">,</span> GL_TEXTURE_2D<span class=\"token punctuation\">,</span> texture<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"渲染缓冲对象附件\"><a class=\"anchor\" href=\"#渲染缓冲对象附件\">#</a> 渲染缓冲对象附件</h3>\n<p>渲染缓冲对象 (Renderbuffer Object) 是在纹理之后引入到 OpenGL 中，作为一个可用的帧缓冲附件类型的，所以在过去纹理是唯一可用的附件。和纹理图像一样，渲染缓冲对象是一个<mark>真正的缓冲</mark>，即<mark>一系列的字节、整数、像素等</mark>。渲染缓冲对象附加的好处是，它会将数据储存为 OpenGL 原生的渲染格式，它是为离屏渲染到帧缓冲优化过的。</p>\n<p>渲染缓冲对象直接将所有的渲染数据储存到它的缓冲中，不会做任何针对纹理格式的转换，让它变为一个更快的可写储存介质。然而，渲染缓冲对象通常都是只写的，所以你不能读取它们（比如使用纹理访问）。当然你仍然还是能够使用<mark> glReadPixels</mark> 来读取它，这会从当前绑定的<mark>帧缓冲</mark>，而<mark>不是附件本身</mark>，中返回特定区域的像素。</p>\n<p>因为它的数据已经是原生的格式了，当写入或者复制它的数据到其它缓冲中时是非常快的。所以，交换缓冲这样的操作在使用渲染缓冲对象时会非常快。我们在每个渲染迭代最后使用的 glfwSwapBuffers，也可以通过渲染缓冲对象实现：只需要写入一个渲染缓冲图像，并在最后交换到另外一个渲染缓冲就可以了。渲染缓冲对象对这种操作非常完美。</p>\n<p>创建一个渲染缓冲对象的代码和帧缓冲的代码很类似：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> rbo<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glGenRenderbuffers</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>rbo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>类似，我们需要绑定这个渲染缓冲对象，让之后所有的渲染缓冲操作影响当前的 rbo：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glBindRenderbuffer</span><span class=\"token punctuation\">(</span>GL_RENDERBUFFER<span class=\"token punctuation\">,</span> rbo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>由于渲染缓冲对象通常都是只写的，它们会经常用于深度和模板附件，因为大部分时间我们都不需要从深度和模板缓冲中读取值，只关心深度和模板测试。我们需要深度和模板值用于测试，但不需要对它们进行采样，所以渲染缓冲对象非常适合它们。当我们不需要从这些缓冲中采样的时候，通常都会选择渲染缓冲对象，因为它会更优化一点。</p>\n<p>创建一个<mark>深度和模板渲染缓冲对象</mark>可以通过调用<mark> glRenderbufferStorage</mark> 函数来完成：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glRenderbufferStorage</span><span class=\"token punctuation\">(</span>GL_RENDERBUFFER<span class=\"token punctuation\">,</span> GL_DEPTH24_STENCIL8<span class=\"token punctuation\">,</span> <span class=\"token number\">800</span><span class=\"token punctuation\">,</span> <span class=\"token number\">600</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>创建一个渲染缓冲对象和纹理对象类似，不同的是这个对象是专门被设计作为图像使用的，而不是纹理那样的通用数据缓冲 (General Purpose Data Buffer)。这里我们选择 GL_DEPTH24_STENCIL8 作为内部格式，它封装了 24 位的深度和 8 位的模板缓冲。</p>\n<p>最后一件事就是附加这个渲染缓冲对象：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glFramebufferRenderbuffer</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> GL_DEPTH_STENCIL_ATTACHMENT<span class=\"token punctuation\">,</span> GL_RENDERBUFFER<span class=\"token punctuation\">,</span> rbo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>渲染缓冲对象能为你的帧缓冲对象提供一些优化，但知道什么时候使用渲染缓冲对象，什么时候使用纹理是很重要的。通常的规则是，如果你<mark>不需要</mark>从一个缓冲中<mark>采样数据</mark>，那么对这个缓冲使用<mark>渲染缓冲</mark>对象会是明智的选择。如果你<mark>需要</mark>从缓冲中<mark>采样</mark>颜色或深度值等数据，那么你应该选择<mark>纹理附件</mark>。性能方面它不会产生非常大的影响的。</p>\n<h3 id=\"渲染到纹理\"><a class=\"anchor\" href=\"#渲染到纹理\">#</a> 渲染到纹理</h3>\n<p>既然我们已经知道帧缓冲（大概）是怎么工作的了，是时候实践它们了。我们将会<mark>将场景</mark>渲染到一个<mark>附加到</mark>帧缓冲对象上的<mark>颜色纹理</mark>中，之后将在一个横跨整个屏幕的四边形上绘制这个纹理。这样视觉输出和没使用帧缓冲时是完全一样的，但这次是打印到了一个四边形上。这为什么很有用呢？我们会在下一部分中知道原因。</p>\n<p>首先要创建一个帧缓冲对象，并绑定它，这些都很直观：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> framebuffer<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glGenFramebuffers</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>framebuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glBindFramebuffer</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> framebuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>接下来我们需要创建一个<mark>纹理图像</mark>，我们将它<mark>作为</mark>一个<mark>颜色附件</mark>附加到帧缓冲上。我们将纹理的维度设置为窗口的宽度和高度，并且<mark>不初始化它的数据</mark>：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 生成纹理</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> texColorBuffer<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glGenTextures</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>texColorBuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> texColorBuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">glTexImage2D</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> GL_RGB<span class=\"token punctuation\">,</span> <span class=\"token number\">800</span><span class=\"token punctuation\">,</span> <span class=\"token number\">600</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> GL_RGB<span class=\"token punctuation\">,</span> GL_UNSIGNED_BYTE<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_MIN_FILTER<span class=\"token punctuation\">,</span> GL_LINEAR <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> GL_TEXTURE_MAG_FILTER<span class=\"token punctuation\">,</span> GL_LINEAR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">// 将它附加到当前绑定的帧缓冲对象</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token function\">glFramebufferTexture2D</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> GL_COLOR_ATTACHMENT0<span class=\"token punctuation\">,</span> GL_TEXTURE_2D<span class=\"token punctuation\">,</span> texColorBuffer<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>我们还希望 OpenGL 能够进行深度测试（如果你需要的话还有模板测试），所以我们还需要添加一个深度（和模板）附件到帧缓冲中。由于我们只希望采样颜色缓冲，而不是其它的缓冲，我们可以为它们创建一个渲染缓冲对象。还记得当我们不需要采样缓冲的时候，渲染缓冲对象是更好的选择吗？</p>\n<p>创建一个渲染缓冲对象不是非常复杂。我们需要记住的唯一事情是，我们将它创建为一个<mark>深度和模板附件渲染缓冲对象</mark>。我们将它的<mark>内部格式</mark>设置为<mark> GL_DEPTH24_STENCIL8</mark>，对我们来说这个精度已经足够了。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> rbo<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glGenRenderbuffers</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>rbo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glBindRenderbuffer</span><span class=\"token punctuation\">(</span>GL_RENDERBUFFER<span class=\"token punctuation\">,</span> rbo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glRenderbufferStorage</span><span class=\"token punctuation\">(</span>GL_RENDERBUFFER<span class=\"token punctuation\">,</span> GL_DEPTH24_STENCIL8<span class=\"token punctuation\">,</span> <span class=\"token number\">800</span><span class=\"token punctuation\">,</span> <span class=\"token number\">600</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">glBindRenderbuffer</span><span class=\"token punctuation\">(</span>GL_RENDERBUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>当我们为渲染缓冲对象分配了足够的内存之后，我们可以<mark>解绑</mark>这个渲染缓冲。</p>\n<p>接下来，作为完成帧缓冲之前的最后一步，我们将渲染缓冲对象<mark>附加到</mark>帧缓冲的深度和模板附件上：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glFramebufferRenderbuffer</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> GL_DEPTH_STENCIL_ATTACHMENT<span class=\"token punctuation\">,</span> GL_RENDERBUFFER<span class=\"token punctuation\">,</span> rbo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>最后，我们希望检查帧缓冲是否是完整的，如果不是，我们将打印错误信息。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">glCheckFramebufferStatus</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> GL_FRAMEBUFFER_COMPLETE<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"ERROR::FRAMEBUFFER:: Framebuffer is not complete!\"</span> <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glBindFramebuffer</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>记得要解绑帧缓冲，保证我们不会不小心渲染到错误的帧缓冲上。</p>\n<p>现在这个帧缓冲就完整了，我们只需要绑定这个帧缓冲对象，让渲染到帧缓冲的缓冲中而不是默认的帧缓冲中。之后的渲染指令将会影响当前绑定的帧缓冲。所有的深度和模板操作都会从当前绑定的帧缓冲的深度和模板附件中（如果有的话）读取。如果你忽略了深度缓冲，那么所有的深度测试操作将不再工作，因为当前绑定的帧缓冲中不存在深度缓冲。</p>\n<p>所以，要想绘制场景到一个纹理上，我们需要采取以下的步骤：</p>\n<ul>\n<li>将新的帧缓冲绑定为<mark>激活</mark>的帧缓冲，和往常一样渲染场景。</li>\n<li>绑定默认的帧缓冲。</li>\n<li>绘制一个横跨整个屏幕的四边形，将帧缓冲的颜色缓冲作为它的纹理。</li>\n</ul>\n<p>我们将会绘制深度测试小节中的场景，但这次使用的是旧的箱子纹理。</p>\n<p>为了绘制这个四边形，我们将会新创建一套简单的着色器。我们将不会包含任何花哨的矩阵变换，因为我们提供的是标准化设备坐标的顶点坐标，所以我们可以直接将它们设定为顶点着色器的输出。顶点着色器是这样的：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> in vec2 aPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> in vec2 aTexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>out vec2 TexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>aPos<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">,</span> aPos<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    TexCoords <span class=\"token operator\">=</span> aTexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>并没有太复杂的东西。片段着色器会更加基础，我们做的唯一一件事就是从纹理中采样：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>out vec4 FragColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>in vec2 TexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>uniform sampler2D screenTexture<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#123;</span> </pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>screenTexture<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>接着就靠你来为屏幕四边形创建并配置一个 VAO 了。帧缓冲的一个渲染迭代将会有以下的结构：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 第一处理阶段 (Pass)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glBindFramebuffer</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> framebuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glClearColor</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.1f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.1f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.1f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glClear</span><span class=\"token punctuation\">(</span>GL_COLOR_BUFFER_BIT <span class=\"token operator\">|</span> GL_DEPTH_BUFFER_BIT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 我们现在不使用模板缓冲</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">glEnable</span><span class=\"token punctuation\">(</span>GL_DEPTH_TEST<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">DrawScene</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    </pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">// 第二处理阶段</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token function\">glBindFramebuffer</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 返回默认</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token function\">glClearColor</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token function\">glClear</span><span class=\"token punctuation\">(</span>GL_COLOR_BUFFER_BIT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>screenShader<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token function\">glBindVertexArray</span><span class=\"token punctuation\">(</span>quadVAO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token function\">glDisable</span><span class=\"token punctuation\">(</span>GL_DEPTH_TEST<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> textureColorbuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token function\">glDrawArrays</span><span class=\"token punctuation\">(</span>GL_TRIANGLES<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>要注意一些事情。第一，由于我们使用的每个帧缓冲都有它自己一套缓冲，我们希望设置合适的位置，调用 glClear，清除这些缓冲。第二，当绘制四边形时，我们将禁用深度测试，因为我们是在绘制一个简单的四边形，并不需要关系深度测试。在绘制普通场景的时候我们将会重新启用深度测试。</p>\n<p>有很多步骤都可能会出错，所以如果你没有得到输出的话，尝试调试程序，并重新阅读本节的相关部分。如果所有的东西都能够正常工作，你将会得到下面这样的视觉输出：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/05/framebuffers_screen_texture.png\" alt=\"image\" /></p>\n<p>左边展示的是视觉输出，它和深度测试中是完全一样的，但这次是渲染在一个简单的四边形上。如果我们使用线框模式渲染场景，就会变得很明显，我们在默认的帧缓冲中只绘制了一个简单的四边形。</p>\n<p>所以这个有什么用处呢？因为我们能够以一个纹理图像的方式访问已渲染场景中的每个像素，我们可以在片段着色器中创建出非常有趣的效果。这些有趣效果统称为<mark>后期处理</mark> (Post-processing) 效果。</p>\n<h3 id=\"后期处理\"><a class=\"anchor\" href=\"#后期处理\">#</a> 后期处理</h3>\n<p>既然整个场景都被渲染到了一个纹理上，我们可以简单地通过修改纹理数据创建出一些非常有意思的效果。在这一部分中，我们将会向你展示一些流行的后期处理效果，并告诉你改如何使用创造力创建你自己的效果。</p>\n<p>让我们先从最简单的后期处理效果开始。</p>\n<h4 id=\"反相\"><a class=\"anchor\" href=\"#反相\">#</a> 反相</h4>\n<p>我们现在能够访问渲染输出的每个颜色，所以在（译注：屏幕的）片段着色器中返回这些颜色的反相 (Inversion) 并不是很难。我们将会从屏幕纹理中取颜色值，然后用 1.0 减去它，对它进行反相：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span> <span class=\"token operator\">-</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>screenTexture<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>尽管反相是一个相对简单的后期处理效果，它已经能创造一些奇怪的效果了：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/05/framebuffers_inverse.png\" alt=\"image\" /></p>\n<h4 id=\"灰度\"><a class=\"anchor\" href=\"#灰度\">#</a> 灰度</h4>\n<p>另外一个很有趣的效果是，移除场景中除了黑白灰以外所有的颜色，让整个图像灰度化 (Grayscale)。很简单的实现方式是，取所有的颜色分量，将它们平均化：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>screenTexture<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">float</span> average <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>FragColor<span class=\"token punctuation\">.</span>r <span class=\"token operator\">+</span> FragColor<span class=\"token punctuation\">.</span>g <span class=\"token operator\">+</span> FragColor<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">3.0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>average<span class=\"token punctuation\">,</span> average<span class=\"token punctuation\">,</span> average<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><img data-src=\"https://learnopengl-cn.github.io/img/04/05/framebuffers_grayscale.png\" alt=\"image\" /></p>\n<h4 id=\"核效果\"><a class=\"anchor\" href=\"#核效果\">#</a> 核效果</h4>\n<p>在一个纹理图像上做后期处理的另外一个好处是，我们可以从纹理的其它地方采样颜色值。比如说我们可以在当前纹理坐标的周围取一小块区域，对当前纹理值周围的多个纹理值进行采样。我们可以结合它们创建出很有意思的效果。</p>\n<p><mark>核</mark> (Kernel)（或卷积矩阵 (Convolution Matrix)）是一个类矩阵的数值数组，它的中心为当前的像素，它会用它的核值乘以周围的像素值，并将结果相加变成一个值。所以，基本上我们是在对当前像素周围的纹理坐标添加一个小的偏移量，并根据核将结果合并。下面是核的一个例子：</p>\n<pre><code class=\"language-math\">\\begin&#123;bmatrix&#125;\n   2 &amp; 2 &amp; 2 \\\\\n   2 &amp; -15 &amp; 2 \\\\\n   2 &amp; 2 &amp; 2\n\\end&#123;bmatrix&#125;\n</code></pre>\n<p>这个核取了 8 个周围像素值，将它们乘以 2，而把当前的像素乘以 - 15。这个核的例子将周围的像素乘上了一个权重，并将当前像素乘以一个比较大的负权重来平衡结果。</p>\n<blockquote>\n<p>你在网上找到的大部分核将所有的权重加起来之后都应该会等于 1，如果它们加起来不等于 1，这就意味着最终的纹理颜色将会比原纹理值更亮或者更暗了。</p>\n</blockquote>\n<p>核是后期处理一个非常有用的工具，它们使用和实验起来都很简单，网上也能找到很多例子。我们需要稍微修改一下片段着色器，让它能够支持核。我们假设使用的核都是 3x3 核（实际上大部分核都是）</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">const</span> <span class=\"token keyword\">float</span> offset <span class=\"token operator\">=</span> <span class=\"token number\">1.0</span> <span class=\"token operator\">/</span> <span class=\"token number\">300.0</span><span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    vec2 offsets<span class=\"token punctuation\">[</span><span class=\"token number\">9</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> vec2<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token function\">vec2</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>offset<span class=\"token punctuation\">,</span>  offset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 左上</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token function\">vec2</span><span class=\"token punctuation\">(</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>    offset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 正上</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token function\">vec2</span><span class=\"token punctuation\">(</span> offset<span class=\"token punctuation\">,</span>  offset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 右上</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token function\">vec2</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>offset<span class=\"token punctuation\">,</span>  <span class=\"token number\">0.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>   <span class=\"token comment\">// 左</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token function\">vec2</span><span class=\"token punctuation\">(</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>    <span class=\"token number\">0.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>   <span class=\"token comment\">// 中</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token function\">vec2</span><span class=\"token punctuation\">(</span> offset<span class=\"token punctuation\">,</span>  <span class=\"token number\">0.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>   <span class=\"token comment\">// 右</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token function\">vec2</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>offset<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span>offset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 左下</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token function\">vec2</span><span class=\"token punctuation\">(</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>   <span class=\"token operator\">-</span>offset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 正下</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token function\">vec2</span><span class=\"token punctuation\">(</span> offset<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span>offset<span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 右下</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token keyword\">float</span> kernel<span class=\"token punctuation\">[</span><span class=\"token number\">9</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">float</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    vec3 sampleTex<span class=\"token punctuation\">[</span><span class=\"token number\">9</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">9</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        sampleTex<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>screenTexture<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">.</span>st <span class=\"token operator\">+</span> offsets<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    vec3 col <span class=\"token operator\">=</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">9</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>        col <span class=\"token operator\">+=</span> sampleTex<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> kernel<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>col<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在片段着色器中，我们首先为周围的纹理坐标创建了一个 9 个 vec2 偏移量的数组。偏移量是一个常量，你可以按照你的喜好自定义它。之后我们定义一个核，在这个例子中是一个<mark>锐化 (Sharpen) 核</mark>，它会采样周围的所有像素，锐化每个颜色值。最后，在采样时我们将每个偏移量加到当前纹理坐标上，获取需要采样的纹理，之后将这些纹理值乘以加权的核值，并将它们加到一起。</p>\n<p>这个锐化核看起来是这样的：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/05/framebuffers_sharpen.png\" alt=\"image\" /></p>\n<h4 id=\"模糊\"><a class=\"anchor\" href=\"#模糊\">#</a> 模糊</h4>\n<p>创建模糊 (Blur) 效果的核是这样的：</p>\n<pre><code class=\"language-math\">\\begin&#123;bmatrix&#125;\n   1 &amp; 2 &amp; 1 \\\\\n   2 &amp; 4 &amp; 2 \\\\\n   1 &amp; 2 &amp; 1\n\\end&#123;bmatrix&#125;\n/16\n</code></pre>\n<p>由于所有值的和是 16，所以直接返回合并的采样颜色将产生非常亮的颜色，所以我们需要将核的每个值都除以 16。最终的核数组将会是：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> kernel<span class=\"token punctuation\">[</span><span class=\"token number\">9</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">float</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token number\">1.0</span> <span class=\"token operator\">/</span> <span class=\"token number\">16</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2.0</span> <span class=\"token operator\">/</span> <span class=\"token number\">16</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span> <span class=\"token operator\">/</span> <span class=\"token number\">16</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token number\">2.0</span> <span class=\"token operator\">/</span> <span class=\"token number\">16</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4.0</span> <span class=\"token operator\">/</span> <span class=\"token number\">16</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2.0</span> <span class=\"token operator\">/</span> <span class=\"token number\">16</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token number\">1.0</span> <span class=\"token operator\">/</span> <span class=\"token number\">16</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2.0</span> <span class=\"token operator\">/</span> <span class=\"token number\">16</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span> <span class=\"token operator\">/</span> <span class=\"token number\">16</span>  </pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>通过在片段着色器中改变核的 float 数组，我们完全改变了后期处理效果。它现在看起来是这样子的：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/05/framebuffers_blur.png\" alt=\"image\" /></p>\n<p>这样的模糊效果创造了很多的可能性。我们可以随着时间修改模糊的量，创造出玩家醉酒时的效果，或者在主角没带眼镜的时候增加模糊。模糊也能够让我们来平滑颜色值，我们将在之后教程中使用到。</p>\n<p>你可以看到，只要我们有了这个核的实现，创建炫酷的后期处理特效是非常容易的事。我们再来看最后一个很流行的效果来结束本节的讨论。</p>\n<h4 id=\"边缘检测\"><a class=\"anchor\" href=\"#边缘检测\">#</a> 边缘检测</h4>\n<p>下面的边缘检测 (Edge-detection) 核和锐化核非常相似：</p>\n<pre><code class=\"language-math\">\\begin&#123;bmatrix&#125;\n   1 &amp; 1 &amp; 1 \\\\\n   1 &amp; -8 &amp; 1 \\\\\n   1 &amp; 1 &amp; 1\n\\end&#123;bmatrix&#125;\n</code></pre>\n<p>这个核高亮了所有的边缘，而暗化了其它部分，在我们只关心图像的边角的时候是非常有用的。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/05/framebuffers_edge_detection.png\" alt=\"image\" /></p>\n<p>你可能不会奇怪，像是 Photoshop 这样的图像修改工具 / 滤镜使用的也是这样的核。因为显卡处理片段的时候有着极强的并行处理能力，我们可以很轻松地在实时的情况下逐像素对图像进行处理。所以图像编辑工具在图像处理的时候会更倾向于使用显卡。</p>\n<blockquote>\n<p>注意，核在对屏幕纹理的边缘进行采样的时候，由于还会对中心像素周围的 8 个像素进行采样，其实会取到纹理之外的像素。由于环绕方式默认是 GL_REPEAT，所以在没有设置的情况下取到的是屏幕另一边的像素，而另一边的像素本不应该对中心像素产生影响，这就可能会在屏幕边缘产生很奇怪的条纹。为了消除这一问题，我们可以将屏幕纹理的环绕方式都设置为 GL_CLAMP_TO_EDGE。这样子在取到纹理外的像素时，就能够重复边缘的像素来更精确地估计最终的值了。</p>\n</blockquote>\n<h2 id=\"立方体贴图\"><a class=\"anchor\" href=\"#立方体贴图\">#</a> 立方体贴图</h2>\n<p>我们已经使用 2D 纹理很长时间了，但除此之外仍有更多的纹理类型等着我们探索。在本节中，我们将讨论的是将多个纹理组合起来映射到一张纹理上的一种纹理类型：立方体贴图 (Cube Map)。</p>\n<p>简单来说，立方体贴图就是一个包含了 6 个 2D 纹理的纹理，每个 2D 纹理都组成了立方体的一个面：一个有纹理的立方体。你可能会奇怪，这样一个立方体有什么用途呢？为什么要把 6 张纹理合并到一张纹理中，而不是直接使用 6 个单独的纹理呢？立方体贴图有一个非常有用的特性，它可以<mark>通过一个方向向量</mark>来进行<mark>索引 / 采样</mark>。假设我们有一个 1x1x1 的单位立方体，方向向量的原点位于它的中心。使用一个橘黄色的方向向量来从立方体贴图上采样一个纹理值会像是这样：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/06/cubemaps_sampling.png\" alt=\"image\" /></p>\n<blockquote>\n<p>方向向量的<mark>大小并不重要</mark>，只要提供了方向，OpenGL 就会获取方向向量（最终）所击中的纹素，并返回对应的采样纹理值。</p>\n</blockquote>\n<p>如果我们假设将这样的立方体贴图应用到一个立方体上，采样立方体贴图所使用的方向向量将和立方体（插值的）顶点位置非常相像。这样子，只要立方体的中心位于原点，我们就能使用立方体的实际位置向量来对立方体贴图进行采样了。接下来，我们可以将所有顶点的纹理坐标当做是立方体的顶点位置。最终得到的结果就是可以访问立方体贴图上正确<mark>面 (Face) 纹理</mark>的一个纹理坐标。</p>\n<h3 id=\"创建立方体贴图\"><a class=\"anchor\" href=\"#创建立方体贴图\">#</a> 创建立方体贴图</h3>\n<p>立方体贴图是和其它纹理一样的，所以如果想创建一个立方体贴图的话，我们需要生成一个纹理，并将其绑定到纹理目标上，之后再做其它的纹理操作。这次要绑定到<mark> GL_TEXTURE_CUBE_MAP</mark>：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> textureID<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glGenTextures</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>textureID<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE_CUBE_MAP<span class=\"token punctuation\">,</span> textureID<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>因为立方体贴图包含有 6 个纹理，每个面一个，我们需要调用 glTexImage2D 函数<mark> 6 次</mark>，参数和之前教程中很类似。但这一次我们将纹理目标 (target) 参数设置为立方体贴图的一个特定的面，告诉 OpenGL 我们在对立方体贴图的哪一个面创建纹理。这就意味着我们需要对立方体贴图的每一个面都调用一次 glTexImage2D。</p>\n<p>由于我们有 6 个面，OpenGL 给我们提供了 6 个特殊的纹理目标，专门对应立方体贴图的一个面。</p>\n<table>\n<thead>\n<tr>\n<th>纹理目标</th>\n<th>方位</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_TEXTURE_CUBE_MAP_POSITIVE_X</td>\n<td>右</td>\n</tr>\n<tr>\n<td>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</td>\n<td>左</td>\n</tr>\n<tr>\n<td>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</td>\n<td>上</td>\n</tr>\n<tr>\n<td>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</td>\n<td>下</td>\n</tr>\n<tr>\n<td>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</td>\n<td>后</td>\n</tr>\n<tr>\n<td>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</td>\n<td>前</td>\n</tr>\n</tbody>\n</table>\n<p>和 OpenGL 的很多枚举 (Enum) 一样，它们背后的 int 值是线性<mark>递增</mark>的，所以如果我们有一个纹理位置的数组或者 vector，我们就可以从<mark> GL_TEXTURE_CUBE_MAP_POSITIVE_X</mark> 开始<mark>遍历</mark>它们，在每个迭代中对枚举值加 1，遍历了整个纹理目标：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">,</span> nrChannels<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>data<span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> textures_faces<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    data <span class=\"token operator\">=</span> <span class=\"token function\">stbi_load</span><span class=\"token punctuation\">(</span>textures_faces<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">c_str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>width<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>height<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>nrChannels<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token function\">glTexImage2D</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        GL_TEXTURE_CUBE_MAP_POSITIVE_X <span class=\"token operator\">+</span> i<span class=\"token punctuation\">,</span> </pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> GL_RGB<span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> GL_RGB<span class=\"token punctuation\">,</span> GL_UNSIGNED_BYTE<span class=\"token punctuation\">,</span> data</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这里我们有一个叫做 textures_faces 的 vector，它包含了立方体贴图所需的所有纹理路径，并以表中的顺序排列。这将为当前绑定的立方体贴图中的每个面生成一个纹理。</p>\n<p>因为立方体贴图和其它纹理没什么不同，我们也需要设定它的环绕和过滤方式：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_CUBE_MAP<span class=\"token punctuation\">,</span> GL_TEXTURE_MAG_FILTER<span class=\"token punctuation\">,</span> GL_LINEAR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_CUBE_MAP<span class=\"token punctuation\">,</span> GL_TEXTURE_MIN_FILTER<span class=\"token punctuation\">,</span> GL_LINEAR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_CUBE_MAP<span class=\"token punctuation\">,</span> GL_TEXTURE_WRAP_S<span class=\"token punctuation\">,</span> GL_CLAMP_TO_EDGE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_CUBE_MAP<span class=\"token punctuation\">,</span> GL_TEXTURE_WRAP_T<span class=\"token punctuation\">,</span> GL_CLAMP_TO_EDGE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_CUBE_MAP<span class=\"token punctuation\">,</span> GL_TEXTURE_WRAP_R<span class=\"token punctuation\">,</span> GL_CLAMP_TO_EDGE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>不要被 GL_TEXTURE_WRAP_R 吓到，它仅仅是为纹理的 R 坐标设置了环绕方式，它对应的是纹理的第三个维度（和位置的 z 一样）。我们将环绕方式设置为 GL_CLAMP_TO_EDGE，这是因为正好处于两个面之间的纹理坐标可能不能击中一个面（由于一些硬件限制），所以通过使用 GL_CLAMP_TO_EDGE，OpenGL 将在我们对<mark>两个面之间采样</mark>的时候，永远返回它们的<mark>边界值</mark>。</p>\n<p>在绘制使用立方体贴图的物体之前，我们要先激活对应的纹理单元，并绑定立方体贴图，这和普通的 2D 纹理没什么区别。</p>\n<p>在片段着色器中，我们使用了一个不同类型的采样器，samplerCube，我们将使用 texture 函数使用它进行采样，但这次我们将使用一个 vec3 的方向向量而不是 vec2。使用立方体贴图的片段着色器会像是这样的：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>in vec3 textureDir<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 代表 3D 纹理坐标的方向向量</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>uniform samplerCube cubemap<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 立方体贴图的纹理采样器</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#123;</span>             </pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>cubemap<span class=\"token punctuation\">,</span> textureDir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>看起来很棒，但为什么要用它呢？恰巧有一些很有意思的技术，使用立方体贴图来实现的话会简单多了。其中一个技术就是创建一个<mark>天空盒</mark> (Skybox)。</p>\n<h3 id=\"天空盒\"><a class=\"anchor\" href=\"#天空盒\">#</a> 天空盒</h3>\n<p>天空盒是一个包含了整个场景的（大）立方体，它包含周围环境的 6 个图像，让玩家以为他处在一个比实际大得多的环境当中。游戏中使用天空盒的例子有群山、白云或星空。下面这张截图中展示的是星空的天空盒，它来自于『上古卷轴 3』：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/06/cubemaps_morrowind.jpg\" alt=\"image\" /></p>\n<p>你可能现在已经猜到了，立方体贴图能完美满足天空盒的需求：我们有一个 6 面的立方体，每个面都需要一个纹理。在上面的图片中，他们使用了夜空的几张图片，让玩家产生其位于广袤宇宙中的错觉，但实际上他只是在一个小小的盒子当中。</p>\n<p>你可以在网上找到很多像这样的天空盒资源。比如说<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5jdXN0b21tYXBtYWtlcnMub3JnL3NreWJveGVzLnBocA==\">这个网站</span>就提供了很多天空盒。天空盒图像通常有以下的形式：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/06/cubemaps_skybox.png\" alt=\"image\" /></p>\n<p>如果你将这六个面折成一个立方体，你就会得到一个完全贴图的立方体，模拟一个巨大的场景。一些资源可能会提供了这样格式的天空盒，你必须手动提取六个面的图像，但在大部分情况下它们都是 6 张单独的纹理图像。</p>\n<p>之后我们将在场景中使用这个（高质量的）天空盒。</p>\n<h3 id=\"加载天空盒\"><a class=\"anchor\" href=\"#加载天空盒\">#</a> 加载天空盒</h3>\n<p>因为天空盒本身就是一个立方体贴图，加载天空盒和之前加载立方体贴图时并没有什么不同。为了加载天空盒，我们将使用下面的函数，它接受一个包含 6 个纹理路径的 vector：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> <span class=\"token function\">loadCubemap</span><span class=\"token punctuation\">(</span>vector<span class=\"token operator\">&lt;</span>std<span class=\"token operator\">::</span>string<span class=\"token operator\">></span> faces<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> textureID<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token function\">glGenTextures</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>textureID<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE_CUBE_MAP<span class=\"token punctuation\">,</span> textureID<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">int</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">,</span> nrChannels<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> faces<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>data <span class=\"token operator\">=</span> <span class=\"token function\">stbi_load</span><span class=\"token punctuation\">(</span>faces<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">c_str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>width<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>height<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>nrChannels<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            <span class=\"token function\">glTexImage2D</span><span class=\"token punctuation\">(</span>GL_TEXTURE_CUBE_MAP_POSITIVE_X <span class=\"token operator\">+</span> i<span class=\"token punctuation\">,</span> </pre></td></tr><tr><td data-num=\"14\"></td><td><pre>                         <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> GL_RGB<span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> GL_RGB<span class=\"token punctuation\">,</span> GL_UNSIGNED_BYTE<span class=\"token punctuation\">,</span> data</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>            <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>            <span class=\"token function\">stbi_image_free</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        <span class=\"token keyword\">else</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>            std<span class=\"token operator\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Cubemap texture failed to load at path: \"</span> <span class=\"token operator\">&lt;&lt;</span> faces<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token operator\">::</span>endl<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>            <span class=\"token function\">stbi_image_free</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_CUBE_MAP<span class=\"token punctuation\">,</span> GL_TEXTURE_MIN_FILTER<span class=\"token punctuation\">,</span> GL_LINEAR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_CUBE_MAP<span class=\"token punctuation\">,</span> GL_TEXTURE_MAG_FILTER<span class=\"token punctuation\">,</span> GL_LINEAR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_CUBE_MAP<span class=\"token punctuation\">,</span> GL_TEXTURE_WRAP_S<span class=\"token punctuation\">,</span> GL_CLAMP_TO_EDGE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_CUBE_MAP<span class=\"token punctuation\">,</span> GL_TEXTURE_WRAP_T<span class=\"token punctuation\">,</span> GL_CLAMP_TO_EDGE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token function\">glTexParameteri</span><span class=\"token punctuation\">(</span>GL_TEXTURE_CUBE_MAP<span class=\"token punctuation\">,</span> GL_TEXTURE_WRAP_R<span class=\"token punctuation\">,</span> GL_CLAMP_TO_EDGE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    <span class=\"token keyword\">return</span> textureID<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>函数本身应该很熟悉了。它基本就是上一部分中立方体贴图的代码，只不过合并到了一个便于管理的函数中。</p>\n<p>之后，在调用这个函数之前，我们需要将合适的纹理路径按照立方体贴图枚举指定的顺序加载到一个 vector 中。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vector<span class=\"token operator\">&lt;</span>std<span class=\"token operator\">::</span>string<span class=\"token operator\">></span> faces</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token string\">\"right.jpg\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token string\">\"left.jpg\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token string\">\"top.jpg\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token string\">\"bottom.jpg\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token string\">\"front.jpg\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token string\">\"back.jpg\"</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> cubemapTexture <span class=\"token operator\">=</span> <span class=\"token function\">loadCubemap</span><span class=\"token punctuation\">(</span>faces<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>现在我们就将这个天空盒加载为一个立方体贴图了，它的 id 是 cubemapTexture。我们可以将它绑定到一个立方体中，替换掉用了很长时间的难看的纯色背景。</p>\n<h3 id=\"显示天空盒\"><a class=\"anchor\" href=\"#显示天空盒\">#</a> 显示天空盒</h3>\n<p>由于天空盒是绘制在一个立方体上的，和其它物体一样，我们需要另一个 VAO、VBO 以及新的一组顶点。</p>\n<p>用于贴图 3D 立方体的立方体贴图可以使用立方体的位置作为纹理坐标来采样。当立方体处于原点 (0, 0, 0) 时，它的每一个位置向量都是从原点出发的方向向量。这个方向向量正是获取立方体上特定位置的纹理值所需要的。正是因为这个，我们只需要提供位置向量而不用纹理坐标了。</p>\n<p>要渲染天空盒的话，我们需要一组新的着色器，它们都不是很复杂。因为我们只有一个顶点属性，顶点着色器非常简单：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> in vec3 aPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>out vec3 TexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>uniform mat4 projection<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>uniform mat4 view<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    TexCoords <span class=\"token operator\">=</span> aPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> projection <span class=\"token operator\">*</span> view <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>aPos<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>注意，顶点着色器中很有意思的部分是，我们将输入的位置向量作为输出给片段着色器的纹理坐标。片段着色器会将它作为输入来采样 samplerCube：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>out vec4 FragColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>in vec3 TexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>uniform samplerCube skybox<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#123;</span>    </pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>skybox<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>片段着色器非常直观。我们将顶点属性的位置向量作为纹理的方向向量，并使用它从立方体贴图中采样纹理值。</p>\n<p>有了立方体贴图纹理，渲染天空盒现在就非常简单了，我们只需要绑定立方体贴图纹理，skybox 采样器就会自动填充上天空盒立方体贴图了。绘制天空盒时，我们需要将它变为场景中的<mark>第一个渲染的物体</mark>，并且禁用深度写入。这样子天空盒就会永远被绘制在其它物体的背后了。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glDepthMask</span><span class=\"token punctuation\">(</span>GL_FALSE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>skyboxShader<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">//... 设置观察和投影矩阵</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glBindVertexArray</span><span class=\"token punctuation\">(</span>skyboxVAO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE_CUBE_MAP<span class=\"token punctuation\">,</span> cubemapTexture<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">glDrawArrays</span><span class=\"token punctuation\">(</span>GL_TRIANGLES<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">36</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">glDepthMask</span><span class=\"token punctuation\">(</span>GL_TRUE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">//... 绘制剩下的场景</span></pre></td></tr></table></figure><p>如果你运行一下的话你就会发现出现了一些问题。我们希望天空盒是以玩家为中心的，这样不论玩家移动了多远，天空盒都不会变近，让玩家产生周围环境非常大的印象。然而，当前的观察矩阵会旋转、缩放和位移来变换天空盒的所有位置，所以当玩家移动的时候，立方体贴图也会移动！我们希望移除观察矩阵中的位移部分，让移动不会影响天空盒的位置向量。</p>\n<p>你可能还记得在基础光照小节中，我们通过取 4x4 矩阵左上角的 3x3 矩阵来<mark>移除</mark>变换矩阵的<mark>位移部分</mark>。我们可以将观察矩阵转换为 3x3 矩阵（移除位移），再将其转换回 4x4 矩阵，来达到类似的效果。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span>mat4 view <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">mat4</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">mat3</span><span class=\"token punctuation\">(</span>camera<span class=\"token punctuation\">.</span><span class=\"token function\">GetViewMatrix</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这将移除任何的位移，但保留旋转变换，让玩家仍然能够环顾场景。</p>\n<p>有了天空盒，最终的效果就是一个看起来巨大的场景了。如果你在箱子周围转一转，你就能立刻感受到距离感，极大地提升了场景的真实度。最终的结果看起来是这样的：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/06/cubemaps_skybox_result.png\" alt=\"image\" /></p>\n<h3 id=\"优化\"><a class=\"anchor\" href=\"#优化\">#</a> 优化</h3>\n<p>目前我们是首先渲染天空盒，之后再渲染场景中的其它物体。这样子能够工作，但不是非常高效。如果我们先渲染天空盒，我们就会对屏幕上的每一个像素运行一遍片段着色器，即便只有一小部分的天空盒最终是可见的。可以使用<mark>提前深度测试</mark> (Early Depth Testing) 轻松丢弃掉的片段能够节省我们很多宝贵的带宽。</p>\n<p>所以，我们将会<mark>最后渲染天空盒</mark>，以获得轻微的性能提升。这样子的话，深度缓冲就会填充满所有物体的深度值了，我们只需要在提前深度测试通过的地方渲染天空盒的片段就可以了，很大程度上减少了片段着色器的调用。问题是，天空盒只是一个 1x1x1 的立方体，它很可能会不通过大部分的深度测试，导致渲染失败。不用深度测试来进行渲染不是解决方案，因为天空盒将会复写场景中的其它物体。我们需要欺骗深度缓冲，让它认为天空盒有着最大的深度值 1.0，只要它前面有一个物体，深度测试就会失败。</p>\n<p>在坐标系统小节中我们说过，<mark>透视除法</mark>是在顶点着色器运行之后执行的，将 gl_Position 的 xyz 坐标除以 w 分量。我们又从深度测试小节中知道，相除结果的 z 分量等于顶点的深度值。使用这些信息，我们可以将输出位置的 z 分量等于它的 w 分量，让 z 分量永远等于 1.0，这样子的话，当透视除法执行之后，z 分量会变为 w /w = 1.0。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    TexCoords <span class=\"token operator\">=</span> aPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    vec4 pos <span class=\"token operator\">=</span> projection <span class=\"token operator\">*</span> view <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>aPos<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> pos<span class=\"token punctuation\">.</span>xyww<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>最终的标准化设备坐标将永远会有一个等于 1.0 的 z 值：最大的深度值。结果就是天空盒只会在没有可见物体的地方渲染了（只有这样才能通过深度测试，其它所有的东西都在天空盒前面）。</p>\n<p>我们还要改变一下深度函数，将它从默认的<mark> GL_LESS</mark> 改为<mark> GL_LEQUAL</mark>。深度缓冲将会填充上天空盒的 1.0 值，所以我们需要保证天空盒在值小于或等于深度缓冲而不是小于时通过深度测试。</p>\n<h3 id=\"环境映射\"><a class=\"anchor\" href=\"#环境映射\">#</a> 环境映射</h3>\n<p>我们现在将整个环境映射到了一个纹理对象上了，能利用这个信息的不仅仅只有天空盒。通过使用环境的立方体贴图，我们可以给物体反射和折射的属性。这样使用环境立方体贴图的技术叫做<mark>环境映射</mark> (Environment Mapping)，其中最流行的两个是<mark>反射</mark> (Reflection) 和<mark>折射</mark> (Refraction)。</p>\n<h3 id=\"反射\"><a class=\"anchor\" href=\"#反射\">#</a> 反射</h3>\n<p>反射这个属性表现为物体（或物体的一部分）反射它周围环境，即根据观察者的视角，物体的颜色或多或少等于它的环境。镜子就是一个反射性物体：它会根据观察者的视角反射它周围的环境。</p>\n<p>反射的原理并不难。下面这张图展示了我们如何计算反射向量，并如何使用这个向量来从立方体贴图中采样：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/06/cubemaps_reflection_theory.png\" alt=\"image\" /></p>\n<p>我们根据观察<mark>方向向量 I</mark> 和物体的<mark>法向量 N</mark>，来计算<mark>反射向量 R</mark>。我们可以使用 GLSL 内建的 reflect 函数来计算这个反射向量。最终的 R 向量将会作为索引 / 采样立方体贴图的方向向量，返回环境的颜色值。最终的结果是物体看起来反射了天空盒。</p>\n<p>因为我们已经在场景中配置好天空盒了，创建反射效果并不会很难。我们将会改变箱子的片段着色器，让箱子有反射性：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>out vec4 FragColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>in vec3 Normal<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>in vec3 Position<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>uniform vec3 cameraPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>uniform samplerCube skybox<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#123;</span>             </pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    vec3 I <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>Position <span class=\"token operator\">-</span> cameraPos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    vec3 R <span class=\"token operator\">=</span> <span class=\"token function\">reflect</span><span class=\"token punctuation\">(</span>I<span class=\"token punctuation\">,</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>Normal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span><span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>skybox<span class=\"token punctuation\">,</span> R<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>rgb<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们先计算了观察 / 摄像机方向向量 I，并使用它来计算反射向量 R，之后我们将使用 R 来从天空盒立方体贴图中采样。注意，我们现在又有了片段的插值 Normal 和 Position 变量，所以我们需要更新一下顶点着色器。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> in vec3 aPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> in vec3 aNormal<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>out vec3 Normal<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>out vec3 Position<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>uniform mat4 model<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>uniform mat4 view<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>uniform mat4 projection<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    Normal <span class=\"token operator\">=</span> <span class=\"token function\">mat3</span><span class=\"token punctuation\">(</span><span class=\"token function\">transpose</span><span class=\"token punctuation\">(</span><span class=\"token function\">inverse</span><span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> aNormal<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    Position <span class=\"token operator\">=</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span>model <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>aPos<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> projection <span class=\"token operator\">*</span> view <span class=\"token operator\">*</span> model <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>aPos<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们现在使用了一个法向量，所以我们将再次使用法线矩阵 (Normal Matrix) 来变换它们。Position 输出向量是一个世界空间的位置向量。顶点着色器的这个 Position 输出将用来在片段着色器内计算观察方向向量。</p>\n<p>因为我们使用了法线，你还需要更新一下<mark>顶点数据</mark>，并更新属性指针。还要记得去设置 cameraPos 这个 uniform。</p>\n<p>接下来，我们在渲染箱子之前先绑定立方体贴图纹理：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glBindVertexArray</span><span class=\"token punctuation\">(</span>cubeVAO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE_CUBE_MAP<span class=\"token punctuation\">,</span> skyboxTexture<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>          </pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glDrawArrays</span><span class=\"token punctuation\">(</span>GL_TRIANGLES<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">36</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>编译并运行代码，你将会得到一个像是镜子一样的箱子。周围的天空盒被完美地反射在箱子上。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/06/cubemaps_reflection.png\" alt=\"image\" /></p>\n<p>当反射应用到一整个物体上（像是箱子）时，这个物体看起来就像是钢或者铬这样的高反射性材质。如果我们加载模型加载小节中的纳米装模型，我们会得到一种整个套装都是使用铬做成的效果：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/06/cubemaps_reflection_nanosuit.png\" alt=\"image\" /></p>\n<p>这看起来非常棒，但在现实中大部分的模型都不具有<mark>完全反射性</mark>。我们可以引入<mark>反射贴图</mark> (Reflection Map)，来给模型更多的细节。与漫反射和镜面光贴图一样，反射贴图也是可以采样的纹理图像，它决定这片段的反射性。通过使用反射贴图，我们可以知道模型的哪些部分该以什么强度显示反射。在本节的练习中，将由你来为我们之前创建的模型加载器中引入反射贴图，显著提升纳米装模型的细节。</p>\n<h3 id=\"折射\"><a class=\"anchor\" href=\"#折射\">#</a> 折射</h3>\n<p>环境映射的另一种形式是折射，它和反射很相似。折射是光线由于传播介质的改变而产生的方向变化。在常见的类水表面上所产生的现象就是折射，光线不是直直地传播，而是弯曲了一点。将你的半只胳膊伸进水里，观察出来的就是这种效果。</p>\n<p>折射是通过<mark>斯涅尔定律</mark> (Snell’s Law) 来描述的，使用环境贴图的话看起来像是这样：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/06/cubemaps_refraction_theory.png\" alt=\"image\" /></p>\n<p>同样，我们有一个<mark>观察向量 I</mark>，一个<mark>法向量 N</mark>，而这次是<mark>折射向量 R</mark>。可以看到，观察向量的方向轻微弯曲了。弯折后的向量 R 将会用来从立方体贴图中采样。</p>\n<p>折射可以使用 GLSL 的内建 refract 函数来轻松实现，它需要一个法向量、一个观察方向和两个材质之间的折射率 (Refractive Index)。</p>\n<p>折射率决定了材质中光线弯曲的程度，每个材质都有自己的折射率。一些最常见的折射率可以在下表中找到：</p>\n<table>\n<thead>\n<tr>\n<th>材质</th>\n<th>折射率</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>空气</td>\n<td>1.00</td>\n</tr>\n<tr>\n<td>水</td>\n<td>1.33</td>\n</tr>\n<tr>\n<td>冰</td>\n<td>1.309</td>\n</tr>\n<tr>\n<td>玻璃</td>\n<td>1.52</td>\n</tr>\n<tr>\n<td>钻石</td>\n<td>2.42</td>\n</tr>\n</tbody>\n</table>\n<p>我们使用这些折射率来计算光传播的两种材质间的比值。在我们的例子中，光线 / 视线从空气进入玻璃（如果我们假设箱子是玻璃制的），所以比值为 1.00/1.52=0.658。</p>\n<p>我们已经绑定了立方体贴图，提供了顶点数据和法线，并设置了摄像机位置的 uniform。唯一要修改的就是片段着色器：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span>             </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">float</span> ratio <span class=\"token operator\">=</span> <span class=\"token number\">1.00</span> <span class=\"token operator\">/</span> <span class=\"token number\">1.52</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    vec3 I <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>Position <span class=\"token operator\">-</span> cameraPos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    vec3 R <span class=\"token operator\">=</span> <span class=\"token function\">refract</span><span class=\"token punctuation\">(</span>I<span class=\"token punctuation\">,</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span>Normal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> ratio<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span><span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>skybox<span class=\"token punctuation\">,</span> R<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>rgb<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>通过改变折射率，你可以创建完全不同的视觉效果。编译程序并运行，但结果并不是很有趣，因为我们只使用了一个简单的箱子，它不太能显示折射的效果，现在看起来只是有点像一个放大镜。对纳米装使用相同的着色器却能够展现出了我们期待的效果：一个类玻璃的物体。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/06/cubemaps_refraction.png\" alt=\"image\" /></p>\n<p>你可以想象出有了光照、反射、折射和顶点移动的正确组合，你可以创建出非常漂亮的水。注意，如果要想获得物理上精确的结果，我们还需要在光线离开物体的时候再次折射，现在我们使用的只是<mark>单面折射</mark> (Single-side Refraction)，但它对大部分场合都是没问题的。</p>\n<h3 id=\"动态环境贴图\"><a class=\"anchor\" href=\"#动态环境贴图\">#</a> 动态环境贴图</h3>\n<p>现在我们使用的都是静态图像的组合来作为天空盒，看起来很不错，但它没有在场景中包括可移动的物体。我们一直都没有注意到这一点，因为我们只使用了一个物体。如果我们有一个镜子一样的物体，周围还有多个物体，镜子中可见的只有天空盒，看起来就像它是场景中唯一一个物体一样。</p>\n<p>通过使用帧缓冲，我们能够为物体的 6 个不同角度创建出场景的纹理，并在每个渲染迭代中将它们储存到一个立方体贴图中。之后我们就可以使用这个（动态生成的）立方体贴图来创建出更真实的，包含其它物体的，反射和折射表面了。这就叫做<mark>动态环境映射</mark> (Dynamic Environment Mapping)，因为我们动态创建了物体周围的立方体贴图，并将其用作环境贴图。</p>\n<p>虽然它看起来很棒，但它有一个很大的缺点：我们需要为使用环境贴图的物体渲染场景 6 次，这是对程序是非常大的性能开销。现代的程序通常会尽可能使用天空盒，并在可能的时候使用预编译的立方体贴图，只要它们能产生一点动态环境贴图的效果。虽然动态环境贴图是一个很棒的技术，但是要想在不降低性能的情况下让它工作还是需要非常多的技巧的。</p>\n<h2 id=\"高级数据\"><a class=\"anchor\" href=\"#高级数据\">#</a> 高级数据</h2>\n<p>我们在 OpenGL 中大量使用缓冲来储存数据已经有很长时间了。操作缓冲其实还有更有意思的方式，而且使用纹理将大量数据传入着色器也有更有趣的方法。这一节中，我们将讨论一些更有意思的缓冲函数，以及我们该如何使用纹理对象来储存大量的数据（纹理的部分还没有完成）。</p>\n<p>OpenGL 中的缓冲只是一个<mark>管理特定内存块的对象</mark>，没有其它更多的功能了。在我们将它绑定到一个<mark>缓冲目标</mark> (Buffer Target) 时，我们才赋予了其意义。当我们绑定一个缓冲到 GL_ARRAY_BUFFER 时，它就是一个顶点数组缓冲，但我们也可以很容易地将其绑定到 GL_ELEMENT_ARRAY_BUFFER。OpenGL 内部会为每个目标储存一个缓冲，并且会根据目标的不同，以不同的方式处理缓冲。</p>\n<p>到目前为止，我们一直是调用 glBufferData 函数来填充缓冲对象所管理的内存，这个函数会分配一块内存，并将数据添加到这块内存中。如果我们将它的 data 参数设置为 NULL，那么这个函数将只会分配内存，但不进行填充。这在我们需要预留 (Reserve) 特定大小的内存，之后回到这个缓冲一点一点填充的时候会很有用。</p>\n<p>除了使用一次函数调用填充整个缓冲之外，我们也可以使用 glBufferSubData，填充缓冲的特定区域。这个函数需要一个缓冲目标、一个偏移量、数据的大小和数据本身作为它的参数。这个函数不同的地方在于，我们可以<mark>提供一个偏移量</mark>，指定从何处开始填充这个缓冲。这能够让我们插入或者更新缓冲内存的某一部分。要注意的是，缓冲需要有足够的已分配内存，所以对一个缓冲调用 glBufferSubData 之前必须要先调用 glBufferData。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glBufferSubData</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">24</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 范围： [24, 24 + sizeof (data)]</span></pre></td></tr></table></figure><p>将数据导入缓冲的另外一种方法是，请求缓冲内存的指针，直接将数据复制到缓冲当中。通过调用 glMapBuffer 函数，OpenGL 会返回当前绑定缓冲的内存指针，供我们操作：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> data<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.35f</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">// 获取指针</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>ptr <span class=\"token operator\">=</span> <span class=\"token function\">glMapBuffer</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> GL_WRITE_ONLY<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">// 复制数据到内存</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span>ptr<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">// 记得告诉 OpenGL 我们不再需要这个指针了</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token function\">glUnmapBuffer</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>当我们使用 glUnmapBuffer 函数，告诉 OpenGL 我们已经完成指针操作之后，OpenGL 就会知道你已经完成了。在<mark>解除映射</mark> (Unmapping) 之后，指针将会<mark>不再可用</mark>，并且如果 OpenGL 能够成功将您的数据映射到缓冲中，这个函数将会返回 GL_TRUE。</p>\n<p>如果要直接映射数据到缓冲，而不事先将其存储到临时内存中，glMapBuffer 这个函数会很有用。比如说，你可以从文件中读取数据，并直接将它们复制到缓冲内存中。</p>\n<h3 id=\"分批顶点属性\"><a class=\"anchor\" href=\"#分批顶点属性\">#</a> 分批顶点属性</h3>\n<p>通过使用 glVertexAttribPointer，我们能够指定顶点数组缓冲内容的属性布局。在顶点数组缓冲中，我们对属性进行了<mark>交错 (Interleave) 处理</mark>，也就是说，我们将每一个顶点的位置、方向和 / 或纹理坐标紧密放置在一起。既然我们现在已经对缓冲有了更多的了解，我们可以采取另一种方式。</p>\n<p>我们可以做的是，将每一种属性类型的向量数据打包 (Batch) 为一个大的区块，而不是对它们进行交错储存。与交错布局<mark> 123123123123</mark> 不同，我们将采用分批 (Batched) 的方式<mark> 111122223333</mark>。</p>\n<p>当从文件中加载顶点数据的时候，你通常获取到的是一个位置数组、一个法线数组和 / 或一个纹理坐标数组。我们需要花点力气才能将这些数组转化为一个大的交错数据数组。使用分批的方式会是更简单的解决方案，我们可以很容易使用 glBufferSubData 函数实现：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> positions<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">float</span> normals<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">float</span> tex<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// 填充缓冲</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">glBufferSubData</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>positions<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>positions<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">glBufferSubData</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>positions<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>normals<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>normals<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">glBufferSubData</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>positions<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>normals<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>tex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>tex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这样子我们就能直接将属性数组作为一个整体传递给缓冲，而不需要事先处理它们了。我们仍可以将它们合并为一个大的数组，再使用 glBufferData 来填充缓冲，但对于这种工作，使用 glBufferSubData 会更合适一点。</p>\n<p>我们还需要更新顶点属性指针来反映这些改变：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glVertexAttribPointer</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span> <span class=\"token number\">3</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glVertexAttribPointer</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span> <span class=\"token number\">3</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>positions<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glVertexAttribPointer</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>positions<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>normals<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>注意 stride 参数等于顶点属性的大小，因为下一个顶点属性向量能在 3 个（或 2 个）分量之后找到。</p>\n<p>这给了我们设置顶点属性的另一种方法。使用哪种方法都不会对 OpenGL 有什么立刻的好处，它只是设置顶点属性的一种更整洁的方式。具体使用的方法将完全取决于你的喜好与程序类型。</p>\n<h3 id=\"复制缓冲\"><a class=\"anchor\" href=\"#复制缓冲\">#</a> 复制缓冲</h3>\n<p>当你的缓冲已经填充好数据之后，你可能会想与其它的缓冲共享其中的数据，或者想要将缓冲的内容复制到另一个缓冲当中。glCopyBufferSubData 能够让我们相对容易地从<mark>一个缓冲中复制数据到另一个缓冲中</mark>。这个函数的原型如下：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">glCopyBufferSubData</span><span class=\"token punctuation\">(</span>GLenum readtarget<span class=\"token punctuation\">,</span> GLenum writetarget<span class=\"token punctuation\">,</span> GLintptr readoffset<span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>                         GLintptr writeoffset<span class=\"token punctuation\">,</span> GLsizeiptr size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>readtarget 和 writetarget 参数需要填入<mark>复制源</mark>和<mark>复制目标</mark>的缓冲目标。比如说，我们可以将 VERTEX_ARRAY_BUFFER 缓冲复制到 VERTEX_ELEMENT_ARRAY_BUFFER 缓冲，分别将这些缓冲目标设置为读和写的目标。当前绑定到这些缓冲目标的缓冲将会被影响到。</p>\n<p>但如果我们想读写数据的两个不同缓冲都为顶点数组缓冲该怎么办呢？我们不能同时将两个缓冲绑定到同一个缓冲目标上。正是出于这个原因，OpenGL 提供给我们另外两个缓冲目标，叫做 GL_COPY_READ_BUFFER 和 GL_COPY_WRITE_BUFFER。我们接下来就可以将需要的缓冲绑定到这两个缓冲目标上，并将这两个目标作为 readtarget 和 writetarget 参数。</p>\n<p>接下来 glCopyBufferSubData 会从 readtarget 中读取 size 大小的数据，并将其写入 writetarget 缓冲的 writeoffset 偏移量处。下面这个例子展示了如何复制两个顶点数组缓冲：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> vertexData<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_COPY_READ_BUFFER<span class=\"token punctuation\">,</span> vbo1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_COPY_WRITE_BUFFER<span class=\"token punctuation\">,</span> vbo2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glCopyBufferSubData</span><span class=\"token punctuation\">(</span>GL_COPY_READ_BUFFER<span class=\"token punctuation\">,</span> GL_COPY_WRITE_BUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>vertexData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>我们也可以只将 writetarget 缓冲绑定为新的缓冲目标类型之一：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> vertexData<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> vbo1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_COPY_WRITE_BUFFER<span class=\"token punctuation\">,</span> vbo2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glCopyBufferSubData</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> GL_COPY_WRITE_BUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>vertexData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>有了这些关于如何操作缓冲的额外知识，我们已经能够以更有意思的方式使用它们了。当你越深入 OpenGL 时，这些新的缓冲方法将会变得更加有用。在下一节中，在我们讨论 Uniform 缓冲对象 (Uniform Buffer Object) 时，我们将会充分利用 glBufferSubData。</p>\n<h2 id=\"高级glsl\"><a class=\"anchor\" href=\"#高级glsl\">#</a> 高级 GLSL</h2>\n<p>这一小节并不会向你展示非常先进非常酷的新特性，也不会对场景的视觉质量有显著的提高。但是，这一节会或多或少涉及 GLSL 的一些有趣的地方以及一些很棒的技巧，它们可能在今后会帮助到你。简单来说，它们就是在组合使用 OpenGL 和 GLSL 创建程序时的一些最好要知道的东西，和一些会让你生活更加轻松的特性。</p>\n<p>我们将会讨论一些有趣的<mark>内建变量</mark> (Built-in Variable)，管理<mark>着色器</mark><strong>输入</strong>和<strong>输出</strong>的新方式以及一个叫做<mark> Uniform 缓冲对象</mark> (Uniform Buffer Object) 的有用工具。</p>\n<h3 id=\"glsl的内建变量\"><a class=\"anchor\" href=\"#glsl的内建变量\">#</a> GLSL 的内建变量</h3>\n<p>着色器都是最简化的，如果需要当前着色器以外地方的数据的话，我们必须要将数据传进来。我们已经学会使用顶点属性、uniform 和采样器来完成这一任务了。然而，除此之外，GLSL 还定义了另外几个以 gl_为前缀的变量，它们能提供给我们更多的方式来读取 / 写入数据。我们已经在前面教程中接触过其中的两个了：顶点着色器的<mark>输出向量 gl_Position</mark>，和<mark>片段着色器的 gl_FragCoord</mark>。</p>\n<p>我们将会讨论几个有趣的 GLSL 内建输入和输出变量，并会解释它们能够怎样帮助你。注意，我们将不会讨论 GLSL 中存在的所有内建变量，如果你想知道所有的内建变量的话，请查看 OpenGL 的 wiki。</p>\n<h3 id=\"顶点着色器变量\"><a class=\"anchor\" href=\"#顶点着色器变量\">#</a> 顶点着色器变量</h3>\n<p>我们已经见过 gl_Position 了，它是顶点着色器的裁剪空间输出位置向量。如果你想在屏幕上显示任何东西，在顶点着色器中设置 gl_Position 是必须的步骤。这已经是它的全部功能了。</p>\n<h4 id=\"gl_pointsize设置图原大小\"><a class=\"anchor\" href=\"#gl_pointsize设置图原大小\">#</a> gl_PointSize（设置图原大小）</h4>\n<p>我们能够选用的其中一个图元是 GL_POINTS，如果使用它的话，每一个顶点都是一个图元，都会被渲染为一个点。我们可以通过 OpenGL 的 glPointSize 函数来<mark>设置</mark>渲染出来的<mark>点的大小</mark>，但我们也可以在顶点着色器中修改这个值。</p>\n<p>GLSL 定义了一个叫做 gl_PointSize 输出变量，它是一个 float 变量，你可以使用它来设置点的宽高（像素）。在顶点着色器中修改点的大小的话，你就能对每个顶点设置不同的值了。</p>\n<p>在顶点着色器中修改点大小的功能默认是禁用的，如果你需要启用它的话，你需要启用 OpenGL 的</p>\n<h4 id=\"gl_program_point_size\"><a class=\"anchor\" href=\"#gl_program_point_size\">#</a> GL_PROGRAM_POINT_SIZE：</h4>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glEnable</span><span class=\"token punctuation\">(</span>GL_PROGRAM_POINT_SIZE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>一个简单的例子就是将点的大小设置为裁剪空间位置的 z 值，也就是顶点距观察者的距离。点的大小会随着观察者距顶点距离变远而增大。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> projection <span class=\"token operator\">*</span> view <span class=\"token operator\">*</span> model <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>aPos<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    gl_PointSize <span class=\"token operator\">=</span> gl_Position<span class=\"token punctuation\">.</span>z<span class=\"token punctuation\">;</span>    </pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>结果就是，当我们远离这些点的时候，它们会变得更大：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/08/advanced_glsl_pointsize.png\" alt=\"image\" /></p>\n<h4 id=\"gl_vertexid\"><a class=\"anchor\" href=\"#gl_vertexid\">#</a> gl_VertexID</h4>\n<p>gl_Position 和 gl_PointSize 都是输出变量，因为它们的值是作为顶点着色器的输出被读取的。我们可以对它们进行写入，来改变结果。顶点着色器还为我们提供了一个有趣的输入变量，我们只能对它进行<mark>读取</mark>，它叫做 gl_VertexID。</p>\n<p>整型变量 gl_VertexID 储存了<mark>正在绘制<strong>顶点</strong>的当前 ID</mark>。当（使用 glDrawElements）进行索引渲染的时候，这个变量会存储正在绘制顶点的当前索引。当（使用 glDrawArrays）不使用索引进行绘制的时候，这个变量会储存从渲染调用开始的已处理顶点数量。</p>\n<p>虽然现在它没有什么具体的用途，但知道我们能够访问这个信息总是好的。</p>\n<h3 id=\"片段着色器变量\"><a class=\"anchor\" href=\"#片段着色器变量\">#</a> 片段着色器变量</h3>\n<p>在片段着色器中，我们也能访问到一些有趣的变量。GLSL 提供给我们两个有趣的输入变量：<mark>gl_FragCoord</mark> 和<mark> gl_FrontFacing</mark>。</p>\n<h4 id=\"gl_fragcoord设置屏幕渲染范围\"><a class=\"anchor\" href=\"#gl_fragcoord设置屏幕渲染范围\">#</a> gl_FragCoord (设置屏幕渲染范围)</h4>\n<p>在讨论深度测试的时候，我们已经见过 gl_FragCoord 很多次了，因为 gl_FragCoord 的 z 分量等于对应片段的深度值。然而，我们也能使用它的 x 和 y 分量来实现一些有趣的效果。</p>\n<p>gl_FragCoord 的 x 和 y 分量是片段的窗口空间 (Window-space) 坐标，其原点为窗口的左下角。我们已经使用 glViewport 设定了一个 800x600 的窗口了，所以片段窗口空间坐标的 x 分量将在 0 到 800 之间，y 分量在 0 到 600 之间。</p>\n<p>通过利用片段着色器，我们可以根据片段的窗口坐标，计算出不同的颜色。gl_FragCoord 的一个常见用处是用于对比不同片段计算的视觉输出效果，这在技术演示中可以经常看到。比如说，我们能够将屏幕分成两部分，在窗口的左侧渲染一种输出，在窗口的右侧渲染另一种输出。下面这个例子片段着色器会根据窗口坐标输出不同的颜色：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span>             </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>gl_FragCoord<span class=\"token punctuation\">.</span>x <span class=\"token operator\">&lt;</span> <span class=\"token number\">400</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        FragColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">else</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        FragColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        </pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>因为窗口的宽度是 800。当一个像素的 x 坐标小于 400 时，它一定在窗口的左侧，所以我们给它一个不同的颜色。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/08/advanced_glsl_fragcoord.png\" alt=\"image\" /></p>\n<h4 id=\"gl_frontfacing判断正反面\"><a class=\"anchor\" href=\"#gl_frontfacing判断正反面\">#</a> gl_FrontFacing (判断正反面)</h4>\n<p>片段着色器另外一个很有意思的输入变量是 gl_FrontFacing。在面剔除教程中，我们提到 OpenGL 能够根据顶点的环绕顺序来决定一个面是正向还是背向面。如果我们不（启用 GL_FACE_CULL 来）使用面剔除，那么 gl_FrontFacing 将会告诉我们当前片段是属于正向面的一部分还是背向面的一部分。举例来说，我们能够对正向面计算出不同的颜色。</p>\n<p>gl_FrontFacing 变量是一个 bool，如果当前片段是正向面的一部分那么就是 true，否则就是 false。比如说，我们可以这样子创建一个立方体，在内部和外部使用不同的纹理：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>out vec4 FragColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>in vec2 TexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>uniform sampler2D frontTexture<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>uniform sampler2D backTexture<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#123;</span>             </pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>gl_FrontFacing<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        FragColor <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>frontTexture<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">else</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        FragColor <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>backTexture<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>如果我们往箱子里面看，就能看到使用的是不同的纹理。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/08/advanced_glsl_frontfacing.png\" alt=\"image\" /></p>\n<p>注意，如果你开启了<mark>面剔除</mark>，你就看不到箱子内部的面了，所以现在再使用 gl_FrontFacing 就没有意义了。</p>\n<h4 id=\"gl_fragdepth修改片段深度值\"><a class=\"anchor\" href=\"#gl_fragdepth修改片段深度值\">#</a> gl_FragDepth（修改片段深度值）</h4>\n<p>输入变量 gl_FragCoord 能让我们读取当前片段的窗口空间坐标，并获取它的深度值，但是它是一个<mark>只读</mark> (Read-only) 变量。我们不能修改片段的窗口空间坐标，但实际上<mark>修改片段的深度值</mark>还是可能的。GLSL 提供给我们一个叫做 gl_FragDepth 的输出变量，我们可以使用它来在着色器内设置片段的深度值。</p>\n<p>要想设置深度值，我们直接写入一个 0.0 到 1.0 之间的 float 值到输出变量就可以了：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>gl_FragDepth <span class=\"token operator\">=</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 这个片段现在的深度值为 0.0</span></pre></td></tr></table></figure><p>如果着色器没有写入值到 gl_FragDepth，它会自动取用 gl_FragCoord.z 的值。</p>\n<p>然而，由我们自己设置深度值有一个很大的缺点，只要我们在片段着色器中对 gl_FragDepth 进行写入，OpenGL 就会（像深度测试小节中讨论的那样）<mark>禁用所有的提前深度测试</mark> (Early Depth Testing)。它被禁用的原因是，OpenGL 无法在片段着色器运行之前得知片段将拥有的深度值，因为片段着色器可能会完全修改这个深度值。</p>\n<p>在写入 gl_FragDepth 时，你就需要考虑到它所带来的性能影响。然而，从 OpenGL 4.2 起，我们仍可以对两者进行一定的调和，在片段着色器的<mark>顶部</mark>使用<mark>深度条件</mark> (Depth Condition) 重新声明 gl_FragDepth 变量：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>depth_<span class=\"token operator\">&lt;</span>condition<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> out <span class=\"token keyword\">float</span> gl_FragDepth<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>condition 可以为下面的值：</p>\n<table>\n<thead>\n<tr>\n<th>条件</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>any</td>\n<td>默认值。提前深度测试是禁用的，你会损失很多性能</td>\n</tr>\n<tr>\n<td>greater</td>\n<td>你只能让深度值比 gl_FragCoord.z 更大</td>\n</tr>\n<tr>\n<td>less</td>\n<td>你只能让深度值比 gl_FragCoord.z 更小</td>\n</tr>\n<tr>\n<td>unchanged</td>\n<td>如果你要写入 gl_FragDepth，你将只能写入 gl_FragCoord.z 的值</td>\n</tr>\n</tbody>\n</table>\n<p>通过将深度条件设置为 greater 或者 less，OpenGL 就能假设你只会写入比当前片段深度值更大或者更小的值了。这样子的话，当深度值比片段的深度值要小的时候，OpenGL 仍是能够进行提前深度测试的。</p>\n<p>下面这个例子中，我们对片段的深度值进行了递增，但仍然也保留了一些提前深度测试：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">420</span> core </span><span class=\"token comment\">// 注意 GLSL 的版本！</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>out vec4 FragColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>depth_greater<span class=\"token punctuation\">)</span> out <span class=\"token keyword\">float</span> gl_FragDepth<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#123;</span>             </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    gl_FragDepth <span class=\"token operator\">=</span> gl_FragCoord<span class=\"token punctuation\">.</span>z <span class=\"token operator\">+</span> <span class=\"token number\">0.1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><blockquote>\n<p>注意这个特性只在 OpenGL 4.2 版本或以上才提供。</p>\n</blockquote>\n<h3 id=\"接口块\"><a class=\"anchor\" href=\"#接口块\">#</a> 接口块</h3>\n<p>到目前为止，每当我们希望从顶点着色器向片段着色器发送数据时，我们都声明了几个对应的输入 / 输出变量。将它们一个一个声明是着色器间发送数据最简单的方式了，但当程序变得更大时，你希望发送的可能就不只是几个变量了，它还可能包括数组和结构体。</p>\n<p>为了帮助我们管理这些变量，GLSL 为我们提供了一个叫做<mark>接口块</mark> (Interface Block) 的东西，来方便我们组合这些变量。接口块的声明和 struct 的声明有点相像，不同的是，现在根据它是一个输入还是输出块 (Block)，使用 in 或 out 关键字来定义的。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> in vec3 aPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> in vec2 aTexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>uniform mat4 model<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>uniform mat4 view<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>uniform mat4 projection<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>out VS_OUT</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    vec2 TexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span> vs_out<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> projection <span class=\"token operator\">*</span> view <span class=\"token operator\">*</span> model <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>aPos<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    </pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    vs_out<span class=\"token punctuation\">.</span>TexCoords <span class=\"token operator\">=</span> aTexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这次我们声明了一个叫做 vs_out 的接口块，它打包了我们希望发送到下一个着色器中的所有输出变量。这只是一个很简单的例子，但你可以想象一下，它能够帮助你管理着色器的输入和输出。当我们希望将着色器的输入或输出打包为数组时，它也会非常有用，我们将在下一节讨论几何着色器 (Geometry Shader) 时见到。</p>\n<p>之后，我们还需要在下一个着色器，即片段着色器，中定义一个输入接口块。块名 (Block Name) 应该是和着色器中一样的（VS_OUT），但实例名 (Instance Name)（顶点着色器中用的是 vs_out）可以是随意的，但要避免使用误导性的名称，比如对实际上包含输入变量的接口块命名为 vs_out。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>out vec4 FragColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>in VS_OUT</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    vec2 TexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span> fs_in<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>uniform sampler2D texture<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#123;</span>             </pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">texture</span><span class=\"token punctuation\">(</span>texture<span class=\"token punctuation\">,</span> fs_in<span class=\"token punctuation\">.</span>TexCoords<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   </pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>只要两个接口块的名字一样，它们对应的输入和输出将会匹配起来。这是帮助你管理代码的又一个有用特性，它在几何着色器这样穿插特定着色器阶段的场景下会很有用。</p>\n<h3 id=\"uniform缓冲对象\"><a class=\"anchor\" href=\"#uniform缓冲对象\">#</a> Uniform 缓冲对象</h3>\n<p>我们已经使用 OpenGL 很长时间了，学会了一些很酷的技巧，但也遇到了一些很麻烦的地方。比如说，当使用多于一个的着色器时，尽管大部分的 uniform 变量都是相同的，我们还是需要不断地设置它们，所以为什么要这么麻烦地重复设置它们呢？</p>\n<p>OpenGL 为我们提供了一个叫做<mark> Uniform 缓冲对象</mark> (Uniform Buffer Object) 的工具，它允许我们<mark>定义一系列</mark>在<mark>多个着色器中相同的全局 Uniform 变量</mark>。当使用 Uniform 缓冲对象的时候，我们只需要设置相关的 uniform 一次。当然，我们仍需要手动设置每个着色器中不同的 uniform。并且创建和配置 Uniform 缓冲对象会有一点繁琐。</p>\n<p>因为 Uniform 缓冲对象仍是一个缓冲，我们可以使用 glGenBuffers 来创建它，将它绑定到 GL_UNIFORM_BUFFER 缓冲目标，并将所有相关的 uniform 数据存入缓冲。在 Uniform 缓冲对象中储存数据是有一些规则的，我们将会在之后讨论它。首先，我们将使用一个简单的顶点着色器，将 projection 和 view 矩阵存储到所谓的 Uniform 块 (Uniform Block) 中：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> in vec3 aPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>std140<span class=\"token punctuation\">)</span> uniform Matrices</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    mat4 projection<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    mat4 view<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>uniform mat4 model<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> projection <span class=\"token operator\">*</span> view <span class=\"token operator\">*</span> model <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>aPos<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在我们大多数的例子中，我们都会在每个渲染迭代中，对每个着色器设置 projection 和 view Uniform 矩阵。这是利用 Uniform 缓冲对象的一个非常完美的例子，因为现在我们只需要存储这些矩阵一次就可以了。</p>\n<p>这里，我们声明了一个叫做 Matrices 的 Uniform 块，它储存了两个 4x4 矩阵。Uniform 块中的变量<mark>可以直接访问</mark>，不需要加块名作为前缀。接下来，我们在 OpenGL 代码中将这些矩阵值存入缓冲中，每个声明了这个 Uniform 块的着色器都能够访问这些矩阵。</p>\n<p>你现在可能会在想 layout (std140) 这个语句是什么意思。它的意思是说，当前定义的 Uniform 块对它的内容使用一个特定的内存布局。这个语句设置了 Uniform 块布局 (Uniform Block Layout)。</p>\n<h3 id=\"uniform块布局\"><a class=\"anchor\" href=\"#uniform块布局\">#</a> Uniform 块布局</h3>\n<p>Uniform 块的内容是储存在一个缓冲对象中的，它实际上只是一块预留内存。因为这块内存并不会保存它具体保存的是什么类型的数据，我们还需要告诉 OpenGL 内存的哪一部分对应着着色器中的哪一个 uniform 变量。</p>\n<p>假设着色器中有以下的这个 Uniform 块：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>std140<span class=\"token punctuation\">)</span> uniform ExampleBlock</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">float</span> value<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    vec3  vector<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    mat4  matrix<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">float</span> values<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">bool</span>  boolean<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">int</span>   integer<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>我们需要知道的是每个变量的大小（字节）和（从块起始位置的）偏移量，来让我们能够按顺序将它们放进缓冲中。每个元素的大小都是在 OpenGL 中有清楚地声明的，而且直接对应 C++ 数据类型，其中向量和矩阵都是大的 float 数组。OpenGL 没有声明的是这些变量间的间距 (Spacing)。这允许硬件能够在它认为合适的位置放置变量。比如说，一些硬件可能会将一个 vec3 放置在 float 边上。不是所有的硬件都能这样处理，可能会在附加这个 float 之前，先将 vec3 填充 (Pad) 为一个 4 个 float 的数组。这个特性本身很棒，但是会对我们造成麻烦。</p>\n<p>默认情况下，GLSL 会使用一个叫做<mark>共享 (Shared) 布局的 Uniform 内存布局</mark>，共享是因为一旦硬件定义了偏移量，它们在多个程序中是共享并一致的。使用共享布局时，GLSL 是可以为了优化而对 uniform 变量的位置进行变动的，只要变量的顺序保持不变。因为我们<mark>无法知道</mark>每个 uniform 变量的<mark>偏移量</mark>，我们也就不知道如何准确地填充我们的 Uniform 缓冲了。我们能够使用像是 glGetUniformIndices 这样的函数来查询这个信息，但这超出本节的范围了。</p>\n<p>虽然共享布局给了我们很多节省空间的优化，但是我们需要查询每个 uniform 变量的偏移量，这会产生非常多的工作量。通常的做法是，不使用共享布局，而是使用<mark> std140 布局</mark>。std140 布局声明了每个变量的偏移量都是由一系列规则所决定的，这显式地声明了每个变量类型的内存布局。由于这是显式提及的，我们可以<mark>手动计算</mark>出每个变量的偏移量。</p>\n<p>每个变量都有一个<mark>基准对齐量</mark> (Base Alignment)，它等于一个变量在 Uniform 块中所占据的空间（包括填充量 (Padding)），这个基准对齐量是使用 std140 布局的规则计算出来的。接下来，对每个变量，我们再计算它的对齐偏移量 (Aligned Offset)，它是一个变量从块起始位置的字节偏移量。一个变量的对齐字节偏移量必须等于基准对齐量的倍数。</p>\n<p>布局规则的原文可以在 OpenGL 的 Uniform 缓冲规范<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi91bmlmb3JtX2J1ZmZlcl9vYmplY3QudHh0\">这里找到</span>，但我们将会在下面列出最常见的规则。GLSL 中的每个变量，比如说 int、float 和 bool，都被定义为 4 字节量。每 4 个字节将会用一个 N 来表示。</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>布局规则</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>标量，比如 int 和 bool</td>\n<td>每个标量的基准对齐量为 N。</td>\n</tr>\n<tr>\n<td>向量</td>\n<td>2N 或者 4N。这意味着 vec3 的基准对齐量为 4N。</td>\n</tr>\n<tr>\n<td>标量或向量的数组</td>\n<td>每个元素的基准对齐量与 vec4 的相同。</td>\n</tr>\n<tr>\n<td>矩阵</td>\n<td>储存为列向量的数组，每个向量的基准对齐量与 vec4 的相同。</td>\n</tr>\n<tr>\n<td>结构体</td>\n<td>等于所有元素根据规则计算后的大小，但会填充到 vec4 大小的倍数。</td>\n</tr>\n</tbody>\n</table>\n<p>和 OpenGL 大多数的规范一样，使用例子就能更容易地理解。我们会使用之前引入的那个叫做 ExampleBlock 的 Uniform 块，并使用 std140 布局计算出每个成员的对齐偏移量：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>std140<span class=\"token punctuation\">)</span> uniform ExampleBlock</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>                     <span class=\"token comment\">// 基准对齐量       // 对齐偏移量</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">float</span> value<span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 4               // 0 </span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    vec3 vector<span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 16              // 16  (必须是 16 的倍数，所以 4->16)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    mat4 matrix<span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 16              // 32  (列 0)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>                     <span class=\"token comment\">// 16              // 48  (列 1)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>                     <span class=\"token comment\">// 16              // 64  (列 2)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>                     <span class=\"token comment\">// 16              // 80  (列 3)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">float</span> values<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 16              // 96  (values[0])</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>                     <span class=\"token comment\">// 16              // 112 (values[1])</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>                     <span class=\"token comment\">// 16              // 128 (values[2])</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">bool</span> boolean<span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 4               // 144</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">int</span> integer<span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 4               // 148</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>作为练习，尝试去自己计算一下偏移量，并和表格进行对比。使用计算后的偏移量值，根据 std140 布局的规则，我们就能使用像是 glBufferSubData 的函数将变量数据按照偏移量填充进缓冲中了。虽然 std140 布局不是最高效的布局，但它保证了内存布局在每个声明了这个 Uniform 块的程序中是一致的。</p>\n<p>通过在 Uniform 块定义之前添加 layout (std140) 语句，我们告诉 OpenGL 这个 Uniform 块使用的是 std140 布局。除此之外还可以选择两个布局，但它们都需要我们在填充缓冲之前先查询每个偏移量。我们已经见过 shared 布局了，剩下的一个布局是<mark> packed</mark>。当使用<mark>紧凑</mark> (Packed) 布局时，是不能保证这个布局在每个程序中保持不变的（即非共享），因为它允许编译器去将 uniform 变量从 Uniform 块中优化掉，这在每个着色器中都可能是不同的。</p>\n<h3 id=\"使用uniform缓冲\"><a class=\"anchor\" href=\"#使用uniform缓冲\">#</a> 使用 Uniform 缓冲</h3>\n<p>我们已经讨论了如何在着色器中定义 Uniform 块，并设定它们的内存布局了，但我们还没有讨论该如何使用它们。</p>\n<p>首先，我们需要调用 glGenBuffers，创建一个 Uniform 缓冲对象。一旦我们有了一个缓冲对象，我们需要将它绑定到 GL_UNIFORM_BUFFER 目标，并调用 glBufferData，分配足够的内存。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> uboExampleBlock<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glGenBuffers</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>uboExampleBlock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_UNIFORM_BUFFER<span class=\"token punctuation\">,</span> uboExampleBlock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glBufferData</span><span class=\"token punctuation\">(</span>GL_UNIFORM_BUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">152</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> GL_STATIC_DRAW<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 分配 152 字节的内存</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_UNIFORM_BUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>现在，每当我们需要对缓冲更新或者插入数据，我们都会绑定到 uboExampleBlock，并使用 glBufferSubData 来更新它的内存。我们只需要更新这个 Uniform 缓冲一次，所有使用这个缓冲的着色器就都使用的是更新后的数据了。但是，如何才能让 OpenGL<mark> 知道哪个 Uniform 缓冲<strong>对应</strong>的是哪个 Uniform 块呢</mark>？</p>\n<p>在 OpenGL 上下文中，定义了一些<mark>绑定点</mark> (Binding Point)，我们可以将一个 Uniform 缓冲链接至它。在创建 Uniform 缓冲之后，我们将它绑定到其中一个绑定点上，并将着色器中的 Uniform 块绑定到相同的绑定点，把它们连接到一起。下面的这个图示展示了这个：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/08/advanced_glsl_binding_points.png\" alt=\"image\" /></p>\n<p>你可以看到，我们可以绑定多个 Uniform 缓冲到不同的绑定点上。因为着色器 A 和着色器 B 都有一个链接到绑定点 0 的 Uniform 块，它们的 Uniform 块将会共享相同的 uniform 数据，uboMatrices，前提条件是两个着色器都定义了相同的 Matrices Uniform 块。</p>\n<p>为了将 Uniform 块<mark>绑定到</mark>一个<mark>特定的绑定点</mark>中，我们需要调用<mark> glUniformBlockBinding</mark> 函数，它的第一个参数是一个程序对象，之后是一个 Uniform 块索引和链接到的绑定点。Uniform 块索引 (Uniform Block Index) 是着色器中已定义 Uniform 块的位置值索引。这可以通过调用 glGetUniformBlockIndex 来获取，它接受一个程序对象和 Uniform 块的名称。我们可以用以下方式将图示中的 Lights Uniform 块链接到绑定点 2：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> lights_index <span class=\"token operator\">=</span> <span class=\"token function\">glGetUniformBlockIndex</span><span class=\"token punctuation\">(</span>shaderA<span class=\"token punctuation\">.</span>ID<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Lights\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   </pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glUniformBlockBinding</span><span class=\"token punctuation\">(</span>shaderA<span class=\"token punctuation\">.</span>ID<span class=\"token punctuation\">,</span> lights_index<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>注意我们需要对<strong>每个</strong>着色器重复这一步骤。</p>\n<blockquote>\n<p>从 OpenGL 4.2 版本起，你也可以添加一个布局标识符，显式地将 Uniform 块的绑定点储存在着色器中，这样就不用再调用 glGetUniformBlockIndex 和 glUniformBlockBinding 了。下面的代码显式地设置了 Lights Uniform 块的绑定点。</p>\n</blockquote>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">//binding 对应共享 Uniform 缓存中的 binding points</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span><span class=\"token punctuation\">(</span>std140<span class=\"token punctuation\">,</span> binding <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> uniform Lights <span class=\"token punctuation\">&#123;</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>接下来，我们还需要绑定 Uniform 缓冲对象到相同的绑定点上，这可以使用 glBindBufferBase 或 glBindBufferRange 来完成。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glBindBufferBase</span><span class=\"token punctuation\">(</span>GL_UNIFORM_BUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> uboExampleBlock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// 或</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glBindBufferRange</span><span class=\"token punctuation\">(</span>GL_UNIFORM_BUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> uboExampleBlock<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">152</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>glBindbufferBase 需要一个<mark>目标</mark>，一个<mark>绑定点索引</mark>和一个<mark> Uniform 缓冲对象</mark>作为它的参数。这个函数将 uboExampleBlock 链接到绑定点 2 上，自此，绑定点的两端都链接上了。你也可以使用 glBindBufferRange 函数，它需要一个附加的<mark>偏移量</mark>和<mark>大小参数</mark>，这样子你可以绑定 Uniform 缓冲的特定一部分到绑定点中。通过使用 glBindBufferRange 函数，你可以让多个不同的 Uniform 块绑定到同一个 Uniform 缓冲对象上。</p>\n<p>现在，所有的东西都配置完毕了，我们可以开始向 Uniform 缓冲中添加数据了。只要我们需要，就可以使用 glBufferSubData 函数，用一个字节数组添加所有的数据，或者更新缓冲的一部分。要想更新 uniform 变量 boolean，我们可以用以下方式更新 Uniform 缓冲对象：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_UNIFORM_BUFFER<span class=\"token punctuation\">,</span> uboExampleBlock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// GLSL 中的 bool 是 4 字节的，所以我们将它存为一个 integer</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glBufferSubData</span><span class=\"token punctuation\">(</span>GL_UNIFORM_BUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">144</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_UNIFORM_BUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>同样的步骤也能应用到 Uniform 块中其它的 uniform 变量上，但需要使用不同的范围参数。</p>\n<h3 id=\"一个简单的例子\"><a class=\"anchor\" href=\"#一个简单的例子\">#</a> 一个简单的例子</h3>\n<p>所以，我们来展示一个真正使用 Uniform 缓冲对象的例子。如果我们回头看看之前所有的代码例子，我们不断地在使用 3 个矩阵：投影、观察和模型矩阵。在所有的这些矩阵中，只有模型矩阵会频繁变动。如果我们有多个着色器使用了这同一组矩阵，那么使用 Uniform 缓冲对象可能会更好。</p>\n<p>我们会将投影和模型矩阵存储到一个叫做 Matrices 的 Uniform 块中。我们不会将模型矩阵存在这里，因为模型矩阵在不同的着色器中会不断改变，所以使用 Uniform 缓冲对象并不会带来什么好处。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> in vec3 aPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>std140<span class=\"token punctuation\">)</span> uniform Matrices</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    mat4 projection<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    mat4 view<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>uniform mat4 model<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> projection <span class=\"token operator\">*</span> view <span class=\"token operator\">*</span> model <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>aPos<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这里没什么特别的，除了我们现在使用的是一个 std140 布局的 Uniform 块。我们将在例子程序中，显示 4 个立方体，每个立方体都是使用不同的着色器程序渲染的。这 4 个着色器程序将使用相同的顶点着色器，但使用的是不同的片段着色器，每个着色器会输出不同的颜色。</p>\n<p>首先，我们将顶点着色器的 Uniform 块设置为绑定点 0。注意我们需要对<mark>每个着色器都设置一遍</mark>。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> uniformBlockIndexRed    <span class=\"token operator\">=</span> <span class=\"token function\">glGetUniformBlockIndex</span><span class=\"token punctuation\">(</span>shaderRed<span class=\"token punctuation\">.</span>ID<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Matrices\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> uniformBlockIndexGreen  <span class=\"token operator\">=</span> <span class=\"token function\">glGetUniformBlockIndex</span><span class=\"token punctuation\">(</span>shaderGreen<span class=\"token punctuation\">.</span>ID<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Matrices\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> uniformBlockIndexBlue   <span class=\"token operator\">=</span> <span class=\"token function\">glGetUniformBlockIndex</span><span class=\"token punctuation\">(</span>shaderBlue<span class=\"token punctuation\">.</span>ID<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Matrices\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> uniformBlockIndexYellow <span class=\"token operator\">=</span> <span class=\"token function\">glGetUniformBlockIndex</span><span class=\"token punctuation\">(</span>shaderYellow<span class=\"token punctuation\">.</span>ID<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Matrices\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">glUniformBlockBinding</span><span class=\"token punctuation\">(</span>shaderRed<span class=\"token punctuation\">.</span>ID<span class=\"token punctuation\">,</span>    uniformBlockIndexRed<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">glUniformBlockBinding</span><span class=\"token punctuation\">(</span>shaderGreen<span class=\"token punctuation\">.</span>ID<span class=\"token punctuation\">,</span>  uniformBlockIndexGreen<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">glUniformBlockBinding</span><span class=\"token punctuation\">(</span>shaderBlue<span class=\"token punctuation\">.</span>ID<span class=\"token punctuation\">,</span>   uniformBlockIndexBlue<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token function\">glUniformBlockBinding</span><span class=\"token punctuation\">(</span>shaderYellow<span class=\"token punctuation\">.</span>ID<span class=\"token punctuation\">,</span> uniformBlockIndexYellow<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>接下来，我们创建 Uniform 缓冲对象本身，并将其绑定到绑定点 0：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> uboMatrices</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glGenBuffers</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>uboMatrices<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_UNIFORM_BUFFER<span class=\"token punctuation\">,</span> uboMatrices<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">glBufferData</span><span class=\"token punctuation\">(</span>GL_UNIFORM_BUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span>mat4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> GL_STATIC_DRAW<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_UNIFORM_BUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">glBindBufferRange</span><span class=\"token punctuation\">(</span>GL_UNIFORM_BUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> uboMatrices<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span>mat4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>首先我们为缓冲分配了足够的内存，它等于 glm::mat4 大小的两倍。GLM 矩阵类型的大小直接对应于 GLSL 中的 mat4。接下来，我们将缓冲中的特定范围（在这里是整个缓冲）链接到绑定点 0。</p>\n<p>剩余的就是填充这个缓冲了。如果我们将投影矩阵的视野 (Field of View) 值保持不变（所以摄像机就没有缩放了），我们只需要将其在程序中定义一次 —— 这也意味着我们只需要将它插入到缓冲中一次。因为我们已经为缓冲对象分配了足够的内存，我们可以使用 glBufferSubData 在进入渲染循环之前存储投影矩阵：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span>mat4 projection <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">perspective</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span><span class=\"token function\">radians</span><span class=\"token punctuation\">(</span><span class=\"token number\">45.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span>width<span class=\"token operator\">/</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span>height<span class=\"token punctuation\">,</span> <span class=\"token number\">0.1f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_UNIFORM_BUFFER<span class=\"token punctuation\">,</span> uboMatrices<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glBufferSubData</span><span class=\"token punctuation\">(</span>GL_UNIFORM_BUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span>mat4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">value_ptr</span><span class=\"token punctuation\">(</span>projection<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_UNIFORM_BUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这里我们将投影矩阵储存在 Uniform 缓冲的前半部分。在每次渲染迭代中绘制物体之前，我们会将观察矩阵更新到缓冲的后半部分：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span>mat4 view <span class=\"token operator\">=</span> camera<span class=\"token punctuation\">.</span><span class=\"token function\">GetViewMatrix</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>           </pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_UNIFORM_BUFFER<span class=\"token punctuation\">,</span> uboMatrices<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glBufferSubData</span><span class=\"token punctuation\">(</span>GL_UNIFORM_BUFFER<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span>mat4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span>mat4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">value_ptr</span><span class=\"token punctuation\">(</span>view<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_UNIFORM_BUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>Uniform 缓冲对象的部分就结束了。每个包含了 Matrices 这个 Uniform 块的顶点着色器将会包含储存在 uboMatrices 中的数据。所以，如果我们现在要用 4 个不同的着色器绘制 4 个立方体，它们的投影和观察矩阵都会是一样的。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glBindVertexArray</span><span class=\"token punctuation\">(</span>cubeVAO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>shaderRed<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>glm<span class=\"token operator\">::</span>mat4 model<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>model <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">translate</span><span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">0.75f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.75f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 移动到左上角</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>shaderRed<span class=\"token punctuation\">.</span><span class=\"token function\">setMat4</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"model\"</span><span class=\"token punctuation\">,</span> model<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">glDrawArrays</span><span class=\"token punctuation\">(</span>GL_TRIANGLES<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">36</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        </pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">//... 绘制绿色立方体</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">//... 绘制蓝色立方体</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">//... 绘制黄色立方体</span></pre></td></tr></table></figure><p>唯一需要设置的 uniform 只剩 model uniform 了。在像这样的场景中使用 Uniform 缓冲对象会让我们在每个着色器中都剩下一些 uniform 调用。最终的结果会是这样的：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/08/advanced_glsl_uniform_buffer_objects.png\" alt=\"image\" /></p>\n<p>因为修改了模型矩阵，每个立方体都移动到了窗口的一边，并且由于使用了不同的片段着色器，它们的颜色也不同。这只是一个很简单的情景，我们可能会需要使用 Uniform 缓冲对象，但任何大型的渲染程序都可能同时激活有上百个着色器程序，这时候 Uniform 缓冲对象的优势就会很大地体现出来了。</p>\n<p>Uniform 缓冲对象比起独立的 uniform 有很多好处。第一，一次设置很多 uniform 会比一个一个设置多个 uniform 要快很多。第二，比起在多个着色器中修改同样的 uniform，在 Uniform 缓冲中修改一次会更容易一些。最后一个好处可能不会立即显现，如果使用 Uniform 缓冲对象的话，你可以在着色器中使用更多的 uniform。OpenGL 限制了它能够处理的 uniform 数量，这可以通过 GL_MAX_VERTEX_UNIFORM_COMPONENTS 来查询。当使用 Uniform 缓冲对象时，最大的数量会更高。所以，当你达到了 uniform 的最大数量时（比如再做骨骼动画 (Skeletal Animation) 的时候），你总是可以选择使用 Uniform 缓冲对象。</p>\n<h2 id=\"几何着色器\"><a class=\"anchor\" href=\"#几何着色器\">#</a> 几何着色器</h2>\n<p>在顶点和片段着色器之间有一个可选的<mark>几何着色器</mark> (Geometry Shader)，几何着色器的<mark>输入</mark>是一个<mark>图元</mark>（如点或三角形）的一组顶点。几何着色器可以在顶点发送到下一着色器阶段之前对它们随意变换。然而，几何着色器最有趣的地方在于，它能够将（这一组）<mark>顶点变换为完全不同的图元</mark>，并且还能<mark>生成</mark>比原来<mark>更多的顶点</mark>。</p>\n<p>废话不多说，我们直接先看一个几何着色器的例子：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>points<span class=\"token punctuation\">)</span> in<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>line_strip<span class=\"token punctuation\">,</span> max_vertices <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> out<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>    </pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> gl_in<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>gl_Position <span class=\"token operator\">+</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">0.1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token function\">EmitVertex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> gl_in<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>gl_Position <span class=\"token operator\">+</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span> <span class=\"token number\">0.1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token function\">EmitVertex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token function\">EndPrimitive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在几何着色器的顶部，我们需要声明<mark>从顶点着色器输入的图元类型</mark>。这需要在<strong> in</strong> 关键字前声明一个布局修饰符 (Layout Qualifier)。这个输入布局修饰符可以从顶点着色器接收下列任何一个图元值 (后面是输出结果类型)：</p>\n<ul>\n<li><mark>points</mark>：绘制 GL_POINTS 图元时（1）。</li>\n<li><mark>lines</mark>：绘制 GL_LINES 或 GL_LINE_STRIP 时（2）</li>\n<li><mark>lines_adjacency</mark>：GL_LINES_ADJACENCY 或 GL_LINE_STRIP_ADJACENCY（4）</li>\n<li><mark>triangles</mark>：GL_TRIANGLES、GL_TRIANGLE_STRIP 或 GL_TRIANGLE_FAN（3）</li>\n<li><mark>triangles_adjacency</mark>：GL_TRIANGLES_ADJACENCY 或 GL_TRIANGLE_STRIP_ADJACENCY（6）</li>\n</ul>\n<p>以上是能提供给 glDrawArrays 渲染函数的几乎所有图元了。如果我们想要将顶点绘制为 GL_TRIANGLES，我们就要将输入修饰符设置为 triangles。括号内的数字表示的是一个图元所包含的<mark>最小顶点数</mark>。</p>\n<p>接下来，我们还需要指定几何着色<mark>器输出的图元类型</mark>，这需要在<strong> out</strong> 关键字前面加一个布局修饰符。和输入布局修饰符一样，输出布局修饰符也可以接受几个图元值：</p>\n<ul>\n<li><mark>points</mark> ： 输出为点</li>\n<li><mark>line_strip</mark> ： 输出为线条</li>\n<li><mark>triangle_strip</mark> ：输出为三角形</li>\n</ul>\n<p>有了这 3 个输出修饰符，我们就可以使用输入图元创建几乎任意的形状了。要生成一个三角形的话，我们将输出定义为 triangle_strip，并输出 3 个顶点。</p>\n<p>几何着色器同时希望我们<mark>设置</mark>一个它最大<mark>能够输出的顶点数量</mark>（如果你超过了这个值，OpenGL 将不会绘制多出的顶点），这个也可以在 out 关键字的布局修饰符中设置。在这个例子中，我们将输出一个 line_strip，并将最大顶点数设置为 2 个。</p>\n<p>如果你不知道什么是线条 (Line Strip)：线条连接了一组点，形成一条连续的线，它最少要由两个点来组成。在渲染函数中每多加一个点，就会在这个点与前一个点之间形成一条新的线。在下面这张图中，我们有 5 个顶点：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/09/geometry_shader_line_strip.png\" alt=\"image\" /></p>\n<p>如果使用的是上面定义的着色器，那么这将只能输出一条线段，因为最大顶点数等于 2。</p>\n<p>为了生成更有意义的结果，我们需要某种方式来获取前一着色器阶段的输出。GLSL 提供给我们一个内建 (Built-in) 变量，在内部看起来（可能）是这样的：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>in gl_Vertex</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    vec4  gl_Position<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">float</span> gl_PointSize<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">float</span> gl_ClipDistance<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span> gl_in<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这里，它被声明为一个<mark>接口块</mark>（Interface Block，我们在上一节已经讨论过），它包含了几个很有意思的变量，其中最有趣的一个是 gl_Position，它是和顶点着色器输出非常相似的一个向量。</p>\n<p>要注意的是，它被声明为一个数组，因为大多数的渲染图元包含多于 1 个的顶点，而几何着色器的输入是一个图元的所有顶点。</p>\n<p>有了之前顶点着色器阶段的顶点数据，我们就可以使用 2 个几何着色器函数，EmitVertex 和 EndPrimitive，来生成新的数据了。几何着色器希望你能够生成并输出至少一个定义为输出的图元。在我们的例子中，我们需要至少生成一个线条图元。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> gl_in<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>gl_Position <span class=\"token operator\">+</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">0.1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token function\">EmitVertex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> gl_in<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>gl_Position <span class=\"token operator\">+</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span> <span class=\"token number\">0.1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token function\">EmitVertex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token function\">EndPrimitive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>每次我们调用 EmitVertex 时，gl_Position 中的向量会被添加到图元中来。当 EndPrimitive 被调用时，所有发射出的 (Emitted) 顶点都会合成为指定的输出渲染图元。在一个或多个 EmitVertex 调用之后重复调用 EndPrimitive 能够生成多个图元。在这个例子中，我们发射了两个顶点，它们从原始顶点位置平移了一段距离，之后调用了 EndPrimitive，将这两个顶点合成为一个包含两个顶点的线条。</p>\n<p>现在你（大概）了解了几何着色器的工作方式，你可能已经猜出这个几何着色器是做什么的了。它接受一个点图元作为输入，以这个点为中心，创建一条水平的线图元。如果我们渲染它，看起来会是这样的：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/09/geometry_shader_lines.png\" alt=\"image\" /></p>\n<p>目前还并没有什么令人惊叹的效果，但考虑到这个输出是通过调用下面的渲染函数来生成的，它还是很有意思的：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glDrawArrays</span><span class=\"token punctuation\">(</span>GL_POINTS<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>虽然这是一个比较简单的例子，它的确向你展示了如何能够使用几何着色器来（动态地）生成新的形状。在之后我们会利用几何着色器创建出更有意思的效果，但现在我们仍将从创建一个简单的几何着色器开始。</p>\n<h3 id=\"使用几何着色器\"><a class=\"anchor\" href=\"#使用几何着色器\">#</a> 使用几何着色器</h3>\n<p>为了展示几何着色器的用法，我们将会渲染一个非常简单的场景，我们只会在标准化设备坐标的 z 平面上绘制四个点。这些点的坐标是：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> points<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token operator\">-</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 左上</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>     <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 右上</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>     <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 右下</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token operator\">-</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.5f</span>  <span class=\"token comment\">// 左下</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>顶点着色器只需要在 z 平面绘制点就可以了，所以我们将使用一个最基本顶点着色器：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> in vec2 aPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>aPos<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">,</span> aPos<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>直接在片段着色器中硬编码，将所有的点都输出为绿色：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>out vec4 FragColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   </pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>为点的顶点数据生成一个 VAO 和一个 VBO，然后使用 glDrawArrays 进行绘制：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>shader<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glBindVertexArray</span><span class=\"token punctuation\">(</span>VAO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glDrawArrays</span><span class=\"token punctuation\">(</span>GL_POINTS<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>结果是在黑暗的场景中有四个（很难看见的）绿点：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/09/geometry_shader_points.png\" alt=\"image\" /></p>\n<p>但我们之前不是学过这些吗？是的，但是现在我们将会添加一个几何着色器，为场景添加活力。</p>\n<p>出于学习目的，我们将会创建一个<mark>传递 (Pass-through) 几何着色器</mark>，它会接收一个点图元，并直接将它传递 (Pass) 到下一个着色器：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>points<span class=\"token punctuation\">)</span> in<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>points<span class=\"token punctuation\">,</span> max_vertices <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> out<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>    </pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> gl_in<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>gl_Position<span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token function\">EmitVertex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token function\">EndPrimitive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>现在这个几何着色器应该很容易理解了，它只是将它接收到的顶点位置不作修改直接发射出去，并生成一个点图元。</p>\n<p>和顶点与片段着色器一样，几何着色器也需要编译和链接，但这次在创建着色器时我们将会使用 GL_GEOMETRY_SHADER 作为着色器类型：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>geometryShader <span class=\"token operator\">=</span> <span class=\"token function\">glCreateShader</span><span class=\"token punctuation\">(</span>GL_GEOMETRY_SHADER<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glShaderSource</span><span class=\"token punctuation\">(</span>geometryShader<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>gShaderCode<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glCompileShader</span><span class=\"token punctuation\">(</span>geometryShader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">glAttachShader</span><span class=\"token punctuation\">(</span>program<span class=\"token punctuation\">,</span> geometryShader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">glLinkProgram</span><span class=\"token punctuation\">(</span>program<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>着色器编译的代码和顶点与片段着色器代码都是一样的。记得要检查编译和链接错误！</p>\n<p>如果你现在编译并运行程序，会看到和下面类似的结果：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/09/geometry_shader_points.png\" alt=\"image\" /></p>\n<p>这和没使用几何着色器时是完全一样的！我承认这是有点无聊，但既然我们仍然能够绘制这些点，所以几何着色器是正常工作的，现在是时候做点更有趣的东西了！</p>\n<h3 id=\"造几个房子\"><a class=\"anchor\" href=\"#造几个房子\">#</a> 造几个房子</h3>\n<p>绘制点和线并没有那么有趣，所以我们会使用一点创造力，利用几何着色器在每个点的位置上绘制一个房子。要实现这个，我们可以将几何着色器的输出设置为 triangle_strip，并绘制三个三角形：其中两个组成一个正方形，另一个用作房顶。</p>\n<p>OpenGL 中，三角形带 (Triangle Strip) 是绘制三角形更高效的方式，它使用顶点更少。在第一个三角形绘制完之后，每个后续顶点将会在上一个三角形边上生成另一个三角形：每 3 个临近的顶点将会形成一个三角形。如果我们一共有 6 个构成三角形带的顶点，那么我们会得到这些三角形：(1, 2, 3)、(2, 3, 4)、(3, 4, 5) 和 (4, 5, 6)，共形成 4 个三角形。一个三角形带至少需要 3 个顶点，并会生成 N-2 个三角形。使用 6 个顶点，我们创建了 6-2 = 4 个三角形。下面这幅图展示了这点：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/09/geometry_shader_triangle_strip.png\" alt=\"image\" /></p>\n<p>通过使用三角形带作为几何着色器的输出，我们可以很容易创建出需要的房子形状，只需要以正确的顺序生成 3 个相连的三角形就行了。下面这幅图展示了顶点绘制的顺序，蓝点代表的是输入点：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/09/geometry_shader_house.png\" alt=\"image\" /></p>\n<p>变为几何着色器是这样的：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>points<span class=\"token punctuation\">)</span> in<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>triangle_strip<span class=\"token punctuation\">,</span> max_vertices <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span> out<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">build_house</span><span class=\"token punctuation\">(</span>vec4 position<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#123;</span>    </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> position <span class=\"token operator\">+</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">0.2</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 1: 左下</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token function\">EmitVertex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   </pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> position <span class=\"token operator\">+</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span> <span class=\"token number\">0.2</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 2: 右下</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token function\">EmitVertex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> position <span class=\"token operator\">+</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">0.2</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 3: 左上</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token function\">EmitVertex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> position <span class=\"token operator\">+</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span> <span class=\"token number\">0.2</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 4: 右上</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token function\">EmitVertex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> position <span class=\"token operator\">+</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 5: 顶部</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token function\">EmitVertex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token function\">EndPrimitive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>    </pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token function\">build_house</span><span class=\"token punctuation\">(</span>gl_in<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>gl_Position<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><img data-src=\"https://learnopengl-cn.github.io/img/04/09/geometry_shader_houses.png\" alt=\"image\" /></p>\n<p>你可以看到，每个房子实际上是由 3 个三角形组成的 —— 全部都是使用空间中一点来绘制的。这些绿房子看起来是有点无聊，所以我们会再给每个房子分配一个不同的颜色。为了实现这个，我们需要在顶点着色器中添加一个额外的顶点属性，表示颜色信息，将它传递至几何着色器，并再次发送到片段着色器中。</p>\n<p>下面是更新后的顶点数据：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> points<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token operator\">-</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 左上</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>     <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 右上</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>     <span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 右下</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token operator\">-</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.5f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span>  <span class=\"token comment\">// 左下</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>然后我们更新顶点着色器，使用一个接口块将颜色属性发送到几何着色器中：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> in vec2 aPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> in vec3 aColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>out VS_OUT <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    vec3 color<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span> vs_out<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>aPos<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">,</span> aPos<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    vs_out<span class=\"token punctuation\">.</span>color <span class=\"token operator\">=</span> aColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>接下来我们还需要在几何着色器中声明相同的接口块（使用一个不同的接口名）：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>in VS_OUT <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    vec3 color<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span> gs_in<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>因为几何着色器是作用于输入的一组顶点的，从顶点着色器发来输入数据总是会以数组的形式表示出来，即便我们现在只有一个顶点。</p>\n<blockquote>\n<p>我们并不是必须要用接口块来向几何着色器传递数据。如果顶点着色器发送的颜色向量是 out vec3 vColor，我们也可以这样写：</p>\n</blockquote>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>in vec3 vColor<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><blockquote>\n<p>然而，接口块在几何着色器这样的着色器中会更容易处理一点。实际上，几何着色器的输入能够变得非常大，将它们合并为一个大的接口块数组会更符合逻辑一点。</p>\n</blockquote>\n<p>接下来我们还需要为下个片段着色器阶段声明一个输出颜色向量：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>out vec3 fColor<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>因为片段着色器只需要一个（插值的）颜色，发送多个颜色并没有什么意义。所以，fColor 向量就不是一个数组，而是一个单独的向量。当发射一个顶点的时候，每个顶点将会使用最后在 fColor 中储存的值，来用于片段着色器的运行。对我们的房子来说，我们只需要在第一个顶点发射之前，使用顶点着色器中的颜色填充 fColor 一次就可以了。</p>\n<p>因为片段着色器只需要一个（已进行了插值的）颜色，传送多个颜色没有意义。fColor 向量这样就不是一个数组，而是一个单一的向量。当发射一个顶点时，为了它的片段着色器运行，每个顶点都会储存最后在 fColor 中储存的值。对于这些房子来说，我们可以在第一个顶点被发射，对整个房子上色前，只使用来自顶点着色器的颜色填充 fColor 一次：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>fColor <span class=\"token operator\">=</span> gs_in<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>color<span class=\"token punctuation\">;</span> <span class=\"token comment\">//gs_in [0] 因为只有一个输入顶点</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>gl_Position <span class=\"token operator\">=</span> position <span class=\"token operator\">+</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">0.2</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 1: 左下  </span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">EmitVertex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>gl_Position <span class=\"token operator\">=</span> position <span class=\"token operator\">+</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span> <span class=\"token number\">0.2</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 2: 右下</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">EmitVertex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>gl_Position <span class=\"token operator\">=</span> position <span class=\"token operator\">+</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">0.2</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 3: 左上</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">EmitVertex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>gl_Position <span class=\"token operator\">=</span> position <span class=\"token operator\">+</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span> <span class=\"token number\">0.2</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 4: 右上</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token function\">EmitVertex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>gl_Position <span class=\"token operator\">=</span> position <span class=\"token operator\">+</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 5: 顶部</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token function\">EmitVertex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token function\">EndPrimitive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>所有发射出的顶点都将嵌有最后储存在 fColor 中的值，即顶点的颜色属性值。所有的房子都会有它们自己的颜色了：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/09/geometry_shader_houses_colored.png\" alt=\"image\" /></p>\n<p>仅仅是为了有趣，我们也可以假装这是冬天，将最后一个顶点的颜色设置为白色，给屋顶落上一些雪。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>fColor <span class=\"token operator\">=</span> gs_in<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>color<span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"2\"></td><td><pre>gl_Position <span class=\"token operator\">=</span> position <span class=\"token operator\">+</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">0.2</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 1: 左下 </span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">EmitVertex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>gl_Position <span class=\"token operator\">=</span> position <span class=\"token operator\">+</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span> <span class=\"token number\">0.2</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 2: 右下</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">EmitVertex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>gl_Position <span class=\"token operator\">=</span> position <span class=\"token operator\">+</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">0.2</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 3: 左上</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">EmitVertex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>gl_Position <span class=\"token operator\">=</span> position <span class=\"token operator\">+</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span> <span class=\"token number\">0.2</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 4: 右上</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token function\">EmitVertex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>gl_Position <span class=\"token operator\">=</span> position <span class=\"token operator\">+</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 5: 顶部</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>fColor <span class=\"token operator\">=</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token function\">EmitVertex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token function\">EndPrimitive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>最终结果看起来是这样的：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/09/geometry_shader_houses_snow.png\" alt=\"image\" /></p>\n<p>你可以看到，有了几何着色器，你甚至可以将最简单的图元变得十分有创意。因为这些形状是在<mark> GPU 的超快硬件中动态生成</mark>的，这会比在顶点缓冲中<mark>手动定义</mark>图形要<mark>高效很多</mark>。因此，几何缓冲对简单而且经常重复的形状来说是一个很好的优化工具，比如体素 (Voxel) 世界中的方块和室外草地的每一根草。</p>\n<h3 id=\"爆破物体\"><a class=\"anchor\" href=\"#爆破物体\">#</a> 爆破物体</h3>\n<p>尽管绘制房子非常有趣，但我们不会经常这么做。这也是为什么我们接下来要继续深入，来爆破 (Explode) 物体！虽然这也是一个不怎么常用的东西，但是它能向你展示几何着色器的强大之处。</p>\n<p>当我们说爆破一个物体时，我们并不是指要将宝贵的顶点集给炸掉，我们是要将每个三角形沿着法向量的方向移动一小段时间。效果就是，整个物体看起来像是沿着每个三角形的法线向量爆炸一样。爆炸三角形的效果在纳米装模型上看起来像是这样的：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/09/geometry_shader_explosion.png\" alt=\"image\" /></p>\n<p>这样的几何着色器效果的一个好处就是，无论物体有多复杂，它都能够应用上去。</p>\n<p>因为我们想要沿着三角形的法向量位移每个顶点，我们首先需要计算这个法向量。我们所要做的是计算垂直于三角形表面的向量，仅使用我们能够访问的 3 个顶点。你可能还记得在变换小节中，我们使用叉乘来获取垂直于其它两个向量的一个向量。如果我们能够获取两个平行于三角形表面的向量 a 和 b，我们就能够对这两个向量进行叉乘来获取法向量了。下面这个几何着色器函数做的正是这个，来使用 3 个输入顶点坐标来获取法向量：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vec3 <span class=\"token function\">GetNormal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>   vec3 a <span class=\"token operator\">=</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span>gl_in<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>gl_Position<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span>gl_in<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>gl_Position<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>   vec3 b <span class=\"token operator\">=</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span>gl_in<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>gl_Position<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span>gl_in<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>gl_Position<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>   <span class=\"token keyword\">return</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span><span class=\"token function\">cross</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这里我们使用减法获取了两个平行于三角形表面的向量 a 和 b。因为两个向量相减能够得到这两个向量之间的差值，并且三个点都位于三角平面上，对任意两个向量相减都能够得到一个平行于平面的向量。注意，如果我们交换了 cross 函数中 a 和 b 的位置，我们会得到一个指向相反方向的法向量 —— 这里的顺序很重要！</p>\n<p>既然知道了如何计算法向量了，我们就能够创建一个 explode 函数了，它使用法向量和顶点位置向量作为参数。这个函数会返回一个新的向量，它是位置向量沿着法线向量进行位移之后的结果：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vec4 <span class=\"token function\">explode</span><span class=\"token punctuation\">(</span>vec4 position<span class=\"token punctuation\">,</span> vec3 normal<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">float</span> magnitude <span class=\"token operator\">=</span> <span class=\"token number\">2.0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    vec3 direction <span class=\"token operator\">=</span> normal <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token function\">sin</span><span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2.0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> magnitude<span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">return</span> position <span class=\"token operator\">+</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>direction<span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>函数本身应该不是非常复杂。sin 函数接收一个 time 参数，它根据时间返回一个 - 1.0 到 1.0 之间的值。因为我们不想让物体向内爆炸 (Implode)，我们将 sin 值变换到了 [0, 1] 的范围内。最终的结果会乘以 normal 向量，并且最终的 direction 向量会被加到位置向量上。</p>\n<p>当使用我们的模型加载器绘制一个模型时，爆破 (Explode) 效果的完整片段着色器是这样的：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>triangles<span class=\"token punctuation\">)</span> in<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>triangle_strip<span class=\"token punctuation\">,</span> max_vertices <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> out<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>in VS_OUT <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    vec2 texCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span> gs_in<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>out vec2 TexCoords<span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>uniform <span class=\"token keyword\">float</span> time<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>vec4 <span class=\"token function\">explode</span><span class=\"token punctuation\">(</span>vec4 position<span class=\"token punctuation\">,</span> vec3 normal<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>vec3 <span class=\"token function\">GetNormal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>    </pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    vec3 normal <span class=\"token operator\">=</span> <span class=\"token function\">GetNormal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> <span class=\"token function\">explode</span><span class=\"token punctuation\">(</span>gl_in<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>gl_Position<span class=\"token punctuation\">,</span> normal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    TexCoords <span class=\"token operator\">=</span> gs_in<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>texCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token function\">EmitVertex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> <span class=\"token function\">explode</span><span class=\"token punctuation\">(</span>gl_in<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>gl_Position<span class=\"token punctuation\">,</span> normal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    TexCoords <span class=\"token operator\">=</span> gs_in<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>texCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token function\">EmitVertex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> <span class=\"token function\">explode</span><span class=\"token punctuation\">(</span>gl_in<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>gl_Position<span class=\"token punctuation\">,</span> normal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    TexCoords <span class=\"token operator\">=</span> gs_in<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>texCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token function\">EmitVertex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token function\">EndPrimitive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>注意我们在发射顶点之前输出了对应的纹理坐标。</p>\n<p>而且别忘了在 OpenGL 代码中设置 time 变量：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>shader<span class=\"token punctuation\">.</span><span class=\"token function\">setFloat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"time\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">glfwGetTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><h3 id=\"法向量可视化\"><a class=\"anchor\" href=\"#法向量可视化\">#</a> 法向量可视化</h3>\n<p>在这一部分中，我们将使用几何着色器来实现一个真正有用的例子：显示任意物体的法向量。当编写光照着色器时，你可能会最终会得到一些奇怪的视觉输出，但又很难确定导致问题的原因。光照错误很常见的原因就是法向量错误，这可能是由于不正确加载顶点数据、错误地将它们定义为顶点属性或在着色器中不正确地管理所导致的。我们想要的是使用某种方式来检测提供的法向量是正确的。检测法向量是否正确的一个很好的方式就是对它们进行可视化，几何着色器正是实现这一目的非常有用的工具。</p>\n<p>思路是这样的：我们首先不使用几何着色器正常绘制场景。然后再次绘制场景，但这次只显示通过几何着色器生成法向量。几何着色器接收一个三角形图元，并沿着法向量生成三条线 —— 每个顶点一个法向量。伪代码看起来会像是这样：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>shader<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">DrawScene</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>normalDisplayShader<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">DrawScene</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这次在几何着色器中，我们会使用模型提供的顶点法线，而不是自己生成，为了适配（观察和模型矩阵的）缩放和旋转，我们在将法线变换到裁剪空间坐标之前，先使用法线矩阵变换一次（几何着色器接受的位置向量是剪裁空间坐标，所以我们应该将法向量变换到相同的空间中）。这可以在顶点着色器中完成：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> in vec3 aPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> in vec3 aNormal<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>out VS_OUT <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    vec3 normal<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span> vs_out<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>uniform mat4 projection<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>uniform mat4 view<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>uniform mat4 model<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> projection <span class=\"token operator\">*</span> view <span class=\"token operator\">*</span> model <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>aPos<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    mat3 normalMatrix <span class=\"token operator\">=</span> <span class=\"token function\">mat3</span><span class=\"token punctuation\">(</span><span class=\"token function\">transpose</span><span class=\"token punctuation\">(</span><span class=\"token function\">inverse</span><span class=\"token punctuation\">(</span>view <span class=\"token operator\">*</span> model<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    vs_out<span class=\"token punctuation\">.</span>normal <span class=\"token operator\">=</span> <span class=\"token function\">normalize</span><span class=\"token punctuation\">(</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span>projection <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>normalMatrix <span class=\"token operator\">*</span> aNormal<span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>变换后的裁剪空间法向量会以接口块的形式传递到下个着色器阶段。接下来，几何着色器会接收每一个顶点（包括一个位置向量和一个法向量），并在每个位置向量处绘制一个法线向量：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>triangles<span class=\"token punctuation\">)</span> in<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>line_strip<span class=\"token punctuation\">,</span> max_vertices <span class=\"token operator\">=</span> <span class=\"token number\">6</span><span class=\"token punctuation\">)</span> out<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>in VS_OUT <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    vec3 normal<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span> gs_in<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">const</span> <span class=\"token keyword\">float</span> MAGNITUDE <span class=\"token operator\">=</span> <span class=\"token number\">0.4</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">GenerateLine</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> index<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> gl_in<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>gl_Position<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token function\">EmitVertex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> gl_in<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>gl_Position <span class=\"token operator\">+</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>gs_in<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>normal<span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> MAGNITUDE<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token function\">EmitVertex</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token function\">EndPrimitive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token function\">GenerateLine</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 第一个顶点法线</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token function\">GenerateLine</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 第二个顶点法线</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token function\">GenerateLine</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 第三个顶点法线</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>像这样的几何着色器应该很容易理解了。注意我们将法向量乘以了一个 MAGNITUDE 向量，来限制显示出的法向量大小（否则它们就有点大了）。</p>\n<p>因为法线的可视化通常都是用于调试目的，我们可以使用片段着色器，将它们显示为单色的线（如果你愿意也可以是非常好看的线）：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>out vec4 FragColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span><span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>现在，首先使用普通着色器渲染模型，再使用特别的<mark>法线可视化</mark>着色器渲染，你将看到这样的效果：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/09/geometry_shader_normals.png\" alt=\"image\" /></p>\n<p>尽管我们的纳米装现在看起来像是一个体毛很多而且带着隔热手套的人，它能够很有效地帮助我们判断模型的法线是否正确。你可以想象到，这样的几何着色器也经常用于给物体添加毛发 (Fur)。</p>\n<h2 id=\"实例化\"><a class=\"anchor\" href=\"#实例化\">#</a> 实例化</h2>\n<p>假设你有一个绘制了很多模型的场景，而大部分的模型包含的是同一组顶点数据，只不过进行的是不同的世界空间变换。想象一个充满草的场景：每根草都是一个包含几个三角形的小模型。你可能会需要绘制很多根草，最终在每帧中你可能会需要渲染上千或者上万根草。因为每一根草仅仅是由几个三角形构成，渲染几乎是瞬间完成的，但上千个渲染函数调用却会极大地影响性能。</p>\n<p>如果我们需要渲染大量物体时，代码看起来会像这样：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> amount_of_models_to_draw<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token function\">DoSomePreparations</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 绑定 VAO，绑定纹理，设置 uniform 等</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token function\">glDrawArrays</span><span class=\"token punctuation\">(</span>GL_TRIANGLES<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> amount_of_vertices<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>如果像这样绘制模型的<mark>大量实例</mark> (Instance)，你很快就会因为绘制调用过多而达到性能瓶颈。与绘制顶点本身相比，使用 glDrawArrays 或 glDrawElements 函数告诉 GPU 去绘制你的顶点数据会消耗更多的性能，因为 OpenGL 在绘制顶点数据之前需要做很多准备工作（比如告诉 GPU 该从哪个缓冲读取数据，从哪寻找顶点属性，而且这些都是在相对缓慢的 CPU 到 GPU 总线 (CPU to GPU Bus) 上进行的）。所以，即便渲染顶点非常快，命令 GPU 去渲染却未必。</p>\n<p>如果我们能<mark>够将数据一次性发送给 GPU</mark>，然后使用一个<strong>绘制函数</strong>让 OpenGL 利用这些数据绘制多个物体，就会更方便了。这就是实例化 (Instancing)。</p>\n<p>实例化这项技术能够让我们使用一个渲染调用来绘制多个物体，来节省每次绘制物体时 CPU -&gt; GPU 的通信，它只需要一次即可。如果想使用实例化渲染，我们只需要将<mark> glDrawArrays 和 glDrawElements 的渲染调用分别改为 glDrawArraysInstanced 和 glDrawElementsInstanced</mark> 就可以了。这些渲染函数的实例化版本需要一个额外的参数，叫做<mark>实例数量</mark> (Instance Count)，它能够设置我们需要渲染的实例个数。这样我们只需要将必须的数据发送到 GPU 一次，然后使用一次函数调用告诉 GPU 它应该如何绘制这些实例。GPU 将会直接渲染这些实例，而不用不断地与 CPU 进行通信。</p>\n<p>这个函数本身并没有什么用。渲染同一个物体一千次对我们并没有什么用处，每个物体都是完全相同的，而且还在同一个位置。我们只能看见一个物体！处于这个原因，GLSL 在顶点着色器中嵌入了另一个内建变量，gl_InstanceID。</p>\n<p>在使用实例化渲染调用时，gl_InstanceID 会从 0 开始，在每个实例被渲染时递增 1。比如说，我们正在渲染第 43 个实例，那么顶点着色器中它的 gl_InstanceID 将会是 42。因为每个实例都有唯一的 ID，我们可以建立一个数组，将 ID 与位置值对应起来，将每个实例放置在世界的不同位置。</p>\n<p>为了体验一下实例化绘制，我们将会在标准化设备坐标系中使用一个渲染调用，绘制 100 个 2D 四边形。我们会索引一个包含 100 个偏移向量的 uniform 数组，将偏移值加到每个实例化的四边形上。最终的结果是一个排列整齐的四边形网格：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/10/instancing_quads.png\" alt=\"image\" /></p>\n<p>每个四边形由 2 个三角形所组成，一共有 6 个顶点。每个顶点包含一个 2D 的标准化设备坐标位置向量和一个颜色向量。 下面就是这个例子使用的顶点数据，为了大量填充屏幕，每个三角形都很小：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">float</span> quadVertices<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">// 位置          // 颜色</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token operator\">-</span><span class=\"token number\">0.05f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.05f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>     <span class=\"token number\">0.05f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.05f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token operator\">-</span><span class=\"token number\">0.05f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.05f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token operator\">-</span><span class=\"token number\">0.05f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.05f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>     <span class=\"token number\">0.05f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">0.05f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span>   </pre></td></tr><tr><td data-num=\"9\"></td><td><pre>     <span class=\"token number\">0.05f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.05f</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0f</span>                   </pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>片段着色器会从顶点着色器接受颜色向量，并将其设置为它的颜色输出，来实现四边形的颜色：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>out vec4 FragColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>in vec3 fColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    FragColor <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>fColor<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>到现在都没有什么新内容，但从顶点着色器开始就变得很有趣了：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> in vec2 aPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> in vec3 aColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>out vec3 fColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>uniform vec2 offsets<span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    vec2 offset <span class=\"token operator\">=</span> offsets<span class=\"token punctuation\">[</span>gl_InstanceID<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>aPos <span class=\"token operator\">+</span> offset<span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    fColor <span class=\"token operator\">=</span> aColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这里我们定义了一个叫做 offsets 的数组，它包含 100 个偏移向量。在顶点着色器中，我们会使用 gl_InstanceID 来索引 offsets 数组，获取每个实例的偏移向量。如果我们要实例化绘制 100 个四边形，仅使用这个顶点着色器我们就能得到 100 个位于不同位置的四边形。</p>\n<p>当前，我们仍要设置这些偏移位置，我们会在进入渲染循环之前使用一个嵌套 for 循环计算：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>glm<span class=\"token operator\">::</span>vec2 translations<span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">float</span> offset <span class=\"token operator\">=</span> <span class=\"token number\">0.1f</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> y <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span> y <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> y <span class=\"token operator\">+=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span> x <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> x <span class=\"token operator\">+=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        glm<span class=\"token operator\">::</span>vec2 translation<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        translation<span class=\"token punctuation\">.</span>x <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span>x <span class=\"token operator\">/</span> <span class=\"token number\">10.0f</span> <span class=\"token operator\">+</span> offset<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        translation<span class=\"token punctuation\">.</span>y <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span>y <span class=\"token operator\">/</span> <span class=\"token number\">10.0f</span> <span class=\"token operator\">+</span> offset<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        translations<span class=\"token punctuation\">[</span>index<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> translation<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这里，我们创建 100 个位移向量，表示 10x10 网格上的所有位置。除了生成 translations 数组之外，我们还需要将数据转移到顶点着色器的 uniform 数组中：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>shader<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    stringstream ss<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    string index<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    ss <span class=\"token operator\">&lt;&lt;</span> i<span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    index <span class=\"token operator\">=</span> ss<span class=\"token punctuation\">.</span><span class=\"token function\">str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    shader<span class=\"token punctuation\">.</span><span class=\"token function\">setVec2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"offsets[\"</span> <span class=\"token operator\">+</span> index <span class=\"token operator\">+</span> <span class=\"token string\">\"]\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">c_str</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> translations<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>在这一段代码中，我们将 for 循环的计数器 i 转换为一个 string，我们可以用它来动态创建位置值的字符串，用于 uniform 位置值的索引。接下来，我们会对 offsets uniform 数组中的每一项设置对应的位移向量。</p>\n<p>现在所有的准备工作都做完了，我们可以开始渲染四边形了。对于实例化渲染，我们使用 glDrawArraysInstanced 或 glDrawElementsInstanced。因为我们使用的不是索引缓冲，我们会调用 glDrawArrays 版本的函数：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glBindVertexArray</span><span class=\"token punctuation\">(</span>quadVAO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glDrawArraysInstanced</span><span class=\"token punctuation\">(</span>GL_TRIANGLES<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>glDrawArraysInstanced 的参数和 glDrawArrays 完全一样，除了最后多了个参数用来设置需要绘制的实例数量。因为我们想要在 10x10 网格中显示 100 个四边形，我们将它设置为 100. 运行代码之后，你应该能得到熟悉的 100 个五彩的四边形。</p>\n<h3 id=\"实例化数组\"><a class=\"anchor\" href=\"#实例化数组\">#</a> 实例化数组</h3>\n<p>虽然之前的实现在目前的情况下能够正常工作，但是如果我们要渲染远超过 100 个实例的时候（这其实非常普遍），我们最终会超过最大能够发送至着色器的<mark> uniform 数据大小上限</mark>。它的一个代替方案是<mark>实例化数组</mark> (Instanced Array)，它被定义为一个顶点属性（能够让我们储存更多的数据），仅在顶点着色器渲染一个新的实例时才会更新。</p>\n<p>使用顶点属性时，顶点着色器的每次运行都会让 GLSL 获取新一组适用于当前顶点的属性。而当我们将顶点属性定义为一个实例化数组时，顶点着色器就只需要对每个实例，而不是每个顶点，更新顶点属性的内容了。这允许我们对逐顶点的数据使用普通的顶点属性，而对逐实例的数据使用实例化数组。</p>\n<p>为了给你一个实例化数组的例子，我们将使用之前的例子，并将偏移量 uniform 数组设置为一个实例化数组。我们需要在顶点着色器中再添加一个顶点属性：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> in vec2 aPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> in vec3 aColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> in vec2 aOffset<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>out vec3 fColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>aPos <span class=\"token operator\">+</span> aOffset<span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    fColor <span class=\"token operator\">=</span> aColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们不再使用 gl_InstanceID，现在不需要索引一个 uniform 数组就能够直接使用 offset 属性了。</p>\n<p>因为实例化数组和 position 与 color 变量一样，都是顶点属性，我们还需要将它的内容存在顶点缓冲对象中，并且配置它的属性指针。我们首先将（上一部分的）translations 数组存到一个新的缓冲对象中：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> instanceVBO<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glGenBuffers</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>instanceVBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> instanceVBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glBufferData</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span>vec2<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">100</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>translations<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> GL_STATIC_DRAW<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>之后我们还需要设置它的顶点属性指针，并启用顶点属性：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glEnableVertexAttribArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> instanceVBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glVertexAttribPointer</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   </pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">glVertexAttribDivisor</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>这段代码很有意思的地方在于最后一行，我们调用了<mark> glVertexAttribDivisor</mark>。这个函数告诉了 OpenGL 该什么时候<mark>更新顶点属性</mark>的内容至新一组数据。它的第一个参数是需要的顶点属性，第二个参数是属性除数 (Attribute Divisor)。默认情况下，属性除数是<strong> 0</strong>，告诉 OpenGL 我们需要在顶点着色器的<mark>每次迭代时更新顶点属性</mark>。将它设置为<strong> 1</strong> 时，我们告诉 OpenGL 我们希望在<mark>渲染一个新实例的时候更新顶点属性</mark>。而设置为<strong> 2</strong> 时，我们希望每<strong> 2</strong> 个实例更新一次属性，以此类推。我们将属性除数设置为 1，是在告诉 OpenGL，处于位置值 2 的顶点属性是一个实例化数组。</p>\n<p>如果我们现在使用 glDrawArraysInstanced，再次渲染四边形，会得到以下输出：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/10/instancing_quads.png\" alt=\"image\" /></p>\n<p>这和之前的例子是完全一样的，但这次是使用实例化数组实现的，这让我们能够传递更多的数据到顶点着色器（只要内存允许）来用于实例化绘制。</p>\n<p>为了更有趣一点，我们也可以使用 gl_InstanceID，从右上到左下逐渐缩小四边形：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    vec2 pos <span class=\"token operator\">=</span> aPos <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>gl_InstanceID <span class=\"token operator\">/</span> <span class=\"token number\">100.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>pos <span class=\"token operator\">+</span> aOffset<span class=\"token punctuation\">,</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    fColor <span class=\"token operator\">=</span> aColor<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>结果就是，第一个四边形的实例会非常小，随着绘制实例的增加，gl_InstanceID 会越来越接近 100，四边形也就越来越接近原始大小。像这样将实例化数组与 gl_InstanceID 结合使用是完全可行的。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/10/instancing_quads_arrays.png\" alt=\"image\" /></p>\n<p>如果你还是不确定实例化渲染是如何工作的，或者想看看所有代码是如何组合起来的，你可以在这里找到程序的源代码。</p>\n<p>虽然很有趣，但是这些例子并不是实例化的好例子。是的，它们的确让你知道实例化是怎么工作的，但是我们还没接触到它最有用的一点：绘制巨大数量的相似物体。出于这个原因，我们将会在下一部分进入太空探险，见识实例化渲染真正的威力。</p>\n<h3 id=\"小行星带\"><a class=\"anchor\" href=\"#小行星带\">#</a> 小行星带</h3>\n<p>想象这样一个场景，在宇宙中有一个大的行星，它位于小行星带的中央。这样的小行星带可能包含成千上万的岩块，在很不错的显卡上也很难完成这样的渲染。实例化渲染正是适用于这样的场景，因为所有的小行星都可以使用一个模型来表示。每个小行星可以再使用不同的变换矩阵来进行少许的变化。</p>\n<p>为了展示实例化渲染的作用，我们首先会<mark>不使用实例化渲染</mark>，来渲染小行星绕着行星飞行的场景。这个场景将会包含一个大的行星模型，它可以在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWFybm9wZW5nbC1jbi5naXRodWIuaW8vZGF0YS9wbGFuZXQucmFy\">这里下载</span>，以及很多环绕着行星的小行星。小行星的岩石模型可以在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWFybm9wZW5nbC1jbi5naXRodWIuaW8vZGF0YS9yb2NrLnJhcg==\">这里下载</span>。</p>\n<p>在代码例子中，我们将使用在模型加载小节中定义的模型加载器来加载模型。</p>\n<p>为了得到想要的效果，我们将会为每个小行星生成一个变换矩阵，用作它们的模型矩阵。变换矩阵首先将小行星位移到小行星带中的某处，我们还会加一个小的随机偏移值到这个偏移量上，让这个圆环看起来更自然一点。接下来，我们应用一个随机的缩放，并且以一个旋转向量为轴进行一个随机的旋转。最终的变换矩阵不仅能将小行星变换到行星的周围，而且会让它看起来更自然，与其它小行星不同。最终的结果是一个布满小行星的圆环，其中每一个小行星都与众不同。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> amount <span class=\"token operator\">=</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>glm<span class=\"token operator\">::</span>mat4 <span class=\"token operator\">*</span>modelMatrices<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>modelMatrices <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> glm<span class=\"token operator\">::</span>mat4<span class=\"token punctuation\">[</span>amount<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">srand</span><span class=\"token punctuation\">(</span><span class=\"token function\">glfwGetTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 初始化随机种子    </span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">float</span> radius <span class=\"token operator\">=</span> <span class=\"token number\">50.0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">float</span> offset <span class=\"token operator\">=</span> <span class=\"token number\">2.5f</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> amount<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    glm<span class=\"token operator\">::</span>mat4 model<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\">// 1. 位移：分布在半径为 'radius' 的圆形上，偏移的范围是 [-offset, offset]</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">float</span> angle <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span>i <span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span>amount <span class=\"token operator\">*</span> <span class=\"token number\">360.0f</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">float</span> displacement <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token function\">rand</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span> <span class=\"token operator\">*</span> offset <span class=\"token operator\">*</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">100.0f</span> <span class=\"token operator\">-</span> offset<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">float</span> x <span class=\"token operator\">=</span> <span class=\"token function\">sin</span><span class=\"token punctuation\">(</span>angle<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> radius <span class=\"token operator\">+</span> displacement<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    displacement <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token function\">rand</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span> <span class=\"token operator\">*</span> offset <span class=\"token operator\">*</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">100.0f</span> <span class=\"token operator\">-</span> offset<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">float</span> y <span class=\"token operator\">=</span> displacement <span class=\"token operator\">*</span> <span class=\"token number\">0.4f</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 让行星带的高度比 x 和 z 的宽度要小</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    displacement <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token function\">rand</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span> <span class=\"token operator\">*</span> offset <span class=\"token operator\">*</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">100.0f</span> <span class=\"token operator\">-</span> offset<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token keyword\">float</span> z <span class=\"token operator\">=</span> <span class=\"token function\">cos</span><span class=\"token punctuation\">(</span>angle<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> radius <span class=\"token operator\">+</span> displacement<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    model <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">translate</span><span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">,</span> z<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token comment\">// 2. 缩放：在 0.05 和 0.25f 之间缩放</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token keyword\">float</span> scale <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token function\">rand</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">100.0f</span> <span class=\"token operator\">+</span> <span class=\"token number\">0.05</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    model <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">scale</span><span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span>scale<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token comment\">// 3. 旋转：绕着一个（半）随机选择的旋转轴向量进行随机的旋转</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token keyword\">float</span> rotAngle <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token function\">rand</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">360</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    model <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">rotate</span><span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">,</span> rotAngle<span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.4f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.6f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.8f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token comment\">// 4. 添加到矩阵的数组中</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    modelMatrices<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> model<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这段代码看起来可能有点吓人，但我们只是将小行星的 x 和 z 位置变换到了一个半径为 radius 的圆形上，并且在半径的基础上偏移了 - offset 到 offset。我们让 y 偏移的影响更小一点，让小行星带更扁平一点。接下来，我们应用了缩放和旋转变换，并将最终的变换矩阵储存在 modelMatrices 中，这个数组的大小是 amount。这里，我们一共生成 1000 个模型矩阵，每个小行星一个。</p>\n<p>在加载完行星和岩石模型，并编译完着色器之后，渲染的代码看起来是这样的：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 绘制行星</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>shader<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>glm<span class=\"token operator\">::</span>mat4 model<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>model <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">translate</span><span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">0.0f</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">3.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>model <span class=\"token operator\">=</span> glm<span class=\"token operator\">::</span><span class=\"token function\">scale</span><span class=\"token punctuation\">(</span>model<span class=\"token punctuation\">,</span> glm<span class=\"token operator\">::</span><span class=\"token function\">vec3</span><span class=\"token punctuation\">(</span><span class=\"token number\">4.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4.0f</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4.0f</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>shader<span class=\"token punctuation\">.</span><span class=\"token function\">setMat4</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"model\"</span><span class=\"token punctuation\">,</span> model<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>planet<span class=\"token punctuation\">.</span><span class=\"token function\">Draw</span><span class=\"token punctuation\">(</span>shader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\">// 绘制小行星</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> amount<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    shader<span class=\"token punctuation\">.</span><span class=\"token function\">setMat4</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"model\"</span><span class=\"token punctuation\">,</span> modelMatrices<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    rock<span class=\"token punctuation\">.</span><span class=\"token function\">Draw</span><span class=\"token punctuation\">(</span>shader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们首先绘制了行星的模型，并对它进行位移和缩放，以适应场景，接下来，我们绘制 amount 数量的岩石模型。在绘制每个岩石之前，我们首先需要在着色器内设置对应的模型变换矩阵。</p>\n<p>最终的结果是一个看起来像是太空的场景，环绕着行星的是看起来很自然的小行星带：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/10/instancing_asteroids.png\" alt=\"image\" /></p>\n<p>这个场景每帧包含 1001 次渲染调用，其中 1000 个是岩石模型。</p>\n<p>当我们开始增加这个数字的时候，你很快就会发现场景不再能够流畅运行了，帧数也下降很厉害。当我们将 amount 设置为 2000 的时候，场景就已经慢到移动都很困难的程度了。</p>\n<p>现在，我们来尝试使用实例化渲染来渲染相同的场景。我们首先对顶点着色器进行一点修改：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">version</span> <span class=\"token expression\"><span class=\"token number\">330</span> core</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> in vec3 aPos<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> in vec2 aTexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">layout</span> <span class=\"token punctuation\">(</span>location <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> in mat4 instanceMatrix<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>out vec2 TexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>uniform mat4 projection<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>uniform mat4 view<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    gl_Position <span class=\"token operator\">=</span> projection <span class=\"token operator\">*</span> view <span class=\"token operator\">*</span> instanceMatrix <span class=\"token operator\">*</span> <span class=\"token function\">vec4</span><span class=\"token punctuation\">(</span>aPos<span class=\"token punctuation\">,</span> <span class=\"token number\">1.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    TexCoords <span class=\"token operator\">=</span> aTexCoords<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>我们不再使用模型 uniform 变量，改为一个 mat4 的顶点属性，让我们能够存储一个实例化数组的变换矩阵。然而，当我们顶点属性的类型大于 vec4 时，就要多进行一步处理了。顶点属性最大允许的数据大小等于一个 vec4。因为一个 mat4 本质上是 4 个 vec4，我们需要为这个矩阵预留 4 个顶点属性。因为我们将它的位置值设置为 3，矩阵每一列的顶点属性位置值就是 3、4、5 和 6。</p>\n<p>接下来，我们需要为这 4 个顶点属性设置属性指针，并将它们设置为实例化数组：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 顶点缓冲对象</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> buffer<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glGenBuffers</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glBindBuffer</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">glBufferData</span><span class=\"token punctuation\">(</span>GL_ARRAY_BUFFER<span class=\"token punctuation\">,</span> amount <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span>mat4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>modelMatrices<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> GL_STATIC_DRAW<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> rock<span class=\"token punctuation\">.</span>meshes<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> VAO <span class=\"token operator\">=</span> rock<span class=\"token punctuation\">.</span>meshes<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>VAO<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token function\">glBindVertexArray</span><span class=\"token punctuation\">(</span>VAO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token comment\">// 顶点属性</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    GLsizei vec4Size <span class=\"token operator\">=</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>glm<span class=\"token operator\">::</span>vec4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token function\">glEnableVertexAttribArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token function\">glVertexAttribPointer</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span> <span class=\"token number\">4</span> <span class=\"token operator\">*</span> vec4Size<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token function\">glEnableVertexAttribArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token function\">glVertexAttribPointer</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span> <span class=\"token number\">4</span> <span class=\"token operator\">*</span> vec4Size<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>vec4Size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token function\">glEnableVertexAttribArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token function\">glVertexAttribPointer</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span> <span class=\"token number\">4</span> <span class=\"token operator\">*</span> vec4Size<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span> <span class=\"token operator\">*</span> vec4Size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token function\">glEnableVertexAttribArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token function\">glVertexAttribPointer</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> GL_FLOAT<span class=\"token punctuation\">,</span> GL_FALSE<span class=\"token punctuation\">,</span> <span class=\"token number\">4</span> <span class=\"token operator\">*</span> vec4Size<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span> <span class=\"token operator\">*</span> vec4Size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token function\">glVertexAttribDivisor</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token function\">glVertexAttribDivisor</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token function\">glVertexAttribDivisor</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token function\">glVertexAttribDivisor</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token function\">glBindVertexArray</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>注意这里我们将 Mesh 的 VAO 从私有变量改为了公有变量，让我们能够访问它的顶点数组对象。这并不是最好的解决方案，只是为了配合本小节的一个简单的改动。除此之外代码就应该很清楚了。我们告诉了 OpenGL 应该如何解释每个缓冲顶点属性的缓冲，并且告诉它这些顶点属性是实例化数组。</p>\n<p>接下来，我们再次使用网格的 VAO，这一次使用 glDrawElementsInstanced 进行绘制：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 绘制小行星</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>instanceShader<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> rock<span class=\"token punctuation\">.</span>meshes<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token function\">glBindVertexArray</span><span class=\"token punctuation\">(</span>rock<span class=\"token punctuation\">.</span>meshes<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>VAO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token function\">glDrawElementsInstanced</span><span class=\"token punctuation\">(</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        GL_TRIANGLES<span class=\"token punctuation\">,</span> rock<span class=\"token punctuation\">.</span>meshes<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>indices<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> GL_UNSIGNED_INT<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> amount</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>这里，我们绘制与之前相同数量 amount 的小行星，但是使用的是实例渲染。结果应该是非常相似的，但如果你开始增加 amount 变量，你就能看见实例化渲染的效果了。没有实例化渲染的时候，我们只能流畅渲染 1000 到 1500 个小行星。而使用了实例化渲染之后，我们可以将这个值设置为 100000，每个岩石模型有 576 个顶点，每帧加起来大概要绘制 5700 万个顶点，但性能却没有受到任何影响！</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/10/instancing_asteroids_quantity.png\" alt=\"image\" /></p>\n<p>上面这幅图渲染了 10 万个小行星，半径为 150.0f，偏移量等于 25.0f。</p>\n<blockquote>\n<p>在某些机器上，10 万个小行星可能会太多了，所以尝试修改这个值，直到达到一个你能接受的帧率。</p>\n</blockquote>\n<p>可以看到，在合适的环境下，实例化渲染能够大大增加显卡的渲染能力。正是出于这个原因，实例化渲染通常会用于渲染草、植被、粒子，以及上面这样的场景，基本上只要场景中有很多重复的形状，都能够使用实例化渲染来提高性能。</p>\n<h2 id=\"抗锯齿\"><a class=\"anchor\" href=\"#抗锯齿\">#</a> 抗锯齿</h2>\n<p>在学习渲染的旅途中，你可能会时不时遇到模型边缘有锯齿的情况。这些<mark>锯齿边缘</mark> (Jagged Edges) 的产生和光栅器将顶点数据转化为片段的方式有关。在下面的例子中，你可以看到，我们只是绘制了一个简单的立方体，你就能注意到它存在锯齿边缘了：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/11/anti_aliasing_aliasing.png\" alt=\"image\" /></p>\n<p>可能不是非常明显，但如果你离近仔细观察立方体的边缘，你就应该能够看到锯齿状的图案。如果放大的话，你会看到下面的图案：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/11/anti_aliasing_zoomed.png\" alt=\"image\" /></p>\n<p>这很明显不是我们想要在最终程序中所实现的效果。你能够清楚看见形成边缘的像素。这种现象被称之为<mark>走样</mark> (Aliasing)。有很多种<mark>抗锯齿</mark>（Anti-aliasing，也被称为反走样）的技术能够帮助我们缓解这种现象，从而产生更平滑的边缘。</p>\n<p>最开始我们有一种叫做<mark>超采样抗锯齿</mark> (Super Sample Anti-aliasing, SSAA) 的技术，它会使用比正常分辨率<mark>更高</mark>的分辨率（即超采样）来渲染场景，当图像输出在帧缓冲中更新时，分辨率会被<mark>下采样</mark> (Downsample) 至正常的分辨率。这些<mark>额外的</mark>分辨率会被用来防止锯齿边缘的产生。虽然它确实能够解决走样的问题，但是由于这样比平时要绘制更多的片段，它也会带来很大的<mark>性能开销</mark>。所以这项技术只拥有了短暂的辉煌。</p>\n<p>然而，在这项技术的基础上也诞生了更为现代的技术，叫做<mark>多重采样抗锯齿</mark> (Multisample Anti-aliasing, MSAA)。它借鉴了 SSAA 背后的理念，但却以更加高效的方式实现了抗锯齿。我们在这一节中会深度讨论 OpenGL 中内建的 MSAA 技术。</p>\n<h3 id=\"多重采样\"><a class=\"anchor\" href=\"#多重采样\">#</a> 多重采样</h3>\n<p>为了理解什么是多重采样 (Multisampling)，以及它是如何解决锯齿问题的，我们有必要更加深入地了解 OpenGL 光栅器的工作方式。</p>\n<p><mark>光栅器</mark>是位于最终处理过的顶点之后到片段着色器之前所经过的所有的算法与过程的总和。光栅器会将一个图元的所有顶点作为输入，并将它转换为一系列的片段。顶点坐标理论上可以取任意值，但片段不行，因为它们受限于你窗口的分辨率。顶点坐标与片段之间几乎永远也不会有一对一的映射，所以光栅器必须以某种方式来决定每个顶点最终所在的片段 / 屏幕坐标。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/11/anti_aliasing_rasterization.png\" alt=\"image\" /></p>\n<p>这里我们可以看到一个屏幕像素的网格，每个像素的中心包含有一个<mark>采样点</mark> (Sample Point)，它会被用来决定这个三角形是否遮盖了某个像素。图中红色的采样点被三角形所遮盖，在每一个遮住的像素处都会生成一个片段。虽然三角形边缘的一些部分也遮住了某些屏幕像素，但是这些像素的采样点并没有被三角形内部所遮盖，所以它们不会受到片段着色器的影响。</p>\n<p>你现在可能已经清楚走样的原因了。完整渲染后的三角形在屏幕上会是这样的：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/11/anti_aliasing_rasterization_filled.png\" alt=\"image\" /></p>\n<p>由于屏幕像素总量的限制，有些边缘的像素能够被渲染出来，而有些则不会。结果就是我们使用了不光滑的边缘来渲染图元，导致之前讨论到的锯齿边缘。</p>\n<p><mark>多重采样</mark>所做的正是将<mark>单一</mark>的采样点变为<mark>多个</mark>采样点（这也是它名称的由来）。我们不再使用像素中心的单一采样点，取而代之的是以特定图案排列的 4 个子采样点 (Subsample)。我们将用这些子采样点来决定像素的遮盖度。当然，这也意味着颜色缓冲的大小会随着子采样点的增加而增加。</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/11/anti_aliasing_sample_points.png\" alt=\"image\" /></p>\n<p>上图的左侧展示了正常情况下判定三角形是否遮盖的方式。在例子中的这个像素上不会运行片段着色器（所以它会保持空白）。因为它的采样点并未被三角形所覆盖。上图的右侧展示的是实施多重采样之后的版本，每个像素包含有 4 个采样点。这里，只有两个采样点遮盖住了三角形。</p>\n<blockquote>\n<p>采样点的数量可以是任意的，更多的采样点能带来更精确的遮盖率。</p>\n</blockquote>\n<p>从这里开始多重采样就变得有趣起来了。我们知道三角形只遮盖了 2 个子采样点，所以下一步是决定这个像素的颜色。你的猜想可能是，我们对每个被遮盖住的子采样点运行一次片段着色器，最后将每个像素所有<mark>子采样点的颜色平均一下</mark>。在这个例子中，我们需要在两个子采样点上对被插值的顶点数据运行两次片段着色器，并将结果的颜色储存在这些采样点中。（幸运的是）这并不是它工作的方式，因为这本质上说还是需要运行更多次的片段着色器，会显著地降低性能。</p>\n<p>MSAA 真正的工作方式是，无论三角形遮盖了多少个子采样点，（每个图元中）每个像素只运行一次片段着色器。片段着色器所使用的顶点数据会插值到每个像素的中心，所得到的结果颜色会被储存在每个被遮盖住的子采样点中。当颜色缓冲的子样本被图元的所有颜色填满时，所有的这些颜色将会在每个像素内部平均化。因为上图的 4 个采样点中只有 2 个被遮盖住了，这个像素的颜色将会是三角形颜色与其他两个采样点的颜色（在这里是无色）的平均值，最终形成一种淡蓝色。</p>\n<p>这样子做之后，颜色缓冲中所有的图元边缘将会产生一种更平滑的图形。让我们来看看前面三角形的多重采样会是什么样子：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/11/anti_aliasing_rasterization_samples.png\" alt=\"image\" /></p>\n<p>这里，每个像素包含 4 个子采样点（不相关的采样点都没有标注），蓝色的采样点被三角形所遮盖，而灰色的则没有。对于三角形的内部的像素，片段着色器只会运行一次，颜色输出会被存储到全部的 4 个子样本中。而在三角形的边缘，并不是所有的子采样点都被遮盖，所以片段着色器的结果将只会储存到部分的子样本中。根据被遮盖的子样本的数量，最终的像素颜色将由三角形的颜色与其它子样本中所储存的颜色来决定。</p>\n<p>简单来说，一个像素中如果有更多的采样点被三角形遮盖，那么这个像素的颜色就会更接近于三角形的颜色。如果我们给上面的三角形填充颜色，就能得到以下的效果：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/11/anti_aliasing_rasterization_samples_filled.png\" alt=\"image\" /></p>\n<p>对于每个像素来说，越少的子采样点被三角形所覆盖，那么它受到三角形的影响就越小。三角形的不平滑边缘被稍浅的颜色所包围后，从远处观察时就会显得更加平滑了。</p>\n<p>不仅仅是颜色值会受到多重采样的影响，深度和模板测试也能够使用多个采样点。对深度测试来说，每个顶点的深度值会在运行深度测试之前被插值到各个子样本中。对模板测试来说，我们对每个子样本，而不是每个像素，存储一个模板值。当然，这也意味着深度和模板缓冲的大小会乘以子采样点的个数。</p>\n<p>我们到目前为止讨论的都是多重采样抗锯齿的背后原理，光栅器背后的实际逻辑比目前讨论的要复杂，但你现在应该已经可以理解多重采样抗锯齿的大体概念和逻辑了。</p>\n<p>(译者注： 如果看到这里还是对原理似懂非懂，可以简单看看知乎上 @文刀秋二对抗锯齿技术的<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwMjM2NjM4L2Fuc3dlci8xNDQzODIxOA==\">精彩介绍</span>)</p>\n<h3 id=\"opengl中的msaa\"><a class=\"anchor\" href=\"#opengl中的msaa\">#</a> OpenGL 中的 MSAA</h3>\n<p>如果我们想要在 OpenGL 中使用 MSAA，我们必须要使用一个能在每个像素中存储大于 1 个颜色值的颜色缓冲（因为多重采样需要我们为每个采样点都储存一个颜色）。所以，我们需要一个新的缓冲类型，来存储特定数量的多重采样样本，它叫做<mark>多重采样缓冲</mark> (Multisample Buffer)。</p>\n<p>大多数的窗口系统都应该提供了一个多重采样缓冲，用以代替默认的颜色缓冲。GLFW 同样给了我们这个功能，我们所要做的只是<mark>提示</mark> (Hint) GLFW，我们希望使用一个包含 N 个样本的多重采样缓冲。这可以在创建窗口之前调用 glfwWindowHint 来完成。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glfwWindowHint</span><span class=\"token punctuation\">(</span>GLFW_SAMPLES<span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>现在再调用 glfwCreateWindow 创建渲染窗口时，每个屏幕坐标就会使用一个包含 4 个子采样点的颜色缓冲了。GLFW 会自动创建一个每像素 4 个子采样点的深度和样本缓冲。这也意味着所有缓冲的大小都增长了 4 倍。</p>\n<p>现在我们已经向 GLFW 请求了多重采样缓冲，我们还需要调用<mark> glEnable</mark> 并启用<mark> GL_MULTISAMPLE</mark>，来启用多重采样。在大多数 OpenGL 的驱动上，多重采样都是默认启用的，所以这个调用可能会有点多余，但显式地调用一下会更保险一点。这样子不论是什么 OpenGL 的实现都能够正常启用多重采样了。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glEnable</span><span class=\"token punctuation\">(</span>GL_MULTISAMPLE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>只要默认的帧缓冲有了多重采样缓冲的附件，我们所要做的只是调用 glEnable 来启用多重采样。因为多重采样的算法都在 OpenGL 驱动的光栅器中实现了，我们不需要再多做什么。如果现在再来渲染本节一开始的那个绿色的立方体，我们应该能看到更平滑的边缘：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/11/anti_aliasing_multisampled.png\" alt=\"image\" /></p>\n<p>这个箱子看起来的确要平滑多了，如果在场景中有其它的物体，它们也会看起来平滑很多。</p>\n<h3 id=\"离屏msaa\"><a class=\"anchor\" href=\"#离屏msaa\">#</a> 离屏 MSAA</h3>\n<p>由于 GLFW 负责了创建多重采样缓冲，启用 MSAA 非常简单。然而，如果我们想要使用我们自己的帧缓冲来进行离屏渲染，那么我们就必须要自己动手生成多重采样缓冲了。</p>\n<p>有两种方式可以创建多重采样缓冲，将其作为帧缓冲的附件：纹理附件和渲染缓冲附件，这和在帧缓冲教程中所讨论的普通附件很相似。</p>\n<h3 id=\"多重采样纹理附件\"><a class=\"anchor\" href=\"#多重采样纹理附件\">#</a> 多重采样纹理附件</h3>\n<p>为了创建一个支持储存多个采样点的纹理，我们使用 glTexImage2DMultisample 来替代 glTexImage2D，它的纹理目标是 GL_TEXTURE_2D_MULTISAPLE。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D_MULTISAMPLE<span class=\"token punctuation\">,</span> tex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glTexImage2DMultisample</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D_MULTISAMPLE<span class=\"token punctuation\">,</span> samples<span class=\"token punctuation\">,</span> GL_RGB<span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">,</span> GL_TRUE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D_MULTISAMPLE<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>它的第二个参数设置的是纹理所拥有的样本个数。如果最后一个参数为 GL_TRUE，图像将会对每个纹素使用相同的样本位置以及相同数量的子采样点个数。</p>\n<p>我们使用 glFramebufferTexture2D 将多重采样纹理附加到帧缓冲上，但这里纹理类型使用的是 GL_TEXTURE_2D_MULTISAMPLE。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glFramebufferTexture2D</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> GL_COLOR_ATTACHMENT0<span class=\"token punctuation\">,</span> GL_TEXTURE_2D_MULTISAMPLE<span class=\"token punctuation\">,</span> tex<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>当前绑定的帧缓冲现在就有了一个纹理图像形式的多重采样颜色缓冲。</p>\n<h3 id=\"多重采样渲染缓冲对象\"><a class=\"anchor\" href=\"#多重采样渲染缓冲对象\">#</a> 多重采样渲染缓冲对象</h3>\n<p>和纹理类似，创建一个多重采样渲染缓冲对象并不难。我们所要做的只是在指定（当前绑定的）渲染缓冲的内存存储时，将 glRenderbufferStorage 的调用改为 glRenderbufferStorageMultisample 就可以了。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glRenderbufferStorageMultisample</span><span class=\"token punctuation\">(</span>GL_RENDERBUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> GL_DEPTH24_STENCIL8<span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>函数中，渲染缓冲对象后的参数我们将设定为样本的数量，在当前的例子中是 4。</p>\n<h3 id=\"渲染到多重采样帧缓冲\"><a class=\"anchor\" href=\"#渲染到多重采样帧缓冲\">#</a> 渲染到多重采样帧缓冲</h3>\n<p>渲染到多重采样帧缓冲对象的过程都是自动的。只要我们在帧缓冲绑定时绘制任何东西，光栅器就会负责所有的多重采样运算。我们最终会得到一个多重采样颜色缓冲以及 / 或深度和模板缓冲。因为多重采样缓冲有一点特别，我们不能直接将它们的缓冲图像用于其他运算，比如在着色器中对它们进行采样。</p>\n<p>一个多重采样的图像包含比普通图像更多的信息，我们所要做的是缩小或者还原 (Resolve) 图像。多重采样帧缓冲的还原通常是通过 glBlitFramebuffer 来完成，它能够将一个帧缓冲中的某个区域复制到另一个帧缓冲中，并且将多重采样缓冲还原。</p>\n<p>glBlitFramebuffer 会将一个用 4 个屏幕空间坐标所定义的源区域复制到一个同样用 4 个屏幕空间坐标所定义的目标区域中。你可能记得在帧缓冲教程中，当我们绑定到 GL_FRAMEBUFFER 时，我们是同时绑定了读取和绘制的帧缓冲目标。我们也可以将帧缓冲分开绑定至 GL_READ_FRAMEBUFFER 与 GL_DRAW_FRAMEBUFFER。glBlitFramebuffer 函数会根据这两个目标，决定哪个是源帧缓冲，哪个是目标帧缓冲。接下来，我们可以将图像位块传送 (Blit) 到默认的帧缓冲中，将多重采样的帧缓冲传送到屏幕上。</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">glBindFramebuffer</span><span class=\"token punctuation\">(</span>GL_READ_FRAMEBUFFER<span class=\"token punctuation\">,</span> multisampledFBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">glBindFramebuffer</span><span class=\"token punctuation\">(</span>GL_DRAW_FRAMEBUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">glBlitFramebuffer</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">,</span> GL_COLOR_BUFFER_BIT<span class=\"token punctuation\">,</span> GL_NEAREST<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>如果现在再来渲染这个程序，我们会得到与之前完全一样的结果：一个使用 MSAA 显示出来的橄榄绿色的立方体，而且锯齿边缘明显减少了：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/11/anti_aliasing_multisampled.png\" alt=\"image\" /></p>\n<p>但如果我们想要使用多重采样帧缓冲的纹理输出来做像是后期处理这样的事情呢？我们不能直接在片段着色器中使用多重采样的纹理。但我们能做的是将多重采样缓冲位块传送到一个没有使用多重采样纹理附件的 FBO 中。然后用这个普通的颜色附件来做后期处理，从而达到我们的目的。然而，这也意味着我们需要生成一个新的 FBO，作为中介帧缓冲对象，将多重采样缓冲还原为一个能在着色器中使用的普通 2D 纹理。这个过程的伪代码是这样的：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> msFBO <span class=\"token operator\">=</span> <span class=\"token function\">CreateFBOWithMultiSampledAttachments</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// 使用普通的纹理颜色附件创建一个新的 FBO</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">glFramebufferTexture2D</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> GL_COLOR_ATTACHMENT0<span class=\"token punctuation\">,</span> GL_TEXTURE_2D<span class=\"token punctuation\">,</span> screenTexture<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">glfwWindowShouldClose</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token function\">glBindFramebuffer</span><span class=\"token punctuation\">(</span>msFBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token function\">ClearFrameBuffer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token function\">DrawScene</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token comment\">// 将多重采样缓冲还原到中介 FBO 上</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token function\">glBindFramebuffer</span><span class=\"token punctuation\">(</span>GL_READ_FRAMEBUFFER<span class=\"token punctuation\">,</span> msFBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token function\">glBindFramebuffer</span><span class=\"token punctuation\">(</span>GL_DRAW_FRAMEBUFFER<span class=\"token punctuation\">,</span> intermediateFBO<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token function\">glBlitFramebuffer</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">,</span> GL_COLOR_BUFFER_BIT<span class=\"token punctuation\">,</span> GL_NEAREST<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token comment\">// 现在场景是一个 2D 纹理缓冲，可以将这个图像用来后期处理</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token function\">glBindFramebuffer</span><span class=\"token punctuation\">(</span>GL_FRAMEBUFFER<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token function\">ClearFramebuffer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token function\">glBindTexture</span><span class=\"token punctuation\">(</span>GL_TEXTURE_2D<span class=\"token punctuation\">,</span> screenTexture<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token function\">DrawPostProcessingQuad</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> </pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>如果现在再实现帧缓冲教程中的后期处理效果，我们就能够在一个几乎没有锯齿的场景纹理上进行后期处理了。如果施加模糊的核滤镜，看起来将会是这样：</p>\n<p><img data-src=\"https://learnopengl-cn.github.io/img/04/11/anti_aliasing_post_processing.png\" alt=\"image\" /></p>\n<blockquote>\n<p>因为屏幕纹理又变回了一个只有单一采样点的普通纹理，像是边缘检测这样的后期处理滤镜会重新导致锯齿。为了补偿这一问题，你可以之后对纹理进行模糊处理，或者想出你自己的抗锯齿算法。</p>\n</blockquote>\n<p>你可以看到，如果将多重采样与离屏渲染结合起来，我们需要自己负责一些额外的细节。但所有的这些细节都是值得额外的努力的，因为多重采样能够显著提升场景的视觉质量。当然，要注意，如果使用的采样点非常多，启用多重采样会显著降低程序的性能。在本节写作时，通常采用的是 4 采样点的 MSAA。</p>\n<h3 id=\"自定义抗锯齿算法\"><a class=\"anchor\" href=\"#自定义抗锯齿算法\">#</a> 自定义抗锯齿算法</h3>\n<p>将一个多重采样的纹理图像不进行还原直接传入着色器也是可行的。GLSL 提供了这样的选项，让我们能够对纹理图像的每个子样本进行采样，所以我们可以创建我们自己的抗锯齿算法。在大型的图形应用中通常都会这么做。</p>\n<p>要想获取每个子样本的颜色值，你需要将纹理 uniform 采样器设置为 sampler2DMS，而不是平常使用的 sampler2D：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>uniform sampler2DMS screenTextureMS<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>使用 texelFetch 函数就能够获取每个子样本的颜色值了：</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>vec4 colorSample <span class=\"token operator\">=</span> <span class=\"token function\">texelFetch</span><span class=\"token punctuation\">(</span>screenTextureMS<span class=\"token punctuation\">,</span> TexCoords<span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 第 4 个子样本</span></pre></td></tr></table></figure><p>我们不会深入探究自定义抗锯齿技术的细节，这里仅仅是给你一点启发。</p>\n",
            "tags": [
                "计算机科学",
                "学习笔记",
                "OpenGL"
            ]
        }
    ]
}