<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="鑫酱" href="https://allengx.gitee.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="鑫酱" href="https://allengx.gitee.io/atom.xml"><link rel="alternate" type="application/json" title="鑫酱" href="https://allengx.gitee.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.3"><link rel="canonical" href="https://allengx.gitee.io/computer-science/study/opengl/4-OpenGL-High-Level/"><title>四、高级OpenGL - OpenGL - 学习笔记 - 计算机科学 | 个人博客 = 鑫酱 = 笔记本</title><meta name="generator" content="Hexo 5.1.1"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">四、高级OpenGL</h1><div class="meta"><span class="item" title="创建时间：2020-04-12 20:46:25"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2020-04-12T20:46:25+08:00">2020-04-12</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>84k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>1:17</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">个人博客</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipeun65urj20zk0m81ii.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclh5u05ej20zk0m87df.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipewr8iypj20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicit4jrvuj20zk0m8785.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclxfdlttj20zk0m8npd.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclflwv2aj20zk0m84qp.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main id="main"><div class="inner"><div id="content" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/" itemprop="item" rel="index" title="分类于 计算机科学"><span itemprop="name">计算机科学</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/study/" itemprop="item" rel="index" title="分类于 学习笔记"><span itemprop="name">学习笔记</span></a><meta itemprop="position" content="2"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/study/opengl/" itemprop="item" rel="index" title="分类于 OpenGL"><span itemprop="name">OpenGL</span></a><meta itemprop="position" content="3"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://allengx.gitee.io/computer-science/study/opengl/4-OpenGL-High-Level/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="鑫酱(●'◡'●)"><meta itemprop="description" content="笔记本, 整天摸鱼，却妄想拯救世界的技术宅"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="鑫酱"></span><div class="body md" itemprop="articleBody"><div class="note info"><p>以下为个人学习笔记整理源颜色向量</p></div><h1 id="高级opengl"><a class="anchor" href="#高级opengl">#</a> 高级 OpenGL</h1><h2 id="深度测试"><a class="anchor" href="#深度测试">#</a> 深度测试</h2><p>在坐标系统小节中，我们渲染了一个 3D 箱子，并且运用了<mark>深度缓冲</mark> (Depth Buffer) 来防止被阻挡的面渲染到其它面的前面。在这一节中，我们将会更加深入地讨论这些储存在深度缓冲（或 z 缓冲 (z-buffer)）中的深度值 (Depth Value)，以及它们是如何确定一个片段是处于其它片段后方的。</p><p>深度缓冲就像颜色缓冲 (Color Buffer)（储存所有的片段颜色：视觉输出）一样，在每个片段中储存了信息，并且（通常）和颜色缓冲有着一样的宽度和高度。深度缓冲是由窗口系统自动创建的，它会以 16、24 或 32 位 float 的形式储存它的深度值。在大部分的系统中，深度缓冲的精度都是 24 位的。</p><p>当深度测试 (Depth Testing) 被启用的时候，OpenGL 会将一个片段的的深度值与深度缓冲的内容进行对比。OpenGL 会执行一个<mark>深度测试</mark>，如果这个测试通过了的话，深度缓冲将会更新为新的深度值。如果深度测试失败了，<mark>片段将会被丢弃</mark>。</p><p>深度缓冲是在片段着色器运行之后（以及模板测试 (Stencil Testing) 运行之后，我们将在下一节中讨论）在屏幕空间中运行的。屏幕空间坐标与通过 OpenGL 的 glViewport 所定义的视口密切相关，并且可以直接使用 GLSL 内建变量 gl_FragCoord 从片段着色器中直接访问。gl_FragCoord 的 x 和 y 分量代表了片段的屏幕空间坐标（其中 (0, 0) 位于左下角）。gl_FragCoord 中也包含了一个 z 分量，它包含了片段真正的深度值。z 值就是需要与深度缓冲内容所对比的那个值。</p><blockquote><p>现在大部分的 GPU 都提供一个叫做<mark>提前深度测试</mark> (Early Depth Testing) 的硬件特性。提前深度测试允许<mark>深度测试在片段着色器之前运行</mark>。只要我们清楚一个片段永远不会是可见的（它在其他物体之后），我们就能提前丢弃这个片段。</p></blockquote><blockquote><p>片段着色器通常开销都是很大的，所以我们应该尽可能避免运行它们。当使用提前深度测试时，片段着色器的一个限制是你不能写入片段的深度值。如果一个片段着色器对它的深度值进行了写入，提前深度测试是不可能的。OpenGL 不能提前知道深度值。</p></blockquote><p>深度测试默认是<mark>禁用的</mark>，所以如果要启用深度测试的话，我们需要用 GL_DEPTH_TEST 选项来启用它：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glEnable</span><span class="token punctuation">(</span>GL_DEPTH_TEST<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>当它启用的时候，如果一个片段通过了深度测试的话，OpenGL 会在深度缓冲中储存该片段的<mark> z 值</mark>；如果没有通过深度缓冲，则会丢弃该片段。如果你启用了深度缓冲，你还应该在每个渲染迭代之前使用 GL_DEPTH_BUFFER_BIT 来<mark>清除深度缓冲</mark>，否则你会仍在使用上一次渲染迭代中的写入的深度值：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT <span class="token operator">|</span> GL_DEPTH_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>可以想象，在某些情况下你会需要对所有片段都执行深度测试并丢弃相应的片段，但不希望更新深度缓冲。基本上来说，你在使用一个只读的 (Read-only) 深度缓冲。OpenGL 允许我们<mark>禁用深度缓冲的写入</mark>，只需要设置它的深度掩码 (Depth Mask) 设置为 GL_FALSE 就可以了：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glDepthMask</span><span class="token punctuation">(</span>GL_FALSE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>注意这只在深度测试被启用的时候才有效果。</p></blockquote><h3 id="深度测试函数"><a class="anchor" href="#深度测试函数">#</a> 深度测试函数</h3><p>OpenGL 允许我们修改深度测试中使用的比较运算符。这允许我们来控制 OpenGL 什么时候该通过或丢弃一个片段，什么时候去更新深度缓冲。我们可以调用 glDepthFunc 函数来设置比较运算符（或者说深度函数 (Depth Function)）：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glDepthFunc</span><span class="token punctuation">(</span>GL_LESS<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这个函数接受下面表格中的比较运算符：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>GL_ALWAYS</td><td>永远通过深度测试</td></tr><tr><td>GL_NEVER</td><td>永远不通过深度测试</td></tr><tr><td>GL_LESS</td><td>在片段深度值小于缓冲的深度值时通过测试</td></tr><tr><td>GL_EQUAL</td><td>在片段深度值等于缓冲区的深度值时通过测试</td></tr><tr><td>GL_LEQUAL</td><td>在片段深度值小于等于缓冲区的深度值时通过测试</td></tr><tr><td>GL_GREATER</td><td>在片段深度值大于缓冲区的深度值时通过测试</td></tr><tr><td>GL_NOTEQUAL</td><td>在片段深度值不等于缓冲区的深度值时通过测试</td></tr><tr><td>GL_GEQUAL</td><td>在片段深度值大于等于缓冲区的深度值时通过测试</td></tr></tbody></table><p>默认情况下使用的深度函数是 GL_LESS，它将会丢弃深度值大于等于当前深度缓冲值的所有片段。</p><p>让我们看看改变深度函数会对视觉输出有什么影响。我们将使用一个新的代码配置，它会显示一个没有光照的基本场景，里面有两个有纹理的立方体，放置在一个有纹理的地板上。你可以在这里找到源代码。</p><p>在源代码中，我们将深度函数改为 GL_ALWAYS：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glEnable</span><span class="token punctuation">(</span>GL_DEPTH_TEST<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glDepthFunc</span><span class="token punctuation">(</span>GL_ALWAYS<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这将会模拟我们没有启用深度测试时所得到的结果。深度测试将会永远通过，所以最后绘制的片段将会总是会渲染在之前绘制片段的上面，即使之前绘制的片段本就应该渲染在最前面。因为我们是最后渲染地板的，它会覆盖所有的箱子片段：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/01/depth_testing_func_always.png" alt="image"></p><p>将它重新设置为 GL_LESS，这会将场景还原为原有的样子：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/01/depth_testing_func_less.png" alt="image"></p><h3 id="深度值精度"><a class="anchor" href="#深度值精度">#</a> 深度值精度</h3><p>深度缓冲包含了一个介于 0.0 和 1.0 之间的深度值，它将会与观察者视角所看见的场景中所有物体的 z 值进行比较。观察空间的 z 值可能是投影平截头体的<mark>近平面</mark> (Near) 和<mark>远平面</mark> (Far) 之间的任何值。我们需要一种方式来将这些观察空间的 z 值变换到 [0, 1] 范围之间，其中的一种方式就是将它们线性变换到 [0, 1] 范围之间。下面这个（线性）方程将 z 值变换到了 0.0 到 1.0 之间的深度值：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>F</mi><mrow><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi>z</mi><mo>−</mo><mi>n</mi><mi>e</mi><mi>a</mi><mi>r</mi></mrow><mrow><mi>f</mi><mi>a</mi><mi>r</mi><mo>−</mo><mi>n</mi><mi>e</mi><mi>a</mi><mi>r</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">F_{depth}=\cfrac{z-near}{far-near}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.969438em;vertical-align:-.286108em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3361079999999999em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:2.47044em;vertical-align:-.8804400000000001em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5899999999999999em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.02778em">r</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.74em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.04398em">z</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.02778em">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.8804400000000001em"><span></span></span></span></span></span><span></span></span></span></span></span></span></p><p>这里的 near 和 far 值是我们之前提供给投影矩阵设置可视平截头体的（见坐标系统）那个 near 和 far 值。这个方程需要平截头体中的一个 z 值，并将它变换到了 [0, 1] 的范围中。z 值和对应的深度值之间的关系可以在下图中看到：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/01/depth_linear_graph.png" alt="image"></p><blockquote><p>注意所有的方程都会将非常近的物体的深度值设置为接近 0.0 的值，而当物体非常接近远平面的时候，它的深度值会非常接近 1.0。</p></blockquote><p>然而，在实践中是几乎永远不会使用这样的<mark>线性深度缓冲</mark> (Linear Depth Buffer) 的。要想有正确的投影性质，需要使用一个非线性的深度方程，它是与 <mark>1/z 成正比的</mark>。它做的就是在 z 值很小的时候提供非常高的精度，而在 z 值很远的时候提供更少的精度。花时间想想这个：我们真的需要对 1000 单位远的深度值和只有 1 单位远的充满细节的物体使用相同的精度吗？线性方程并不会考虑这一点。</p><p>由于非线性方程与 1/z 成正比，在 1.0 和 2.0 之间的 z 值将会变换至 1.0 到 0.5 之间的深度值，这就是一个 float 提供给我们的一半精度了，这在 z 值很小的情况下提供了非常大的精度。在 50.0 和 100.0 之间的 z 值将会只占 2% 的 float 精度，这正是我们所需要的。这样的一个考虑了远近距离的方程是这样的：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>F</mi><mrow><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi></mrow></msub><mo>=</mo><mfrac><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mi>z</mi><mo>−</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>n</mi><mi>e</mi><mi>a</mi><mi>r</mi></mrow><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mi>f</mi><mi>a</mi><mi>r</mi><mo>−</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>n</mi><mi>e</mi><mi>a</mi><mi>r</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">F_{depth}=\cfrac{1/z-1/near}{1/far-1/near}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.969438em;vertical-align:-.286108em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3361079999999999em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:2.526em;vertical-align:-.936em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5899999999999999em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord">1</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.02778em">r</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.74em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:.04398em">z</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord">1</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.02778em">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.936em"><span></span></span></span></span></span><span></span></span></span></span></span></span></p><p>如果你不知道这个方程是怎么回事也不用担心。重要的是要记住深度缓冲中的值在屏幕空间中不是线性的（在透视矩阵应用之前在观察空间中是线性的）。深度缓冲中 0.5 的值并不代表着物体的 z 值是位于平截头体的中间了，这个顶点的 z 值实际上非常接近近平面！你可以在下图中看到 z 值和最终的深度缓冲值之间的非线性关系：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/01/depth_non_linear_graph.png" alt="image"></p><p>可以看到，深度值很大一部分是由很小的 z 值所决定的，这给了近处的物体很大的深度精度。这个（从观察者的视角）变换 z 值的方程是嵌入在投影矩阵中的，所以当我们想将一个顶点坐标从观察空间至裁剪空间的时候这个非线性方程就被应用了。如果你想深度了解投影矩阵究竟做了什么，我建议<span class="exturl" data-url="aHR0cDovL3d3dy5zb25naG8uY2Evb3BlbmdsL2dsX3Byb2plY3Rpb25tYXRyaXguaHRtbA==">阅读这篇文章</span>。</p><p>如果我们想要可视化深度缓冲的话，非线性方程的效果很快就会变得很清楚。</p><h3 id="深度缓冲的可视化"><a class="anchor" href="#深度缓冲的可视化">#</a> 深度缓冲的可视化</h3><p>我们知道片段着色器中，内建<mark> gl_FragCoord</mark> 向量的 z 值包含了那个特定片段的深度值。如果我们将这个深度值输出为颜色，我们可以显示场景中所有片段的深度值。我们可以根据片段的深度值返回一个颜色向量来完成这一工作：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span><span class="token function">vec3</span><span class="token punctuation">(</span>gl_FragCoord<span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>如果你再次运行程序的话，你可能会注意到所有东西都是白色的，看起来就想我们所有的深度值都是最大的 1.0。所以为什么没有靠近 0.0（即变暗）的深度值呢？</p><p>你可能还记得在上一部分中说到，屏幕空间中的深度值是非线性的，即它在 z 值很小的时候有很高的精度，而 z 值很大的时候有较低的精度。片段的深度值会随着距离迅速增加，所以<mark>几乎所有的顶点的深度值都是接近于 1.0 的</mark>。如果我们小心地靠近物体，你可能会最终注意到颜色会渐渐变暗，显示它们的 z 值在逐渐变小：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/01/depth_testing_visible_depth.png" alt="image"></p><p>这很清楚地展示了深度值的非线性性质。近处的物体比起远处的物体对深度值有着更大的影响。只需要移动几厘米就能让颜色从暗完全变白。</p><p>然而，我们也可以让片段非线性的深度值变换为线性的。要实现这个，我们需要仅仅反转深度值的投影变换。这也就意味着我们需要首先将深度值 == 从 [0, 1] 范围重新变换到 [-1, 1]== 范围的标准化设备坐标（裁剪空间）。接下来我们需要像投影矩阵那样反转这个非线性方程（方程 2），并将这个反转的方程应用到最终的深度值上。最终的结果就是一个线性的深度值了。听起来是可行的，对吧？</p><p>首先我们将深度值变换为 NDC，不是非常困难：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> z <span class="token operator">=</span> depth <span class="token operator">*</span> <span class="token number">2.0</span> <span class="token operator">-</span> <span class="token number">1.0</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>接下来使用获取到的 z 值，应用逆变换来获取线性的深度值：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> linearDepth <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">2.0</span> <span class="token operator">*</span> near <span class="token operator">*</span> far<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>far <span class="token operator">+</span> near <span class="token operator">-</span> z <span class="token operator">*</span> <span class="token punctuation">(</span>far <span class="token operator">-</span> near<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这个方程是用投影矩阵推导得出的，它使用了方程 2 来非线性化深度值，返回一个 near 与 far 之间的深度值。这篇<span class="exturl" data-url="aHR0cDovL3d3dy5zb25naG8uY2Evb3BlbmdsL2dsX3Byb2plY3Rpb25tYXRyaXguaHRtbA==">注重数学的文章</span>为感兴趣的读者详细解释了投影矩阵，它也展示了这些方程是怎么来的。</p><p>将屏幕空间中非线性的深度值变换至线性深度值的完整片段着色器如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>out vec4 FragColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">float</span> near <span class="token operator">=</span> <span class="token number">0.1</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">float</span> far  <span class="token operator">=</span> <span class="token number">100.0</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">float</span> <span class="token function">LinearizeDepth</span><span class="token punctuation">(</span><span class="token keyword">float</span> depth<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">float</span> z <span class="token operator">=</span> depth <span class="token operator">*</span> <span class="token number">2.0</span> <span class="token operator">-</span> <span class="token number">1.0</span><span class="token punctuation">;</span> <span class="token comment">// back to NDC </span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">2.0</span> <span class="token operator">*</span> near <span class="token operator">*</span> far<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>far <span class="token operator">+</span> near <span class="token operator">-</span> z <span class="token operator">*</span> <span class="token punctuation">(</span>far <span class="token operator">-</span> near<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#123;</span>             </pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">float</span> depth <span class="token operator">=</span> <span class="token function">LinearizeDepth</span><span class="token punctuation">(</span>gl_FragCoord<span class="token punctuation">.</span>z<span class="token punctuation">)</span> <span class="token operator">/</span> far<span class="token punctuation">;</span> <span class="token comment">// 为了演示除以 far</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span><span class="token function">vec3</span><span class="token punctuation">(</span>depth<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>由于线性化的深度值处于 near 与 far 之间，它的大部分值都会大于 1.0 并显示为完全的白色。通过在 main 函数中将线性深度值除以 far，我们近似地将线性深度值转化到 [0, 1] 的范围之间。这样子我们就能逐渐看到一个片段越接近投影平截头体的远平面，它就会变得越亮，更适用于展示目的。</p><p>如果我们现在运行程序，我们就能看见深度值随着距离增大是线性的了。尝试在场景中移动，看看深度值是怎样以线性变化的。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/01/depth_testing_visible_linear.png" alt="image"></p><p>颜色大部分都是黑色，因为深度值的范围是 0.1 的近平面到 100 的远平面，远平面离我们还是非常远的。结果就是，我们相对靠近近平面，所以会得到更低的（更暗的）深度值。</p><h3 id="深度冲突"><a class="anchor" href="#深度冲突">#</a> 深度冲突</h3><p>一个很常见的视觉错误会在两个平面或者三角形非常紧密地平行排列在一起时会发生，深度缓冲没有足够的精度来决定两个形状哪个在前面。结果就是<mark>这两个形状不断地在切换前后顺序</mark>，这会导致很奇怪的花纹。这个现象叫做<mark>深度冲突</mark> (Z-fighting)，因为它看起来像是这两个形状在争夺 (Fight) 谁该处于顶端。</p><p>在我们一直使用的场景中，有几个地方的深度冲突还是非常明显的。箱子被放置在地板的同一高度上，这也就意味着箱子的底面和地板是<mark>共面的</mark> (Coplanar)。这两个面的深度值都是一样的，所以深度测试没有办法决定应该显示哪一个。</p><p>如果你将摄像机移动到其中一个箱子的内部，你就能清楚地看到这个效果的，箱子的底部不断地在箱子底面与地板之间切换，形成一个锯齿的花纹：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/01/depth_testing_z_fighting.png" alt="image"></p><p>深度冲突是深度缓冲的一个常见问题，当物体在远处时效果会更明显（因为深度缓冲在 z 值比较大的时候有着更小的精度）。深度冲突<mark>不能够被完全避免</mark>，但一般会有一些技巧有助于在你的场景中减轻或者完全避免深度冲突。</p><h3 id="防止深度冲突"><a class="anchor" href="#防止深度冲突">#</a> 防止深度冲突</h3><p>第一个也是最重要的技巧是<mark>永远不要把多个物体摆得太靠近</mark>，以至于它们的一些三角形会重叠。通过在两个物体之间设置一个用户无法注意到的偏移值，你可以完全避免这两个物体之间的深度冲突。在箱子和地板的例子中，我们可以将箱子沿着正 y 轴稍微移动一点。箱子位置的这点微小改变将不太可能被注意到，但它能够完全减少深度冲突的发生。然而，这需要对每个物体都手动调整，并且需要进行彻底的测试来保证场景中没有物体会产生深度冲突。</p><p>第二个技巧是尽可能<mark>将近平面设置远一些</mark>。在前面我们提到了<mark>精度在靠近近平面时是非常高的</mark>，所以如果我们将近平面远离观察者，我们将会对整个平截头体有着更大的精度。然而，将近平面设置太远将会导致近处的物体被裁剪掉，所以这通常需要实验和微调来决定最适合你的场景的近平面距离。</p><p>另外一个很好的技巧是牺牲一些性能，使用<mark>更高精度的深度缓冲</mark>。大部分深度缓冲的精度都是 24 位的，但现在大部分的显卡都支持 32 位的深度缓冲，这将会极大地提高精度。所以，牺牲掉一些性能，你就能获得更高精度的深度测试，减少深度冲突。</p><p>我们上面讨论的三个技术是最普遍也是很容易实现的抗深度冲突技术了。还有一些更复杂的技术，但它们依然不能完全消除深度冲突。深度冲突是一个常见的问题，但如果你组合使用了上面列举出来的技术，你可能不会再需要处理深度冲突了。</p><h2 id="模板测试"><a class="anchor" href="#模板测试">#</a> 模板测试</h2><p>当片段着色器处理完一个片段之后，<mark>模板测试</mark> (Stencil Test) 会开始执行，和深度测试一样，它也可能会丢弃片段。接下来，<mark>被保留的片段会进入<strong>深度测试</strong></mark>，它可能会丢弃更多的片段。模板测试是根据又一个缓冲来进行的，它叫做<mark>模板缓冲</mark> (Stencil Buffer)，我们可以在渲染的时候更新它来获得一些很有意思的效果。</p><p>一个模板缓冲中，（通常）每个模板值 (Stencil Value) 是 8 位的。所以每个像素 / 片段一共能有 256 种不同的模板值。我们可以将这些模板值设置为我们想要的值，然后当某一个片段有某一个模板值的时候，我们就可以选择丢弃或是保留这个片段了。</p><blockquote><p>每个窗口库都需要为你配置一个模板缓冲。GLFW 自动做了这件事，所以我们不需要告诉 GLFW 来创建一个，但其它的窗口库可能不会默认给你创建一个模板库，所以记得要查看库的文档。</p></blockquote><p>模板缓冲的一个简单的例子如下（类似于视频遮罩）：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/02/stencil_buffer.png" alt="image"></p><p>模板缓冲首先会被清除为 0，之后在模板缓冲中使用 1 填充了一个空心矩形。场景中的片段将会只在片段的模板值为 1 的时候会被渲染（其它的都被丢弃了）。</p><p>模板缓冲操作允许我们在渲染片段时将模板缓冲设定为一个特定的值。通过在渲染时修改模板缓冲的内容，我们写入了模板缓冲。在同一个（或者接下来的）渲染迭代中，我们可以读取这些值，来决定丢弃还是保留某个片段。使用模板缓冲的时候你可以尽情发挥，但大体的步骤如下：</p><ul><li>启用模板缓冲的写入。</li><li>渲染物体，更新模板缓冲的内容。</li><li>禁用模板缓冲的写入。</li><li>渲染（其它）物体，这次根据模板缓冲的内容丢弃特定的片段。</li></ul><p>所以，通过使用模板缓冲，我们可以根据场景中已绘制的其它物体的片段，来决定是否丢弃特定的片段。</p><p>你可以启用 GL_STENCIL_TEST 来启用模板测试。在这一行代码之后，所有的渲染调用都会以某种方式影响着模板缓冲。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glEnable</span><span class="token punctuation">(</span>GL_STENCIL_TEST<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>注意，和颜色和深度缓冲一样，你也需要在每次迭代之前清除模板缓冲。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT <span class="token operator">|</span> GL_DEPTH_BUFFER_BIT <span class="token operator">|</span> GL_STENCIL_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>和深度测试的 glDepthMask 函数一样，模板缓冲也有一个类似的函数。glStencilMask 允许我们设置一个位掩码 (Bitmask)，它会与将要写入缓冲的模板值进行<mark>与</mark> (AND) 运算。默认情况下设置的位掩码所有位都为 1，不影响输出，但如果我们将它设置为 0x00，写入缓冲的所有模板值最后都会变成 0. 这与深度测试中的 glDepthMask (GL_FALSE) 是等价的。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glStencilMask</span><span class="token punctuation">(</span><span class="token number">0xFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 每一位写入模板缓冲时都保持原样</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glStencilMask</span><span class="token punctuation">(</span><span class="token number">0x00</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 每一位在写入模板缓冲时都会变成 0（禁用写入）</span></pre></td></tr></table></figure><p>大部分情况下你都只会使用 0x00 或者 0xFF 作为模板掩码 (Stencil Mask)，但是知道有选项可以设置自定义的位掩码总是好的。</p><h3 id="模板函数"><a class="anchor" href="#模板函数">#</a> 模板函数</h3><p>和深度测试一样，我们对模板缓冲应该通过还是失败，以及它应该如何影响模板缓冲，也是有一定控制的。一共有两个函数能够用来配置模板测试：<mark>glStencilFunc</mark> 和<mark> glStencilOp</mark>。</p><p><mark><strong>glStencilFunc</strong></mark> (GLenum func, GLint ref, GLuint mask) 一共包含三个参数：</p><ul><li>func：设置<mark>模板测试函数</mark> (Stencil Test Function)。这个测试函数将会应用到已储存的模板值上和 glStencilFunc 函数的 ref 值上。可用的选项有：GL_NEVER、GL_LESS、GL_LEQUAL、GL_GREATER、GL_GEQUAL、GL_EQUAL、GL_NOTEQUAL 和 GL_ALWAYS。它们的语义和深度缓冲的函数类似。</li><li>ref：设置了模板测试的<mark>参考值</mark> (Reference Value)。模板缓冲的内容将会与这个值进行比较。</li><li>mask：设置一个<mark>掩码</mark>，它将会与参考值和储存的模板值在测试比较它们之前进行与 (AND) 运算。初始情况下所有位都为 1。</li></ul><p>在一开始的那个简单的模板例子中，函数被设置为：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glStencilFunc</span><span class="token punctuation">(</span>GL_EQUAL<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0xFF</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>这会告诉 OpenGL，只要一个片段的模板值等于 (GL_EQUAL) 参考值 1，片段将会通过测试并被绘制，否则会被丢弃。</p><p>但是 glStencilFunc 仅仅描述了<mark> OpenGL 如何处理模板缓冲区内容</mark>，而不是我们应该如何<mark>更新缓冲</mark>。这就需要<mark> glStencilOp</mark> 这个函数了。</p><p><mark><strong>glStencilOp</strong></mark> (GLenum sfail, GLenum dpfail, GLenum dppass) 一共包含三个选项，我们能够设定每个选项应该采取的行为：</p><ul><li>sfail：<mark>模板测试失败</mark>时采取的<mark>行为</mark>。</li><li>dpfail：模板测试通过，但<mark>深度测试失败</mark>时采取的行为。</li><li>dppass：模板测试和深度测试<mark>都通过</mark>时采取的行为。</li></ul><p>每个选项都可以选用以下的其中一种行为：</p><table><thead><tr><th>行为</th><th>描述</th></tr></thead><tbody><tr><td>GL_KEEP</td><td>保持当前储存的模板值</td></tr><tr><td>GL_ZERO</td><td>将模板值设置为 0</td></tr><tr><td>GL_REPLACE</td><td>将模板值设置为 glStencilFunc 函数设置的 ref 值</td></tr><tr><td>GL_INCR</td><td>如果模板值小于最大值则将模板值加 1</td></tr><tr><td>GL_INCR_WRAP</td><td>与 GL_INCR 一样，但如果模板值超过了最大值则归零</td></tr><tr><td>GL_DECR</td><td>如果模板值大于最小值则将模板值减 1</td></tr><tr><td>GL_DECR_WRAP</td><td>与 GL_DECR 一样，但如果模板值小于 0 则将其设置为最大值</td></tr><tr><td>GL_INVERT</td><td>按位翻转当前的模板缓冲值</td></tr></tbody></table><p>默认情况下 glStencilOp 是设置为 (GL_KEEP, GL_KEEP, GL_KEEP) 的，所以不论任何测试的结果是如何，模板缓冲都会保留它的值。默认的行为不会更新模板缓冲，所以如果你想写入模板缓冲的话，你需要至少对其中一个选项设置不同的值。</p><p>所以，通过使用 glStencilFunc 和 glStencilOp，我们可以精确地指定更新模板缓冲的时机与行为了，我们也可以指定什么时候该让模板缓冲通过，即什么时候片段需要被丢弃。</p><h3 id="物体轮廓"><a class="anchor" href="#物体轮廓">#</a> 物体轮廓</h3><p>仅仅看了前面的部分你还是不太可能能够完全理解模板测试的工作原理，所以我们将会展示一个使用模板测试就可以完成的有用特性，它叫做<mark>物体轮廓</mark> (Object Outlining)。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/02/stencil_object_outlining.png" alt="image"></p><p>物体轮廓所能做的事情正如它名字所描述的那样。我们将会为每个（或者一个）物体在它的周围创建一个很小的有色边框。当你想要在策略游戏中选中一个单位进行操作的，想要告诉玩家选中的是哪个单位的时候，这个效果就非常有用了。为物体创建轮廓的步骤如下：</p><ol><li>在绘制（需要添加轮廓的）物体之前，将模板函数设置为 GL_ALWAYS，每当物体的片段被渲染时，将模板缓冲更新为 1。</li><li>渲染物体。</li><li>禁用模板写入以及深度测试。</li><li>将每个物体缩放一点点。</li><li>使用一个不同的片段着色器，输出一个单独的（边框）颜色。</li><li>再次绘制物体，但只在它们片段的模板值不等于 1 时才绘制。</li><li>再次启用模板写入和深度测试。</li></ol><p>这个过程将每个物体的片段的模板缓冲设置为 1，当我们想要绘制边框的时候，我们主要绘制放大版本的物体中模板测试通过的部分，也就是物体的边框的位置。我们主要使用模板缓冲丢弃了放大版本中属于原物体片段的部分。</p><p>所以我们首先来创建一个很简单的片段着色器，它会输出一个边框颜色。我们简单地给它设置一个硬编码的颜色值，将这个着色器命名为 shaderSingleColor：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span><span class="token number">0.04</span><span class="token punctuation">,</span> <span class="token number">0.28</span><span class="token punctuation">,</span> <span class="token number">0.26</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>我们只想给那两个箱子加上边框，所以我们让地板不参与这个过程。我们希望首先绘制地板，再绘制两个箱子（并写入模板缓冲），之后绘制放大的箱子（并丢弃覆盖了之前绘制的箱子片段的那些片段）。</p><p>我们首先启用模板测试，并设置测试通过或失败时的行为：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glEnable</span><span class="token punctuation">(</span>GL_DEPTH_TEST<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glStencilOp</span><span class="token punctuation">(</span>GL_KEEP<span class="token punctuation">,</span> GL_KEEP<span class="token punctuation">,</span> GL_REPLACE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>如果其中的一个测试失败了，我们什么都不做，我们仅仅保留当前储存在模板缓冲中的值。如果模板测试和深度测试都通过了，那么我们希望将储存的模板值设置为参考值，参考值能够通过<mark> glStencilFunc</mark> 来设置，我们之后会设置为 1。</p><p>我们将模板缓冲清除为 0，对箱子中所有绘制的片段，将模板值更新为 1：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glStencilFunc</span><span class="token punctuation">(</span>GL_ALWAYS<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0xFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 所有的片段都应该更新模板缓冲</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glStencilMask</span><span class="token punctuation">(</span><span class="token number">0xFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 启用模板缓冲写入</span></pre></td></tr><tr><td data-num="3"></td><td><pre>normalShader<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">DrawTwoContainers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>通过使用 GL_ALWAYS 模板测试函数，我们保证了箱子的每个片段都会将模板缓冲的模板值更新为 1。因为片段永远会通过模板测试，在绘制片段的地方，模板缓冲会被更新为参考值。</p><p>现在模板缓冲在箱子被绘制的地方都更新为 1 了，我们将要绘制放大的箱子，但这次要禁用模板缓冲的写入：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glStencilFunc</span><span class="token punctuation">(</span>GL_NOTEQUAL<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0xFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glStencilMask</span><span class="token punctuation">(</span><span class="token number">0x00</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 禁止模板缓冲的写入</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glDisable</span><span class="token punctuation">(</span>GL_DEPTH_TEST<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>shaderSingleColor<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">DrawTwoScaledUpContainers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>我们将模板函数设置为<mark> GL_NOTEQUAL</mark>，它会保证我们只绘制箱子上模板值不为 1 的部分，即只绘制箱子在之前绘制的箱子之外的部分。注意我们也禁用了深度测试，让放大的箱子，即边框，不会被地板所覆盖。</p><p>记得要在完成之后重新启用深度缓冲。</p><p>场景中物体轮廓的完整步骤会看起来像这样：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glEnable</span><span class="token punctuation">(</span>GL_DEPTH_TEST<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glStencilOp</span><span class="token punctuation">(</span>GL_KEEP<span class="token punctuation">,</span> GL_KEEP<span class="token punctuation">,</span> GL_REPLACE<span class="token punctuation">)</span><span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT <span class="token operator">|</span> GL_DEPTH_BUFFER_BIT <span class="token operator">|</span> GL_STENCIL_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">glStencilMask</span><span class="token punctuation">(</span><span class="token number">0x00</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 记得保证我们在绘制地板的时候不会更新模板缓冲</span></pre></td></tr><tr><td data-num="7"></td><td><pre>normalShader<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">DrawFloor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  </pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token function">glStencilFunc</span><span class="token punctuation">(</span>GL_ALWAYS<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0xFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token function">glStencilMask</span><span class="token punctuation">(</span><span class="token number">0xFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token function">DrawTwoContainers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token function">glStencilFunc</span><span class="token punctuation">(</span>GL_NOTEQUAL<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0xFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token function">glStencilMask</span><span class="token punctuation">(</span><span class="token number">0x00</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token function">glDisable</span><span class="token punctuation">(</span>GL_DEPTH_TEST<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>shaderSingleColor<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token function">DrawTwoScaledUpContainers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token function">glStencilMask</span><span class="token punctuation">(</span><span class="token number">0xFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token function">glEnable</span><span class="token punctuation">(</span>GL_DEPTH_TEST<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>只要你理解了模板缓冲背后的大体思路，这个代码片段就不是那么难理解了。如果还是不能理解的话，尝试再次仔细阅读之前的部分，并尝试通过上面使用的范例，完全理解每个函数的功能。</p><p>在深度测试小节的场景中，这个轮廓算法的结果看起来会像是这样的：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/02/stencil_scene_outlined.png" alt="image"></p><blockquote><p>你可以看到这两个箱子的边框重合了，这通常都是我们想要的结果（想想策略游戏中，我们希望选择 10 个单位，合并边框通常是我们想需要的结果）。如果你想让每个物体都有一个完整的边框，你需要对每个物体都清空模板缓冲，并有创意地利用深度缓冲。</p></blockquote><p>你看到的物体轮廓算法在需要显示选中物体的游戏（想想策略游戏）中非常常见。这样的算法能够在一个模型类中轻松实现。你可以在模型类中设置一个 boolean 标记，来设置需不需要绘制边框。如果你有创造力的话，你也可以使用后期处理滤镜 (Filter)，像是高斯模糊 (Gaussian Blur)，让边框看起来更自然。</p><p>除了物体轮廓之外，模板测试还有很多用途，比如在一个后视镜中绘制纹理，让它能够<mark>绘制到镜子</mark>形状中，或者使用一个叫做阴影体积 (Shadow Volume) 的模板缓冲技术渲染实时阴影。模板缓冲为我们已经很丰富的 OpenGL 工具箱又提供了一个很好的工具。</p><h2 id="混合"><a class="anchor" href="#混合">#</a> 混合</h2><p>OpenGL 中，<mark>混合</mark> (Blending) 通常是实现物体<mark>透明度</mark> (Transparency) 的一种技术。透明就是说一个物体（或者其中的一部分）不是<mark>纯色</mark> (Solid Color) 的，它的颜色是物体本身的颜色和它背后其它物体的颜色的不同强度结合。一个有色玻璃窗是一个透明的物体，玻璃有它自己的颜色，但它最终的颜色还包含了玻璃之后所有物体的颜色。这也是混合这一名字的出处，我们混合 (Blend)（不同物体的）多种颜色为一种颜色。所以透明度能让我们看穿物体。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/03/blending_transparency.png" alt="image"></p><p>透明的物体可以是完全透明的（让所有的颜色穿过），或者是半透明的（它让颜色通过，同时也会显示自身的颜色）。一个物体的透明度是通过它颜色的<mark> aplha</mark> 值来决定的。Alpha 颜色值是颜色向量的第四个分量，你可能已经看到过它很多遍了。在这个教程之前我们都将这个第四个分量设置为 1.0，让这个物体的透明度为 0.0，而当 alpha 值为 0.0 时物体将会是完全透明的。当 alpha 值为 0.5 时，物体的颜色有 50% 是来自物体自身的颜色，50% 来自背后物体的颜色。</p><p>我们目前一直使用的纹理有三个颜色分量：红、绿、蓝。但一些材质会有一个内嵌的 alpha 通道，对每个纹素 (Texel) 都包含了一个 alpha 值。这个 alpha 值精确地告诉我们纹理各个部分的透明度。比如说，下面这个窗户纹理中的玻璃部分的 alpha 值为 0.25（它在一般情况下是完全的红色，但由于它有 75% 的透明度，能让很大一部分的网站背景颜色穿过，让它看起来不那么红了），边框的 alpha 值是 0.0。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/03/blending_transparent_window.png" alt="image"></p><p>我们很快就会将这个窗户纹理添加到场景中，但是首先我们需要讨论一个更简单的技术，来实现只有完全透明和完全不透明的纹理的透明度。</p><h3 id="丢弃片段"><a class="anchor" href="#丢弃片段">#</a> 丢弃片段</h3><p>有些图片并不需要半透明，只需要根据纹理颜色值，显示一部分，或者不显示一部分，没有中间情况。比如说草，如果想不太费劲地创建草这种东西，你需要将一个草的纹理贴在一个 2D 四边形 (Quad) 上，然后将这个四边形放到场景中。然而，草的形状和 2D 四边形的形状并不完全相同，所以你只想显示草纹理的某些部分，而忽略剩下的部分。</p><p>下面这个纹理正是这样的，它要么是完全不透明的（alpha 值为 1.0），要么是完全透明的（alpha 值为 0.0），没有中间情况。你可以看到，只要不是草的部分，这个图片显示的都是网站的背景颜色而不是它本身的颜色。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/03/grass.png" alt="image"></p><p>所以当添加像草这样的植被到场景中时，我们不希望看到草的方形图像，而是只显示草的部分，并能看透图像其余的部分。我们想要丢弃 (Discard) 显示纹理中透明部分的片段，不将这些片段存储到颜色缓冲中。在此之前，我们还要学习如何加载一个透明的纹理。</p><p>要想加载有 alpha 值的纹理，我们并不需要改很多东西，stb_image 在纹理有 alpha 通道的时候会自动加载，但我们仍要在纹理生成过程中告诉 OpenGL，我们的纹理现在使用 alpha 通道了：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glTexImage2D</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RGBA<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RGBA<span class="token punctuation">,</span> GL_UNSIGNED_BYTE<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>同样，保证你在片段着色器中获取了纹理的全部 4 个颜色分量，而不仅仅是 RGB 分量：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// FragColor = vec4(vec3(texture(texture1, TexCoords)), 1.0);</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>texture1<span class="token punctuation">,</span> TexCoords<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>既然我们已经知道该如何加载透明的纹理了，是时候将它带入实战了，我们将会在深度测试小节的场景中加入几棵草。</p><p>我们会创建一个 vector，向里面添加几个 glm::vec3 变量来代表草的位置：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vector<span class="token operator">&lt;</span>glm<span class="token operator">::</span>vec3<span class="token operator">></span> vegetation<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>vegetation<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1.5f</span><span class="token punctuation">,</span>  <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.48f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>vegetation<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span> <span class="token number">1.5f</span><span class="token punctuation">,</span>  <span class="token number">0.0f</span><span class="token punctuation">,</span>  <span class="token number">0.51f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>vegetation<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>  <span class="token number">0.0f</span><span class="token punctuation">,</span>  <span class="token number">0.7f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>vegetation<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.3f</span><span class="token punctuation">,</span>  <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.3f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>vegetation<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span> <span class="token number">0.5f</span><span class="token punctuation">,</span>  <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.6f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>每个草都被渲染到了一个四边形上，贴上草的纹理。这并不能完美地表示 3D 的草，但这比加载复杂的模型要快多了。使用一些小技巧，比如在同一个位置加入一些旋转后的草四边形，你仍然能获得比较好的结果的。</p><p>因为草的纹理是添加到四边形对象上的，我们还需要创建另外一个 VAO，填充 VBO，设置正确的顶点属性指针。接下来，在绘制完地板和两个立方体后，我们将会绘制草：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>vegetationVAO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> grassTexture<span class="token punctuation">)</span><span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vegetation<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    model <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    model <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">translate</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span> vegetation<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               </pre></td></tr><tr><td data-num="7"></td><td><pre>    shader<span class="token punctuation">.</span><span class="token function">setMat4</span><span class="token punctuation">(</span><span class="token string">"model"</span><span class="token punctuation">,</span> model<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">glDrawArrays</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>运行程序你将看到：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/03/blending_no_discard.png" alt="image"></p><p>出现这种情况是因为 OpenGL 默认是不知道怎么处理 alpha 值的，更不知道什么时候应该丢弃片段。我们需要自己手动来弄。幸运的是，有了着色器，这还是非常容易的。GLSL 给了我们<mark> discard</mark> 命令，一旦被调用，它就会保证<mark>片段不会被进一步处理</mark>，所以就不会进入颜色缓冲。有了这个指令，我们就能够在片段着色器中检测一个片段的 alpha 值是否低于某个阈值，如果是的话，则丢弃这个片段，就好像它不存在一样：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>out vec4 FragColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>in vec2 TexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>uniform sampler2D texture1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#123;</span>             </pre></td></tr><tr><td data-num="10"></td><td><pre>    vec4 texColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>texture1<span class="token punctuation">,</span> TexCoords<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>texColor<span class="token punctuation">.</span>a <span class="token operator">&lt;</span> <span class="token number">0.1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        discard<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    FragColor <span class="token operator">=</span> texColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里，我们检测被采样的纹理颜色的 alpha 值是否低于 0.1 的阈值，如果是的话，则丢弃这个片段。片段着色器保证了它只会渲染不是（几乎）完全透明的片段。现在它看起来就正常了：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/03/blending_discard.png" alt="image"></p><blockquote><p>注意，当采样纹理的边缘的时候，OpenGL 会对边缘的值和纹理下一个重复的值进行插值（因为我们将它的环绕方式设置为了 GL_REPEAT。这通常是没问题的，但是由于我们使用了透明值，纹理图像的顶部将会与底部边缘的纯色值进行插值。这样的结果是一个半透明的有色边框，你可能会看见它环绕着你的纹理四边形。要想避免这个，每当你 alpha 纹理的时候，请将纹理的环绕方式设置为 GL_CLAMP_TO_EDGE：</p></blockquote><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span> GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_WRAP_S<span class="token punctuation">,</span> GL_CLAMP_TO_EDGE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span> GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_WRAP_T<span class="token punctuation">,</span> GL_CLAMP_TO_EDGE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 最终效果如下，你可能需要区分不同的渲染实现不一样的纹理设置</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_WRAP_S<span class="token punctuation">,</span> format <span class="token operator">==</span> GL_RGBA <span class="token operator">?</span> GL_CLAMP_TO_EDGE <span class="token operator">:</span> GL_REPEAT<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// for this tutorial: use GL_CLAMP_TO_EDGE to prevent semi-transparent borders. Due to interpolation it takes texels from next repeat </span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_WRAP_T<span class="token punctuation">,</span> format <span class="token operator">==</span> GL_RGBA <span class="token operator">?</span> GL_CLAMP_TO_EDGE <span class="token operator">:</span> GL_REPEAT<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="混合-2"><a class="anchor" href="#混合-2">#</a> 混合</h3><p>虽然直接丢弃片段很好，但它不能让我们渲染半透明的图像。我们要么渲染一个片段，要么完全丢弃它。要想渲染有多个透明度级别的图像，我们需要启用<mark>混合</mark> (Blending)。和 OpenGL 大多数的功能一样，我们可以启用 GL_BLEND 来启用混合：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glEnable</span><span class="token punctuation">(</span>GL_BLEND<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>启用了混合之后，我们需要告诉 OpenGL 它该如何混合。</p><p>OpenGL 中的混合是通过下面这个方程来实现的：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mover accent="true"><mi>C</mi><mo>ˉ</mo></mover><mrow><mi>r</mi><mi>e</mi><mi>s</mi><mi>u</mi><mi>l</mi><mi>t</mi></mrow></msub><mo>=</mo><msub><mover accent="true"><mi>C</mi><mo>ˉ</mo></mover><mrow><mi>s</mi><mi>o</mi><mi>u</mi><mi>r</mi><mi>c</mi><mi>e</mi></mrow></msub><mo>∗</mo><msub><mi>F</mi><mrow><mi>s</mi><mi>o</mi><mi>u</mi><mi>r</mi><mi>c</mi><mi>e</mi></mrow></msub><mo>+</mo><msub><mover accent="true"><mi>C</mi><mo>ˉ</mo></mover><mrow><mi>d</mi><mi>e</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></msub><mo>∗</mo><msub><mi>F</mi><mrow><mi>d</mi><mi>e</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\bar{C}_{result}=\bar{C}_{source}*F_{source}+\bar{C}_{destination}*F_{destination}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.9701099999999999em;vertical-align:-.15em"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8201099999999999em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.07153em">C</span></span></span><span style="top:-3.25233em"><span class="pstrut" style="height:3em"></span><span class="accent-body" style="left:-.16666em"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.33610799999999996em"><span style="top:-2.5500000000000003em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.02778em">r</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight" style="margin-right:.01968em">l</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.9701099999999999em;vertical-align:-.15em"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8201099999999999em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.07153em">C</span></span></span><span style="top:-3.25233em"><span class="pstrut" style="height:3em"></span><span class="accent-body" style="left:-.16666em"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight" style="margin-right:.02778em">r</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight" style="margin-right:.02778em">r</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.9701099999999999em;vertical-align:-.15em"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8201099999999999em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.07153em">C</span></span></span><span style="top:-3.25233em"><span class="pstrut" style="height:3em"></span><span class="accent-body" style="left:-.16666em"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.33610799999999996em"><span style="top:-2.5500000000000003em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.33610799999999996em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span></span></p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/image-20201002173636403.png" alt="image-20201002173636403"></p><p>片段着色器运行完成后，并且所有的测试都通过之后，这个混合方程 (Blend Equation) 才会应用到片段颜色输出与当前颜色缓冲中的值（当前片段之前储存的之前片段的颜色）上。源颜色和目标颜色将会由 OpenGL 自动设定，但源因子和目标因子的值可以由我们来决定。我们先来看一个简单的例子：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/03/blending_equation.png" alt="image"></p><p>我们有两个方形，我们希望将这个半透明的绿色方形绘制在红色方形之上。红色的方形将会是目标颜色（所以它应该先在颜色缓冲中），我们将要在这个红色方形之上绘制这个绿色方形。</p><p>问题来了：我们将因子值设置为什么？嘛，我们至少想让绿色方形乘以它的 alpha 值，所以我们想要将 Fsrc 设置为源颜色向量的 alpha 值，也就是 0.6。接下来就应该清楚了，目标方形的贡献应该为剩下的 alpha 值。如果绿色方形对最终颜色贡献了 60%，那么红色方块应该对最终颜色贡献了 40%，即 1.0 - 0.6。所以我们将 Fdestination 设置为 1 减去源颜色向量的 alpha 值。这个方程变成了：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mover accent="true"><mi>C</mi><mo>ˉ</mo></mover><mrow><mi>r</mi><mi>e</mi><mi>s</mi><mi>u</mi><mi>l</mi><mi>t</mi></mrow></msub><mo>=</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0.0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1.0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0.0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0.6</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mo>∗</mo><mn>0.6</mn><mo>+</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1.0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0.0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0.0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1.6</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mo>∗</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mn>0.6</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\bar{C}_{result}= \begin{pmatrix} 0.0\\ 1.0\\ 0.0\\ 0.6 \end{pmatrix} * 0.6+ \begin{pmatrix} 1.0\\ 0.0\\ 0.0\\ 1.6 \end{pmatrix} *(1-0.6)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.9701099999999999em;vertical-align:-.15em"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8201099999999999em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.07153em">C</span></span></span><span style="top:-3.25233em"><span class="pstrut" style="height:3em"></span><span class="accent-body" style="left:-.16666em"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.33610799999999996em"><span style="top:-2.5500000000000003em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.02778em">r</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight" style="margin-right:.01968em">l</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:4.80006em;vertical-align:-2.15003em"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em"><span style="top:-1.6499900000000003em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.8000000000000003em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.39501em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.41001em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em"><span style="top:-4.8100000000000005em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span></span></span><span style="top:-3.61em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em"><span style="top:-1.6499900000000003em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.8000000000000003em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.39501em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.41001em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:4.80006em;vertical-align:-2.15003em"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em"><span style="top:-1.6499900000000003em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.8000000000000003em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.39501em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-3.41001em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.65003em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500000000000004em"><span style="top:-4.8100000000000005em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span></span></span><span style="top:-3.61em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span></span></span><span style="top:-1.2099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.1500000000000004em"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.6500299999999997em"><span style="top:-1.6499900000000003em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.8000000000000003em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.39501em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-3.41001em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.65003em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15003em"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mclose">)</span></span></span></span></span></p><p>结果就是重叠方形的片段包含了一个 60% 绿色，40% 红色的一种脏兮兮的颜色：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/03/blending_equation_mixed.png" alt="image"></p><p>最终的颜色将会被储存到颜色缓冲中，替代之前的颜色。</p><p>这样子很不错，但我们该如何让 OpenGL 使用这样的因子呢？正好有一个专门的函数，叫做<mark> glBlendFunc</mark>。</p><p>glBlendFunc (GLenum sfactor, GLenum dfactor) 函数接受两个参数，来设置源和目标因子。OpenGL 为我们定义了很多个选项，我们将在下面列出大部分最常用的选项。注意常数<mark>颜色向量</mark>可以通过 glBlendColor 函数来另外设置。</p><table><thead><tr><th>选项</th><th>值</th></tr></thead><tbody><tr><td>GL_ZERO</td><td>因子等于 0</td></tr><tr><td>GL_ONE</td><td>因子等于 1</td></tr><tr><td>GL_SRC_COLOR</td><td>因子等于源颜色向量 C¯source</td></tr><tr><td>GL_ONE_MINUS_SRC_COLOR</td><td>因子等于 1−C¯source</td></tr><tr><td>GL_DST_COLOR</td><td>因子等于目标颜色向量 C¯destination</td></tr><tr><td>GL_ONE_MINUS_DST_COLOR</td><td>因子等于 1−C¯destination</td></tr><tr><td>GL_SRC_ALPHA</td><td>因子等于 C¯source 的 alpha 分量</td></tr><tr><td>GL_ONE_MINUS_SRC_ALPHA</td><td>因子等于 1− C¯source 的 alpha 分量</td></tr><tr><td>GL_DST_ALPHA</td><td>因子等于 C¯destination 的 alpha 分量</td></tr><tr><td>GL_ONE_MINUS_DST_ALPHA</td><td>因子等于 1− C¯destination 的 alpha 分量</td></tr><tr><td>GL_CONSTANT_COLOR</td><td>因子等于常数颜色向量 C¯constant</td></tr><tr><td>GL_ONE_MINUS_CONSTANT_COLOR</td><td>因子等于 1−C¯constant</td></tr><tr><td>GL_CONSTANT_ALPHA</td><td>因子等于 C¯constant 的 alpha 分量</td></tr><tr><td>GL_ONE_MINUS_CONSTANT_ALPHA</td><td>因子等于 1− C¯constant 的 alpha 分量</td></tr></tbody></table><p>为了获得之前两个方形的混合结果，我们需要使用源颜色向量的 alpha 作为源因子，使用 1−alpha 作为目标因子。这将会产生以下的 glBlendFunc：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glBlendFunc</span><span class="token punctuation">(</span>GL_SRC_ALPHA<span class="token punctuation">,</span> GL_ONE_MINUS_SRC_ALPHA<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>也可以使用 glBlendFuncSeparate 为 RGB 和 alpha 通道分别设置不同的选项：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glBlendFuncSeparate</span><span class="token punctuation">(</span>GL_SRC_ALPHA<span class="token punctuation">,</span> GL_ONE_MINUS_SRC_ALPHA<span class="token punctuation">,</span> GL_ONE<span class="token punctuation">,</span> GL_ZERO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这个函数和我们之前设置的那样设置了 RGB 分量，但这样只能让最终的 alpha 分量被源颜色向量的 alpha 值所影响到。</p><p>OpenGL 甚至给了我们更多的灵活性，允许我们改变方程中源和目标部分的运算符。当前源和目标是相加的，但如果愿意的话，我们也可以让它们相减。glBlendEquation (GLenum mode) 允许我们设置运算符，它提供了三个选项：</p><ul><li>GL_FUNC_ADD：默认选项，将两个分量相加：C¯result=Src+Dst。</li><li>GL_FUNC_SUBTRACT：将两个分量相减： C¯result=Src−Dst。</li><li>GL_FUNC_REVERSE_SUBTRACT：将两个分量相减，但顺序相反：C¯result=Dst−Src。</li></ul><p>通常我们都可以省略调用 glBlendEquation，因为 GL_FUNC_ADD 对大部分的操作来说都是我们希望的混合方程，但如果你真的想打破主流，其它的方程也可能符合你的要求。</p><h3 id="渲染半透明纹理"><a class="anchor" href="#渲染半透明纹理">#</a> 渲染半透明纹理</h3><p>既然我们已经知道 OpenGL 是如何处理混合的了，是时候将我们的知识运用到实战中了，我们将会在场景中添加几个半透明的窗户。我们将使用本节开始的那个场景，但是这次不再是渲染草的纹理了，我们现在将使用本节开始时的那个透明的窗户纹理。</p><p>首先，在初始化时我们启用混合，并设定相应的混合函数：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glEnable</span><span class="token punctuation">(</span>GL_BLEND<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glBlendFunc</span><span class="token punctuation">(</span>GL_SRC_ALPHA<span class="token punctuation">,</span> GL_ONE_MINUS_SRC_ALPHA<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>由于启用了混合，我们就不需要丢弃片段了，所以我们把片段着色器还原：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>out vec4 FragColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>in vec2 TexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>uniform sampler2D texture1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#123;</span>             </pre></td></tr><tr><td data-num="10"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>texture1<span class="token punctuation">,</span> TexCoords<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>现在（每当 OpenGL 渲染了一个片段时）它都会将当前片段的颜色和当前颜色缓冲中的片段颜色根据 alpha 值来进行混合。由于窗户纹理的玻璃部分是半透明的，我们应该能通窗户中看到背后的场景了。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/03/blending_incorrect_order.png" alt="image"></p><p>如果你仔细看的话，你可能会注意到有些不对劲。<mark>最前面窗户的透明部分遮蔽了背后的窗户</mark>？这为什么会发生呢？</p><p>发生这一现象的原因是，深度测试和混合一起使用的话会产生一些麻烦。当写入深度缓冲时，深度缓冲不会检查片段是否是透明的，所以透明的部分会和其它值一样写入到深度缓冲中。结果就是窗户的整个四边形不论透明度都会进行深度测试。即使透明的部分应该显示背后的窗户，深度测试仍然丢弃了它们。</p><p>所以我们不能随意地决定如何渲染窗户，让深度缓冲解决所有的问题了。这也是混合变得有些麻烦的部分。要想保证窗户中能够显示它们背后的窗户，我们需要首<mark>先绘制背后的这部分窗户</mark>。这也就是说在绘制的时候，我们必须先手动将窗户按照<mark>最远到最近来排序</mark>，再按照顺序渲染。</p><blockquote><p>注意，对于草这种全透明的物体，我们可以选择丢弃透明的片段而不是混合它们，这样就解决了这些头疼的问题（没有深度问题）。</p></blockquote><h3 id="不要打乱顺序"><a class="anchor" href="#不要打乱顺序">#</a> 不要打乱顺序</h3><p>要想让混合在多个物体上工作，我们需要最先绘制最远的物体，最后绘制最近的物体。普通不需要混合的物体仍然可以使用深度缓冲正常绘制，所以它们不需要排序。但我们仍要保证它们在绘制（排序的）透明物体之前已经绘制完毕了。当绘制一个有不透明和透明物体的场景的时候，大体的原则如下：</p><ul><li>先绘制所有不透明的物体。</li><li>对所有透明的物体排序。</li><li>按顺序绘制所有透明的物体。</li></ul><p>排序透明物体的一种方法是，从观察者视角获取物体的距离。这可以通过计算摄像机位置向量和物体的位置向量之间的距离所获得。接下来我们把距离和它对应的位置向量存储到一个 STL 库的 map 数据结构中。map 会自动根据键值 (Key) 对它的值排序，所以只要我们添加了所有的位置，并以它的距离作为键，它们就会自动根据距离值排序了。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>std<span class="token operator">::</span>map<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token punctuation">,</span> glm<span class="token operator">::</span>vec3<span class="token operator">></span> sorted<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> windows<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">float</span> distance <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">length</span><span class="token punctuation">(</span>camera<span class="token punctuation">.</span>Position <span class="token operator">-</span> windows<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    sorted<span class="token punctuation">[</span>distance<span class="token punctuation">]</span> <span class="token operator">=</span> windows<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>结果就是一个排序后的容器对象，它根据 distance 键值从低到高储存了每个窗户的位置。</p><p>之后，这次在渲染的时候，我们将以逆序（从远到近）从 map 中获取值，之后以正确的顺序绘制对应的窗户：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>map<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token punctuation">,</span>glm<span class="token operator">::</span>vec3<span class="token operator">></span><span class="token operator">::</span>reverse_iterator it <span class="token operator">=</span> sorted<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> sorted<span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    model <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    model <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">translate</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span> it<span class="token operator">-></span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>              </pre></td></tr><tr><td data-num="5"></td><td><pre>    shader<span class="token punctuation">.</span><span class="token function">setMat4</span><span class="token punctuation">(</span><span class="token string">"model"</span><span class="token punctuation">,</span> model<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">glDrawArrays</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>我们使用了 map 的一个反向迭代器 (Reverse Iterator)，反向遍历其中的条目，并将每个窗户四边形位移到对应的窗户位置上。这是排序透明物体的一个比较简单的实现，它能够修复之前的问题，现在场景看起来是这样的：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/03/blending_sorted.png" alt="image"></p><p>虽然按照距离排序物体这种方法对我们这个场景能够正常工作，但它并没有考虑旋转、缩放或者其它的变换，奇怪形状的物体需要一个不同的计量，而不是仅仅一个位置向量。</p><p>在场景中<mark>排序物体是一个很困难的技术</mark>，很大程度上由你场景的类型所决定，更别说它额外需要消耗的处理能力了。完整渲染一个包含不透明和透明物体的场景并不是那么容易。更高级的技术还有<mark>次序无关透明度</mark> (Order Independent Transparency, OIT)，但这超出本教程的范围了。现在，你还是必须要普通地混合你的物体，但如果你很小心，并且知道目前方法的限制的话，你仍然能够获得一个比较不错的混合实现。</p><h2 id="面剔除"><a class="anchor" href="#面剔除">#</a> 面剔除</h2><p>尝试在脑子中想象一个 3D 立方体，数数你从任意方向最多能同时看到几个面。如果你的想象力不是过于丰富了，你应该能得出最大的面数是 3。你可以从任意位置和任意方向看向这个球体，但你永远不能看到 3 个以上的面。所以我们为什么要浪费时间绘制我们不能看见的那 3 个面呢？如果我们能够以某种方式丢弃这几个看不见的面，我们能省下超过 50% 的片段着色器执行数！</p><blockquote><p>我说的是超过 50% 而不是 50%，因为从特定角度来看的话只能看见 2 个甚至是 1 个面。在这种情况下，我们就能省下超过 50% 了。</p></blockquote><p>这是一个很好的主意，但我们仍有一个问题需要解决：我们如何知道一个物体的某一个面不能从观察者视角看到呢？<br>如果我们想象任何一个闭合形状，它的每一个面都有两侧，每一侧要么面向用户，要么背对用户。如果我们能够只绘制面向观察者的面呢？</p><p>这正是<mark>面剔除</mark> (Face Culling) 所做的。OpenGL 能够检查所有面向 (Front Facing) 观察者的面，并渲染它们，而丢弃那些背向 (Back Facing) 的面，节省我们很多的片段着色器调用（它们的开销很大！）。但我们仍要告诉 OpenGL 哪些面是正向面 (Front Face)，哪些面是背向面 (Back Face)。OpenGL 使用了一个很聪明的技巧，<mark>分析顶点数据的环绕顺序 (Winding Order)</mark>。</p><h3 id="环绕顺序"><a class="anchor" href="#环绕顺序">#</a> 环绕顺序</h3><p>当我们定义一组三角形顶点时，我们会以特定的环绕顺序来定义它们，可能是顺时针 (Clockwise) 的，也可能是逆时针 (Counter-clockwise) 的。每个三角形由 3 个顶点所组成，我们会从三角形中间来看，为这 3 个顶点设定一个环绕顺序。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/04/faceculling_windingorder.png" alt="image"></p><p>可以看到，我们首先定义了顶点 1，之后我们可以选择定义顶点 2 或者顶点 3，这个选择将定义了这个三角形的环绕顺序。下面的代码展示了这点：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> vertices<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 顺时针</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    vertices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 顶点 1</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    vertices<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 顶点 2</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    vertices<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 顶点 3</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 逆时针</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    vertices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 顶点 1</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    vertices<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 顶点 3</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    vertices<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment">// 顶点 2  </span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>每组组成三角形图元的三个顶点就包含了一个环绕顺序。OpenGL 在渲染图元的时候将使用这个信息来决定一个三角形是一个正向三角形还是背向三角形。默认情况下，<mark>逆时针</mark>顶点所定义的三角形将会被处理为<mark>正向三角形</mark>。</p><p>当你定义顶点顺序的时候，你应该想象对应的三角形是面向你的，所以你定义的三角形从正面看去应该是逆时针的。这样定义顶点很棒的一点是，实际的环绕顺序是在光栅化阶段进行的，也就是顶点着色器运行之后。这些顶点就是从观察者视角所见的了。</p><p>观察者所面向的所有三角形顶点就是我们所指定的正确环绕顺序了，而立方体另一面的三角形顶点则是以相反的环绕顺序所渲染的。这样的结果就是，我们所面向的三角形将会是正向三角形，而背面的三角形则是背向三角形。下面这张图显示了这个效果：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/04/faceculling_frontback.png" alt="image"></p><p>在顶点数据中，我们将两个三角形都以逆时针顺序定义（正面的三角形是 1、2、3，背面的三角形也是 1、2、3（如果我们从正面看这个三角形的话））。然而，如果从观察者当前视角使用 1、2、3 的顺序来绘制的话，从观察者的方向来看，<mark>背面的三角形</mark>将会是以<mark>顺时针顺序渲染</mark>的。虽然背面的三角形是以<mark>逆时针定义</mark>的，它现在是以顺时针顺序渲染的了。这正是我们想要剔除（Cull，丢弃）的不可见面了！</p><blockquote><p>即：把看不见的面顺时针渲染</p></blockquote><p>在顶点数据中，我们定义的是两个逆时针顺序的三角形。然而，从观察者的方面看，后面的三角形是顺时针的，如果我们仍以 1、2、3 的顺序以观察者当面的视野看的话。即使我们以逆时针顺序定义后面的三角形，它现在还是变为<mark>顺时针</mark>。它正是我们打算<mark>剔除</mark>（丢弃）的<mark>不可见的面</mark>！</p><h3 id="面剔除-2"><a class="anchor" href="#面剔除-2">#</a> 面剔除</h3><p>在本节的开头我们就说过，OpenGL 能够<mark>丢弃</mark>那些渲染为<mark>背向三角形</mark>的三角形图元。既然已经知道如何设置顶点的环绕顺序了，我们就可以使用 OpenGL 的面剔除选项了，它默认是禁用状态的。</p><p>在之前教程中使用的立方体顶点数据并不是按照逆时针环绕顺序定义的，所以我更新了顶点数据，来反映逆时针的环绕顺序，你可以从这里复制它们。尝试想象这些顶点，确认在每个三角形中它们都是以逆时针定义的，这是一个很好的习惯。</p><p>要想启用面剔除，我们只需要启用 OpenGL 的<mark> GL_CULL_FACE</mark> 选项：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glEnable</span><span class="token punctuation">(</span>GL_CULL_FACE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>从这一句代码之后，所有背向面都将被丢弃（尝试飞进立方体内部，看看所有的内面是不是都被丢弃了）。目前我们在渲染片段的时候能够节省 50% 以上的性能，但注意这只对像立方体这样的封闭形状有效。当我们想要绘制上一节中的草时，我们必须要再次禁用面剔除，因为它们的正向面和背向面都应该是可见的。</p><p>OpenGL 允许我们改变需要剔除的面的类型。如果我们只想剔除正向面而不是背向面会怎么样？我们可以调用<mark> glCullFace</mark> 来定义这一行为：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glCullFace</span><span class="token punctuation">(</span>GL_FRONT<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>glCullFace 函数有三个可用的选项：</p><ul><li>GL_BACK：只剔除<mark>背</mark>向面。</li><li>GL_FRONT：只剔除<mark>正</mark>向面。</li><li>GL_FRONT_AND_BACK：剔除<mark>正向面和背向面</mark>。</li></ul><p>glCullFace 的初始值是 GL_BACK。除了需要剔除的面之外，我们也可以通过调用 glFrontFace，告诉 OpenGL 我们希望<mark>将顺时针的面（而不是逆时针的面）定义为正向面</mark>：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glFrontFace</span><span class="token punctuation">(</span>GL_CCW<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>默认值是<mark> GL_CCW</mark>，它代表的是<mark>逆时针</mark>的环绕顺序，另一个选项是<mark> GL_CW</mark>，它（显然）代表的是<mark>顺时针</mark>顺序。</p><p>我们可以来做一个实验，告诉 OpenGL 现在顺时针顺序代表的是正向面：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glEnable</span><span class="token punctuation">(</span>GL_CULL_FACE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glCullFace</span><span class="token punctuation">(</span>GL_BACK<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glFrontFace</span><span class="token punctuation">(</span>GL_CW<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/04/faceculling_reverse.png" alt="image"></p><p>注意你可以仍使用默认的逆时针环绕顺序，但剔除正向面，来达到相同的效果：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glEnable</span><span class="token punctuation">(</span>GL_CULL_FACE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glCullFace</span><span class="token punctuation">(</span>GL_FRONT<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h2 id="帧缓冲"><a class="anchor" href="#帧缓冲">#</a> 帧缓冲</h2><p>到目前为止，我们已经使用了很多屏幕缓冲了：用于写入颜色值的颜色缓冲、用于写入深度信息的深度缓冲和允许我们根据一些条件丢弃特定片段的模板缓冲。这些缓冲结合起来叫做<mark>帧缓冲</mark> (Framebuffer)，它被储存在内存中。OpenGL 允许我们定义我们自己的帧缓冲，也就是说我们能够定义我们自己的颜色缓冲，甚至是深度缓冲和模板缓冲。</p><p>我们目前所做的所有操作都是在默认帧缓冲的渲染缓冲上进行的。<mark>默认</mark>的<mark>帧缓冲</mark>是在你创建窗口的时候生成和配置的（GLFW 帮我们做了这些）。有了我们自己的帧缓冲，我们就能够有更多方式来渲染了。</p><p>你可能不能很快理解帧缓冲的应用，但渲染你的场景到不同的帧缓冲能够让我们在场景中加入类似镜子的东西，或者做出很酷的后期处理效果。首先我们会讨论它是如何工作的，之后我们将来实现这些炫酷的后期处理效果。</p><h3 id="创建一个帧缓冲"><a class="anchor" href="#创建一个帧缓冲">#</a> 创建一个帧缓冲</h3><p>和 OpenGL 中的其它对象一样，我们会使用一个叫做<mark> glGenFramebuffers</mark> 的函数来创建一个帧缓冲对象 (Framebuffer Object, FBO)：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> fbo<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glGenFramebuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fbo<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这种创建和使用对象的方式我们已经见过很多次了，所以它的使用函数也和其它的对象类似。首先我们创建一个帧缓冲对象，将它绑定为激活的 (Active) 帧缓冲，做一些操作，之后解绑帧缓冲。我们使用<mark> glBindFramebuffer</mark> 来绑定帧缓冲。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> fbo<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在绑定到<mark> GL_FRAMEBUFFER</mark> 目标之后，所有的读取和写入帧缓冲的操作将会影响当前绑定的帧缓冲。我们也可以使用<mark> GL_READ_FRAMEBUFFER</mark> 或<mark> GL_DRAW_FRAMEBUFFER</mark>，将一个帧缓冲分别绑定到读取目标或写入目标。绑定到 GL_READ_FRAMEBUFFER 的帧缓冲将会使用像是 glReadPixels 的<mark>读取操作中</mark>，而绑定到 GL_DRAW_FRAMEBUFFER 的帧缓冲将会被用作<mark>渲染</mark>、<mark>清除</mark>等<mark>写入操作</mark>的目标。大部分情况你都不需要区分它们，通常都会使用 GL_FRAMEBUFFER，绑定到两个上。</p><p>不幸的是，我们现在还不能使用我们的帧缓冲，因为它还不完整 (Complete)，一个完整的帧缓冲需要满足以下的条件：</p><ul><li>附加<mark>至少一个</mark>缓冲（颜色、深度或模板缓冲）。</li><li>至少有<mark>一个颜色附件</mark> (Attachment)。</li><li>所有的附件都必须是<mark>完整</mark>的（保留了内存）。</li><li>每个缓冲都应该有<mark>相同</mark>的样本数。</li></ul><p>从上面的条件中可以知道，我们需要为帧缓冲创建一些附件，并将附件附加到帧缓冲上。在完成所有的条件之后，我们可以以 GL_FRAMEBUFFER 为参数调用<mark> glCheckFramebufferStatus</mark>，检查帧缓冲是否完整。它将会检测当前绑定的帧缓冲，并返回规范中这些值的其中之一。如果它返回的是<mark> GL_FRAMEBUFFER_COMPLETE</mark>，帧缓冲就是<mark>完整的</mark>了。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">glCheckFramebufferStatus</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">)</span> <span class="token operator">==</span> GL_FRAMEBUFFER_COMPLETE<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token comment">// 执行胜利的舞蹈</span></pre></td></tr></table></figure><p>之后所有的渲染操作将会渲染到当前绑定帧缓冲的附件中。由于我们的帧缓冲不是默认帧缓冲，渲染指令将不会对窗口的视觉输出有任何影响。出于这个原因，渲染到一个不同的帧缓冲被叫做<mark>离屏渲染</mark> (Off-screen Rendering)。要保证所有的渲染操作在主窗口中有视觉效果，我们需要再次激活默认帧缓冲，将它绑定到 0。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在完成所有的帧缓冲操作之后，不要忘记删除这个帧缓冲对象：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glDeleteFramebuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fbo<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在完整性检查执行之前，我们需要给帧缓冲附加一个附件。<mark>附件</mark>是一个<mark>内存位置</mark>，它能够作为帧缓冲的一个缓冲，可以将它想象为一个图像。当创建一个附件的时候我们有两个选项：纹理或渲染缓冲对象 (Renderbuffer Object)。</p><h3 id="纹理附件"><a class="anchor" href="#纹理附件">#</a> 纹理附件</h3><p>当把一个纹理附加到帧缓冲的时候，所有的渲染指令将会写入到这个纹理中，就想它是一个普通的颜色 / 深度或模板缓冲一样。使用纹理的优点是，所有渲染操作的结果将会被储存在一个纹理图像中，我们之后可以在着色器中很方便地使用它。</p><p>为帧缓冲创建一个纹理和创建一个普通的纹理差不多：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> texture<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glGenTextures</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>texture<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> texture<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">glTexImage2D</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RGB<span class="token punctuation">,</span> <span class="token number">800</span><span class="token punctuation">,</span> <span class="token number">600</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RGB<span class="token punctuation">,</span> GL_UNSIGNED_BYTE<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_MIN_FILTER<span class="token punctuation">,</span> GL_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_MAG_FILTER<span class="token punctuation">,</span> GL_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>主要的区别就是，我们将维度设置为了屏幕大小（尽管这不是必须的），并且我们给纹理的 data 参数传递了<mark> NULL</mark>。对于这个纹理，我们仅<mark>仅分配了内存而没有填充它</mark>。填充这个纹理将会在我们渲染到帧缓冲之后来进行。同样注意我们并不关心环绕方式或多级渐远纹理，我们在大多数情况下都不会需要它们。</p><blockquote><p>如果你想将你的屏幕渲染到一个更小或更大的纹理上，你需要（在<mark>渲染到你的帧缓冲之前</mark>）再次调用<mark> glViewport</mark>，使用纹理的新维度作为参数，否则只有一小部分的纹理或屏幕会被渲染到这个纹理上。</p></blockquote><p>现在我们已经创建好一个纹理了，要做的最后一件事就是将它附加到帧缓冲上了：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glFramebufferTexture2D</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> GL_COLOR_ATTACHMENT0<span class="token punctuation">,</span> GL_TEXTURE_2D<span class="token punctuation">,</span> texture<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>glFrameBufferTexture2D 有以下的参数：</p><ul><li>target：帧缓冲的目标（绘制、读取或者两者皆有）</li><li>attachment：我们想要附加的附件类型。当前我们正在附加一个颜色附件。注意最后的 0 意味着我们可以附加多个颜色附件。我们将在之后的教程中提到。</li><li>textarget：你希望附加的纹理类型</li><li>texture：要附加的纹理本身</li><li>level：多级渐远纹理的级别。我们将它保留为 0。</li></ul><p>除了颜色附件之外，我们还可以附加一个深度和模板缓冲纹理到帧缓冲对象中。要附加深度缓冲的话，我们将附件类型设置为<mark> GL_DEPTH_ATTACHMENT</mark>。注意纹理的格式 (Format) 和内部格式 (Internalformat) 类型将变为 GL_DEPTH_COMPONENT，来反映深度缓冲的储存格式。要附加模板缓冲的话，你要将第二个参数设置为 GL_STENCIL_ATTACHMENT，并将纹理的格式设定为 GL_STENCIL_INDEX。</p><p>也可以将深度缓冲和模板缓冲附加为一个单独的纹理。纹理的每 32 位数值将包含 24 位的深度信息和 8 位的模板信息。要将深度和模板缓冲附加为一个纹理的话，我们使用 GL_DEPTH_STENCIL_ATTACHMENT 类型，并配置纹理的格式，让它包含合并的深度和模板值。将一个深度和模板缓冲附加为一个纹理到帧缓冲的例子可以在下面找到：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glTexImage2D</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_DEPTH24_STENCIL8<span class="token punctuation">,</span> <span class="token number">800</span><span class="token punctuation">,</span> <span class="token number">600</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="3"></td><td><pre>  GL_DEPTH_STENCIL<span class="token punctuation">,</span> GL_UNSIGNED_INT_24_8<span class="token punctuation">,</span> <span class="token constant">NULL</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">glFramebufferTexture2D</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> GL_DEPTH_STENCIL_ATTACHMENT<span class="token punctuation">,</span> GL_TEXTURE_2D<span class="token punctuation">,</span> texture<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="渲染缓冲对象附件"><a class="anchor" href="#渲染缓冲对象附件">#</a> 渲染缓冲对象附件</h3><p>渲染缓冲对象 (Renderbuffer Object) 是在纹理之后引入到 OpenGL 中，作为一个可用的帧缓冲附件类型的，所以在过去纹理是唯一可用的附件。和纹理图像一样，渲染缓冲对象是一个<mark>真正的缓冲</mark>，即<mark>一系列的字节、整数、像素等</mark>。渲染缓冲对象附加的好处是，它会将数据储存为 OpenGL 原生的渲染格式，它是为离屏渲染到帧缓冲优化过的。</p><p>渲染缓冲对象直接将所有的渲染数据储存到它的缓冲中，不会做任何针对纹理格式的转换，让它变为一个更快的可写储存介质。然而，渲染缓冲对象通常都是只写的，所以你不能读取它们（比如使用纹理访问）。当然你仍然还是能够使用<mark> glReadPixels</mark> 来读取它，这会从当前绑定的<mark>帧缓冲</mark>，而<mark>不是附件本身</mark>，中返回特定区域的像素。</p><p>因为它的数据已经是原生的格式了，当写入或者复制它的数据到其它缓冲中时是非常快的。所以，交换缓冲这样的操作在使用渲染缓冲对象时会非常快。我们在每个渲染迭代最后使用的 glfwSwapBuffers，也可以通过渲染缓冲对象实现：只需要写入一个渲染缓冲图像，并在最后交换到另外一个渲染缓冲就可以了。渲染缓冲对象对这种操作非常完美。</p><p>创建一个渲染缓冲对象的代码和帧缓冲的代码很类似：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> rbo<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glGenRenderbuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>rbo<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>类似，我们需要绑定这个渲染缓冲对象，让之后所有的渲染缓冲操作影响当前的 rbo：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glBindRenderbuffer</span><span class="token punctuation">(</span>GL_RENDERBUFFER<span class="token punctuation">,</span> rbo<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>由于渲染缓冲对象通常都是只写的，它们会经常用于深度和模板附件，因为大部分时间我们都不需要从深度和模板缓冲中读取值，只关心深度和模板测试。我们需要深度和模板值用于测试，但不需要对它们进行采样，所以渲染缓冲对象非常适合它们。当我们不需要从这些缓冲中采样的时候，通常都会选择渲染缓冲对象，因为它会更优化一点。</p><p>创建一个<mark>深度和模板渲染缓冲对象</mark>可以通过调用<mark> glRenderbufferStorage</mark> 函数来完成：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glRenderbufferStorage</span><span class="token punctuation">(</span>GL_RENDERBUFFER<span class="token punctuation">,</span> GL_DEPTH24_STENCIL8<span class="token punctuation">,</span> <span class="token number">800</span><span class="token punctuation">,</span> <span class="token number">600</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>创建一个渲染缓冲对象和纹理对象类似，不同的是这个对象是专门被设计作为图像使用的，而不是纹理那样的通用数据缓冲 (General Purpose Data Buffer)。这里我们选择 GL_DEPTH24_STENCIL8 作为内部格式，它封装了 24 位的深度和 8 位的模板缓冲。</p><p>最后一件事就是附加这个渲染缓冲对象：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glFramebufferRenderbuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> GL_DEPTH_STENCIL_ATTACHMENT<span class="token punctuation">,</span> GL_RENDERBUFFER<span class="token punctuation">,</span> rbo<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>渲染缓冲对象能为你的帧缓冲对象提供一些优化，但知道什么时候使用渲染缓冲对象，什么时候使用纹理是很重要的。通常的规则是，如果你<mark>不需要</mark>从一个缓冲中<mark>采样数据</mark>，那么对这个缓冲使用<mark>渲染缓冲</mark>对象会是明智的选择。如果你<mark>需要</mark>从缓冲中<mark>采样</mark>颜色或深度值等数据，那么你应该选择<mark>纹理附件</mark>。性能方面它不会产生非常大的影响的。</p><h3 id="渲染到纹理"><a class="anchor" href="#渲染到纹理">#</a> 渲染到纹理</h3><p>既然我们已经知道帧缓冲（大概）是怎么工作的了，是时候实践它们了。我们将会<mark>将场景</mark>渲染到一个<mark>附加到</mark>帧缓冲对象上的<mark>颜色纹理</mark>中，之后将在一个横跨整个屏幕的四边形上绘制这个纹理。这样视觉输出和没使用帧缓冲时是完全一样的，但这次是打印到了一个四边形上。这为什么很有用呢？我们会在下一部分中知道原因。</p><p>首先要创建一个帧缓冲对象，并绑定它，这些都很直观：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> framebuffer<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glGenFramebuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>framebuffer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> framebuffer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>接下来我们需要创建一个<mark>纹理图像</mark>，我们将它<mark>作为</mark>一个<mark>颜色附件</mark>附加到帧缓冲上。我们将纹理的维度设置为窗口的宽度和高度，并且<mark>不初始化它的数据</mark>：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 生成纹理</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> texColorBuffer<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glGenTextures</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>texColorBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> texColorBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">glTexImage2D</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RGB<span class="token punctuation">,</span> <span class="token number">800</span><span class="token punctuation">,</span> <span class="token number">600</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RGB<span class="token punctuation">,</span> GL_UNSIGNED_BYTE<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_MIN_FILTER<span class="token punctuation">,</span> GL_LINEAR <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_MAG_FILTER<span class="token punctuation">,</span> GL_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// 将它附加到当前绑定的帧缓冲对象</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token function">glFramebufferTexture2D</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> GL_COLOR_ATTACHMENT0<span class="token punctuation">,</span> GL_TEXTURE_2D<span class="token punctuation">,</span> texColorBuffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>我们还希望 OpenGL 能够进行深度测试（如果你需要的话还有模板测试），所以我们还需要添加一个深度（和模板）附件到帧缓冲中。由于我们只希望采样颜色缓冲，而不是其它的缓冲，我们可以为它们创建一个渲染缓冲对象。还记得当我们不需要采样缓冲的时候，渲染缓冲对象是更好的选择吗？</p><p>创建一个渲染缓冲对象不是非常复杂。我们需要记住的唯一事情是，我们将它创建为一个<mark>深度和模板附件渲染缓冲对象</mark>。我们将它的<mark>内部格式</mark>设置为<mark> GL_DEPTH24_STENCIL8</mark>，对我们来说这个精度已经足够了。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> rbo<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glGenRenderbuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>rbo<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glBindRenderbuffer</span><span class="token punctuation">(</span>GL_RENDERBUFFER<span class="token punctuation">,</span> rbo<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glRenderbufferStorage</span><span class="token punctuation">(</span>GL_RENDERBUFFER<span class="token punctuation">,</span> GL_DEPTH24_STENCIL8<span class="token punctuation">,</span> <span class="token number">800</span><span class="token punctuation">,</span> <span class="token number">600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">glBindRenderbuffer</span><span class="token punctuation">(</span>GL_RENDERBUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>当我们为渲染缓冲对象分配了足够的内存之后，我们可以<mark>解绑</mark>这个渲染缓冲。</p><p>接下来，作为完成帧缓冲之前的最后一步，我们将渲染缓冲对象<mark>附加到</mark>帧缓冲的深度和模板附件上：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glFramebufferRenderbuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> GL_DEPTH_STENCIL_ATTACHMENT<span class="token punctuation">,</span> GL_RENDERBUFFER<span class="token punctuation">,</span> rbo<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>最后，我们希望检查帧缓冲是否是完整的，如果不是，我们将打印错误信息。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">glCheckFramebufferStatus</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">)</span> <span class="token operator">!=</span> GL_FRAMEBUFFER_COMPLETE<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ERROR::FRAMEBUFFER:: Framebuffer is not complete!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>记得要解绑帧缓冲，保证我们不会不小心渲染到错误的帧缓冲上。</p><p>现在这个帧缓冲就完整了，我们只需要绑定这个帧缓冲对象，让渲染到帧缓冲的缓冲中而不是默认的帧缓冲中。之后的渲染指令将会影响当前绑定的帧缓冲。所有的深度和模板操作都会从当前绑定的帧缓冲的深度和模板附件中（如果有的话）读取。如果你忽略了深度缓冲，那么所有的深度测试操作将不再工作，因为当前绑定的帧缓冲中不存在深度缓冲。</p><p>所以，要想绘制场景到一个纹理上，我们需要采取以下的步骤：</p><ul><li>将新的帧缓冲绑定为<mark>激活</mark>的帧缓冲，和往常一样渲染场景。</li><li>绑定默认的帧缓冲。</li><li>绘制一个横跨整个屏幕的四边形，将帧缓冲的颜色缓冲作为它的纹理。</li></ul><p>我们将会绘制深度测试小节中的场景，但这次使用的是旧的箱子纹理。</p><p>为了绘制这个四边形，我们将会新创建一套简单的着色器。我们将不会包含任何花哨的矩阵变换，因为我们提供的是标准化设备坐标的顶点坐标，所以我们可以直接将它们设定为顶点着色器的输出。顶点着色器是这样的：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> in vec2 aPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> in vec2 aTexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>out vec2 TexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    gl_Position <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>aPos<span class="token punctuation">.</span>x<span class="token punctuation">,</span> aPos<span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre>    TexCoords <span class="token operator">=</span> aTexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>并没有太复杂的东西。片段着色器会更加基础，我们做的唯一一件事就是从纹理中采样：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>out vec4 FragColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>in vec2 TexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>uniform sampler2D screenTexture<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>screenTexture<span class="token punctuation">,</span> TexCoords<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>接着就靠你来为屏幕四边形创建并配置一个 VAO 了。帧缓冲的一个渲染迭代将会有以下的结构：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 第一处理阶段 (Pass)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> framebuffer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glClearColor</span><span class="token punctuation">(</span><span class="token number">0.1f</span><span class="token punctuation">,</span> <span class="token number">0.1f</span><span class="token punctuation">,</span> <span class="token number">0.1f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT <span class="token operator">|</span> GL_DEPTH_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 我们现在不使用模板缓冲</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">glEnable</span><span class="token punctuation">(</span>GL_DEPTH_TEST<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">DrawScene</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// 第二处理阶段</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回默认</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token function">glClearColor</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>screenShader<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>quadVAO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token function">glDisable</span><span class="token punctuation">(</span>GL_DEPTH_TEST<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> textureColorbuffer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token function">glDrawArrays</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>要注意一些事情。第一，由于我们使用的每个帧缓冲都有它自己一套缓冲，我们希望设置合适的位置，调用 glClear，清除这些缓冲。第二，当绘制四边形时，我们将禁用深度测试，因为我们是在绘制一个简单的四边形，并不需要关系深度测试。在绘制普通场景的时候我们将会重新启用深度测试。</p><p>有很多步骤都可能会出错，所以如果你没有得到输出的话，尝试调试程序，并重新阅读本节的相关部分。如果所有的东西都能够正常工作，你将会得到下面这样的视觉输出：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/05/framebuffers_screen_texture.png" alt="image"></p><p>左边展示的是视觉输出，它和深度测试中是完全一样的，但这次是渲染在一个简单的四边形上。如果我们使用线框模式渲染场景，就会变得很明显，我们在默认的帧缓冲中只绘制了一个简单的四边形。</p><p>所以这个有什么用处呢？因为我们能够以一个纹理图像的方式访问已渲染场景中的每个像素，我们可以在片段着色器中创建出非常有趣的效果。这些有趣效果统称为<mark>后期处理</mark> (Post-processing) 效果。</p><h3 id="后期处理"><a class="anchor" href="#后期处理">#</a> 后期处理</h3><p>既然整个场景都被渲染到了一个纹理上，我们可以简单地通过修改纹理数据创建出一些非常有意思的效果。在这一部分中，我们将会向你展示一些流行的后期处理效果，并告诉你改如何使用创造力创建你自己的效果。</p><p>让我们先从最简单的后期处理效果开始。</p><h4 id="反相"><a class="anchor" href="#反相">#</a> 反相</h4><p>我们现在能够访问渲染输出的每个颜色，所以在（译注：屏幕的）片段着色器中返回这些颜色的反相 (Inversion) 并不是很难。我们将会从屏幕纹理中取颜色值，然后用 1.0 减去它，对它进行反相：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> <span class="token function">texture</span><span class="token punctuation">(</span>screenTexture<span class="token punctuation">,</span> TexCoords<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>尽管反相是一个相对简单的后期处理效果，它已经能创造一些奇怪的效果了：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/05/framebuffers_inverse.png" alt="image"></p><h4 id="灰度"><a class="anchor" href="#灰度">#</a> 灰度</h4><p>另外一个很有趣的效果是，移除场景中除了黑白灰以外所有的颜色，让整个图像灰度化 (Grayscale)。很简单的实现方式是，取所有的颜色分量，将它们平均化：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>screenTexture<span class="token punctuation">,</span> TexCoords<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">float</span> average <span class="token operator">=</span> <span class="token punctuation">(</span>FragColor<span class="token punctuation">.</span>r <span class="token operator">+</span> FragColor<span class="token punctuation">.</span>g <span class="token operator">+</span> FragColor<span class="token punctuation">.</span>b<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">3.0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>average<span class="token punctuation">,</span> average<span class="token punctuation">,</span> average<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/05/framebuffers_grayscale.png" alt="image"></p><h4 id="核效果"><a class="anchor" href="#核效果">#</a> 核效果</h4><p>在一个纹理图像上做后期处理的另外一个好处是，我们可以从纹理的其它地方采样颜色值。比如说我们可以在当前纹理坐标的周围取一小块区域，对当前纹理值周围的多个纹理值进行采样。我们可以结合它们创建出很有意思的效果。</p><p><mark>核</mark> (Kernel)（或卷积矩阵 (Convolution Matrix)）是一个类矩阵的数值数组，它的中心为当前的像素，它会用它的核值乘以周围的像素值，并将结果相加变成一个值。所以，基本上我们是在对当前像素周围的纹理坐标添加一个小的偏移量，并根据核将结果合并。下面是核的一个例子：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>15</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\begin{bmatrix} 2 &amp; 2 &amp; 2 \\ 2 &amp; -15 &amp; 2 \\ 2 &amp; 2 &amp; 2 \end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.6010299999999997em;vertical-align:-1.55002em"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em"><span style="top:-2.2500000000000004em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.8099900000000004em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.05101em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em"><span style="top:-4.21em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.0099999999999993em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-1.8099999999999994em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em"><span></span></span></span></span></span><span class="arraycolsep" style="width:.5em"></span><span class="arraycolsep" style="width:.5em"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em"><span style="top:-4.21em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.0099999999999993em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span><span class="mord">5</span></span></span><span style="top:-1.8099999999999994em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em"><span></span></span></span></span></span><span class="arraycolsep" style="width:.5em"></span><span class="arraycolsep" style="width:.5em"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em"><span style="top:-4.21em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.0099999999999993em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-1.8099999999999994em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em"><span style="top:-2.2500000000000004em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.8099900000000004em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.05101em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>这个核取了 8 个周围像素值，将它们乘以 2，而把当前的像素乘以 - 15。这个核的例子将周围的像素乘上了一个权重，并将当前像素乘以一个比较大的负权重来平衡结果。</p><blockquote><p>你在网上找到的大部分核将所有的权重加起来之后都应该会等于 1，如果它们加起来不等于 1，这就意味着最终的纹理颜色将会比原纹理值更亮或者更暗了。</p></blockquote><p>核是后期处理一个非常有用的工具，它们使用和实验起来都很简单，网上也能找到很多例子。我们需要稍微修改一下片段着色器，让它能够支持核。我们假设使用的核都是 3x3 核（实际上大部分核都是）</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">float</span> offset <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token number">300.0</span><span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    vec2 offsets<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> vec2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token function">vec2</span><span class="token punctuation">(</span><span class="token operator">-</span>offset<span class="token punctuation">,</span>  offset<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 左上</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token function">vec2</span><span class="token punctuation">(</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>    offset<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 正上</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token function">vec2</span><span class="token punctuation">(</span> offset<span class="token punctuation">,</span>  offset<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 右上</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token function">vec2</span><span class="token punctuation">(</span><span class="token operator">-</span>offset<span class="token punctuation">,</span>  <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span>   <span class="token comment">// 左</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token function">vec2</span><span class="token punctuation">(</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>    <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span>   <span class="token comment">// 中</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token function">vec2</span><span class="token punctuation">(</span> offset<span class="token punctuation">,</span>  <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span>   <span class="token comment">// 右</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token function">vec2</span><span class="token punctuation">(</span><span class="token operator">-</span>offset<span class="token punctuation">,</span> <span class="token operator">-</span>offset<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 左下</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token function">vec2</span><span class="token punctuation">(</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>   <span class="token operator">-</span>offset<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 正下</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token function">vec2</span><span class="token punctuation">(</span> offset<span class="token punctuation">,</span> <span class="token operator">-</span>offset<span class="token punctuation">)</span>  <span class="token comment">// 右下</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">float</span> kernel<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">float</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">9</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>    vec3 sampleTex<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        sampleTex<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token function">texture</span><span class="token punctuation">(</span>screenTexture<span class="token punctuation">,</span> TexCoords<span class="token punctuation">.</span>st <span class="token operator">+</span> offsets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    vec3 col <span class="token operator">=</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        col <span class="token operator">+=</span> sampleTex<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> kernel<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>col<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在片段着色器中，我们首先为周围的纹理坐标创建了一个 9 个 vec2 偏移量的数组。偏移量是一个常量，你可以按照你的喜好自定义它。之后我们定义一个核，在这个例子中是一个<mark>锐化 (Sharpen) 核</mark>，它会采样周围的所有像素，锐化每个颜色值。最后，在采样时我们将每个偏移量加到当前纹理坐标上，获取需要采样的纹理，之后将这些纹理值乘以加权的核值，并将它们加到一起。</p><p>这个锐化核看起来是这样的：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/05/framebuffers_sharpen.png" alt="image"></p><h4 id="模糊"><a class="anchor" href="#模糊">#</a> 模糊</h4><p>创建模糊 (Blur) 效果的核是这样的：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mi mathvariant="normal">/</mi><mn>16</mn></mrow><annotation encoding="application/x-tex">\begin{bmatrix} 1 &amp; 2 &amp; 1 \\ 2 &amp; 4 &amp; 2 \\ 1 &amp; 2 &amp; 1 \end{bmatrix} /16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.6010299999999997em;vertical-align:-1.55002em"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em"><span style="top:-2.2500000000000004em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.8099900000000004em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.05101em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em"><span style="top:-4.21em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-1.8099999999999994em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em"><span></span></span></span></span></span><span class="arraycolsep" style="width:.5em"></span><span class="arraycolsep" style="width:.5em"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em"><span style="top:-4.21em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.0099999999999993em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">4</span></span></span><span style="top:-1.8099999999999994em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em"><span></span></span></span></span></span><span class="arraycolsep" style="width:.5em"></span><span class="arraycolsep" style="width:.5em"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em"><span style="top:-4.21em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-1.8099999999999994em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em"><span style="top:-2.2500000000000004em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.8099900000000004em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.05101em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">/</span><span class="mord">1</span><span class="mord">6</span></span></span></span></span></p><p>由于所有值的和是 16，所以直接返回合并的采样颜色将产生非常亮的颜色，所以我们需要将核的每个值都除以 16。最终的核数组将会是：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> kernel<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">float</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">2.0</span> <span class="token operator">/</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token number">16</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token number">2.0</span> <span class="token operator">/</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">4.0</span> <span class="token operator">/</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">2.0</span> <span class="token operator">/</span> <span class="token number">16</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">2.0</span> <span class="token operator">/</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token number">16</span>  </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>通过在片段着色器中改变核的 float 数组，我们完全改变了后期处理效果。它现在看起来是这样子的：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/05/framebuffers_blur.png" alt="image"></p><p>这样的模糊效果创造了很多的可能性。我们可以随着时间修改模糊的量，创造出玩家醉酒时的效果，或者在主角没带眼镜的时候增加模糊。模糊也能够让我们来平滑颜色值，我们将在之后教程中使用到。</p><p>你可以看到，只要我们有了这个核的实现，创建炫酷的后期处理特效是非常容易的事。我们再来看最后一个很流行的效果来结束本节的讨论。</p><h4 id="边缘检测"><a class="anchor" href="#边缘检测">#</a> 边缘检测</h4><p>下面的边缘检测 (Edge-detection) 核和锐化核非常相似：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>8</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\begin{bmatrix} 1 &amp; 1 &amp; 1 \\ 1 &amp; -8 &amp; 1 \\ 1 &amp; 1 &amp; 1 \end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.6010299999999997em;vertical-align:-1.55002em"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em"><span style="top:-2.2500000000000004em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.8099900000000004em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.05101em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em"><span style="top:-4.21em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em"><span></span></span></span></span></span><span class="arraycolsep" style="width:.5em"></span><span class="arraycolsep" style="width:.5em"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em"><span style="top:-4.21em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">−</span><span class="mord">8</span></span></span><span style="top:-1.8099999999999994em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em"><span></span></span></span></span></span><span class="arraycolsep" style="width:.5em"></span><span class="arraycolsep" style="width:.5em"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em"><span style="top:-4.21em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0510099999999998em"><span style="top:-2.2500000000000004em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.8099900000000004em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.05101em"><span class="pstrut" style="height:3.1550000000000002em"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>这个核高亮了所有的边缘，而暗化了其它部分，在我们只关心图像的边角的时候是非常有用的。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/05/framebuffers_edge_detection.png" alt="image"></p><p>你可能不会奇怪，像是 Photoshop 这样的图像修改工具 / 滤镜使用的也是这样的核。因为显卡处理片段的时候有着极强的并行处理能力，我们可以很轻松地在实时的情况下逐像素对图像进行处理。所以图像编辑工具在图像处理的时候会更倾向于使用显卡。</p><blockquote><p>注意，核在对屏幕纹理的边缘进行采样的时候，由于还会对中心像素周围的 8 个像素进行采样，其实会取到纹理之外的像素。由于环绕方式默认是 GL_REPEAT，所以在没有设置的情况下取到的是屏幕另一边的像素，而另一边的像素本不应该对中心像素产生影响，这就可能会在屏幕边缘产生很奇怪的条纹。为了消除这一问题，我们可以将屏幕纹理的环绕方式都设置为 GL_CLAMP_TO_EDGE。这样子在取到纹理外的像素时，就能够重复边缘的像素来更精确地估计最终的值了。</p></blockquote><h2 id="立方体贴图"><a class="anchor" href="#立方体贴图">#</a> 立方体贴图</h2><p>我们已经使用 2D 纹理很长时间了，但除此之外仍有更多的纹理类型等着我们探索。在本节中，我们将讨论的是将多个纹理组合起来映射到一张纹理上的一种纹理类型：立方体贴图 (Cube Map)。</p><p>简单来说，立方体贴图就是一个包含了 6 个 2D 纹理的纹理，每个 2D 纹理都组成了立方体的一个面：一个有纹理的立方体。你可能会奇怪，这样一个立方体有什么用途呢？为什么要把 6 张纹理合并到一张纹理中，而不是直接使用 6 个单独的纹理呢？立方体贴图有一个非常有用的特性，它可以<mark>通过一个方向向量</mark>来进行<mark>索引 / 采样</mark>。假设我们有一个 1x1x1 的单位立方体，方向向量的原点位于它的中心。使用一个橘黄色的方向向量来从立方体贴图上采样一个纹理值会像是这样：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/06/cubemaps_sampling.png" alt="image"></p><blockquote><p>方向向量的<mark>大小并不重要</mark>，只要提供了方向，OpenGL 就会获取方向向量（最终）所击中的纹素，并返回对应的采样纹理值。</p></blockquote><p>如果我们假设将这样的立方体贴图应用到一个立方体上，采样立方体贴图所使用的方向向量将和立方体（插值的）顶点位置非常相像。这样子，只要立方体的中心位于原点，我们就能使用立方体的实际位置向量来对立方体贴图进行采样了。接下来，我们可以将所有顶点的纹理坐标当做是立方体的顶点位置。最终得到的结果就是可以访问立方体贴图上正确<mark>面 (Face) 纹理</mark>的一个纹理坐标。</p><h3 id="创建立方体贴图"><a class="anchor" href="#创建立方体贴图">#</a> 创建立方体贴图</h3><p>立方体贴图是和其它纹理一样的，所以如果想创建一个立方体贴图的话，我们需要生成一个纹理，并将其绑定到纹理目标上，之后再做其它的纹理操作。这次要绑定到<mark> GL_TEXTURE_CUBE_MAP</mark>：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> textureID<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glGenTextures</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>textureID<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> textureID<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>因为立方体贴图包含有 6 个纹理，每个面一个，我们需要调用 glTexImage2D 函数<mark> 6 次</mark>，参数和之前教程中很类似。但这一次我们将纹理目标 (target) 参数设置为立方体贴图的一个特定的面，告诉 OpenGL 我们在对立方体贴图的哪一个面创建纹理。这就意味着我们需要对立方体贴图的每一个面都调用一次 glTexImage2D。</p><p>由于我们有 6 个面，OpenGL 给我们提供了 6 个特殊的纹理目标，专门对应立方体贴图的一个面。</p><table><thead><tr><th>纹理目标</th><th>方位</th></tr></thead><tbody><tr><td>GL_TEXTURE_CUBE_MAP_POSITIVE_X</td><td>右</td></tr><tr><td>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</td><td>左</td></tr><tr><td>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</td><td>上</td></tr><tr><td>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</td><td>下</td></tr><tr><td>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</td><td>后</td></tr><tr><td>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</td><td>前</td></tr></tbody></table><p>和 OpenGL 的很多枚举 (Enum) 一样，它们背后的 int 值是线性<mark>递增</mark>的，所以如果我们有一个纹理位置的数组或者 vector，我们就可以从<mark> GL_TEXTURE_CUBE_MAP_POSITIVE_X</mark> 开始<mark>遍历</mark>它们，在每个迭代中对枚举值加 1，遍历了整个纹理目标：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> nrChannels<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>data<span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> textures_faces<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    data <span class="token operator">=</span> <span class="token function">stbi_load</span><span class="token punctuation">(</span>textures_faces<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>width<span class="token punctuation">,</span> <span class="token operator">&amp;</span>height<span class="token punctuation">,</span> <span class="token operator">&amp;</span>nrChannels<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">glTexImage2D</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        GL_TEXTURE_CUBE_MAP_POSITIVE_X <span class="token operator">+</span> i<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token number">0</span><span class="token punctuation">,</span> GL_RGB<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RGB<span class="token punctuation">,</span> GL_UNSIGNED_BYTE<span class="token punctuation">,</span> data</pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里我们有一个叫做 textures_faces 的 vector，它包含了立方体贴图所需的所有纹理路径，并以表中的顺序排列。这将为当前绑定的立方体贴图中的每个面生成一个纹理。</p><p>因为立方体贴图和其它纹理没什么不同，我们也需要设定它的环绕和过滤方式：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> GL_TEXTURE_MAG_FILTER<span class="token punctuation">,</span> GL_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> GL_TEXTURE_MIN_FILTER<span class="token punctuation">,</span> GL_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> GL_TEXTURE_WRAP_S<span class="token punctuation">,</span> GL_CLAMP_TO_EDGE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> GL_TEXTURE_WRAP_T<span class="token punctuation">,</span> GL_CLAMP_TO_EDGE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> GL_TEXTURE_WRAP_R<span class="token punctuation">,</span> GL_CLAMP_TO_EDGE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>不要被 GL_TEXTURE_WRAP_R 吓到，它仅仅是为纹理的 R 坐标设置了环绕方式，它对应的是纹理的第三个维度（和位置的 z 一样）。我们将环绕方式设置为 GL_CLAMP_TO_EDGE，这是因为正好处于两个面之间的纹理坐标可能不能击中一个面（由于一些硬件限制），所以通过使用 GL_CLAMP_TO_EDGE，OpenGL 将在我们对<mark>两个面之间采样</mark>的时候，永远返回它们的<mark>边界值</mark>。</p><p>在绘制使用立方体贴图的物体之前，我们要先激活对应的纹理单元，并绑定立方体贴图，这和普通的 2D 纹理没什么区别。</p><p>在片段着色器中，我们使用了一个不同类型的采样器，samplerCube，我们将使用 texture 函数使用它进行采样，但这次我们将使用一个 vec3 的方向向量而不是 vec2。使用立方体贴图的片段着色器会像是这样的：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>in vec3 textureDir<span class="token punctuation">;</span> <span class="token comment">// 代表 3D 纹理坐标的方向向量</span></pre></td></tr><tr><td data-num="2"></td><td><pre>uniform samplerCube cubemap<span class="token punctuation">;</span> <span class="token comment">// 立方体贴图的纹理采样器</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span>             </pre></td></tr><tr><td data-num="6"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>cubemap<span class="token punctuation">,</span> textureDir<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>看起来很棒，但为什么要用它呢？恰巧有一些很有意思的技术，使用立方体贴图来实现的话会简单多了。其中一个技术就是创建一个<mark>天空盒</mark> (Skybox)。</p><h3 id="天空盒"><a class="anchor" href="#天空盒">#</a> 天空盒</h3><p>天空盒是一个包含了整个场景的（大）立方体，它包含周围环境的 6 个图像，让玩家以为他处在一个比实际大得多的环境当中。游戏中使用天空盒的例子有群山、白云或星空。下面这张截图中展示的是星空的天空盒，它来自于『上古卷轴 3』：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/06/cubemaps_morrowind.jpg" alt="image"></p><p>你可能现在已经猜到了，立方体贴图能完美满足天空盒的需求：我们有一个 6 面的立方体，每个面都需要一个纹理。在上面的图片中，他们使用了夜空的几张图片，让玩家产生其位于广袤宇宙中的错觉，但实际上他只是在一个小小的盒子当中。</p><p>你可以在网上找到很多像这样的天空盒资源。比如说<span class="exturl" data-url="aHR0cDovL3d3dy5jdXN0b21tYXBtYWtlcnMub3JnL3NreWJveGVzLnBocA==">这个网站</span>就提供了很多天空盒。天空盒图像通常有以下的形式：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/06/cubemaps_skybox.png" alt="image"></p><p>如果你将这六个面折成一个立方体，你就会得到一个完全贴图的立方体，模拟一个巨大的场景。一些资源可能会提供了这样格式的天空盒，你必须手动提取六个面的图像，但在大部分情况下它们都是 6 张单独的纹理图像。</p><p>之后我们将在场景中使用这个（高质量的）天空盒。</p><h3 id="加载天空盒"><a class="anchor" href="#加载天空盒">#</a> 加载天空盒</h3><p>因为天空盒本身就是一个立方体贴图，加载天空盒和之前加载立方体贴图时并没有什么不同。为了加载天空盒，我们将使用下面的函数，它接受一个包含 6 个纹理路径的 vector：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">loadCubemap</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> faces<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> textureID<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">glGenTextures</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>textureID<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> textureID<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">int</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> nrChannels<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> faces<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>data <span class="token operator">=</span> <span class="token function">stbi_load</span><span class="token punctuation">(</span>faces<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>width<span class="token punctuation">,</span> <span class="token operator">&amp;</span>height<span class="token punctuation">,</span> <span class="token operator">&amp;</span>nrChannels<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token function">glTexImage2D</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP_POSITIVE_X <span class="token operator">+</span> i<span class="token punctuation">,</span> </pre></td></tr><tr><td data-num="14"></td><td><pre>                         <span class="token number">0</span><span class="token punctuation">,</span> GL_RGB<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_RGB<span class="token punctuation">,</span> GL_UNSIGNED_BYTE<span class="token punctuation">,</span> data</pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token function">stbi_image_free</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">else</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Cubemap texture failed to load at path: "</span> <span class="token operator">&lt;&lt;</span> faces<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token function">stbi_image_free</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> GL_TEXTURE_MIN_FILTER<span class="token punctuation">,</span> GL_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> GL_TEXTURE_MAG_FILTER<span class="token punctuation">,</span> GL_LINEAR<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> GL_TEXTURE_WRAP_S<span class="token punctuation">,</span> GL_CLAMP_TO_EDGE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> GL_TEXTURE_WRAP_T<span class="token punctuation">,</span> GL_CLAMP_TO_EDGE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> GL_TEXTURE_WRAP_R<span class="token punctuation">,</span> GL_CLAMP_TO_EDGE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token keyword">return</span> textureID<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>函数本身应该很熟悉了。它基本就是上一部分中立方体贴图的代码，只不过合并到了一个便于管理的函数中。</p><p>之后，在调用这个函数之前，我们需要将合适的纹理路径按照立方体贴图枚举指定的顺序加载到一个 vector 中。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">></span> faces</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token string">"right.jpg"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token string">"left.jpg"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token string">"top.jpg"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token string">"bottom.jpg"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token string">"front.jpg"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token string">"back.jpg"</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> cubemapTexture <span class="token operator">=</span> <span class="token function">loadCubemap</span><span class="token punctuation">(</span>faces<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>现在我们就将这个天空盒加载为一个立方体贴图了，它的 id 是 cubemapTexture。我们可以将它绑定到一个立方体中，替换掉用了很长时间的难看的纯色背景。</p><h3 id="显示天空盒"><a class="anchor" href="#显示天空盒">#</a> 显示天空盒</h3><p>由于天空盒是绘制在一个立方体上的，和其它物体一样，我们需要另一个 VAO、VBO 以及新的一组顶点。</p><p>用于贴图 3D 立方体的立方体贴图可以使用立方体的位置作为纹理坐标来采样。当立方体处于原点 (0, 0, 0) 时，它的每一个位置向量都是从原点出发的方向向量。这个方向向量正是获取立方体上特定位置的纹理值所需要的。正是因为这个，我们只需要提供位置向量而不用纹理坐标了。</p><p>要渲染天空盒的话，我们需要一组新的着色器，它们都不是很复杂。因为我们只有一个顶点属性，顶点着色器非常简单：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> in vec3 aPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>out vec3 TexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>uniform mat4 projection<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>uniform mat4 view<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    TexCoords <span class="token operator">=</span> aPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    gl_Position <span class="token operator">=</span> projection <span class="token operator">*</span> view <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>aPos<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>注意，顶点着色器中很有意思的部分是，我们将输入的位置向量作为输出给片段着色器的纹理坐标。片段着色器会将它作为输入来采样 samplerCube：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>out vec4 FragColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>in vec3 TexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>uniform samplerCube skybox<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#123;</span>    </pre></td></tr><tr><td data-num="10"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>skybox<span class="token punctuation">,</span> TexCoords<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>片段着色器非常直观。我们将顶点属性的位置向量作为纹理的方向向量，并使用它从立方体贴图中采样纹理值。</p><p>有了立方体贴图纹理，渲染天空盒现在就非常简单了，我们只需要绑定立方体贴图纹理，skybox 采样器就会自动填充上天空盒立方体贴图了。绘制天空盒时，我们需要将它变为场景中的<mark>第一个渲染的物体</mark>，并且禁用深度写入。这样子天空盒就会永远被绘制在其它物体的背后了。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glDepthMask</span><span class="token punctuation">(</span>GL_FALSE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>skyboxShader<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">//... 设置观察和投影矩阵</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>skyboxVAO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> cubemapTexture<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">glDrawArrays</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">glDepthMask</span><span class="token punctuation">(</span>GL_TRUE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">//... 绘制剩下的场景</span></pre></td></tr></table></figure><p>如果你运行一下的话你就会发现出现了一些问题。我们希望天空盒是以玩家为中心的，这样不论玩家移动了多远，天空盒都不会变近，让玩家产生周围环境非常大的印象。然而，当前的观察矩阵会旋转、缩放和位移来变换天空盒的所有位置，所以当玩家移动的时候，立方体贴图也会移动！我们希望移除观察矩阵中的位移部分，让移动不会影响天空盒的位置向量。</p><p>你可能还记得在基础光照小节中，我们通过取 4x4 矩阵左上角的 3x3 矩阵来<mark>移除</mark>变换矩阵的<mark>位移部分</mark>。我们可以将观察矩阵转换为 3x3 矩阵（移除位移），再将其转换回 4x4 矩阵，来达到类似的效果。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span>mat4 view <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">mat4</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">mat3</span><span class="token punctuation">(</span>camera<span class="token punctuation">.</span><span class="token function">GetViewMatrix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这将移除任何的位移，但保留旋转变换，让玩家仍然能够环顾场景。</p><p>有了天空盒，最终的效果就是一个看起来巨大的场景了。如果你在箱子周围转一转，你就能立刻感受到距离感，极大地提升了场景的真实度。最终的结果看起来是这样的：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/06/cubemaps_skybox_result.png" alt="image"></p><h3 id="优化"><a class="anchor" href="#优化">#</a> 优化</h3><p>目前我们是首先渲染天空盒，之后再渲染场景中的其它物体。这样子能够工作，但不是非常高效。如果我们先渲染天空盒，我们就会对屏幕上的每一个像素运行一遍片段着色器，即便只有一小部分的天空盒最终是可见的。可以使用<mark>提前深度测试</mark> (Early Depth Testing) 轻松丢弃掉的片段能够节省我们很多宝贵的带宽。</p><p>所以，我们将会<mark>最后渲染天空盒</mark>，以获得轻微的性能提升。这样子的话，深度缓冲就会填充满所有物体的深度值了，我们只需要在提前深度测试通过的地方渲染天空盒的片段就可以了，很大程度上减少了片段着色器的调用。问题是，天空盒只是一个 1x1x1 的立方体，它很可能会不通过大部分的深度测试，导致渲染失败。不用深度测试来进行渲染不是解决方案，因为天空盒将会复写场景中的其它物体。我们需要欺骗深度缓冲，让它认为天空盒有着最大的深度值 1.0，只要它前面有一个物体，深度测试就会失败。</p><p>在坐标系统小节中我们说过，<mark>透视除法</mark>是在顶点着色器运行之后执行的，将 gl_Position 的 xyz 坐标除以 w 分量。我们又从深度测试小节中知道，相除结果的 z 分量等于顶点的深度值。使用这些信息，我们可以将输出位置的 z 分量等于它的 w 分量，让 z 分量永远等于 1.0，这样子的话，当透视除法执行之后，z 分量会变为 w /w = 1.0。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    TexCoords <span class="token operator">=</span> aPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    vec4 pos <span class="token operator">=</span> projection <span class="token operator">*</span> view <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>aPos<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    gl_Position <span class="token operator">=</span> pos<span class="token punctuation">.</span>xyww<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>最终的标准化设备坐标将永远会有一个等于 1.0 的 z 值：最大的深度值。结果就是天空盒只会在没有可见物体的地方渲染了（只有这样才能通过深度测试，其它所有的东西都在天空盒前面）。</p><p>我们还要改变一下深度函数，将它从默认的<mark> GL_LESS</mark> 改为<mark> GL_LEQUAL</mark>。深度缓冲将会填充上天空盒的 1.0 值，所以我们需要保证天空盒在值小于或等于深度缓冲而不是小于时通过深度测试。</p><h3 id="环境映射"><a class="anchor" href="#环境映射">#</a> 环境映射</h3><p>我们现在将整个环境映射到了一个纹理对象上了，能利用这个信息的不仅仅只有天空盒。通过使用环境的立方体贴图，我们可以给物体反射和折射的属性。这样使用环境立方体贴图的技术叫做<mark>环境映射</mark> (Environment Mapping)，其中最流行的两个是<mark>反射</mark> (Reflection) 和<mark>折射</mark> (Refraction)。</p><h3 id="反射"><a class="anchor" href="#反射">#</a> 反射</h3><p>反射这个属性表现为物体（或物体的一部分）反射它周围环境，即根据观察者的视角，物体的颜色或多或少等于它的环境。镜子就是一个反射性物体：它会根据观察者的视角反射它周围的环境。</p><p>反射的原理并不难。下面这张图展示了我们如何计算反射向量，并如何使用这个向量来从立方体贴图中采样：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/06/cubemaps_reflection_theory.png" alt="image"></p><p>我们根据观察<mark>方向向量 I</mark> 和物体的<mark>法向量 N</mark>，来计算<mark>反射向量 R</mark>。我们可以使用 GLSL 内建的 reflect 函数来计算这个反射向量。最终的 R 向量将会作为索引 / 采样立方体贴图的方向向量，返回环境的颜色值。最终的结果是物体看起来反射了天空盒。</p><p>因为我们已经在场景中配置好天空盒了，创建反射效果并不会很难。我们将会改变箱子的片段着色器，让箱子有反射性：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>out vec4 FragColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>in vec3 Normal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>in vec3 Position<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>uniform vec3 cameraPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>uniform samplerCube skybox<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#123;</span>             </pre></td></tr><tr><td data-num="12"></td><td><pre>    vec3 I <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>Position <span class="token operator">-</span> cameraPos<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    vec3 R <span class="token operator">=</span> <span class="token function">reflect</span><span class="token punctuation">(</span>I<span class="token punctuation">,</span> <span class="token function">normalize</span><span class="token punctuation">(</span>Normal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span><span class="token function">texture</span><span class="token punctuation">(</span>skybox<span class="token punctuation">,</span> R<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>我们先计算了观察 / 摄像机方向向量 I，并使用它来计算反射向量 R，之后我们将使用 R 来从天空盒立方体贴图中采样。注意，我们现在又有了片段的插值 Normal 和 Position 变量，所以我们需要更新一下顶点着色器。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> in vec3 aPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> in vec3 aNormal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>out vec3 Normal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>out vec3 Position<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>uniform mat4 model<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>uniform mat4 view<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>uniform mat4 projection<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    Normal <span class="token operator">=</span> <span class="token function">mat3</span><span class="token punctuation">(</span><span class="token function">transpose</span><span class="token punctuation">(</span><span class="token function">inverse</span><span class="token punctuation">(</span>model<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> aNormal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    Position <span class="token operator">=</span> <span class="token function">vec3</span><span class="token punctuation">(</span>model <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>aPos<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    gl_Position <span class="token operator">=</span> projection <span class="token operator">*</span> view <span class="token operator">*</span> model <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>aPos<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>我们现在使用了一个法向量，所以我们将再次使用法线矩阵 (Normal Matrix) 来变换它们。Position 输出向量是一个世界空间的位置向量。顶点着色器的这个 Position 输出将用来在片段着色器内计算观察方向向量。</p><p>因为我们使用了法线，你还需要更新一下<mark>顶点数据</mark>，并更新属性指针。还要记得去设置 cameraPos 这个 uniform。</p><p>接下来，我们在渲染箱子之前先绑定立方体贴图纹理：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>cubeVAO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_CUBE_MAP<span class="token punctuation">,</span> skyboxTexture<span class="token punctuation">)</span><span class="token punctuation">;</span>          </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glDrawArrays</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>编译并运行代码，你将会得到一个像是镜子一样的箱子。周围的天空盒被完美地反射在箱子上。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/06/cubemaps_reflection.png" alt="image"></p><p>当反射应用到一整个物体上（像是箱子）时，这个物体看起来就像是钢或者铬这样的高反射性材质。如果我们加载模型加载小节中的纳米装模型，我们会得到一种整个套装都是使用铬做成的效果：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/06/cubemaps_reflection_nanosuit.png" alt="image"></p><p>这看起来非常棒，但在现实中大部分的模型都不具有<mark>完全反射性</mark>。我们可以引入<mark>反射贴图</mark> (Reflection Map)，来给模型更多的细节。与漫反射和镜面光贴图一样，反射贴图也是可以采样的纹理图像，它决定这片段的反射性。通过使用反射贴图，我们可以知道模型的哪些部分该以什么强度显示反射。在本节的练习中，将由你来为我们之前创建的模型加载器中引入反射贴图，显著提升纳米装模型的细节。</p><h3 id="折射"><a class="anchor" href="#折射">#</a> 折射</h3><p>环境映射的另一种形式是折射，它和反射很相似。折射是光线由于传播介质的改变而产生的方向变化。在常见的类水表面上所产生的现象就是折射，光线不是直直地传播，而是弯曲了一点。将你的半只胳膊伸进水里，观察出来的就是这种效果。</p><p>折射是通过<mark>斯涅尔定律</mark> (Snell’s Law) 来描述的，使用环境贴图的话看起来像是这样：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/06/cubemaps_refraction_theory.png" alt="image"></p><p>同样，我们有一个<mark>观察向量 I</mark>，一个<mark>法向量 N</mark>，而这次是<mark>折射向量 R</mark>。可以看到，观察向量的方向轻微弯曲了。弯折后的向量 R 将会用来从立方体贴图中采样。</p><p>折射可以使用 GLSL 的内建 refract 函数来轻松实现，它需要一个法向量、一个观察方向和两个材质之间的折射率 (Refractive Index)。</p><p>折射率决定了材质中光线弯曲的程度，每个材质都有自己的折射率。一些最常见的折射率可以在下表中找到：</p><table><thead><tr><th>材质</th><th>折射率</th></tr></thead><tbody><tr><td>空气</td><td>1.00</td></tr><tr><td>水</td><td>1.33</td></tr><tr><td>冰</td><td>1.309</td></tr><tr><td>玻璃</td><td>1.52</td></tr><tr><td>钻石</td><td>2.42</td></tr></tbody></table><p>我们使用这些折射率来计算光传播的两种材质间的比值。在我们的例子中，光线 / 视线从空气进入玻璃（如果我们假设箱子是玻璃制的），所以比值为 1.00/1.52=0.658。</p><p>我们已经绑定了立方体贴图，提供了顶点数据和法线，并设置了摄像机位置的 uniform。唯一要修改的就是片段着色器：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span>             </pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">float</span> ratio <span class="token operator">=</span> <span class="token number">1.00</span> <span class="token operator">/</span> <span class="token number">1.52</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    vec3 I <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>Position <span class="token operator">-</span> cameraPos<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    vec3 R <span class="token operator">=</span> <span class="token function">refract</span><span class="token punctuation">(</span>I<span class="token punctuation">,</span> <span class="token function">normalize</span><span class="token punctuation">(</span>Normal<span class="token punctuation">)</span><span class="token punctuation">,</span> ratio<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span><span class="token function">texture</span><span class="token punctuation">(</span>skybox<span class="token punctuation">,</span> R<span class="token punctuation">)</span><span class="token punctuation">.</span>rgb<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>通过改变折射率，你可以创建完全不同的视觉效果。编译程序并运行，但结果并不是很有趣，因为我们只使用了一个简单的箱子，它不太能显示折射的效果，现在看起来只是有点像一个放大镜。对纳米装使用相同的着色器却能够展现出了我们期待的效果：一个类玻璃的物体。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/06/cubemaps_refraction.png" alt="image"></p><p>你可以想象出有了光照、反射、折射和顶点移动的正确组合，你可以创建出非常漂亮的水。注意，如果要想获得物理上精确的结果，我们还需要在光线离开物体的时候再次折射，现在我们使用的只是<mark>单面折射</mark> (Single-side Refraction)，但它对大部分场合都是没问题的。</p><h3 id="动态环境贴图"><a class="anchor" href="#动态环境贴图">#</a> 动态环境贴图</h3><p>现在我们使用的都是静态图像的组合来作为天空盒，看起来很不错，但它没有在场景中包括可移动的物体。我们一直都没有注意到这一点，因为我们只使用了一个物体。如果我们有一个镜子一样的物体，周围还有多个物体，镜子中可见的只有天空盒，看起来就像它是场景中唯一一个物体一样。</p><p>通过使用帧缓冲，我们能够为物体的 6 个不同角度创建出场景的纹理，并在每个渲染迭代中将它们储存到一个立方体贴图中。之后我们就可以使用这个（动态生成的）立方体贴图来创建出更真实的，包含其它物体的，反射和折射表面了。这就叫做<mark>动态环境映射</mark> (Dynamic Environment Mapping)，因为我们动态创建了物体周围的立方体贴图，并将其用作环境贴图。</p><p>虽然它看起来很棒，但它有一个很大的缺点：我们需要为使用环境贴图的物体渲染场景 6 次，这是对程序是非常大的性能开销。现代的程序通常会尽可能使用天空盒，并在可能的时候使用预编译的立方体贴图，只要它们能产生一点动态环境贴图的效果。虽然动态环境贴图是一个很棒的技术，但是要想在不降低性能的情况下让它工作还是需要非常多的技巧的。</p><h2 id="高级数据"><a class="anchor" href="#高级数据">#</a> 高级数据</h2><p>我们在 OpenGL 中大量使用缓冲来储存数据已经有很长时间了。操作缓冲其实还有更有意思的方式，而且使用纹理将大量数据传入着色器也有更有趣的方法。这一节中，我们将讨论一些更有意思的缓冲函数，以及我们该如何使用纹理对象来储存大量的数据（纹理的部分还没有完成）。</p><p>OpenGL 中的缓冲只是一个<mark>管理特定内存块的对象</mark>，没有其它更多的功能了。在我们将它绑定到一个<mark>缓冲目标</mark> (Buffer Target) 时，我们才赋予了其意义。当我们绑定一个缓冲到 GL_ARRAY_BUFFER 时，它就是一个顶点数组缓冲，但我们也可以很容易地将其绑定到 GL_ELEMENT_ARRAY_BUFFER。OpenGL 内部会为每个目标储存一个缓冲，并且会根据目标的不同，以不同的方式处理缓冲。</p><p>到目前为止，我们一直是调用 glBufferData 函数来填充缓冲对象所管理的内存，这个函数会分配一块内存，并将数据添加到这块内存中。如果我们将它的 data 参数设置为 NULL，那么这个函数将只会分配内存，但不进行填充。这在我们需要预留 (Reserve) 特定大小的内存，之后回到这个缓冲一点一点填充的时候会很有用。</p><p>除了使用一次函数调用填充整个缓冲之外，我们也可以使用 glBufferSubData，填充缓冲的特定区域。这个函数需要一个缓冲目标、一个偏移量、数据的大小和数据本身作为它的参数。这个函数不同的地方在于，我们可以<mark>提供一个偏移量</mark>，指定从何处开始填充这个缓冲。这能够让我们插入或者更新缓冲内存的某一部分。要注意的是，缓冲需要有足够的已分配内存，所以对一个缓冲调用 glBufferSubData 之前必须要先调用 glBufferData。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glBufferSubData</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 范围： [24, 24 + sizeof (data)]</span></pre></td></tr></table></figure><p>将数据导入缓冲的另外一种方法是，请求缓冲内存的指针，直接将数据复制到缓冲当中。通过调用 glMapBuffer 函数，OpenGL 会返回当前绑定缓冲的内存指针，供我们操作：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> data<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.35f</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 获取指针</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">void</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token function">glMapBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> GL_WRITE_ONLY<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// 复制数据到内存</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token function">memcpy</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// 记得告诉 OpenGL 我们不再需要这个指针了</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token function">glUnmapBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>当我们使用 glUnmapBuffer 函数，告诉 OpenGL 我们已经完成指针操作之后，OpenGL 就会知道你已经完成了。在<mark>解除映射</mark> (Unmapping) 之后，指针将会<mark>不再可用</mark>，并且如果 OpenGL 能够成功将您的数据映射到缓冲中，这个函数将会返回 GL_TRUE。</p><p>如果要直接映射数据到缓冲，而不事先将其存储到临时内存中，glMapBuffer 这个函数会很有用。比如说，你可以从文件中读取数据，并直接将它们复制到缓冲内存中。</p><h3 id="分批顶点属性"><a class="anchor" href="#分批顶点属性">#</a> 分批顶点属性</h3><p>通过使用 glVertexAttribPointer，我们能够指定顶点数组缓冲内容的属性布局。在顶点数组缓冲中，我们对属性进行了<mark>交错 (Interleave) 处理</mark>，也就是说，我们将每一个顶点的位置、方向和 / 或纹理坐标紧密放置在一起。既然我们现在已经对缓冲有了更多的了解，我们可以采取另一种方式。</p><p>我们可以做的是，将每一种属性类型的向量数据打包 (Batch) 为一个大的区块，而不是对它们进行交错储存。与交错布局<mark> 123123123123</mark> 不同，我们将采用分批 (Batched) 的方式<mark> 111122223333</mark>。</p><p>当从文件中加载顶点数据的时候，你通常获取到的是一个位置数组、一个法线数组和 / 或一个纹理坐标数组。我们需要花点力气才能将这些数组转化为一个大的交错数据数组。使用分批的方式会是更简单的解决方案，我们可以很容易使用 glBufferSubData 函数实现：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> positions<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">float</span> normals<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">float</span> tex<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 填充缓冲</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">glBufferSubData</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>positions<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>positions<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">glBufferSubData</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>positions<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>normals<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>normals<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">glBufferSubData</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>positions<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>normals<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>tex<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>tex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这样子我们就能直接将属性数组作为一个整体传递给缓冲，而不需要事先处理它们了。我们仍可以将它们合并为一个大的数组，再使用 glBufferData 来填充缓冲，但对于这种工作，使用 glBufferSubData 会更合适一点。</p><p>我们还需要更新顶点属性指针来反映这些改变：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>positions<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>positions<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>normals<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>注意 stride 参数等于顶点属性的大小，因为下一个顶点属性向量能在 3 个（或 2 个）分量之后找到。</p><p>这给了我们设置顶点属性的另一种方法。使用哪种方法都不会对 OpenGL 有什么立刻的好处，它只是设置顶点属性的一种更整洁的方式。具体使用的方法将完全取决于你的喜好与程序类型。</p><h3 id="复制缓冲"><a class="anchor" href="#复制缓冲">#</a> 复制缓冲</h3><p>当你的缓冲已经填充好数据之后，你可能会想与其它的缓冲共享其中的数据，或者想要将缓冲的内容复制到另一个缓冲当中。glCopyBufferSubData 能够让我们相对容易地从<mark>一个缓冲中复制数据到另一个缓冲中</mark>。这个函数的原型如下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">glCopyBufferSubData</span><span class="token punctuation">(</span>GLenum readtarget<span class="token punctuation">,</span> GLenum writetarget<span class="token punctuation">,</span> GLintptr readoffset<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="2"></td><td><pre>                         GLintptr writeoffset<span class="token punctuation">,</span> GLsizeiptr size<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>readtarget 和 writetarget 参数需要填入<mark>复制源</mark>和<mark>复制目标</mark>的缓冲目标。比如说，我们可以将 VERTEX_ARRAY_BUFFER 缓冲复制到 VERTEX_ELEMENT_ARRAY_BUFFER 缓冲，分别将这些缓冲目标设置为读和写的目标。当前绑定到这些缓冲目标的缓冲将会被影响到。</p><p>但如果我们想读写数据的两个不同缓冲都为顶点数组缓冲该怎么办呢？我们不能同时将两个缓冲绑定到同一个缓冲目标上。正是出于这个原因，OpenGL 提供给我们另外两个缓冲目标，叫做 GL_COPY_READ_BUFFER 和 GL_COPY_WRITE_BUFFER。我们接下来就可以将需要的缓冲绑定到这两个缓冲目标上，并将这两个目标作为 readtarget 和 writetarget 参数。</p><p>接下来 glCopyBufferSubData 会从 readtarget 中读取 size 大小的数据，并将其写入 writetarget 缓冲的 writeoffset 偏移量处。下面这个例子展示了如何复制两个顶点数组缓冲：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> vertexData<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_COPY_READ_BUFFER<span class="token punctuation">,</span> vbo1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_COPY_WRITE_BUFFER<span class="token punctuation">,</span> vbo2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glCopyBufferSubData</span><span class="token punctuation">(</span>GL_COPY_READ_BUFFER<span class="token punctuation">,</span> GL_COPY_WRITE_BUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>vertexData<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>我们也可以只将 writetarget 缓冲绑定为新的缓冲目标类型之一：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> vertexData<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> vbo1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_COPY_WRITE_BUFFER<span class="token punctuation">,</span> vbo2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glCopyBufferSubData</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> GL_COPY_WRITE_BUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>vertexData<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>有了这些关于如何操作缓冲的额外知识，我们已经能够以更有意思的方式使用它们了。当你越深入 OpenGL 时，这些新的缓冲方法将会变得更加有用。在下一节中，在我们讨论 Uniform 缓冲对象 (Uniform Buffer Object) 时，我们将会充分利用 glBufferSubData。</p><h2 id="高级glsl"><a class="anchor" href="#高级glsl">#</a> 高级 GLSL</h2><p>这一小节并不会向你展示非常先进非常酷的新特性，也不会对场景的视觉质量有显著的提高。但是，这一节会或多或少涉及 GLSL 的一些有趣的地方以及一些很棒的技巧，它们可能在今后会帮助到你。简单来说，它们就是在组合使用 OpenGL 和 GLSL 创建程序时的一些最好要知道的东西，和一些会让你生活更加轻松的特性。</p><p>我们将会讨论一些有趣的<mark>内建变量</mark> (Built-in Variable)，管理<mark>着色器</mark><strong>输入</strong>和<strong>输出</strong>的新方式以及一个叫做<mark> Uniform 缓冲对象</mark> (Uniform Buffer Object) 的有用工具。</p><h3 id="glsl的内建变量"><a class="anchor" href="#glsl的内建变量">#</a> GLSL 的内建变量</h3><p>着色器都是最简化的，如果需要当前着色器以外地方的数据的话，我们必须要将数据传进来。我们已经学会使用顶点属性、uniform 和采样器来完成这一任务了。然而，除此之外，GLSL 还定义了另外几个以 gl_为前缀的变量，它们能提供给我们更多的方式来读取 / 写入数据。我们已经在前面教程中接触过其中的两个了：顶点着色器的<mark>输出向量 gl_Position</mark>，和<mark>片段着色器的 gl_FragCoord</mark>。</p><p>我们将会讨论几个有趣的 GLSL 内建输入和输出变量，并会解释它们能够怎样帮助你。注意，我们将不会讨论 GLSL 中存在的所有内建变量，如果你想知道所有的内建变量的话，请查看 OpenGL 的 wiki。</p><h3 id="顶点着色器变量"><a class="anchor" href="#顶点着色器变量">#</a> 顶点着色器变量</h3><p>我们已经见过 gl_Position 了，它是顶点着色器的裁剪空间输出位置向量。如果你想在屏幕上显示任何东西，在顶点着色器中设置 gl_Position 是必须的步骤。这已经是它的全部功能了。</p><h4 id="gl_pointsize设置图原大小"><a class="anchor" href="#gl_pointsize设置图原大小">#</a> gl_PointSize（设置图原大小）</h4><p>我们能够选用的其中一个图元是 GL_POINTS，如果使用它的话，每一个顶点都是一个图元，都会被渲染为一个点。我们可以通过 OpenGL 的 glPointSize 函数来<mark>设置</mark>渲染出来的<mark>点的大小</mark>，但我们也可以在顶点着色器中修改这个值。</p><p>GLSL 定义了一个叫做 gl_PointSize 输出变量，它是一个 float 变量，你可以使用它来设置点的宽高（像素）。在顶点着色器中修改点的大小的话，你就能对每个顶点设置不同的值了。</p><p>在顶点着色器中修改点大小的功能默认是禁用的，如果你需要启用它的话，你需要启用 OpenGL 的</p><h4 id="gl_program_point_size"><a class="anchor" href="#gl_program_point_size">#</a> GL_PROGRAM_POINT_SIZE：</h4><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glEnable</span><span class="token punctuation">(</span>GL_PROGRAM_POINT_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>一个简单的例子就是将点的大小设置为裁剪空间位置的 z 值，也就是顶点距观察者的距离。点的大小会随着观察者距顶点距离变远而增大。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    gl_Position <span class="token operator">=</span> projection <span class="token operator">*</span> view <span class="token operator">*</span> model <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>aPos<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num="4"></td><td><pre>    gl_PointSize <span class="token operator">=</span> gl_Position<span class="token punctuation">.</span>z<span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>结果就是，当我们远离这些点的时候，它们会变得更大：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/08/advanced_glsl_pointsize.png" alt="image"></p><h4 id="gl_vertexid"><a class="anchor" href="#gl_vertexid">#</a> gl_VertexID</h4><p>gl_Position 和 gl_PointSize 都是输出变量，因为它们的值是作为顶点着色器的输出被读取的。我们可以对它们进行写入，来改变结果。顶点着色器还为我们提供了一个有趣的输入变量，我们只能对它进行<mark>读取</mark>，它叫做 gl_VertexID。</p><p>整型变量 gl_VertexID 储存了<mark>正在绘制<strong>顶点</strong>的当前 ID</mark>。当（使用 glDrawElements）进行索引渲染的时候，这个变量会存储正在绘制顶点的当前索引。当（使用 glDrawArrays）不使用索引进行绘制的时候，这个变量会储存从渲染调用开始的已处理顶点数量。</p><p>虽然现在它没有什么具体的用途，但知道我们能够访问这个信息总是好的。</p><h3 id="片段着色器变量"><a class="anchor" href="#片段着色器变量">#</a> 片段着色器变量</h3><p>在片段着色器中，我们也能访问到一些有趣的变量。GLSL 提供给我们两个有趣的输入变量：<mark>gl_FragCoord</mark> 和<mark> gl_FrontFacing</mark>。</p><h4 id="gl_fragcoord设置屏幕渲染范围"><a class="anchor" href="#gl_fragcoord设置屏幕渲染范围">#</a> gl_FragCoord (设置屏幕渲染范围)</h4><p>在讨论深度测试的时候，我们已经见过 gl_FragCoord 很多次了，因为 gl_FragCoord 的 z 分量等于对应片段的深度值。然而，我们也能使用它的 x 和 y 分量来实现一些有趣的效果。</p><p>gl_FragCoord 的 x 和 y 分量是片段的窗口空间 (Window-space) 坐标，其原点为窗口的左下角。我们已经使用 glViewport 设定了一个 800x600 的窗口了，所以片段窗口空间坐标的 x 分量将在 0 到 800 之间，y 分量在 0 到 600 之间。</p><p>通过利用片段着色器，我们可以根据片段的窗口坐标，计算出不同的颜色。gl_FragCoord 的一个常见用处是用于对比不同片段计算的视觉输出效果，这在技术演示中可以经常看到。比如说，我们能够将屏幕分成两部分，在窗口的左侧渲染一种输出，在窗口的右侧渲染另一种输出。下面这个例子片段着色器会根据窗口坐标输出不同的颜色：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span>             </pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>gl_FragCoord<span class="token punctuation">.</span>x <span class="token operator">&lt;</span> <span class="token number">400</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">else</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>因为窗口的宽度是 800。当一个像素的 x 坐标小于 400 时，它一定在窗口的左侧，所以我们给它一个不同的颜色。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/08/advanced_glsl_fragcoord.png" alt="image"></p><h4 id="gl_frontfacing判断正反面"><a class="anchor" href="#gl_frontfacing判断正反面">#</a> gl_FrontFacing (判断正反面)</h4><p>片段着色器另外一个很有意思的输入变量是 gl_FrontFacing。在面剔除教程中，我们提到 OpenGL 能够根据顶点的环绕顺序来决定一个面是正向还是背向面。如果我们不（启用 GL_FACE_CULL 来）使用面剔除，那么 gl_FrontFacing 将会告诉我们当前片段是属于正向面的一部分还是背向面的一部分。举例来说，我们能够对正向面计算出不同的颜色。</p><p>gl_FrontFacing 变量是一个 bool，如果当前片段是正向面的一部分那么就是 true，否则就是 false。比如说，我们可以这样子创建一个立方体，在内部和外部使用不同的纹理：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>out vec4 FragColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>in vec2 TexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>uniform sampler2D frontTexture<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>uniform sampler2D backTexture<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span>             </pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">if</span><span class="token punctuation">(</span>gl_FrontFacing<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        FragColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>frontTexture<span class="token punctuation">,</span> TexCoords<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">else</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        FragColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>backTexture<span class="token punctuation">,</span> TexCoords<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>如果我们往箱子里面看，就能看到使用的是不同的纹理。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/08/advanced_glsl_frontfacing.png" alt="image"></p><p>注意，如果你开启了<mark>面剔除</mark>，你就看不到箱子内部的面了，所以现在再使用 gl_FrontFacing 就没有意义了。</p><h4 id="gl_fragdepth修改片段深度值"><a class="anchor" href="#gl_fragdepth修改片段深度值">#</a> gl_FragDepth（修改片段深度值）</h4><p>输入变量 gl_FragCoord 能让我们读取当前片段的窗口空间坐标，并获取它的深度值，但是它是一个<mark>只读</mark> (Read-only) 变量。我们不能修改片段的窗口空间坐标，但实际上<mark>修改片段的深度值</mark>还是可能的。GLSL 提供给我们一个叫做 gl_FragDepth 的输出变量，我们可以使用它来在着色器内设置片段的深度值。</p><p>要想设置深度值，我们直接写入一个 0.0 到 1.0 之间的 float 值到输出变量就可以了：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>gl_FragDepth <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span> <span class="token comment">// 这个片段现在的深度值为 0.0</span></pre></td></tr></table></figure><p>如果着色器没有写入值到 gl_FragDepth，它会自动取用 gl_FragCoord.z 的值。</p><p>然而，由我们自己设置深度值有一个很大的缺点，只要我们在片段着色器中对 gl_FragDepth 进行写入，OpenGL 就会（像深度测试小节中讨论的那样）<mark>禁用所有的提前深度测试</mark> (Early Depth Testing)。它被禁用的原因是，OpenGL 无法在片段着色器运行之前得知片段将拥有的深度值，因为片段着色器可能会完全修改这个深度值。</p><p>在写入 gl_FragDepth 时，你就需要考虑到它所带来的性能影响。然而，从 OpenGL 4.2 起，我们仍可以对两者进行一定的调和，在片段着色器的<mark>顶部</mark>使用<mark>深度条件</mark> (Depth Condition) 重新声明 gl_FragDepth 变量：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>depth_<span class="token operator">&lt;</span>condition<span class="token operator">></span><span class="token punctuation">)</span> out <span class="token keyword">float</span> gl_FragDepth<span class="token punctuation">;</span></pre></td></tr></table></figure><p>condition 可以为下面的值：</p><table><thead><tr><th>条件</th><th>描述</th></tr></thead><tbody><tr><td>any</td><td>默认值。提前深度测试是禁用的，你会损失很多性能</td></tr><tr><td>greater</td><td>你只能让深度值比 gl_FragCoord.z 更大</td></tr><tr><td>less</td><td>你只能让深度值比 gl_FragCoord.z 更小</td></tr><tr><td>unchanged</td><td>如果你要写入 gl_FragDepth，你将只能写入 gl_FragCoord.z 的值</td></tr></tbody></table><p>通过将深度条件设置为 greater 或者 less，OpenGL 就能假设你只会写入比当前片段深度值更大或者更小的值了。这样子的话，当深度值比片段的深度值要小的时候，OpenGL 仍是能够进行提前深度测试的。</p><p>下面这个例子中，我们对片段的深度值进行了递增，但仍然也保留了一些提前深度测试：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">420</span> core </span><span class="token comment">// 注意 GLSL 的版本！</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>out vec4 FragColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>depth_greater<span class="token punctuation">)</span> out <span class="token keyword">float</span> gl_FragDepth<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span>             </pre></td></tr><tr><td data-num="7"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    gl_FragDepth <span class="token operator">=</span> gl_FragCoord<span class="token punctuation">.</span>z <span class="token operator">+</span> <span class="token number">0.1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><blockquote><p>注意这个特性只在 OpenGL 4.2 版本或以上才提供。</p></blockquote><h3 id="接口块"><a class="anchor" href="#接口块">#</a> 接口块</h3><p>到目前为止，每当我们希望从顶点着色器向片段着色器发送数据时，我们都声明了几个对应的输入 / 输出变量。将它们一个一个声明是着色器间发送数据最简单的方式了，但当程序变得更大时，你希望发送的可能就不只是几个变量了，它还可能包括数组和结构体。</p><p>为了帮助我们管理这些变量，GLSL 为我们提供了一个叫做<mark>接口块</mark> (Interface Block) 的东西，来方便我们组合这些变量。接口块的声明和 struct 的声明有点相像，不同的是，现在根据它是一个输入还是输出块 (Block)，使用 in 或 out 关键字来定义的。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> in vec3 aPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> in vec2 aTexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>uniform mat4 model<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>uniform mat4 view<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>uniform mat4 projection<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>out VS_OUT</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    vec2 TexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span> vs_out<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    gl_Position <span class="token operator">=</span> projection <span class="token operator">*</span> view <span class="token operator">*</span> model <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>aPos<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num="17"></td><td><pre>    vs_out<span class="token punctuation">.</span>TexCoords <span class="token operator">=</span> aTexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这次我们声明了一个叫做 vs_out 的接口块，它打包了我们希望发送到下一个着色器中的所有输出变量。这只是一个很简单的例子，但你可以想象一下，它能够帮助你管理着色器的输入和输出。当我们希望将着色器的输入或输出打包为数组时，它也会非常有用，我们将在下一节讨论几何着色器 (Geometry Shader) 时见到。</p><p>之后，我们还需要在下一个着色器，即片段着色器，中定义一个输入接口块。块名 (Block Name) 应该是和着色器中一样的（VS_OUT），但实例名 (Instance Name)（顶点着色器中用的是 vs_out）可以是随意的，但要避免使用误导性的名称，比如对实际上包含输入变量的接口块命名为 vs_out。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>out vec4 FragColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>in VS_OUT</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    vec2 TexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span> fs_in<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>uniform sampler2D texture<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#123;</span>             </pre></td></tr><tr><td data-num="13"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>texture<span class="token punctuation">,</span> fs_in<span class="token punctuation">.</span>TexCoords<span class="token punctuation">)</span><span class="token punctuation">;</span>   </pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>只要两个接口块的名字一样，它们对应的输入和输出将会匹配起来。这是帮助你管理代码的又一个有用特性，它在几何着色器这样穿插特定着色器阶段的场景下会很有用。</p><h3 id="uniform缓冲对象"><a class="anchor" href="#uniform缓冲对象">#</a> Uniform 缓冲对象</h3><p>我们已经使用 OpenGL 很长时间了，学会了一些很酷的技巧，但也遇到了一些很麻烦的地方。比如说，当使用多于一个的着色器时，尽管大部分的 uniform 变量都是相同的，我们还是需要不断地设置它们，所以为什么要这么麻烦地重复设置它们呢？</p><p>OpenGL 为我们提供了一个叫做<mark> Uniform 缓冲对象</mark> (Uniform Buffer Object) 的工具，它允许我们<mark>定义一系列</mark>在<mark>多个着色器中相同的全局 Uniform 变量</mark>。当使用 Uniform 缓冲对象的时候，我们只需要设置相关的 uniform 一次。当然，我们仍需要手动设置每个着色器中不同的 uniform。并且创建和配置 Uniform 缓冲对象会有一点繁琐。</p><p>因为 Uniform 缓冲对象仍是一个缓冲，我们可以使用 glGenBuffers 来创建它，将它绑定到 GL_UNIFORM_BUFFER 缓冲目标，并将所有相关的 uniform 数据存入缓冲。在 Uniform 缓冲对象中储存数据是有一些规则的，我们将会在之后讨论它。首先，我们将使用一个简单的顶点着色器，将 projection 和 view 矩阵存储到所谓的 Uniform 块 (Uniform Block) 中：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> in vec3 aPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>std140<span class="token punctuation">)</span> uniform Matrices</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    mat4 projection<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    mat4 view<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>uniform mat4 model<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    gl_Position <span class="token operator">=</span> projection <span class="token operator">*</span> view <span class="token operator">*</span> model <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>aPos<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在我们大多数的例子中，我们都会在每个渲染迭代中，对每个着色器设置 projection 和 view Uniform 矩阵。这是利用 Uniform 缓冲对象的一个非常完美的例子，因为现在我们只需要存储这些矩阵一次就可以了。</p><p>这里，我们声明了一个叫做 Matrices 的 Uniform 块，它储存了两个 4x4 矩阵。Uniform 块中的变量<mark>可以直接访问</mark>，不需要加块名作为前缀。接下来，我们在 OpenGL 代码中将这些矩阵值存入缓冲中，每个声明了这个 Uniform 块的着色器都能够访问这些矩阵。</p><p>你现在可能会在想 layout (std140) 这个语句是什么意思。它的意思是说，当前定义的 Uniform 块对它的内容使用一个特定的内存布局。这个语句设置了 Uniform 块布局 (Uniform Block Layout)。</p><h3 id="uniform块布局"><a class="anchor" href="#uniform块布局">#</a> Uniform 块布局</h3><p>Uniform 块的内容是储存在一个缓冲对象中的，它实际上只是一块预留内存。因为这块内存并不会保存它具体保存的是什么类型的数据，我们还需要告诉 OpenGL 内存的哪一部分对应着着色器中的哪一个 uniform 变量。</p><p>假设着色器中有以下的这个 Uniform 块：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>std140<span class="token punctuation">)</span> uniform ExampleBlock</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">float</span> value<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    vec3  vector<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    mat4  matrix<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">float</span> values<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">bool</span>  boolean<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">int</span>   integer<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>我们需要知道的是每个变量的大小（字节）和（从块起始位置的）偏移量，来让我们能够按顺序将它们放进缓冲中。每个元素的大小都是在 OpenGL 中有清楚地声明的，而且直接对应 C++ 数据类型，其中向量和矩阵都是大的 float 数组。OpenGL 没有声明的是这些变量间的间距 (Spacing)。这允许硬件能够在它认为合适的位置放置变量。比如说，一些硬件可能会将一个 vec3 放置在 float 边上。不是所有的硬件都能这样处理，可能会在附加这个 float 之前，先将 vec3 填充 (Pad) 为一个 4 个 float 的数组。这个特性本身很棒，但是会对我们造成麻烦。</p><p>默认情况下，GLSL 会使用一个叫做<mark>共享 (Shared) 布局的 Uniform 内存布局</mark>，共享是因为一旦硬件定义了偏移量，它们在多个程序中是共享并一致的。使用共享布局时，GLSL 是可以为了优化而对 uniform 变量的位置进行变动的，只要变量的顺序保持不变。因为我们<mark>无法知道</mark>每个 uniform 变量的<mark>偏移量</mark>，我们也就不知道如何准确地填充我们的 Uniform 缓冲了。我们能够使用像是 glGetUniformIndices 这样的函数来查询这个信息，但这超出本节的范围了。</p><p>虽然共享布局给了我们很多节省空间的优化，但是我们需要查询每个 uniform 变量的偏移量，这会产生非常多的工作量。通常的做法是，不使用共享布局，而是使用<mark> std140 布局</mark>。std140 布局声明了每个变量的偏移量都是由一系列规则所决定的，这显式地声明了每个变量类型的内存布局。由于这是显式提及的，我们可以<mark>手动计算</mark>出每个变量的偏移量。</p><p>每个变量都有一个<mark>基准对齐量</mark> (Base Alignment)，它等于一个变量在 Uniform 块中所占据的空间（包括填充量 (Padding)），这个基准对齐量是使用 std140 布局的规则计算出来的。接下来，对每个变量，我们再计算它的对齐偏移量 (Aligned Offset)，它是一个变量从块起始位置的字节偏移量。一个变量的对齐字节偏移量必须等于基准对齐量的倍数。</p><p>布局规则的原文可以在 OpenGL 的 Uniform 缓冲规范<span class="exturl" data-url="aHR0cDovL3d3dy5vcGVuZ2wub3JnL3JlZ2lzdHJ5L3NwZWNzL0FSQi91bmlmb3JtX2J1ZmZlcl9vYmplY3QudHh0">这里找到</span>，但我们将会在下面列出最常见的规则。GLSL 中的每个变量，比如说 int、float 和 bool，都被定义为 4 字节量。每 4 个字节将会用一个 N 来表示。</p><table><thead><tr><th>类型</th><th>布局规则</th></tr></thead><tbody><tr><td>标量，比如 int 和 bool</td><td>每个标量的基准对齐量为 N。</td></tr><tr><td>向量</td><td>2N 或者 4N。这意味着 vec3 的基准对齐量为 4N。</td></tr><tr><td>标量或向量的数组</td><td>每个元素的基准对齐量与 vec4 的相同。</td></tr><tr><td>矩阵</td><td>储存为列向量的数组，每个向量的基准对齐量与 vec4 的相同。</td></tr><tr><td>结构体</td><td>等于所有元素根据规则计算后的大小，但会填充到 vec4 大小的倍数。</td></tr></tbody></table><p>和 OpenGL 大多数的规范一样，使用例子就能更容易地理解。我们会使用之前引入的那个叫做 ExampleBlock 的 Uniform 块，并使用 std140 布局计算出每个成员的对齐偏移量：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>std140<span class="token punctuation">)</span> uniform ExampleBlock</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>                     <span class="token comment">// 基准对齐量       // 对齐偏移量</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">float</span> value<span class="token punctuation">;</span>     <span class="token comment">// 4               // 0 </span></pre></td></tr><tr><td data-num="5"></td><td><pre>    vec3 vector<span class="token punctuation">;</span>     <span class="token comment">// 16              // 16  (必须是 16 的倍数，所以 4->16)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    mat4 matrix<span class="token punctuation">;</span>     <span class="token comment">// 16              // 32  (列 0)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                     <span class="token comment">// 16              // 48  (列 1)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                     <span class="token comment">// 16              // 64  (列 2)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                     <span class="token comment">// 16              // 80  (列 3)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">float</span> values<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 16              // 96  (values[0])</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                     <span class="token comment">// 16              // 112 (values[1])</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                     <span class="token comment">// 16              // 128 (values[2])</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">bool</span> boolean<span class="token punctuation">;</span>    <span class="token comment">// 4               // 144</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">int</span> integer<span class="token punctuation">;</span>     <span class="token comment">// 4               // 148</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>作为练习，尝试去自己计算一下偏移量，并和表格进行对比。使用计算后的偏移量值，根据 std140 布局的规则，我们就能使用像是 glBufferSubData 的函数将变量数据按照偏移量填充进缓冲中了。虽然 std140 布局不是最高效的布局，但它保证了内存布局在每个声明了这个 Uniform 块的程序中是一致的。</p><p>通过在 Uniform 块定义之前添加 layout (std140) 语句，我们告诉 OpenGL 这个 Uniform 块使用的是 std140 布局。除此之外还可以选择两个布局，但它们都需要我们在填充缓冲之前先查询每个偏移量。我们已经见过 shared 布局了，剩下的一个布局是<mark> packed</mark>。当使用<mark>紧凑</mark> (Packed) 布局时，是不能保证这个布局在每个程序中保持不变的（即非共享），因为它允许编译器去将 uniform 变量从 Uniform 块中优化掉，这在每个着色器中都可能是不同的。</p><h3 id="使用uniform缓冲"><a class="anchor" href="#使用uniform缓冲">#</a> 使用 Uniform 缓冲</h3><p>我们已经讨论了如何在着色器中定义 Uniform 块，并设定它们的内存布局了，但我们还没有讨论该如何使用它们。</p><p>首先，我们需要调用 glGenBuffers，创建一个 Uniform 缓冲对象。一旦我们有了一个缓冲对象，我们需要将它绑定到 GL_UNIFORM_BUFFER 目标，并调用 glBufferData，分配足够的内存。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> uboExampleBlock<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>uboExampleBlock<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_UNIFORM_BUFFER<span class="token punctuation">,</span> uboExampleBlock<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_UNIFORM_BUFFER<span class="token punctuation">,</span> <span class="token number">152</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 分配 152 字节的内存</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_UNIFORM_BUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>现在，每当我们需要对缓冲更新或者插入数据，我们都会绑定到 uboExampleBlock，并使用 glBufferSubData 来更新它的内存。我们只需要更新这个 Uniform 缓冲一次，所有使用这个缓冲的着色器就都使用的是更新后的数据了。但是，如何才能让 OpenGL<mark> 知道哪个 Uniform 缓冲<strong>对应</strong>的是哪个 Uniform 块呢</mark>？</p><p>在 OpenGL 上下文中，定义了一些<mark>绑定点</mark> (Binding Point)，我们可以将一个 Uniform 缓冲链接至它。在创建 Uniform 缓冲之后，我们将它绑定到其中一个绑定点上，并将着色器中的 Uniform 块绑定到相同的绑定点，把它们连接到一起。下面的这个图示展示了这个：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/08/advanced_glsl_binding_points.png" alt="image"></p><p>你可以看到，我们可以绑定多个 Uniform 缓冲到不同的绑定点上。因为着色器 A 和着色器 B 都有一个链接到绑定点 0 的 Uniform 块，它们的 Uniform 块将会共享相同的 uniform 数据，uboMatrices，前提条件是两个着色器都定义了相同的 Matrices Uniform 块。</p><p>为了将 Uniform 块<mark>绑定到</mark>一个<mark>特定的绑定点</mark>中，我们需要调用<mark> glUniformBlockBinding</mark> 函数，它的第一个参数是一个程序对象，之后是一个 Uniform 块索引和链接到的绑定点。Uniform 块索引 (Uniform Block Index) 是着色器中已定义 Uniform 块的位置值索引。这可以通过调用 glGetUniformBlockIndex 来获取，它接受一个程序对象和 Uniform 块的名称。我们可以用以下方式将图示中的 Lights Uniform 块链接到绑定点 2：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> lights_index <span class="token operator">=</span> <span class="token function">glGetUniformBlockIndex</span><span class="token punctuation">(</span>shaderA<span class="token punctuation">.</span>ID<span class="token punctuation">,</span> <span class="token string">"Lights"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glUniformBlockBinding</span><span class="token punctuation">(</span>shaderA<span class="token punctuation">.</span>ID<span class="token punctuation">,</span> lights_index<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>注意我们需要对<strong>每个</strong>着色器重复这一步骤。</p><blockquote><p>从 OpenGL 4.2 版本起，你也可以添加一个布局标识符，显式地将 Uniform 块的绑定点储存在着色器中，这样就不用再调用 glGetUniformBlockIndex 和 glUniformBlockBinding 了。下面的代码显式地设置了 Lights Uniform 块的绑定点。</p></blockquote><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//binding 对应共享 Uniform 缓存中的 binding points</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span><span class="token punctuation">(</span>std140<span class="token punctuation">,</span> binding <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> uniform Lights <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>接下来，我们还需要绑定 Uniform 缓冲对象到相同的绑定点上，这可以使用 glBindBufferBase 或 glBindBufferRange 来完成。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glBindBufferBase</span><span class="token punctuation">(</span>GL_UNIFORM_BUFFER<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> uboExampleBlock<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 或</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glBindBufferRange</span><span class="token punctuation">(</span>GL_UNIFORM_BUFFER<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> uboExampleBlock<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">152</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>glBindbufferBase 需要一个<mark>目标</mark>，一个<mark>绑定点索引</mark>和一个<mark> Uniform 缓冲对象</mark>作为它的参数。这个函数将 uboExampleBlock 链接到绑定点 2 上，自此，绑定点的两端都链接上了。你也可以使用 glBindBufferRange 函数，它需要一个附加的<mark>偏移量</mark>和<mark>大小参数</mark>，这样子你可以绑定 Uniform 缓冲的特定一部分到绑定点中。通过使用 glBindBufferRange 函数，你可以让多个不同的 Uniform 块绑定到同一个 Uniform 缓冲对象上。</p><p>现在，所有的东西都配置完毕了，我们可以开始向 Uniform 缓冲中添加数据了。只要我们需要，就可以使用 glBufferSubData 函数，用一个字节数组添加所有的数据，或者更新缓冲的一部分。要想更新 uniform 变量 boolean，我们可以用以下方式更新 Uniform 缓冲对象：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_UNIFORM_BUFFER<span class="token punctuation">,</span> uboExampleBlock<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// GLSL 中的 bool 是 4 字节的，所以我们将它存为一个 integer</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glBufferSubData</span><span class="token punctuation">(</span>GL_UNIFORM_BUFFER<span class="token punctuation">,</span> <span class="token number">144</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_UNIFORM_BUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>同样的步骤也能应用到 Uniform 块中其它的 uniform 变量上，但需要使用不同的范围参数。</p><h3 id="一个简单的例子"><a class="anchor" href="#一个简单的例子">#</a> 一个简单的例子</h3><p>所以，我们来展示一个真正使用 Uniform 缓冲对象的例子。如果我们回头看看之前所有的代码例子，我们不断地在使用 3 个矩阵：投影、观察和模型矩阵。在所有的这些矩阵中，只有模型矩阵会频繁变动。如果我们有多个着色器使用了这同一组矩阵，那么使用 Uniform 缓冲对象可能会更好。</p><p>我们会将投影和模型矩阵存储到一个叫做 Matrices 的 Uniform 块中。我们不会将模型矩阵存在这里，因为模型矩阵在不同的着色器中会不断改变，所以使用 Uniform 缓冲对象并不会带来什么好处。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> in vec3 aPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>std140<span class="token punctuation">)</span> uniform Matrices</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    mat4 projection<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    mat4 view<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>uniform mat4 model<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    gl_Position <span class="token operator">=</span> projection <span class="token operator">*</span> view <span class="token operator">*</span> model <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>aPos<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里没什么特别的，除了我们现在使用的是一个 std140 布局的 Uniform 块。我们将在例子程序中，显示 4 个立方体，每个立方体都是使用不同的着色器程序渲染的。这 4 个着色器程序将使用相同的顶点着色器，但使用的是不同的片段着色器，每个着色器会输出不同的颜色。</p><p>首先，我们将顶点着色器的 Uniform 块设置为绑定点 0。注意我们需要对<mark>每个着色器都设置一遍</mark>。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> uniformBlockIndexRed    <span class="token operator">=</span> <span class="token function">glGetUniformBlockIndex</span><span class="token punctuation">(</span>shaderRed<span class="token punctuation">.</span>ID<span class="token punctuation">,</span> <span class="token string">"Matrices"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> uniformBlockIndexGreen  <span class="token operator">=</span> <span class="token function">glGetUniformBlockIndex</span><span class="token punctuation">(</span>shaderGreen<span class="token punctuation">.</span>ID<span class="token punctuation">,</span> <span class="token string">"Matrices"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> uniformBlockIndexBlue   <span class="token operator">=</span> <span class="token function">glGetUniformBlockIndex</span><span class="token punctuation">(</span>shaderBlue<span class="token punctuation">.</span>ID<span class="token punctuation">,</span> <span class="token string">"Matrices"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> uniformBlockIndexYellow <span class="token operator">=</span> <span class="token function">glGetUniformBlockIndex</span><span class="token punctuation">(</span>shaderYellow<span class="token punctuation">.</span>ID<span class="token punctuation">,</span> <span class="token string">"Matrices"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">glUniformBlockBinding</span><span class="token punctuation">(</span>shaderRed<span class="token punctuation">.</span>ID<span class="token punctuation">,</span>    uniformBlockIndexRed<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">glUniformBlockBinding</span><span class="token punctuation">(</span>shaderGreen<span class="token punctuation">.</span>ID<span class="token punctuation">,</span>  uniformBlockIndexGreen<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">glUniformBlockBinding</span><span class="token punctuation">(</span>shaderBlue<span class="token punctuation">.</span>ID<span class="token punctuation">,</span>   uniformBlockIndexBlue<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token function">glUniformBlockBinding</span><span class="token punctuation">(</span>shaderYellow<span class="token punctuation">.</span>ID<span class="token punctuation">,</span> uniformBlockIndexYellow<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>接下来，我们创建 Uniform 缓冲对象本身，并将其绑定到绑定点 0：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> uboMatrices</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>uboMatrices<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_UNIFORM_BUFFER<span class="token punctuation">,</span> uboMatrices<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_UNIFORM_BUFFER<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>glm<span class="token operator">::</span>mat4<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_UNIFORM_BUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">glBindBufferRange</span><span class="token punctuation">(</span>GL_UNIFORM_BUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> uboMatrices<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>glm<span class="token operator">::</span>mat4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>首先我们为缓冲分配了足够的内存，它等于 glm::mat4 大小的两倍。GLM 矩阵类型的大小直接对应于 GLSL 中的 mat4。接下来，我们将缓冲中的特定范围（在这里是整个缓冲）链接到绑定点 0。</p><p>剩余的就是填充这个缓冲了。如果我们将投影矩阵的视野 (Field of View) 值保持不变（所以摄像机就没有缩放了），我们只需要将其在程序中定义一次 —— 这也意味着我们只需要将它插入到缓冲中一次。因为我们已经为缓冲对象分配了足够的内存，我们可以使用 glBufferSubData 在进入渲染循环之前存储投影矩阵：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span>mat4 projection <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">perspective</span><span class="token punctuation">(</span>glm<span class="token operator">::</span><span class="token function">radians</span><span class="token punctuation">(</span><span class="token number">45.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>width<span class="token operator">/</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>height<span class="token punctuation">,</span> <span class="token number">0.1f</span><span class="token punctuation">,</span> <span class="token number">100.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_UNIFORM_BUFFER<span class="token punctuation">,</span> uboMatrices<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glBufferSubData</span><span class="token punctuation">(</span>GL_UNIFORM_BUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>glm<span class="token operator">::</span>mat4<span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">value_ptr</span><span class="token punctuation">(</span>projection<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_UNIFORM_BUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这里我们将投影矩阵储存在 Uniform 缓冲的前半部分。在每次渲染迭代中绘制物体之前，我们会将观察矩阵更新到缓冲的后半部分：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span>mat4 view <span class="token operator">=</span> camera<span class="token punctuation">.</span><span class="token function">GetViewMatrix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_UNIFORM_BUFFER<span class="token punctuation">,</span> uboMatrices<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glBufferSubData</span><span class="token punctuation">(</span>GL_UNIFORM_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>glm<span class="token operator">::</span>mat4<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>glm<span class="token operator">::</span>mat4<span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">value_ptr</span><span class="token punctuation">(</span>view<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_UNIFORM_BUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>Uniform 缓冲对象的部分就结束了。每个包含了 Matrices 这个 Uniform 块的顶点着色器将会包含储存在 uboMatrices 中的数据。所以，如果我们现在要用 4 个不同的着色器绘制 4 个立方体，它们的投影和观察矩阵都会是一样的。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>cubeVAO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>shaderRed<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>glm<span class="token operator">::</span>mat4 model<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>model <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">translate</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.75f</span><span class="token punctuation">,</span> <span class="token number">0.75f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 移动到左上角</span></pre></td></tr><tr><td data-num="5"></td><td><pre>shaderRed<span class="token punctuation">.</span><span class="token function">setMat4</span><span class="token punctuation">(</span><span class="token string">"model"</span><span class="token punctuation">,</span> model<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">glDrawArrays</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">//... 绘制绿色立方体</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">//... 绘制蓝色立方体</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">//... 绘制黄色立方体</span></pre></td></tr></table></figure><p>唯一需要设置的 uniform 只剩 model uniform 了。在像这样的场景中使用 Uniform 缓冲对象会让我们在每个着色器中都剩下一些 uniform 调用。最终的结果会是这样的：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/08/advanced_glsl_uniform_buffer_objects.png" alt="image"></p><p>因为修改了模型矩阵，每个立方体都移动到了窗口的一边，并且由于使用了不同的片段着色器，它们的颜色也不同。这只是一个很简单的情景，我们可能会需要使用 Uniform 缓冲对象，但任何大型的渲染程序都可能同时激活有上百个着色器程序，这时候 Uniform 缓冲对象的优势就会很大地体现出来了。</p><p>Uniform 缓冲对象比起独立的 uniform 有很多好处。第一，一次设置很多 uniform 会比一个一个设置多个 uniform 要快很多。第二，比起在多个着色器中修改同样的 uniform，在 Uniform 缓冲中修改一次会更容易一些。最后一个好处可能不会立即显现，如果使用 Uniform 缓冲对象的话，你可以在着色器中使用更多的 uniform。OpenGL 限制了它能够处理的 uniform 数量，这可以通过 GL_MAX_VERTEX_UNIFORM_COMPONENTS 来查询。当使用 Uniform 缓冲对象时，最大的数量会更高。所以，当你达到了 uniform 的最大数量时（比如再做骨骼动画 (Skeletal Animation) 的时候），你总是可以选择使用 Uniform 缓冲对象。</p><h2 id="几何着色器"><a class="anchor" href="#几何着色器">#</a> 几何着色器</h2><p>在顶点和片段着色器之间有一个可选的<mark>几何着色器</mark> (Geometry Shader)，几何着色器的<mark>输入</mark>是一个<mark>图元</mark>（如点或三角形）的一组顶点。几何着色器可以在顶点发送到下一着色器阶段之前对它们随意变换。然而，几何着色器最有趣的地方在于，它能够将（这一组）<mark>顶点变换为完全不同的图元</mark>，并且还能<mark>生成</mark>比原来<mark>更多的顶点</mark>。</p><p>废话不多说，我们直接先看一个几何着色器的例子：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>points<span class="token punctuation">)</span> in<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>line_strip<span class="token punctuation">,</span> max_vertices <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> out<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    </pre></td></tr><tr><td data-num="6"></td><td><pre>    gl_Position <span class="token operator">=</span> gl_in<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>gl_Position <span class="token operator">+</span> <span class="token function">vec4</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">EmitVertex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    gl_Position <span class="token operator">=</span> gl_in<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>gl_Position <span class="token operator">+</span> <span class="token function">vec4</span><span class="token punctuation">(</span> <span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token function">EmitVertex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token function">EndPrimitive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在几何着色器的顶部，我们需要声明<mark>从顶点着色器输入的图元类型</mark>。这需要在<strong> in</strong> 关键字前声明一个布局修饰符 (Layout Qualifier)。这个输入布局修饰符可以从顶点着色器接收下列任何一个图元值 (后面是输出结果类型)：</p><ul><li><mark>points</mark>：绘制 GL_POINTS 图元时（1）。</li><li><mark>lines</mark>：绘制 GL_LINES 或 GL_LINE_STRIP 时（2）</li><li><mark>lines_adjacency</mark>：GL_LINES_ADJACENCY 或 GL_LINE_STRIP_ADJACENCY（4）</li><li><mark>triangles</mark>：GL_TRIANGLES、GL_TRIANGLE_STRIP 或 GL_TRIANGLE_FAN（3）</li><li><mark>triangles_adjacency</mark>：GL_TRIANGLES_ADJACENCY 或 GL_TRIANGLE_STRIP_ADJACENCY（6）</li></ul><p>以上是能提供给 glDrawArrays 渲染函数的几乎所有图元了。如果我们想要将顶点绘制为 GL_TRIANGLES，我们就要将输入修饰符设置为 triangles。括号内的数字表示的是一个图元所包含的<mark>最小顶点数</mark>。</p><p>接下来，我们还需要指定几何着色<mark>器输出的图元类型</mark>，这需要在<strong> out</strong> 关键字前面加一个布局修饰符。和输入布局修饰符一样，输出布局修饰符也可以接受几个图元值：</p><ul><li><mark>points</mark> ： 输出为点</li><li><mark>line_strip</mark> ： 输出为线条</li><li><mark>triangle_strip</mark> ：输出为三角形</li></ul><p>有了这 3 个输出修饰符，我们就可以使用输入图元创建几乎任意的形状了。要生成一个三角形的话，我们将输出定义为 triangle_strip，并输出 3 个顶点。</p><p>几何着色器同时希望我们<mark>设置</mark>一个它最大<mark>能够输出的顶点数量</mark>（如果你超过了这个值，OpenGL 将不会绘制多出的顶点），这个也可以在 out 关键字的布局修饰符中设置。在这个例子中，我们将输出一个 line_strip，并将最大顶点数设置为 2 个。</p><p>如果你不知道什么是线条 (Line Strip)：线条连接了一组点，形成一条连续的线，它最少要由两个点来组成。在渲染函数中每多加一个点，就会在这个点与前一个点之间形成一条新的线。在下面这张图中，我们有 5 个顶点：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/09/geometry_shader_line_strip.png" alt="image"></p><p>如果使用的是上面定义的着色器，那么这将只能输出一条线段，因为最大顶点数等于 2。</p><p>为了生成更有意义的结果，我们需要某种方式来获取前一着色器阶段的输出。GLSL 提供给我们一个内建 (Built-in) 变量，在内部看起来（可能）是这样的：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>in gl_Vertex</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    vec4  gl_Position<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">float</span> gl_PointSize<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">float</span> gl_ClipDistance<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span> gl_in<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这里，它被声明为一个<mark>接口块</mark>（Interface Block，我们在上一节已经讨论过），它包含了几个很有意思的变量，其中最有趣的一个是 gl_Position，它是和顶点着色器输出非常相似的一个向量。</p><p>要注意的是，它被声明为一个数组，因为大多数的渲染图元包含多于 1 个的顶点，而几何着色器的输入是一个图元的所有顶点。</p><p>有了之前顶点着色器阶段的顶点数据，我们就可以使用 2 个几何着色器函数，EmitVertex 和 EndPrimitive，来生成新的数据了。几何着色器希望你能够生成并输出至少一个定义为输出的图元。在我们的例子中，我们需要至少生成一个线条图元。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    gl_Position <span class="token operator">=</span> gl_in<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>gl_Position <span class="token operator">+</span> <span class="token function">vec4</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">EmitVertex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    gl_Position <span class="token operator">=</span> gl_in<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>gl_Position <span class="token operator">+</span> <span class="token function">vec4</span><span class="token punctuation">(</span> <span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">EmitVertex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">EndPrimitive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>每次我们调用 EmitVertex 时，gl_Position 中的向量会被添加到图元中来。当 EndPrimitive 被调用时，所有发射出的 (Emitted) 顶点都会合成为指定的输出渲染图元。在一个或多个 EmitVertex 调用之后重复调用 EndPrimitive 能够生成多个图元。在这个例子中，我们发射了两个顶点，它们从原始顶点位置平移了一段距离，之后调用了 EndPrimitive，将这两个顶点合成为一个包含两个顶点的线条。</p><p>现在你（大概）了解了几何着色器的工作方式，你可能已经猜出这个几何着色器是做什么的了。它接受一个点图元作为输入，以这个点为中心，创建一条水平的线图元。如果我们渲染它，看起来会是这样的：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/09/geometry_shader_lines.png" alt="image"></p><p>目前还并没有什么令人惊叹的效果，但考虑到这个输出是通过调用下面的渲染函数来生成的，它还是很有意思的：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glDrawArrays</span><span class="token punctuation">(</span>GL_POINTS<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>虽然这是一个比较简单的例子，它的确向你展示了如何能够使用几何着色器来（动态地）生成新的形状。在之后我们会利用几何着色器创建出更有意思的效果，但现在我们仍将从创建一个简单的几何着色器开始。</p><h3 id="使用几何着色器"><a class="anchor" href="#使用几何着色器">#</a> 使用几何着色器</h3><p>为了展示几何着色器的用法，我们将会渲染一个非常简单的场景，我们只会在标准化设备坐标的 z 平面上绘制四个点。这些点的坐标是：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> points<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span>  <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token comment">// 左上</span></pre></td></tr><tr><td data-num="3"></td><td><pre>     <span class="token number">0.5f</span><span class="token punctuation">,</span>  <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token comment">// 右上</span></pre></td></tr><tr><td data-num="4"></td><td><pre>     <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token comment">// 右下</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5f</span>  <span class="token comment">// 左下</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>顶点着色器只需要在 z 平面绘制点就可以了，所以我们将使用一个最基本顶点着色器：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> in vec2 aPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    gl_Position <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>aPos<span class="token punctuation">.</span>x<span class="token punctuation">,</span> aPos<span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>直接在片段着色器中硬编码，将所有的点都输出为绿色：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>out vec4 FragColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>为点的顶点数据生成一个 VAO 和一个 VBO，然后使用 glDrawArrays 进行绘制：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>shader<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>VAO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glDrawArrays</span><span class="token punctuation">(</span>GL_POINTS<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>结果是在黑暗的场景中有四个（很难看见的）绿点：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/09/geometry_shader_points.png" alt="image"></p><p>但我们之前不是学过这些吗？是的，但是现在我们将会添加一个几何着色器，为场景添加活力。</p><p>出于学习目的，我们将会创建一个<mark>传递 (Pass-through) 几何着色器</mark>，它会接收一个点图元，并直接将它传递 (Pass) 到下一个着色器：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>points<span class="token punctuation">)</span> in<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>points<span class="token punctuation">,</span> max_vertices <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> out<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    </pre></td></tr><tr><td data-num="6"></td><td><pre>    gl_Position <span class="token operator">=</span> gl_in<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>gl_Position<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">EmitVertex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">EndPrimitive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>现在这个几何着色器应该很容易理解了，它只是将它接收到的顶点位置不作修改直接发射出去，并生成一个点图元。</p><p>和顶点与片段着色器一样，几何着色器也需要编译和链接，但这次在创建着色器时我们将会使用 GL_GEOMETRY_SHADER 作为着色器类型：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>geometryShader <span class="token operator">=</span> <span class="token function">glCreateShader</span><span class="token punctuation">(</span>GL_GEOMETRY_SHADER<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glShaderSource</span><span class="token punctuation">(</span>geometryShader<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>gShaderCode<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glCompileShader</span><span class="token punctuation">(</span>geometryShader<span class="token punctuation">)</span><span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">glAttachShader</span><span class="token punctuation">(</span>program<span class="token punctuation">,</span> geometryShader<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">glLinkProgram</span><span class="token punctuation">(</span>program<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>着色器编译的代码和顶点与片段着色器代码都是一样的。记得要检查编译和链接错误！</p><p>如果你现在编译并运行程序，会看到和下面类似的结果：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/09/geometry_shader_points.png" alt="image"></p><p>这和没使用几何着色器时是完全一样的！我承认这是有点无聊，但既然我们仍然能够绘制这些点，所以几何着色器是正常工作的，现在是时候做点更有趣的东西了！</p><h3 id="造几个房子"><a class="anchor" href="#造几个房子">#</a> 造几个房子</h3><p>绘制点和线并没有那么有趣，所以我们会使用一点创造力，利用几何着色器在每个点的位置上绘制一个房子。要实现这个，我们可以将几何着色器的输出设置为 triangle_strip，并绘制三个三角形：其中两个组成一个正方形，另一个用作房顶。</p><p>OpenGL 中，三角形带 (Triangle Strip) 是绘制三角形更高效的方式，它使用顶点更少。在第一个三角形绘制完之后，每个后续顶点将会在上一个三角形边上生成另一个三角形：每 3 个临近的顶点将会形成一个三角形。如果我们一共有 6 个构成三角形带的顶点，那么我们会得到这些三角形：(1, 2, 3)、(2, 3, 4)、(3, 4, 5) 和 (4, 5, 6)，共形成 4 个三角形。一个三角形带至少需要 3 个顶点，并会生成 N-2 个三角形。使用 6 个顶点，我们创建了 6-2 = 4 个三角形。下面这幅图展示了这点：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/09/geometry_shader_triangle_strip.png" alt="image"></p><p>通过使用三角形带作为几何着色器的输出，我们可以很容易创建出需要的房子形状，只需要以正确的顺序生成 3 个相连的三角形就行了。下面这幅图展示了顶点绘制的顺序，蓝点代表的是输入点：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/09/geometry_shader_house.png" alt="image"></p><p>变为几何着色器是这样的：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>points<span class="token punctuation">)</span> in<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>triangle_strip<span class="token punctuation">,</span> max_vertices <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">)</span> out<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">void</span> <span class="token function">build_house</span><span class="token punctuation">(</span>vec4 position<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#123;</span>    </pre></td></tr><tr><td data-num="7"></td><td><pre>    gl_Position <span class="token operator">=</span> position <span class="token operator">+</span> <span class="token function">vec4</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 1: 左下</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">EmitVertex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   </pre></td></tr><tr><td data-num="9"></td><td><pre>    gl_Position <span class="token operator">=</span> position <span class="token operator">+</span> <span class="token function">vec4</span><span class="token punctuation">(</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2: 右下</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token function">EmitVertex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    gl_Position <span class="token operator">=</span> position <span class="token operator">+</span> <span class="token function">vec4</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.2</span><span class="token punctuation">,</span>  <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3: 左上</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token function">EmitVertex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    gl_Position <span class="token operator">=</span> position <span class="token operator">+</span> <span class="token function">vec4</span><span class="token punctuation">(</span> <span class="token number">0.2</span><span class="token punctuation">,</span>  <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4: 右上</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token function">EmitVertex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    gl_Position <span class="token operator">=</span> position <span class="token operator">+</span> <span class="token function">vec4</span><span class="token punctuation">(</span> <span class="token number">0.0</span><span class="token punctuation">,</span>  <span class="token number">0.4</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 5: 顶部</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token function">EmitVertex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token function">EndPrimitive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    </pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token function">build_house</span><span class="token punctuation">(</span>gl_in<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>gl_Position<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/09/geometry_shader_houses.png" alt="image"></p><p>你可以看到，每个房子实际上是由 3 个三角形组成的 —— 全部都是使用空间中一点来绘制的。这些绿房子看起来是有点无聊，所以我们会再给每个房子分配一个不同的颜色。为了实现这个，我们需要在顶点着色器中添加一个额外的顶点属性，表示颜色信息，将它传递至几何着色器，并再次发送到片段着色器中。</p><p>下面是更新后的顶点数据：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> points<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span>  <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token comment">// 左上</span></pre></td></tr><tr><td data-num="3"></td><td><pre>     <span class="token number">0.5f</span><span class="token punctuation">,</span>  <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token comment">// 右上</span></pre></td></tr><tr><td data-num="4"></td><td><pre>     <span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token comment">// 右下</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.5f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span>  <span class="token comment">// 左下</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>然后我们更新顶点着色器，使用一个接口块将颜色属性发送到几何着色器中：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> in vec2 aPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> in vec3 aColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>out VS_OUT <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    vec3 color<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span> vs_out<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    gl_Position <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>aPos<span class="token punctuation">.</span>x<span class="token punctuation">,</span> aPos<span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="12"></td><td><pre>    vs_out<span class="token punctuation">.</span>color <span class="token operator">=</span> aColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>接下来我们还需要在几何着色器中声明相同的接口块（使用一个不同的接口名）：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>in VS_OUT <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    vec3 color<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span> gs_in<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>因为几何着色器是作用于输入的一组顶点的，从顶点着色器发来输入数据总是会以数组的形式表示出来，即便我们现在只有一个顶点。</p><blockquote><p>我们并不是必须要用接口块来向几何着色器传递数据。如果顶点着色器发送的颜色向量是 out vec3 vColor，我们也可以这样写：</p></blockquote><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>in vec3 vColor<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>然而，接口块在几何着色器这样的着色器中会更容易处理一点。实际上，几何着色器的输入能够变得非常大，将它们合并为一个大的接口块数组会更符合逻辑一点。</p></blockquote><p>接下来我们还需要为下个片段着色器阶段声明一个输出颜色向量：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>out vec3 fColor<span class="token punctuation">;</span></pre></td></tr></table></figure><p>因为片段着色器只需要一个（插值的）颜色，发送多个颜色并没有什么意义。所以，fColor 向量就不是一个数组，而是一个单独的向量。当发射一个顶点的时候，每个顶点将会使用最后在 fColor 中储存的值，来用于片段着色器的运行。对我们的房子来说，我们只需要在第一个顶点发射之前，使用顶点着色器中的颜色填充 fColor 一次就可以了。</p><p>因为片段着色器只需要一个（已进行了插值的）颜色，传送多个颜色没有意义。fColor 向量这样就不是一个数组，而是一个单一的向量。当发射一个顶点时，为了它的片段着色器运行，每个顶点都会储存最后在 fColor 中储存的值。对于这些房子来说，我们可以在第一个顶点被发射，对整个房子上色前，只使用来自顶点着色器的颜色填充 fColor 一次：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>fColor <span class="token operator">=</span> gs_in<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>color<span class="token punctuation">;</span> <span class="token comment">//gs_in [0] 因为只有一个输入顶点</span></pre></td></tr><tr><td data-num="2"></td><td><pre>gl_Position <span class="token operator">=</span> position <span class="token operator">+</span> <span class="token function">vec4</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 1: 左下  </span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">EmitVertex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   </pre></td></tr><tr><td data-num="4"></td><td><pre>gl_Position <span class="token operator">=</span> position <span class="token operator">+</span> <span class="token function">vec4</span><span class="token punctuation">(</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2: 右下</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">EmitVertex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>gl_Position <span class="token operator">=</span> position <span class="token operator">+</span> <span class="token function">vec4</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.2</span><span class="token punctuation">,</span>  <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3: 左上</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">EmitVertex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>gl_Position <span class="token operator">=</span> position <span class="token operator">+</span> <span class="token function">vec4</span><span class="token punctuation">(</span> <span class="token number">0.2</span><span class="token punctuation">,</span>  <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4: 右上</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token function">EmitVertex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>gl_Position <span class="token operator">=</span> position <span class="token operator">+</span> <span class="token function">vec4</span><span class="token punctuation">(</span> <span class="token number">0.0</span><span class="token punctuation">,</span>  <span class="token number">0.4</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 5: 顶部</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token function">EmitVertex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token function">EndPrimitive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>所有发射出的顶点都将嵌有最后储存在 fColor 中的值，即顶点的颜色属性值。所有的房子都会有它们自己的颜色了：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/09/geometry_shader_houses_colored.png" alt="image"></p><p>仅仅是为了有趣，我们也可以假装这是冬天，将最后一个顶点的颜色设置为白色，给屋顶落上一些雪。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>fColor <span class="token operator">=</span> gs_in<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>color<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre>gl_Position <span class="token operator">=</span> position <span class="token operator">+</span> <span class="token function">vec4</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 1: 左下 </span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">EmitVertex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   </pre></td></tr><tr><td data-num="4"></td><td><pre>gl_Position <span class="token operator">=</span> position <span class="token operator">+</span> <span class="token function">vec4</span><span class="token punctuation">(</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2: 右下</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">EmitVertex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>gl_Position <span class="token operator">=</span> position <span class="token operator">+</span> <span class="token function">vec4</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0.2</span><span class="token punctuation">,</span>  <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3: 左上</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">EmitVertex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>gl_Position <span class="token operator">=</span> position <span class="token operator">+</span> <span class="token function">vec4</span><span class="token punctuation">(</span> <span class="token number">0.2</span><span class="token punctuation">,</span>  <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4: 右上</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token function">EmitVertex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>gl_Position <span class="token operator">=</span> position <span class="token operator">+</span> <span class="token function">vec4</span><span class="token punctuation">(</span> <span class="token number">0.0</span><span class="token punctuation">,</span>  <span class="token number">0.4</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 5: 顶部</span></pre></td></tr><tr><td data-num="11"></td><td><pre>fColor <span class="token operator">=</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token function">EmitVertex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token function">EndPrimitive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>最终结果看起来是这样的：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/09/geometry_shader_houses_snow.png" alt="image"></p><p>你可以看到，有了几何着色器，你甚至可以将最简单的图元变得十分有创意。因为这些形状是在<mark> GPU 的超快硬件中动态生成</mark>的，这会比在顶点缓冲中<mark>手动定义</mark>图形要<mark>高效很多</mark>。因此，几何缓冲对简单而且经常重复的形状来说是一个很好的优化工具，比如体素 (Voxel) 世界中的方块和室外草地的每一根草。</p><h3 id="爆破物体"><a class="anchor" href="#爆破物体">#</a> 爆破物体</h3><p>尽管绘制房子非常有趣，但我们不会经常这么做。这也是为什么我们接下来要继续深入，来爆破 (Explode) 物体！虽然这也是一个不怎么常用的东西，但是它能向你展示几何着色器的强大之处。</p><p>当我们说爆破一个物体时，我们并不是指要将宝贵的顶点集给炸掉，我们是要将每个三角形沿着法向量的方向移动一小段时间。效果就是，整个物体看起来像是沿着每个三角形的法线向量爆炸一样。爆炸三角形的效果在纳米装模型上看起来像是这样的：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/09/geometry_shader_explosion.png" alt="image"></p><p>这样的几何着色器效果的一个好处就是，无论物体有多复杂，它都能够应用上去。</p><p>因为我们想要沿着三角形的法向量位移每个顶点，我们首先需要计算这个法向量。我们所要做的是计算垂直于三角形表面的向量，仅使用我们能够访问的 3 个顶点。你可能还记得在变换小节中，我们使用叉乘来获取垂直于其它两个向量的一个向量。如果我们能够获取两个平行于三角形表面的向量 a 和 b，我们就能够对这两个向量进行叉乘来获取法向量了。下面这个几何着色器函数做的正是这个，来使用 3 个输入顶点坐标来获取法向量：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vec3 <span class="token function">GetNormal</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   vec3 a <span class="token operator">=</span> <span class="token function">vec3</span><span class="token punctuation">(</span>gl_in<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>gl_Position<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">vec3</span><span class="token punctuation">(</span>gl_in<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>gl_Position<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   vec3 b <span class="token operator">=</span> <span class="token function">vec3</span><span class="token punctuation">(</span>gl_in<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>gl_Position<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">vec3</span><span class="token punctuation">(</span>gl_in<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>gl_Position<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token keyword">return</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token function">cross</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里我们使用减法获取了两个平行于三角形表面的向量 a 和 b。因为两个向量相减能够得到这两个向量之间的差值，并且三个点都位于三角平面上，对任意两个向量相减都能够得到一个平行于平面的向量。注意，如果我们交换了 cross 函数中 a 和 b 的位置，我们会得到一个指向相反方向的法向量 —— 这里的顺序很重要！</p><p>既然知道了如何计算法向量了，我们就能够创建一个 explode 函数了，它使用法向量和顶点位置向量作为参数。这个函数会返回一个新的向量，它是位置向量沿着法线向量进行位移之后的结果：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vec4 <span class="token function">explode</span><span class="token punctuation">(</span>vec4 position<span class="token punctuation">,</span> vec3 normal<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">float</span> magnitude <span class="token operator">=</span> <span class="token number">2.0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    vec3 direction <span class="token operator">=</span> normal <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">sin</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1.0</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2.0</span><span class="token punctuation">)</span> <span class="token operator">*</span> magnitude<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">return</span> position <span class="token operator">+</span> <span class="token function">vec4</span><span class="token punctuation">(</span>direction<span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>函数本身应该不是非常复杂。sin 函数接收一个 time 参数，它根据时间返回一个 - 1.0 到 1.0 之间的值。因为我们不想让物体向内爆炸 (Implode)，我们将 sin 值变换到了 [0, 1] 的范围内。最终的结果会乘以 normal 向量，并且最终的 direction 向量会被加到位置向量上。</p><p>当使用我们的模型加载器绘制一个模型时，爆破 (Explode) 效果的完整片段着色器是这样的：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>triangles<span class="token punctuation">)</span> in<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>triangle_strip<span class="token punctuation">,</span> max_vertices <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span> out<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>in VS_OUT <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    vec2 texCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span> gs_in<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>out vec2 TexCoords<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>uniform <span class="token keyword">float</span> time<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>vec4 <span class="token function">explode</span><span class="token punctuation">(</span>vec4 position<span class="token punctuation">,</span> vec3 normal<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>vec3 <span class="token function">GetNormal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    </pre></td></tr><tr><td data-num="18"></td><td><pre>    vec3 normal <span class="token operator">=</span> <span class="token function">GetNormal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>    gl_Position <span class="token operator">=</span> <span class="token function">explode</span><span class="token punctuation">(</span>gl_in<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>gl_Position<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    TexCoords <span class="token operator">=</span> gs_in<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>texCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token function">EmitVertex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    gl_Position <span class="token operator">=</span> <span class="token function">explode</span><span class="token punctuation">(</span>gl_in<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>gl_Position<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    TexCoords <span class="token operator">=</span> gs_in<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>texCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token function">EmitVertex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    gl_Position <span class="token operator">=</span> <span class="token function">explode</span><span class="token punctuation">(</span>gl_in<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>gl_Position<span class="token punctuation">,</span> normal<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    TexCoords <span class="token operator">=</span> gs_in<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>texCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token function">EmitVertex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token function">EndPrimitive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>注意我们在发射顶点之前输出了对应的纹理坐标。</p><p>而且别忘了在 OpenGL 代码中设置 time 变量：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>shader<span class="token punctuation">.</span><span class="token function">setFloat</span><span class="token punctuation">(</span><span class="token string">"time"</span><span class="token punctuation">,</span> <span class="token function">glfwGetTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="法向量可视化"><a class="anchor" href="#法向量可视化">#</a> 法向量可视化</h3><p>在这一部分中，我们将使用几何着色器来实现一个真正有用的例子：显示任意物体的法向量。当编写光照着色器时，你可能会最终会得到一些奇怪的视觉输出，但又很难确定导致问题的原因。光照错误很常见的原因就是法向量错误，这可能是由于不正确加载顶点数据、错误地将它们定义为顶点属性或在着色器中不正确地管理所导致的。我们想要的是使用某种方式来检测提供的法向量是正确的。检测法向量是否正确的一个很好的方式就是对它们进行可视化，几何着色器正是实现这一目的非常有用的工具。</p><p>思路是这样的：我们首先不使用几何着色器正常绘制场景。然后再次绘制场景，但这次只显示通过几何着色器生成法向量。几何着色器接收一个三角形图元，并沿着法向量生成三条线 —— 每个顶点一个法向量。伪代码看起来会像是这样：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>shader<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">DrawScene</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>normalDisplayShader<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">DrawScene</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这次在几何着色器中，我们会使用模型提供的顶点法线，而不是自己生成，为了适配（观察和模型矩阵的）缩放和旋转，我们在将法线变换到裁剪空间坐标之前，先使用法线矩阵变换一次（几何着色器接受的位置向量是剪裁空间坐标，所以我们应该将法向量变换到相同的空间中）。这可以在顶点着色器中完成：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> in vec3 aPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> in vec3 aNormal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>out VS_OUT <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    vec3 normal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span> vs_out<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>uniform mat4 projection<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>uniform mat4 view<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>uniform mat4 model<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    gl_Position <span class="token operator">=</span> projection <span class="token operator">*</span> view <span class="token operator">*</span> model <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>aPos<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre>    mat3 normalMatrix <span class="token operator">=</span> <span class="token function">mat3</span><span class="token punctuation">(</span><span class="token function">transpose</span><span class="token punctuation">(</span><span class="token function">inverse</span><span class="token punctuation">(</span>view <span class="token operator">*</span> model<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    vs_out<span class="token punctuation">.</span>normal <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token function">vec3</span><span class="token punctuation">(</span>projection <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>normalMatrix <span class="token operator">*</span> aNormal<span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>变换后的裁剪空间法向量会以接口块的形式传递到下个着色器阶段。接下来，几何着色器会接收每一个顶点（包括一个位置向量和一个法向量），并在每个位置向量处绘制一个法线向量：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>triangles<span class="token punctuation">)</span> in<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>line_strip<span class="token punctuation">,</span> max_vertices <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">)</span> out<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>in VS_OUT <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    vec3 normal<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span> gs_in<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">float</span> MAGNITUDE <span class="token operator">=</span> <span class="token number">0.4</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">void</span> <span class="token function">GenerateLine</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    gl_Position <span class="token operator">=</span> gl_in<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>gl_Position<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token function">EmitVertex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    gl_Position <span class="token operator">=</span> gl_in<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>gl_Position <span class="token operator">+</span> <span class="token function">vec4</span><span class="token punctuation">(</span>gs_in<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>normal<span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token operator">*</span> MAGNITUDE<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token function">EmitVertex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token function">EndPrimitive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token function">GenerateLine</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第一个顶点法线</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token function">GenerateLine</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第二个顶点法线</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token function">GenerateLine</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第三个顶点法线</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>像这样的几何着色器应该很容易理解了。注意我们将法向量乘以了一个 MAGNITUDE 向量，来限制显示出的法向量大小（否则它们就有点大了）。</p><p>因为法线的可视化通常都是用于调试目的，我们可以使用片段着色器，将它们显示为单色的线（如果你愿意也可以是非常好看的线）：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>out vec4 FragColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>现在，首先使用普通着色器渲染模型，再使用特别的<mark>法线可视化</mark>着色器渲染，你将看到这样的效果：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/09/geometry_shader_normals.png" alt="image"></p><p>尽管我们的纳米装现在看起来像是一个体毛很多而且带着隔热手套的人，它能够很有效地帮助我们判断模型的法线是否正确。你可以想象到，这样的几何着色器也经常用于给物体添加毛发 (Fur)。</p><h2 id="实例化"><a class="anchor" href="#实例化">#</a> 实例化</h2><p>假设你有一个绘制了很多模型的场景，而大部分的模型包含的是同一组顶点数据，只不过进行的是不同的世界空间变换。想象一个充满草的场景：每根草都是一个包含几个三角形的小模型。你可能会需要绘制很多根草，最终在每帧中你可能会需要渲染上千或者上万根草。因为每一根草仅仅是由几个三角形构成，渲染几乎是瞬间完成的，但上千个渲染函数调用却会极大地影响性能。</p><p>如果我们需要渲染大量物体时，代码看起来会像这样：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> amount_of_models_to_draw<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">DoSomePreparations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 绑定 VAO，绑定纹理，设置 uniform 等</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token function">glDrawArrays</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> amount_of_vertices<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>如果像这样绘制模型的<mark>大量实例</mark> (Instance)，你很快就会因为绘制调用过多而达到性能瓶颈。与绘制顶点本身相比，使用 glDrawArrays 或 glDrawElements 函数告诉 GPU 去绘制你的顶点数据会消耗更多的性能，因为 OpenGL 在绘制顶点数据之前需要做很多准备工作（比如告诉 GPU 该从哪个缓冲读取数据，从哪寻找顶点属性，而且这些都是在相对缓慢的 CPU 到 GPU 总线 (CPU to GPU Bus) 上进行的）。所以，即便渲染顶点非常快，命令 GPU 去渲染却未必。</p><p>如果我们能<mark>够将数据一次性发送给 GPU</mark>，然后使用一个<strong>绘制函数</strong>让 OpenGL 利用这些数据绘制多个物体，就会更方便了。这就是实例化 (Instancing)。</p><p>实例化这项技术能够让我们使用一个渲染调用来绘制多个物体，来节省每次绘制物体时 CPU -&gt; GPU 的通信，它只需要一次即可。如果想使用实例化渲染，我们只需要将<mark> glDrawArrays 和 glDrawElements 的渲染调用分别改为 glDrawArraysInstanced 和 glDrawElementsInstanced</mark> 就可以了。这些渲染函数的实例化版本需要一个额外的参数，叫做<mark>实例数量</mark> (Instance Count)，它能够设置我们需要渲染的实例个数。这样我们只需要将必须的数据发送到 GPU 一次，然后使用一次函数调用告诉 GPU 它应该如何绘制这些实例。GPU 将会直接渲染这些实例，而不用不断地与 CPU 进行通信。</p><p>这个函数本身并没有什么用。渲染同一个物体一千次对我们并没有什么用处，每个物体都是完全相同的，而且还在同一个位置。我们只能看见一个物体！处于这个原因，GLSL 在顶点着色器中嵌入了另一个内建变量，gl_InstanceID。</p><p>在使用实例化渲染调用时，gl_InstanceID 会从 0 开始，在每个实例被渲染时递增 1。比如说，我们正在渲染第 43 个实例，那么顶点着色器中它的 gl_InstanceID 将会是 42。因为每个实例都有唯一的 ID，我们可以建立一个数组，将 ID 与位置值对应起来，将每个实例放置在世界的不同位置。</p><p>为了体验一下实例化绘制，我们将会在标准化设备坐标系中使用一个渲染调用，绘制 100 个 2D 四边形。我们会索引一个包含 100 个偏移向量的 uniform 数组，将偏移值加到每个实例化的四边形上。最终的结果是一个排列整齐的四边形网格：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/10/instancing_quads.png" alt="image"></p><p>每个四边形由 2 个三角形所组成，一共有 6 个顶点。每个顶点包含一个 2D 的标准化设备坐标位置向量和一个颜色向量。 下面就是这个例子使用的顶点数据，为了大量填充屏幕，每个三角形都很小：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> quadVertices<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 位置          // 颜色</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token operator">-</span><span class="token number">0.05f</span><span class="token punctuation">,</span>  <span class="token number">0.05f</span><span class="token punctuation">,</span>  <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>     <span class="token number">0.05f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.05f</span><span class="token punctuation">,</span>  <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token operator">-</span><span class="token number">0.05f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.05f</span><span class="token punctuation">,</span>  <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token operator">-</span><span class="token number">0.05f</span><span class="token punctuation">,</span>  <span class="token number">0.05f</span><span class="token punctuation">,</span>  <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="8"></td><td><pre>     <span class="token number">0.05f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.05f</span><span class="token punctuation">,</span>  <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span>   </pre></td></tr><tr><td data-num="9"></td><td><pre>     <span class="token number">0.05f</span><span class="token punctuation">,</span>  <span class="token number">0.05f</span><span class="token punctuation">,</span>  <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span>                   </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>片段着色器会从顶点着色器接受颜色向量，并将其设置为它的颜色输出，来实现四边形的颜色：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>out vec4 FragColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>in vec3 fColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    FragColor <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>fColor<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>到现在都没有什么新内容，但从顶点着色器开始就变得很有趣了：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> in vec2 aPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> in vec3 aColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>out vec3 fColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>uniform vec2 offsets<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    vec2 offset <span class="token operator">=</span> offsets<span class="token punctuation">[</span>gl_InstanceID<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    gl_Position <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>aPos <span class="token operator">+</span> offset<span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    fColor <span class="token operator">=</span> aColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里我们定义了一个叫做 offsets 的数组，它包含 100 个偏移向量。在顶点着色器中，我们会使用 gl_InstanceID 来索引 offsets 数组，获取每个实例的偏移向量。如果我们要实例化绘制 100 个四边形，仅使用这个顶点着色器我们就能得到 100 个位于不同位置的四边形。</p><p>当前，我们仍要设置这些偏移位置，我们会在进入渲染循环之前使用一个嵌套 for 循环计算：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>glm<span class="token operator">::</span>vec2 translations<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">float</span> offset <span class="token operator">=</span> <span class="token number">0.1f</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">;</span> y <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> y <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> x <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        glm<span class="token operator">::</span>vec2 translation<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        translation<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>x <span class="token operator">/</span> <span class="token number">10.0f</span> <span class="token operator">+</span> offset<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        translation<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>y <span class="token operator">/</span> <span class="token number">10.0f</span> <span class="token operator">+</span> offset<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        translations<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> translation<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里，我们创建 100 个位移向量，表示 10x10 网格上的所有位置。除了生成 translations 数组之外，我们还需要将数据转移到顶点着色器的 uniform 数组中：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>shader<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    stringstream ss<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    string index<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    ss <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="7"></td><td><pre>    index <span class="token operator">=</span> ss<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="8"></td><td><pre>    shader<span class="token punctuation">.</span><span class="token function">setVec2</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"offsets["</span> <span class="token operator">+</span> index <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> translations<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在这一段代码中，我们将 for 循环的计数器 i 转换为一个 string，我们可以用它来动态创建位置值的字符串，用于 uniform 位置值的索引。接下来，我们会对 offsets uniform 数组中的每一项设置对应的位移向量。</p><p>现在所有的准备工作都做完了，我们可以开始渲染四边形了。对于实例化渲染，我们使用 glDrawArraysInstanced 或 glDrawElementsInstanced。因为我们使用的不是索引缓冲，我们会调用 glDrawArrays 版本的函数：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>quadVAO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glDrawArraysInstanced</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>glDrawArraysInstanced 的参数和 glDrawArrays 完全一样，除了最后多了个参数用来设置需要绘制的实例数量。因为我们想要在 10x10 网格中显示 100 个四边形，我们将它设置为 100. 运行代码之后，你应该能得到熟悉的 100 个五彩的四边形。</p><h3 id="实例化数组"><a class="anchor" href="#实例化数组">#</a> 实例化数组</h3><p>虽然之前的实现在目前的情况下能够正常工作，但是如果我们要渲染远超过 100 个实例的时候（这其实非常普遍），我们最终会超过最大能够发送至着色器的<mark> uniform 数据大小上限</mark>。它的一个代替方案是<mark>实例化数组</mark> (Instanced Array)，它被定义为一个顶点属性（能够让我们储存更多的数据），仅在顶点着色器渲染一个新的实例时才会更新。</p><p>使用顶点属性时，顶点着色器的每次运行都会让 GLSL 获取新一组适用于当前顶点的属性。而当我们将顶点属性定义为一个实例化数组时，顶点着色器就只需要对每个实例，而不是每个顶点，更新顶点属性的内容了。这允许我们对逐顶点的数据使用普通的顶点属性，而对逐实例的数据使用实例化数组。</p><p>为了给你一个实例化数组的例子，我们将使用之前的例子，并将偏移量 uniform 数组设置为一个实例化数组。我们需要在顶点着色器中再添加一个顶点属性：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> in vec2 aPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> in vec3 aColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> in vec2 aOffset<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>out vec3 fColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    gl_Position <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>aPos <span class="token operator">+</span> aOffset<span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    fColor <span class="token operator">=</span> aColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>我们不再使用 gl_InstanceID，现在不需要索引一个 uniform 数组就能够直接使用 offset 属性了。</p><p>因为实例化数组和 position 与 color 变量一样，都是顶点属性，我们还需要将它的内容存在顶点缓冲对象中，并且配置它的属性指针。我们首先将（上一部分的）translations 数组存到一个新的缓冲对象中：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> instanceVBO<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>instanceVBO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> instanceVBO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>glm<span class="token operator">::</span>vec2<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>translations<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>之后我们还需要设置它的顶点属性指针，并启用顶点属性：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> instanceVBO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">glVertexAttribDivisor</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这段代码很有意思的地方在于最后一行，我们调用了<mark> glVertexAttribDivisor</mark>。这个函数告诉了 OpenGL 该什么时候<mark>更新顶点属性</mark>的内容至新一组数据。它的第一个参数是需要的顶点属性，第二个参数是属性除数 (Attribute Divisor)。默认情况下，属性除数是<strong> 0</strong>，告诉 OpenGL 我们需要在顶点着色器的<mark>每次迭代时更新顶点属性</mark>。将它设置为<strong> 1</strong> 时，我们告诉 OpenGL 我们希望在<mark>渲染一个新实例的时候更新顶点属性</mark>。而设置为<strong> 2</strong> 时，我们希望每<strong> 2</strong> 个实例更新一次属性，以此类推。我们将属性除数设置为 1，是在告诉 OpenGL，处于位置值 2 的顶点属性是一个实例化数组。</p><p>如果我们现在使用 glDrawArraysInstanced，再次渲染四边形，会得到以下输出：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/10/instancing_quads.png" alt="image"></p><p>这和之前的例子是完全一样的，但这次是使用实例化数组实现的，这让我们能够传递更多的数据到顶点着色器（只要内存允许）来用于实例化绘制。</p><p>为了更有趣一点，我们也可以使用 gl_InstanceID，从右上到左下逐渐缩小四边形：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    vec2 pos <span class="token operator">=</span> aPos <span class="token operator">*</span> <span class="token punctuation">(</span>gl_InstanceID <span class="token operator">/</span> <span class="token number">100.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    gl_Position <span class="token operator">=</span> <span class="token function">vec4</span><span class="token punctuation">(</span>pos <span class="token operator">+</span> aOffset<span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    fColor <span class="token operator">=</span> aColor<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>结果就是，第一个四边形的实例会非常小，随着绘制实例的增加，gl_InstanceID 会越来越接近 100，四边形也就越来越接近原始大小。像这样将实例化数组与 gl_InstanceID 结合使用是完全可行的。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/10/instancing_quads_arrays.png" alt="image"></p><p>如果你还是不确定实例化渲染是如何工作的，或者想看看所有代码是如何组合起来的，你可以在这里找到程序的源代码。</p><p>虽然很有趣，但是这些例子并不是实例化的好例子。是的，它们的确让你知道实例化是怎么工作的，但是我们还没接触到它最有用的一点：绘制巨大数量的相似物体。出于这个原因，我们将会在下一部分进入太空探险，见识实例化渲染真正的威力。</p><h3 id="小行星带"><a class="anchor" href="#小行星带">#</a> 小行星带</h3><p>想象这样一个场景，在宇宙中有一个大的行星，它位于小行星带的中央。这样的小行星带可能包含成千上万的岩块，在很不错的显卡上也很难完成这样的渲染。实例化渲染正是适用于这样的场景，因为所有的小行星都可以使用一个模型来表示。每个小行星可以再使用不同的变换矩阵来进行少许的变化。</p><p>为了展示实例化渲染的作用，我们首先会<mark>不使用实例化渲染</mark>，来渲染小行星绕着行星飞行的场景。这个场景将会包含一个大的行星模型，它可以在<span class="exturl" data-url="aHR0cHM6Ly9sZWFybm9wZW5nbC1jbi5naXRodWIuaW8vZGF0YS9wbGFuZXQucmFy">这里下载</span>，以及很多环绕着行星的小行星。小行星的岩石模型可以在<span class="exturl" data-url="aHR0cHM6Ly9sZWFybm9wZW5nbC1jbi5naXRodWIuaW8vZGF0YS9yb2NrLnJhcg==">这里下载</span>。</p><p>在代码例子中，我们将使用在模型加载小节中定义的模型加载器来加载模型。</p><p>为了得到想要的效果，我们将会为每个小行星生成一个变换矩阵，用作它们的模型矩阵。变换矩阵首先将小行星位移到小行星带中的某处，我们还会加一个小的随机偏移值到这个偏移量上，让这个圆环看起来更自然一点。接下来，我们应用一个随机的缩放，并且以一个旋转向量为轴进行一个随机的旋转。最终的变换矩阵不仅能将小行星变换到行星的周围，而且会让它看起来更自然，与其它小行星不同。最终的结果是一个布满小行星的圆环，其中每一个小行星都与众不同。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> amount <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>glm<span class="token operator">::</span>mat4 <span class="token operator">*</span>modelMatrices<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>modelMatrices <span class="token operator">=</span> <span class="token keyword">new</span> glm<span class="token operator">::</span>mat4<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">srand</span><span class="token punctuation">(</span><span class="token function">glfwGetTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化随机种子    </span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">float</span> radius <span class="token operator">=</span> <span class="token number">50.0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">float</span> offset <span class="token operator">=</span> <span class="token number">2.5f</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> amount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    glm<span class="token operator">::</span>mat4 model<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">// 1. 位移：分布在半径为 'radius' 的圆形上，偏移的范围是 [-offset, offset]</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">float</span> angle <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>i <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>amount <span class="token operator">*</span> <span class="token number">360.0f</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">float</span> displacement <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> offset <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">100.0f</span> <span class="token operator">-</span> offset<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">float</span> x <span class="token operator">=</span> <span class="token function">sin</span><span class="token punctuation">(</span>angle<span class="token punctuation">)</span> <span class="token operator">*</span> radius <span class="token operator">+</span> displacement<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    displacement <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> offset <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">100.0f</span> <span class="token operator">-</span> offset<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">float</span> y <span class="token operator">=</span> displacement <span class="token operator">*</span> <span class="token number">0.4f</span><span class="token punctuation">;</span> <span class="token comment">// 让行星带的高度比 x 和 z 的宽度要小</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    displacement <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> offset <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">100.0f</span> <span class="token operator">-</span> offset<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">float</span> z <span class="token operator">=</span> <span class="token function">cos</span><span class="token punctuation">(</span>angle<span class="token punctuation">)</span> <span class="token operator">*</span> radius <span class="token operator">+</span> displacement<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    model <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">translate</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token comment">// 2. 缩放：在 0.05 和 0.25f 之间缩放</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">float</span> scale <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">100.0f</span> <span class="token operator">+</span> <span class="token number">0.05</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    model <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">scale</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span>scale<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token comment">// 3. 旋转：绕着一个（半）随机选择的旋转轴向量进行随机的旋转</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">float</span> rotAngle <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">360</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>    model <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">rotate</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span> rotAngle<span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.4f</span><span class="token punctuation">,</span> <span class="token number">0.6f</span><span class="token punctuation">,</span> <span class="token number">0.8f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token comment">// 4. 添加到矩阵的数组中</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    modelMatrices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> model<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这段代码看起来可能有点吓人，但我们只是将小行星的 x 和 z 位置变换到了一个半径为 radius 的圆形上，并且在半径的基础上偏移了 - offset 到 offset。我们让 y 偏移的影响更小一点，让小行星带更扁平一点。接下来，我们应用了缩放和旋转变换，并将最终的变换矩阵储存在 modelMatrices 中，这个数组的大小是 amount。这里，我们一共生成 1000 个模型矩阵，每个小行星一个。</p><p>在加载完行星和岩石模型，并编译完着色器之后，渲染的代码看起来是这样的：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 绘制行星</span></pre></td></tr><tr><td data-num="2"></td><td><pre>shader<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>glm<span class="token operator">::</span>mat4 model<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>model <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">translate</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>model <span class="token operator">=</span> glm<span class="token operator">::</span><span class="token function">scale</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span> glm<span class="token operator">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">4.0f</span><span class="token punctuation">,</span> <span class="token number">4.0f</span><span class="token punctuation">,</span> <span class="token number">4.0f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>shader<span class="token punctuation">.</span><span class="token function">setMat4</span><span class="token punctuation">(</span><span class="token string">"model"</span><span class="token punctuation">,</span> model<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>planet<span class="token punctuation">.</span><span class="token function">Draw</span><span class="token punctuation">(</span>shader<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">// 绘制小行星</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> amount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    shader<span class="token punctuation">.</span><span class="token function">setMat4</span><span class="token punctuation">(</span><span class="token string">"model"</span><span class="token punctuation">,</span> modelMatrices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    rock<span class="token punctuation">.</span><span class="token function">Draw</span><span class="token punctuation">(</span>shader<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>我们首先绘制了行星的模型，并对它进行位移和缩放，以适应场景，接下来，我们绘制 amount 数量的岩石模型。在绘制每个岩石之前，我们首先需要在着色器内设置对应的模型变换矩阵。</p><p>最终的结果是一个看起来像是太空的场景，环绕着行星的是看起来很自然的小行星带：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/10/instancing_asteroids.png" alt="image"></p><p>这个场景每帧包含 1001 次渲染调用，其中 1000 个是岩石模型。</p><p>当我们开始增加这个数字的时候，你很快就会发现场景不再能够流畅运行了，帧数也下降很厉害。当我们将 amount 设置为 2000 的时候，场景就已经慢到移动都很困难的程度了。</p><p>现在，我们来尝试使用实例化渲染来渲染相同的场景。我们首先对顶点着色器进行一点修改：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span> core</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> in vec3 aPos<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> in vec2 aTexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span> in mat4 instanceMatrix<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>out vec2 TexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>uniform mat4 projection<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>uniform mat4 view<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    gl_Position <span class="token operator">=</span> projection <span class="token operator">*</span> view <span class="token operator">*</span> instanceMatrix <span class="token operator">*</span> <span class="token function">vec4</span><span class="token punctuation">(</span>aPos<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre>    TexCoords <span class="token operator">=</span> aTexCoords<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>我们不再使用模型 uniform 变量，改为一个 mat4 的顶点属性，让我们能够存储一个实例化数组的变换矩阵。然而，当我们顶点属性的类型大于 vec4 时，就要多进行一步处理了。顶点属性最大允许的数据大小等于一个 vec4。因为一个 mat4 本质上是 4 个 vec4，我们需要为这个矩阵预留 4 个顶点属性。因为我们将它的位置值设置为 3，矩阵每一列的顶点属性位置值就是 3、4、5 和 6。</p><p>接下来，我们需要为这 4 个顶点属性设置属性指针，并将它们设置为实例化数组：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 顶点缓冲对象</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> buffer<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glGenBuffers</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> amount <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>glm<span class="token operator">::</span>mat4<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>modelMatrices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> rock<span class="token punctuation">.</span>meshes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> VAO <span class="token operator">=</span> rock<span class="token punctuation">.</span>meshes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>VAO<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>VAO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">// 顶点属性</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    GLsizei vec4Size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>glm<span class="token operator">::</span>vec4<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">*</span> vec4Size<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">*</span> vec4Size<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>vec4Size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">*</span> vec4Size<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> vec4Size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">*</span> vec4Size<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> vec4Size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token function">glVertexAttribDivisor</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token function">glVertexAttribDivisor</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token function">glVertexAttribDivisor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token function">glVertexAttribDivisor</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>注意这里我们将 Mesh 的 VAO 从私有变量改为了公有变量，让我们能够访问它的顶点数组对象。这并不是最好的解决方案，只是为了配合本小节的一个简单的改动。除此之外代码就应该很清楚了。我们告诉了 OpenGL 应该如何解释每个缓冲顶点属性的缓冲，并且告诉它这些顶点属性是实例化数组。</p><p>接下来，我们再次使用网格的 VAO，这一次使用 glDrawElementsInstanced 进行绘制：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 绘制小行星</span></pre></td></tr><tr><td data-num="2"></td><td><pre>instanceShader<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> rock<span class="token punctuation">.</span>meshes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>rock<span class="token punctuation">.</span>meshes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>VAO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">glDrawElementsInstanced</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        GL_TRIANGLES<span class="token punctuation">,</span> rock<span class="token punctuation">.</span>meshes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>indices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> GL_UNSIGNED_INT<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> amount</pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这里，我们绘制与之前相同数量 amount 的小行星，但是使用的是实例渲染。结果应该是非常相似的，但如果你开始增加 amount 变量，你就能看见实例化渲染的效果了。没有实例化渲染的时候，我们只能流畅渲染 1000 到 1500 个小行星。而使用了实例化渲染之后，我们可以将这个值设置为 100000，每个岩石模型有 576 个顶点，每帧加起来大概要绘制 5700 万个顶点，但性能却没有受到任何影响！</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/10/instancing_asteroids_quantity.png" alt="image"></p><p>上面这幅图渲染了 10 万个小行星，半径为 150.0f，偏移量等于 25.0f。</p><blockquote><p>在某些机器上，10 万个小行星可能会太多了，所以尝试修改这个值，直到达到一个你能接受的帧率。</p></blockquote><p>可以看到，在合适的环境下，实例化渲染能够大大增加显卡的渲染能力。正是出于这个原因，实例化渲染通常会用于渲染草、植被、粒子，以及上面这样的场景，基本上只要场景中有很多重复的形状，都能够使用实例化渲染来提高性能。</p><h2 id="抗锯齿"><a class="anchor" href="#抗锯齿">#</a> 抗锯齿</h2><p>在学习渲染的旅途中，你可能会时不时遇到模型边缘有锯齿的情况。这些<mark>锯齿边缘</mark> (Jagged Edges) 的产生和光栅器将顶点数据转化为片段的方式有关。在下面的例子中，你可以看到，我们只是绘制了一个简单的立方体，你就能注意到它存在锯齿边缘了：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/11/anti_aliasing_aliasing.png" alt="image"></p><p>可能不是非常明显，但如果你离近仔细观察立方体的边缘，你就应该能够看到锯齿状的图案。如果放大的话，你会看到下面的图案：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/11/anti_aliasing_zoomed.png" alt="image"></p><p>这很明显不是我们想要在最终程序中所实现的效果。你能够清楚看见形成边缘的像素。这种现象被称之为<mark>走样</mark> (Aliasing)。有很多种<mark>抗锯齿</mark>（Anti-aliasing，也被称为反走样）的技术能够帮助我们缓解这种现象，从而产生更平滑的边缘。</p><p>最开始我们有一种叫做<mark>超采样抗锯齿</mark> (Super Sample Anti-aliasing, SSAA) 的技术，它会使用比正常分辨率<mark>更高</mark>的分辨率（即超采样）来渲染场景，当图像输出在帧缓冲中更新时，分辨率会被<mark>下采样</mark> (Downsample) 至正常的分辨率。这些<mark>额外的</mark>分辨率会被用来防止锯齿边缘的产生。虽然它确实能够解决走样的问题，但是由于这样比平时要绘制更多的片段，它也会带来很大的<mark>性能开销</mark>。所以这项技术只拥有了短暂的辉煌。</p><p>然而，在这项技术的基础上也诞生了更为现代的技术，叫做<mark>多重采样抗锯齿</mark> (Multisample Anti-aliasing, MSAA)。它借鉴了 SSAA 背后的理念，但却以更加高效的方式实现了抗锯齿。我们在这一节中会深度讨论 OpenGL 中内建的 MSAA 技术。</p><h3 id="多重采样"><a class="anchor" href="#多重采样">#</a> 多重采样</h3><p>为了理解什么是多重采样 (Multisampling)，以及它是如何解决锯齿问题的，我们有必要更加深入地了解 OpenGL 光栅器的工作方式。</p><p><mark>光栅器</mark>是位于最终处理过的顶点之后到片段着色器之前所经过的所有的算法与过程的总和。光栅器会将一个图元的所有顶点作为输入，并将它转换为一系列的片段。顶点坐标理论上可以取任意值，但片段不行，因为它们受限于你窗口的分辨率。顶点坐标与片段之间几乎永远也不会有一对一的映射，所以光栅器必须以某种方式来决定每个顶点最终所在的片段 / 屏幕坐标。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/11/anti_aliasing_rasterization.png" alt="image"></p><p>这里我们可以看到一个屏幕像素的网格，每个像素的中心包含有一个<mark>采样点</mark> (Sample Point)，它会被用来决定这个三角形是否遮盖了某个像素。图中红色的采样点被三角形所遮盖，在每一个遮住的像素处都会生成一个片段。虽然三角形边缘的一些部分也遮住了某些屏幕像素，但是这些像素的采样点并没有被三角形内部所遮盖，所以它们不会受到片段着色器的影响。</p><p>你现在可能已经清楚走样的原因了。完整渲染后的三角形在屏幕上会是这样的：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/11/anti_aliasing_rasterization_filled.png" alt="image"></p><p>由于屏幕像素总量的限制，有些边缘的像素能够被渲染出来，而有些则不会。结果就是我们使用了不光滑的边缘来渲染图元，导致之前讨论到的锯齿边缘。</p><p><mark>多重采样</mark>所做的正是将<mark>单一</mark>的采样点变为<mark>多个</mark>采样点（这也是它名称的由来）。我们不再使用像素中心的单一采样点，取而代之的是以特定图案排列的 4 个子采样点 (Subsample)。我们将用这些子采样点来决定像素的遮盖度。当然，这也意味着颜色缓冲的大小会随着子采样点的增加而增加。</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/11/anti_aliasing_sample_points.png" alt="image"></p><p>上图的左侧展示了正常情况下判定三角形是否遮盖的方式。在例子中的这个像素上不会运行片段着色器（所以它会保持空白）。因为它的采样点并未被三角形所覆盖。上图的右侧展示的是实施多重采样之后的版本，每个像素包含有 4 个采样点。这里，只有两个采样点遮盖住了三角形。</p><blockquote><p>采样点的数量可以是任意的，更多的采样点能带来更精确的遮盖率。</p></blockquote><p>从这里开始多重采样就变得有趣起来了。我们知道三角形只遮盖了 2 个子采样点，所以下一步是决定这个像素的颜色。你的猜想可能是，我们对每个被遮盖住的子采样点运行一次片段着色器，最后将每个像素所有<mark>子采样点的颜色平均一下</mark>。在这个例子中，我们需要在两个子采样点上对被插值的顶点数据运行两次片段着色器，并将结果的颜色储存在这些采样点中。（幸运的是）这并不是它工作的方式，因为这本质上说还是需要运行更多次的片段着色器，会显著地降低性能。</p><p>MSAA 真正的工作方式是，无论三角形遮盖了多少个子采样点，（每个图元中）每个像素只运行一次片段着色器。片段着色器所使用的顶点数据会插值到每个像素的中心，所得到的结果颜色会被储存在每个被遮盖住的子采样点中。当颜色缓冲的子样本被图元的所有颜色填满时，所有的这些颜色将会在每个像素内部平均化。因为上图的 4 个采样点中只有 2 个被遮盖住了，这个像素的颜色将会是三角形颜色与其他两个采样点的颜色（在这里是无色）的平均值，最终形成一种淡蓝色。</p><p>这样子做之后，颜色缓冲中所有的图元边缘将会产生一种更平滑的图形。让我们来看看前面三角形的多重采样会是什么样子：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/11/anti_aliasing_rasterization_samples.png" alt="image"></p><p>这里，每个像素包含 4 个子采样点（不相关的采样点都没有标注），蓝色的采样点被三角形所遮盖，而灰色的则没有。对于三角形的内部的像素，片段着色器只会运行一次，颜色输出会被存储到全部的 4 个子样本中。而在三角形的边缘，并不是所有的子采样点都被遮盖，所以片段着色器的结果将只会储存到部分的子样本中。根据被遮盖的子样本的数量，最终的像素颜色将由三角形的颜色与其它子样本中所储存的颜色来决定。</p><p>简单来说，一个像素中如果有更多的采样点被三角形遮盖，那么这个像素的颜色就会更接近于三角形的颜色。如果我们给上面的三角形填充颜色，就能得到以下的效果：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/11/anti_aliasing_rasterization_samples_filled.png" alt="image"></p><p>对于每个像素来说，越少的子采样点被三角形所覆盖，那么它受到三角形的影响就越小。三角形的不平滑边缘被稍浅的颜色所包围后，从远处观察时就会显得更加平滑了。</p><p>不仅仅是颜色值会受到多重采样的影响，深度和模板测试也能够使用多个采样点。对深度测试来说，每个顶点的深度值会在运行深度测试之前被插值到各个子样本中。对模板测试来说，我们对每个子样本，而不是每个像素，存储一个模板值。当然，这也意味着深度和模板缓冲的大小会乘以子采样点的个数。</p><p>我们到目前为止讨论的都是多重采样抗锯齿的背后原理，光栅器背后的实际逻辑比目前讨论的要复杂，但你现在应该已经可以理解多重采样抗锯齿的大体概念和逻辑了。</p><p>(译者注： 如果看到这里还是对原理似懂非懂，可以简单看看知乎上 @文刀秋二对抗锯齿技术的<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwMjM2NjM4L2Fuc3dlci8xNDQzODIxOA==">精彩介绍</span>)</p><h3 id="opengl中的msaa"><a class="anchor" href="#opengl中的msaa">#</a> OpenGL 中的 MSAA</h3><p>如果我们想要在 OpenGL 中使用 MSAA，我们必须要使用一个能在每个像素中存储大于 1 个颜色值的颜色缓冲（因为多重采样需要我们为每个采样点都储存一个颜色）。所以，我们需要一个新的缓冲类型，来存储特定数量的多重采样样本，它叫做<mark>多重采样缓冲</mark> (Multisample Buffer)。</p><p>大多数的窗口系统都应该提供了一个多重采样缓冲，用以代替默认的颜色缓冲。GLFW 同样给了我们这个功能，我们所要做的只是<mark>提示</mark> (Hint) GLFW，我们希望使用一个包含 N 个样本的多重采样缓冲。这可以在创建窗口之前调用 glfwWindowHint 来完成。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glfwWindowHint</span><span class="token punctuation">(</span>GLFW_SAMPLES<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>现在再调用 glfwCreateWindow 创建渲染窗口时，每个屏幕坐标就会使用一个包含 4 个子采样点的颜色缓冲了。GLFW 会自动创建一个每像素 4 个子采样点的深度和样本缓冲。这也意味着所有缓冲的大小都增长了 4 倍。</p><p>现在我们已经向 GLFW 请求了多重采样缓冲，我们还需要调用<mark> glEnable</mark> 并启用<mark> GL_MULTISAMPLE</mark>，来启用多重采样。在大多数 OpenGL 的驱动上，多重采样都是默认启用的，所以这个调用可能会有点多余，但显式地调用一下会更保险一点。这样子不论是什么 OpenGL 的实现都能够正常启用多重采样了。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glEnable</span><span class="token punctuation">(</span>GL_MULTISAMPLE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>只要默认的帧缓冲有了多重采样缓冲的附件，我们所要做的只是调用 glEnable 来启用多重采样。因为多重采样的算法都在 OpenGL 驱动的光栅器中实现了，我们不需要再多做什么。如果现在再来渲染本节一开始的那个绿色的立方体，我们应该能看到更平滑的边缘：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/11/anti_aliasing_multisampled.png" alt="image"></p><p>这个箱子看起来的确要平滑多了，如果在场景中有其它的物体，它们也会看起来平滑很多。</p><h3 id="离屏msaa"><a class="anchor" href="#离屏msaa">#</a> 离屏 MSAA</h3><p>由于 GLFW 负责了创建多重采样缓冲，启用 MSAA 非常简单。然而，如果我们想要使用我们自己的帧缓冲来进行离屏渲染，那么我们就必须要自己动手生成多重采样缓冲了。</p><p>有两种方式可以创建多重采样缓冲，将其作为帧缓冲的附件：纹理附件和渲染缓冲附件，这和在帧缓冲教程中所讨论的普通附件很相似。</p><h3 id="多重采样纹理附件"><a class="anchor" href="#多重采样纹理附件">#</a> 多重采样纹理附件</h3><p>为了创建一个支持储存多个采样点的纹理，我们使用 glTexImage2DMultisample 来替代 glTexImage2D，它的纹理目标是 GL_TEXTURE_2D_MULTISAPLE。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D_MULTISAMPLE<span class="token punctuation">,</span> tex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glTexImage2DMultisample</span><span class="token punctuation">(</span>GL_TEXTURE_2D_MULTISAMPLE<span class="token punctuation">,</span> samples<span class="token punctuation">,</span> GL_RGB<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> GL_TRUE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D_MULTISAMPLE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>它的第二个参数设置的是纹理所拥有的样本个数。如果最后一个参数为 GL_TRUE，图像将会对每个纹素使用相同的样本位置以及相同数量的子采样点个数。</p><p>我们使用 glFramebufferTexture2D 将多重采样纹理附加到帧缓冲上，但这里纹理类型使用的是 GL_TEXTURE_2D_MULTISAMPLE。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glFramebufferTexture2D</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> GL_COLOR_ATTACHMENT0<span class="token punctuation">,</span> GL_TEXTURE_2D_MULTISAMPLE<span class="token punctuation">,</span> tex<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>当前绑定的帧缓冲现在就有了一个纹理图像形式的多重采样颜色缓冲。</p><h3 id="多重采样渲染缓冲对象"><a class="anchor" href="#多重采样渲染缓冲对象">#</a> 多重采样渲染缓冲对象</h3><p>和纹理类似，创建一个多重采样渲染缓冲对象并不难。我们所要做的只是在指定（当前绑定的）渲染缓冲的内存存储时，将 glRenderbufferStorage 的调用改为 glRenderbufferStorageMultisample 就可以了。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glRenderbufferStorageMultisample</span><span class="token punctuation">(</span>GL_RENDERBUFFER<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> GL_DEPTH24_STENCIL8<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>函数中，渲染缓冲对象后的参数我们将设定为样本的数量，在当前的例子中是 4。</p><h3 id="渲染到多重采样帧缓冲"><a class="anchor" href="#渲染到多重采样帧缓冲">#</a> 渲染到多重采样帧缓冲</h3><p>渲染到多重采样帧缓冲对象的过程都是自动的。只要我们在帧缓冲绑定时绘制任何东西，光栅器就会负责所有的多重采样运算。我们最终会得到一个多重采样颜色缓冲以及 / 或深度和模板缓冲。因为多重采样缓冲有一点特别，我们不能直接将它们的缓冲图像用于其他运算，比如在着色器中对它们进行采样。</p><p>一个多重采样的图像包含比普通图像更多的信息，我们所要做的是缩小或者还原 (Resolve) 图像。多重采样帧缓冲的还原通常是通过 glBlitFramebuffer 来完成，它能够将一个帧缓冲中的某个区域复制到另一个帧缓冲中，并且将多重采样缓冲还原。</p><p>glBlitFramebuffer 会将一个用 4 个屏幕空间坐标所定义的源区域复制到一个同样用 4 个屏幕空间坐标所定义的目标区域中。你可能记得在帧缓冲教程中，当我们绑定到 GL_FRAMEBUFFER 时，我们是同时绑定了读取和绘制的帧缓冲目标。我们也可以将帧缓冲分开绑定至 GL_READ_FRAMEBUFFER 与 GL_DRAW_FRAMEBUFFER。glBlitFramebuffer 函数会根据这两个目标，决定哪个是源帧缓冲，哪个是目标帧缓冲。接下来，我们可以将图像位块传送 (Blit) 到默认的帧缓冲中，将多重采样的帧缓冲传送到屏幕上。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_READ_FRAMEBUFFER<span class="token punctuation">,</span> multisampledFBO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_DRAW_FRAMEBUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">glBlitFramebuffer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> GL_COLOR_BUFFER_BIT<span class="token punctuation">,</span> GL_NEAREST<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>如果现在再来渲染这个程序，我们会得到与之前完全一样的结果：一个使用 MSAA 显示出来的橄榄绿色的立方体，而且锯齿边缘明显减少了：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/11/anti_aliasing_multisampled.png" alt="image"></p><p>但如果我们想要使用多重采样帧缓冲的纹理输出来做像是后期处理这样的事情呢？我们不能直接在片段着色器中使用多重采样的纹理。但我们能做的是将多重采样缓冲位块传送到一个没有使用多重采样纹理附件的 FBO 中。然后用这个普通的颜色附件来做后期处理，从而达到我们的目的。然而，这也意味着我们需要生成一个新的 FBO，作为中介帧缓冲对象，将多重采样缓冲还原为一个能在着色器中使用的普通 2D 纹理。这个过程的伪代码是这样的：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">unsigned</span> <span class="token keyword">int</span> msFBO <span class="token operator">=</span> <span class="token function">CreateFBOWithMultiSampledAttachments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 使用普通的纹理颜色附件创建一个新的 FBO</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">glFramebufferTexture2D</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> GL_COLOR_ATTACHMENT0<span class="token punctuation">,</span> GL_TEXTURE_2D<span class="token punctuation">,</span> screenTexture<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">glfwWindowShouldClose</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>msFBO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token function">ClearFrameBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token function">DrawScene</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">// 将多重采样缓冲还原到中介 FBO 上</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_READ_FRAMEBUFFER<span class="token punctuation">,</span> msFBO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_DRAW_FRAMEBUFFER<span class="token punctuation">,</span> intermediateFBO<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token function">glBlitFramebuffer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> GL_COLOR_BUFFER_BIT<span class="token punctuation">,</span> GL_NEAREST<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token comment">// 现在场景是一个 2D 纹理缓冲，可以将这个图像用来后期处理</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token function">ClearFramebuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> screenTexture<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token function">DrawPostProcessingQuad</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> </pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>如果现在再实现帧缓冲教程中的后期处理效果，我们就能够在一个几乎没有锯齿的场景纹理上进行后期处理了。如果施加模糊的核滤镜，看起来将会是这样：</p><p><img data-src="https://gitee.com/allengx/pic_bed/raw/master/img/04/11/anti_aliasing_post_processing.png" alt="image"></p><blockquote><p>因为屏幕纹理又变回了一个只有单一采样点的普通纹理，像是边缘检测这样的后期处理滤镜会重新导致锯齿。为了补偿这一问题，你可以之后对纹理进行模糊处理，或者想出你自己的抗锯齿算法。</p></blockquote><p>你可以看到，如果将多重采样与离屏渲染结合起来，我们需要自己负责一些额外的细节。但所有的这些细节都是值得额外的努力的，因为多重采样能够显著提升场景的视觉质量。当然，要注意，如果使用的采样点非常多，启用多重采样会显著降低程序的性能。在本节写作时，通常采用的是 4 采样点的 MSAA。</p><h3 id="自定义抗锯齿算法"><a class="anchor" href="#自定义抗锯齿算法">#</a> 自定义抗锯齿算法</h3><p>将一个多重采样的纹理图像不进行还原直接传入着色器也是可行的。GLSL 提供了这样的选项，让我们能够对纹理图像的每个子样本进行采样，所以我们可以创建我们自己的抗锯齿算法。在大型的图形应用中通常都会这么做。</p><p>要想获取每个子样本的颜色值，你需要将纹理 uniform 采样器设置为 sampler2DMS，而不是平常使用的 sampler2D：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>uniform sampler2DMS screenTextureMS<span class="token punctuation">;</span></pre></td></tr></table></figure><p>使用 texelFetch 函数就能够获取每个子样本的颜色值了：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>vec4 colorSample <span class="token operator">=</span> <span class="token function">texelFetch</span><span class="token punctuation">(</span>screenTextureMS<span class="token punctuation">,</span> TexCoords<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 第 4 个子样本</span></pre></td></tr></table></figure><p>我们不会深入探究自定义抗锯齿技术的细节，这里仅仅是给你一点启发。</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2020-10-26 10:33:45" itemprop="dateModified" datetime="2020-10-26T10:33:45+08:00">2020-10-26</time> </span><span id="computer-science/study/opengl/4-OpenGL-High-Level/" class="item leancloud_visitors" data-flag-title="四、高级OpenGL" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 充电</button><p>请我[恰饭]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="鑫酱(●'◡'●) 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="鑫酱(●'◡'●) 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>鑫酱(●'◡'●) <i class="ic i-at"><em>@</em></i>鑫酱</li><li class="link"><strong>本文链接：</strong> <a href="https://allengx.gitee.io/computer-science/study/opengl/4-OpenGL-High-Level/" title="四、高级OpenGL">https://allengx.gitee.io/computer-science/study/opengl/4-OpenGL-High-Level/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="nav"><div class="item left"></div><div class="item right"><a href="/computer-science/study/opengl/5-OpenGL-Heigh-Light/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipeybxm1pj20zk0m8niv.jpg" title="五、高级光照"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> OpenGL</span><h3>五、高级光照</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7opengl"><span class="toc-number">1.</span> <span class="toc-text">高级 OpenGL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95"><span class="toc-number">1.1.</span> <span class="toc-text">深度测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">深度测试函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E5%80%BC%E7%B2%BE%E5%BA%A6"><span class="toc-number">1.1.2.</span> <span class="toc-text">深度值精度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-number">1.1.3.</span> <span class="toc-text">深度缓冲的可视化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E5%86%B2%E7%AA%81"><span class="toc-number">1.1.4.</span> <span class="toc-text">深度冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E6%B7%B1%E5%BA%A6%E5%86%B2%E7%AA%81"><span class="toc-number">1.1.5.</span> <span class="toc-text">防止深度冲突</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95"><span class="toc-number">1.2.</span> <span class="toc-text">模板测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">模板函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E4%BD%93%E8%BD%AE%E5%BB%93"><span class="toc-number">1.2.2.</span> <span class="toc-text">物体轮廓</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B7%E5%90%88"><span class="toc-number">1.3.</span> <span class="toc-text">混合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A2%E5%BC%83%E7%89%87%E6%AE%B5"><span class="toc-number">1.3.1.</span> <span class="toc-text">丢弃片段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88-2"><span class="toc-number">1.3.2.</span> <span class="toc-text">混合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E5%8D%8A%E9%80%8F%E6%98%8E%E7%BA%B9%E7%90%86"><span class="toc-number">1.3.3.</span> <span class="toc-text">渲染半透明纹理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E6%89%93%E4%B9%B1%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.3.4.</span> <span class="toc-text">不要打乱顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%89%94%E9%99%A4"><span class="toc-number">1.4.</span> <span class="toc-text">面剔除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E7%BB%95%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">环绕顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%89%94%E9%99%A4-2"><span class="toc-number">1.4.2.</span> <span class="toc-text">面剔除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A7%E7%BC%93%E5%86%B2"><span class="toc-number">1.5.</span> <span class="toc-text">帧缓冲</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B8%A7%E7%BC%93%E5%86%B2"><span class="toc-number">1.5.1.</span> <span class="toc-text">创建一个帧缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%B9%E7%90%86%E9%99%84%E4%BB%B6"><span class="toc-number">1.5.2.</span> <span class="toc-text">纹理附件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E7%BC%93%E5%86%B2%E5%AF%B9%E8%B1%A1%E9%99%84%E4%BB%B6"><span class="toc-number">1.5.3.</span> <span class="toc-text">渲染缓冲对象附件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E5%88%B0%E7%BA%B9%E7%90%86"><span class="toc-number">1.5.4.</span> <span class="toc-text">渲染到纹理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86"><span class="toc-number">1.5.5.</span> <span class="toc-text">后期处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E7%9B%B8"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">反相</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%81%B0%E5%BA%A6"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">灰度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E6%95%88%E6%9E%9C"><span class="toc-number">1.5.5.3.</span> <span class="toc-text">核效果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E7%B3%8A"><span class="toc-number">1.5.5.4.</span> <span class="toc-text">模糊</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B"><span class="toc-number">1.5.5.5.</span> <span class="toc-text">边缘检测</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%8B%E6%96%B9%E4%BD%93%E8%B4%B4%E5%9B%BE"><span class="toc-number">1.6.</span> <span class="toc-text">立方体贴图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%AB%8B%E6%96%B9%E4%BD%93%E8%B4%B4%E5%9B%BE"><span class="toc-number">1.6.1.</span> <span class="toc-text">创建立方体贴图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A9%E7%A9%BA%E7%9B%92"><span class="toc-number">1.6.2.</span> <span class="toc-text">天空盒</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E5%A4%A9%E7%A9%BA%E7%9B%92"><span class="toc-number">1.6.3.</span> <span class="toc-text">加载天空盒</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%A4%A9%E7%A9%BA%E7%9B%92"><span class="toc-number">1.6.4.</span> <span class="toc-text">显示天空盒</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">1.6.5.</span> <span class="toc-text">优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84"><span class="toc-number">1.6.6.</span> <span class="toc-text">环境映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">1.6.7.</span> <span class="toc-text">反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%98%E5%B0%84"><span class="toc-number">1.6.8.</span> <span class="toc-text">折射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%8E%AF%E5%A2%83%E8%B4%B4%E5%9B%BE"><span class="toc-number">1.6.9.</span> <span class="toc-text">动态环境贴图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE"><span class="toc-number">1.7.</span> <span class="toc-text">高级数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%89%B9%E9%A1%B6%E7%82%B9%E5%B1%9E%E6%80%A7"><span class="toc-number">1.7.1.</span> <span class="toc-text">分批顶点属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%BC%93%E5%86%B2"><span class="toc-number">1.7.2.</span> <span class="toc-text">复制缓冲</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7glsl"><span class="toc-number">1.8.</span> <span class="toc-text">高级 GLSL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#glsl%E7%9A%84%E5%86%85%E5%BB%BA%E5%8F%98%E9%87%8F"><span class="toc-number">1.8.1.</span> <span class="toc-text">GLSL 的内建变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.8.2.</span> <span class="toc-text">顶点着色器变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gl_pointsize%E8%AE%BE%E7%BD%AE%E5%9B%BE%E5%8E%9F%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">gl_PointSize（设置图原大小）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gl_program_point_size"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">GL_PROGRAM_POINT_SIZE：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gl_vertexid"><span class="toc-number">1.8.2.3.</span> <span class="toc-text">gl_VertexID</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%87%E6%AE%B5%E7%9D%80%E8%89%B2%E5%99%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.8.3.</span> <span class="toc-text">片段着色器变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gl_fragcoord%E8%AE%BE%E7%BD%AE%E5%B1%8F%E5%B9%95%E6%B8%B2%E6%9F%93%E8%8C%83%E5%9B%B4"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">gl_FragCoord (设置屏幕渲染范围)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gl_frontfacing%E5%88%A4%E6%96%AD%E6%AD%A3%E5%8F%8D%E9%9D%A2"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">gl_FrontFacing (判断正反面)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gl_fragdepth%E4%BF%AE%E6%94%B9%E7%89%87%E6%AE%B5%E6%B7%B1%E5%BA%A6%E5%80%BC"><span class="toc-number">1.8.3.3.</span> <span class="toc-text">gl_FragDepth（修改片段深度值）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%9D%97"><span class="toc-number">1.8.4.</span> <span class="toc-text">接口块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#uniform%E7%BC%93%E5%86%B2%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.8.5.</span> <span class="toc-text">Uniform 缓冲对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#uniform%E5%9D%97%E5%B8%83%E5%B1%80"><span class="toc-number">1.8.6.</span> <span class="toc-text">Uniform 块布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8uniform%E7%BC%93%E5%86%B2"><span class="toc-number">1.8.7.</span> <span class="toc-text">使用 Uniform 缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">1.8.8.</span> <span class="toc-text">一个简单的例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.9.</span> <span class="toc-text">几何着色器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.9.1.</span> <span class="toc-text">使用几何着色器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%A0%E5%87%A0%E4%B8%AA%E6%88%BF%E5%AD%90"><span class="toc-number">1.9.2.</span> <span class="toc-text">造几个房子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%86%E7%A0%B4%E7%89%A9%E4%BD%93"><span class="toc-number">1.9.3.</span> <span class="toc-text">爆破物体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%95%E5%90%91%E9%87%8F%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-number">1.9.4.</span> <span class="toc-text">法向量可视化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">1.10.</span> <span class="toc-text">实例化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%95%B0%E7%BB%84"><span class="toc-number">1.10.1.</span> <span class="toc-text">实例化数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E8%A1%8C%E6%98%9F%E5%B8%A6"><span class="toc-number">1.10.2.</span> <span class="toc-text">小行星带</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%97%E9%94%AF%E9%BD%BF"><span class="toc-number">1.11.</span> <span class="toc-text">抗锯齿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E9%87%87%E6%A0%B7"><span class="toc-number">1.11.1.</span> <span class="toc-text">多重采样</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#opengl%E4%B8%AD%E7%9A%84msaa"><span class="toc-number">1.11.2.</span> <span class="toc-text">OpenGL 中的 MSAA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%BB%E5%B1%8Fmsaa"><span class="toc-number">1.11.3.</span> <span class="toc-text">离屏 MSAA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E9%87%87%E6%A0%B7%E7%BA%B9%E7%90%86%E9%99%84%E4%BB%B6"><span class="toc-number">1.11.4.</span> <span class="toc-text">多重采样纹理附件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E9%87%87%E6%A0%B7%E6%B8%B2%E6%9F%93%E7%BC%93%E5%86%B2%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.11.5.</span> <span class="toc-text">多重采样渲染缓冲对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E5%88%B0%E5%A4%9A%E9%87%8D%E9%87%87%E6%A0%B7%E5%B8%A7%E7%BC%93%E5%86%B2"><span class="toc-number">1.11.6.</span> <span class="toc-text">渲染到多重采样帧缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8A%97%E9%94%AF%E9%BD%BF%E7%AE%97%E6%B3%95"><span class="toc-number">1.11.7.</span> <span class="toc-text">自定义抗锯齿算法</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/computer-science/study/opengl/1-OpenGL-Introduction/" rel="bookmark" title="一、OpenGL入门">一、OpenGL入门</a></li><li><a href="/computer-science/study/opengl/2-OpenGL-Load-Model/" rel="bookmark" title="三、OpenGL模型加载">三、OpenGL模型加载</a></li><li><a href="/computer-science/study/opengl/3-OpenGL-Lighting/" rel="bookmark" title="二、OpenGL光照">二、OpenGL光照</a></li><li><a href="/computer-science/study/opengl/5-OpenGL-Heigh-Light/" rel="bookmark" title="五、高级光照">五、高级光照</a></li><li class="active"><a href="/computer-science/study/opengl/4-OpenGL-High-Level/" rel="bookmark" title="四、高级OpenGL">四、高级OpenGL</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="鑫酱(●'◡'●)" data-src="/images/avatar.jpg"><p class="name" itemprop="name">鑫酱(●'◡'●)</p><div class="description" itemprop="description">整天摸鱼，却妄想拯救世界的技术宅</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">27</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">15</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">8</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FsbGVuR1g=" title="https:&#x2F;&#x2F;github.com&#x2F;AllenGX"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTgwNTM4MjQy" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;80538242"><i class="ic i-cloud-music"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjE0MTM5MDcxNTNAcXEuY29t" title="mailto:1413907153@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>链接</a></li><li class="item"><a href="/travellings/" rel="section"><i class="ic i-paper-plane"></i>开往</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/python/" title="分类于 Python">Python</a></div><span><a href="/computer-science/study/python/Python-C-extension/" title="编写Python的C扩展">编写Python的C扩展</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/opengl/" title="分类于 OpenGL">OpenGL</a></div><span><a href="/computer-science/study/opengl/2-OpenGL-Load-Model/" title="三、OpenGL模型加载">三、OpenGL模型加载</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/opengl/" title="分类于 OpenGL">OpenGL</a></div><span><a href="/computer-science/study/opengl/3-OpenGL-Lighting/" title="二、OpenGL光照">二、OpenGL光照</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/task-list/" title="分类于 任务清单">任务清单</a></div><span><a href="/computer-science/task-list/plan-table/" title="计划表">计划表</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/micro-service/" title="分类于 微服务">微服务</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/micro-service/kubernetes/" title="分类于 K8s">K8s</a></div><span><a href="/computer-science/study/micro-service/kubernetes/Kubernetes-Introduction/" title="Kubernetes简介">Kubernetes简介</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/python/" title="分类于 Python">Python</a></div><span><a href="/computer-science/study/python/Python2-Source-Code/" title="python2源码剖析">python2源码剖析</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/opengl/" title="分类于 OpenGL">OpenGL</a></div><span><a href="/computer-science/study/opengl/1-OpenGL-Introduction/" title="一、OpenGL入门">一、OpenGL入门</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/redis/" title="分类于 Redis">Redis</a></div><span><a href="/computer-science/study/redis/5-Redis-Building-Program/" title="五、使用redis构建支持程序">五、使用redis构建支持程序</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/redis/" title="分类于 Redis">Redis</a></div><span><a href="/computer-science/study/redis/4-Redis-Data-Security-And-Performance/" title="四、redis数据安全及性能保障">四、redis数据安全及性能保障</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/" title="分类于 学习笔记">学习笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/micro-service/" title="分类于 微服务">微服务</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/study/micro-service/istio/" title="分类于 Istio">Istio</a></div><span><a href="/computer-science/study/micro-service/istio/Istio-Introduction-And-Service-Mesh/" title="Istio简介&amp;&amp;服务网格">Istio简介&&服务网格</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">鑫酱(●'◡'●) @ 个人博客</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">386k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">5:51</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"computer-science/study/opengl/4-OpenGL-High-Level/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.3"></script></body></html>